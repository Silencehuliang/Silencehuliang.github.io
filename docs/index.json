[{"categories":["Tornado"],"content":"简介 与Django框架相比，Tornado没有自带ORM，对于数据库需要自己去适配。我们使用MySQL数据库。 在Tornado3.0版本以前提供tornado.database模块用来操作MySQL数据库，而从3.0版本开始，此模块就被独立出来，作为torndb包单独提供。torndb只是对MySQLdb的简单封装，不支持Python 3。 ","date":"0001-01-01","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E5%BA%93/:1:0","tags":["Python学习之路"],"title":"Python学习之路-Tornado基础:数据库","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["Tornado"],"content":"连接初始化 我们需要在应用启动时创建一个数据库连接实例，供各个RequestHandler使用。我们可以在构造Application的时候创建一个数据库实例并作为其属性，而RequestHandler可以通过self.application获取其属性，进而操作数据库实例。 import torndb class Application(tornado.web.Application): def __init__(self): handlers = [ (r\"/\", IndexHandler), ] settings = dict( template_path=os.path.join(os.path.dirname(__file__), \"templates\"), static_path=os.path.join(os.path.dirname(__file__), \"statics\"), debug=True, ) super(Application, self).__init__(handlers, **settings) # 创建一个全局mysql连接实例供handler使用 self.db = torndb.Connection( host=\"127.0.0.1\", database=\"itcast\", user=\"root\", password=\"mysql\" ) ","date":"0001-01-01","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E5%BA%93/:2:0","tags":["Python学习之路"],"title":"Python学习之路-Tornado基础:数据库","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["Tornado"],"content":"使用数据库 新建数据库与表 执行语句，执行语句主要用来执行非查询语句。 execute(query, *parameters, **kwparameters) 返回影响的最后一条自增字段值 execute_rowcount(query, *parameters, **kwparameters) 返回影响的行 query为要执行的sql语句，parameters与kwparameters为要绑定的参数 查询语句 get(query, *parameters, **kwparameters) 返回单行结果或None，若出现多行则报错。返回值为torndb.Row类型，是一个类字典的对象，即同时支持字典的关键字索引和对象的属相访问。 query(query, *parameters, **kwparameters) 返回多行结果，torndb.Row的列表。 ","date":"0001-01-01","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E5%BA%93/:3:0","tags":["Python学习之路"],"title":"Python学习之路-Tornado基础:数据库","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["Tornado"],"content":"Application ","date":"2020-12-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E6%B7%B1%E5%85%A5tornado/:1:0","tags":["Python学习之路"],"title":"Python学习之路-Tornado基础:深入Tornado","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E6%B7%B1%E5%85%A5tornado/"},{"categories":["Tornado"],"content":"settings 前面的学习中，我们在创建tornado.web.Application的对象时，传入了第一个参数——路由映射列表。实际上Application类的构造函数还接收很多关于tornado web应用的配置参数，在后面的学习中我们用到的地方会为大家介绍。 我们先来学习一个参数： debug，设置tornado是否工作在调试模式，默认为False即工作在生产模式。当设置debug=True 后，tornado会工作在调试/开发模式，在此种模式下，tornado为方便我们开发而提供了几种特性： 自动重启，tornado应用会监控我们的源代码文件，当有改动保存后便会重启程序，这可以减少我们手动重启程序的次数。需要注意的是，一旦我们保存的更改有错误，自动重启会导致程序报错而退出，从而需要我们保存修正错误后手动启动程序。这一特性也可单独通过autoreload=True设置； 取消缓存编译的模板，可以单独通过compiled_template_cache=False来设置； 取消缓存静态文件hash值，可以单独通过static_hash_cache=False来设置； 提供追踪信息，当RequestHandler或者其子类抛出一个异常而未被捕获后，会生成一个包含追踪信息的页面，可以单独通过serve_traceback=True来设置。 使用debug参数的方法： import tornado.web app = tornado.web.Application([], debug=True) ","date":"2020-12-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E6%B7%B1%E5%85%A5tornado/:1:1","tags":["Python学习之路"],"title":"Python学习之路-Tornado基础:深入Tornado","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E6%B7%B1%E5%85%A5tornado/"},{"categories":["Tornado"],"content":"路由映射 先前我们在构建路由映射列表的时候，使用的是二元元组，如： [(r\"/\", IndexHandler),] 对于这个映射列表中的路由，实际上还可以传入多个信息，如： [ (r\"/\", Indexhandler), (r\"/cpp\", ItcastHandler, {\"subject\":\"c++\"}), url(r\"/python\", ItcastHandler, {\"subject\":\"python\"}, name=\"python_url\") ] 对于路由中的字典，会传入到对应的RequestHandler的initialize()方法中： from tornado.web import RequestHandler class ItcastHandler(RequestHandler): def initialize(self, subject): self.subject = subject def get(self): self.write(self.subject) 对于路由中的name字段，注意此时不能再使用元组，而应使用tornado.web.url来构建。name是给该路由起一个名字，可以通过调用RequestHandler.reverse_url(name)来获取该名子对应的url。 # coding:utf-8 import tornado.web import tornado.ioloop import tornado.httpserver import tornado.options from tornado.options import options, define from tornado.web import url, RequestHandler define(\"port\", default=8000, type=int, help=\"run server on the given port.\") class IndexHandler(RequestHandler): def get(self): python_url = self.reverse_url(\"python_url\") self.write('\u003ca href=\"%s\"\u003eitcast\u003c/a\u003e' % python_url) class ItcastHandler(RequestHandler): def initialize(self, subject): self.subject = subject def get(self): self.write(self.subject) if __name__ == \"__main__\": tornado.options.parse_command_line() app = tornado.web.Application([ (r\"/\", Indexhandler), (r\"/cpp\", ItcastHandler, {\"subject\":\"c++\"}), url(r\"/python\", ItcastHandler, {\"subject\":\"python\"}, name=\"python_url\") ], debug = True) http_server = tornado.httpserver.HTTPServer(app) http_server.listen(options.port) tornado.ioloop.IOLoop.current().start() ","date":"2020-12-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E6%B7%B1%E5%85%A5tornado/:1:2","tags":["Python学习之路"],"title":"Python学习之路-Tornado基础:深入Tornado","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E6%B7%B1%E5%85%A5tornado/"},{"categories":["Tornado"],"content":"输入 ","date":"2020-12-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E6%B7%B1%E5%85%A5tornado/:2:0","tags":["Python学习之路"],"title":"Python学习之路-Tornado基础:深入Tornado","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E6%B7%B1%E5%85%A5tornado/"},{"categories":["Tornado"],"content":"简介 下面几节主要讲解tornado.web.RequestHandler。 回想一下，利用HTTP协议向服务器传参有几种途径？ 查询字符串（query string)，形如key1=value1\u0026key2=value2； 请求体（body）中发送的数据，比如表单数据、json、xml； 提取uri的特定部分，如/blogs/2016/09/0001，可以在服务器端的路由中用正则表达式截取； 在http报文的头（header）中增加自定义字段，如X-XSRFToken=itcast。 我们现在来看下tornado中为我们提供了哪些方法来获取请求的信息。 ","date":"2020-12-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E6%B7%B1%E5%85%A5tornado/:2:1","tags":["Python学习之路"],"title":"Python学习之路-Tornado基础:深入Tornado","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E6%B7%B1%E5%85%A5tornado/"},{"categories":["Tornado"],"content":"获取查询字符串参数 get_query_argument(name, default=_ARG_DEFAULT, strip=True) 从请求的查询字符串中返回指定参数name的值，如果出现多个同名参数，则返回最后一个的值。 default为设值未传name参数时返回的默认值，如若default也未设置，则会抛出tornado.web.MissingArgumentError异常。 strip表示是否过滤掉左右两边的空白字符，默认为过滤。 get_query_arguments(name, strip=True) 从请求的查询字符串中返回指定参数name的值，注意返回的是list列表（即使对应name参数只有一个值）。若未找到name参数，则返回空列表[]。 strip同前，不再赘述。 ","date":"2020-12-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E6%B7%B1%E5%85%A5tornado/:2:2","tags":["Python学习之路"],"title":"Python学习之路-Tornado基础:深入Tornado","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E6%B7%B1%E5%85%A5tornado/"},{"categories":["Tornado"],"content":"获取请求体参数 get_body_argument(name, default=_ARG_DEFAULT, strip=True) 从请求体中返回指定参数name的值，如果出现多个同名参数，则返回最后一个的值。 default与strip同前，不再赘述。 get_body_arguments(name, strip=True) 从请求体中返回指定参数name的值，注意返回的是list列表（即使对应name参数只有一个值）。若未找到name参数，则返回空列表[]。 strip同前，不再赘述。 说明 对于请求体中的数据要求为字符串，且格式为表单编码格式（与url中的请求字符串格式相同），即key1=value1\u0026key2=value2，HTTP报文头Header中的\"Content-Type\"为application/x-www-form-urlencoded 或 multipart/form-data。对于请求体数据为json或xml的，无法通过这两个方法获取。 ","date":"2020-12-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E6%B7%B1%E5%85%A5tornado/:2:3","tags":["Python学习之路"],"title":"Python学习之路-Tornado基础:深入Tornado","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E6%B7%B1%E5%85%A5tornado/"},{"categories":["Tornado"],"content":"前两类方法的整合 get_argument(name, default=_ARG_DEFAULT, strip=True) 从请求体和查询字符串中返回指定参数name的值，如果出现多个同名参数，则返回最后一个的值。 default与strip同前，不再赘述。 get_arguments(name, strip=True) 从请求体和查询字符串中返回指定参数name的值，注意返回的是list列表（即使对应name参数只有一个值）。若未找到name参数，则返回空列表[]。 strip同前，不再赘述。 说明 对于请求体中数据的要求同前。 这两个方法最常用。 用代码来看上述六中方法的使用： # coding:utf-8 import tornado.web import tornado.ioloop import tornado.httpserver import tornado.options from tornado.options import options, define from tornado.web import RequestHandler, MissingArgumentError define(\"port\", default=8000, type=int, help=\"run server on the given port.\") class IndexHandler(RequestHandler): def post(self): query_arg = self.get_query_argument(\"a\") query_args = self.get_query_arguments(\"a\") body_arg = self.get_body_argument(\"a\") body_args = self.get_body_arguments(\"a\", strip=False) arg = self.get_argument(\"a\") args = self.get_arguments(\"a\") default_arg = self.get_argument(\"b\", \"itcast\") default_args = self.get_arguments(\"b\") try: missing_arg = self.get_argument(\"c\") except MissingArgumentError as e: missing_arg = \"We catched the MissingArgumentError!\" print e missing_args = self.get_arguments(\"c\") rep = \"query_arg:%s\u003cbr/\u003e\" % query_arg rep += \"query_args:%s\u003cbr/\u003e\" % query_args rep += \"body_arg:%s\u003cbr/\u003e\" % body_arg rep += \"body_args:%s\u003cbr/\u003e\" % body_args rep += \"arg:%s\u003cbr/\u003e\" % arg rep += \"args:%s\u003cbr/\u003e\" % args rep += \"default_arg:%s\u003cbr/\u003e\" % default_arg rep += \"default_args:%s\u003cbr/\u003e\" % default_args rep += \"missing_arg:%s\u003cbr/\u003e\" % missing_arg rep += \"missing_args:%s\u003cbr/\u003e\" % missing_args self.write(rep) if __name__ == \"__main__\": tornado.options.parse_command_line() app = tornado.web.Application([ (r\"/\", IndexHandler), ]) http_server = tornado.httpserver.HTTPServer(app) http_server.listen(options.port) tornado.ioloop.IOLoop.current().start() 注意 以上方法返回的都是unicode字符串 ","date":"2020-12-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E6%B7%B1%E5%85%A5tornado/:2:4","tags":["Python学习之路"],"title":"Python学习之路-Tornado基础:深入Tornado","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E6%B7%B1%E5%85%A5tornado/"},{"categories":["Tornado"],"content":"思考 什么时候设置default，什么时候不设置default？ default的默认值_ARG_DEFAULT是什么？ 什么时候使用strip，亦即什么时候要截断空白字符，什么时候不需要？ ","date":"2020-12-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E6%B7%B1%E5%85%A5tornado/:2:5","tags":["Python学习之路"],"title":"Python学习之路-Tornado基础:深入Tornado","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E6%B7%B1%E5%85%A5tornado/"},{"categories":["Tornado"],"content":"关于请求的其他信息 RequestHandler.request 对象存储了关于请求的相关信息，具体属性有： method HTTP的请求方式，如GET或POST; host 被请求的主机名； uri 请求的完整资源标示，包括路径和查询字符串； path 请求的路径部分； query 请求的查询字符串部分； version 使用的HTTP版本； headers 请求的协议头，是类字典型的对象，支持关键字索引的方式获取特定协议头信息，例如：request.headers[“Content-Type”] body 请求体数据； remote_ip 客户端的IP地址； files 用户上传的文件，为字典类型，型如： { \"form_filename1\":[\u003ctornado.httputil.HTTPFile\u003e, \u003ctornado.httputil.HTTPFile\u003e], \"form_filename2\":[\u003ctornado.httputil.HTTPFile\u003e,], ... } tornado.httputil.HTTPFile是接收到的文件对象，它有三个属性： filename 文件的实际名字，与form_filename1不同，字典中的键名代表的是表单对应项的名字； body 文件的数据实体； content_type 文件的类型。 这三个对象属性可以像字典一样支持关键字索引，如request.files[“form_filename1”][0][“body”]。 我们来实现一个上传文件并保存在服务器本地的小程序upload.py： # coding:utf-8 import tornado.web import tornado.ioloop import tornado.httpserver import tornado.options from tornado.options import options, define from tornado.web import RequestHandler define(\"port\", default=8000, type=int, help=\"run server on the given port.\") class IndexHandler(RequestHandler): def get(self): self.write(\"hello itcast.\") class UploadHandler(RequestHandler): def post(self): files = self.request.files img_files = files.get('img') if img_files: img_file = img_files[0][\"body\"] file = open(\"./itcast\", 'w+') file.write(img_file) file.close() self.write(\"OK\") if __name__ == \"__main__\": tornado.options.parse_command_line() app = tornado.web.Application([ (r\"/\", IndexHandler), (r\"/upload\", UploadHandler), ]) http_server = tornado.httpserver.HTTPServer(app) http_server.listen(options.port) tornado.ioloop.IOLoop.current().start() ","date":"2020-12-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E6%B7%B1%E5%85%A5tornado/:2:6","tags":["Python学习之路"],"title":"Python学习之路-Tornado基础:深入Tornado","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E6%B7%B1%E5%85%A5tornado/"},{"categories":["Tornado"],"content":"正则提取uri tornado中对于路由映射也支持正则提取uri，提取出来的参数会作为RequestHandler中对应请求方式的成员方法参数。若在正则表达式中定义了名字，则参数按名传递；若未定义名字，则参数按顺序传递。提取出来的参数会作为对应请求方式的成员方法的参数。 # coding:utf-8 import tornado.web import tornado.ioloop import tornado.httpserver import tornado.options from tornado.options import options, define from tornado.web import RequestHandler define(\"port\", default=8000, type=int, help=\"run server on the given port.\") class IndexHandler(RequestHandler): def get(self): self.write(\"hello itcast.\") class SubjectCityHandler(RequestHandler): def get(self, subject, city): self.write((\"Subject: %s\u003cbr/\u003eCity: %s\" % (subject, city))) class SubjectDateHandler(RequestHandler): def get(self, date, subject): self.write((\"Date: %s\u003cbr/\u003eSubject: %s\" % (date, subject))) if __name__ == \"__main__\": tornado.options.parse_command_line() app = tornado.web.Application([ (r\"/\", IndexHandler), (r\"/sub-city/(.+)/([a-z]+)\", SubjectCityHandler), # 无名方式 (r\"/sub-date/(?P\u003csubject\u003e.+)/(?P\u003cdate\u003e\\d+)\", SubjectDateHandler), #　命名方式 ]) http_server = tornado.httpserver.HTTPServer(app) http_server.listen(options.port) tornado.ioloop.IOLoop.current().start() 建议：提取多个值时最好用命名方式。 ","date":"2020-12-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E6%B7%B1%E5%85%A5tornado/:2:7","tags":["Python学习之路"],"title":"Python学习之路-Tornado基础:深入Tornado","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E6%B7%B1%E5%85%A5tornado/"},{"categories":["Tornado"],"content":"输出 ","date":"2020-12-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E6%B7%B1%E5%85%A5tornado/:3:0","tags":["Python学习之路"],"title":"Python学习之路-Tornado基础:深入Tornado","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E6%B7%B1%E5%85%A5tornado/"},{"categories":["Tornado"],"content":"write(chunk) 将chunk数据写到输出缓冲区。如我们在之前的示例代码中写的： class IndexHandler(RequestHandler): def get(self): self.write(\"hello itcast!\") 想一想，可不可以在同一个处理方法中多次使用write方法？下面的代码会出现什么效果？ class IndexHandler(RequestHandler): def get(self): self.write(\"hello itcast 1!\") self.write(\"hello itcast 2!\") self.write(\"hello itcast 3!\") 提示 write方法是写到缓冲区的，我们可以像写文件一样多次使用write方法不断追加响应内容，最终所有写到缓冲区的内容一起作为本次请求的响应输出。 想一想，如何利用write方法写json数据？ import json class IndexHandler(RequestHandler): def get(self): stu = { \"name\":\"zhangsan\", \"age\":24, \"gender\":1, } stu_json = json.dumps(stu) self.write(stu_json) 实际上，我们可以不用自己手动去做json序列化，当write方法检测到我们传入的chunk参数是字典类型后，会自动帮我们转换为json字符串。 class IndexHandler(RequestHandler): def get(self): stu = { \"name\":\"zhangsan\", \"age\":24, \"gender\":1, } self.write(stu) 两种方式有什么差异？ 对比一下两种方式的响应头header中Content-Type字段，自己手动序列化时为Content-Type:text/html; charset=UTF-8，而采用write方法时为Content-Type:application/json; charset=UTF-8。 write方法除了帮我们将字典转换为json字符串之外，还帮我们将Content-Type设置为application/json; charset=UTF-8。 ","date":"2020-12-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E6%B7%B1%E5%85%A5tornado/:3:1","tags":["Python学习之路"],"title":"Python学习之路-Tornado基础:深入Tornado","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E6%B7%B1%E5%85%A5tornado/"},{"categories":["Tornado"],"content":"set_header(name, value) 利用set_header(name, value)方法，可以手动设置一个名为name、值为value的响应头header字段。 用set_header方法来完成上面write所做的工作。 import json class IndexHandler(RequestHandler): def get(self): stu = { \"name\":\"zhangsan\", \"age\":24, \"gender\":1, } stu_json = json.dumps(stu) self.write(stu_json) self.set_header(\"Content-Type\", \"application/json; charset=UTF-8\") ","date":"2020-12-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E6%B7%B1%E5%85%A5tornado/:3:2","tags":["Python学习之路"],"title":"Python学习之路-Tornado基础:深入Tornado","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E6%B7%B1%E5%85%A5tornado/"},{"categories":["Tornado"],"content":"set_default_headers() 该方法会在进入HTTP处理方法前先被调用，可以重写此方法来预先设置默认的headers。注意：在HTTP处理方法中使用set_header()方法会覆盖掉在set_default_headers()方法中设置的同名header。 class IndexHandler(RequestHandler): def set_default_headers(self): print \"执行了set_default_headers()\" # 设置get与post方式的默认响应体格式为json self.set_header(\"Content-Type\", \"application/json; charset=UTF-8\") # 设置一个名为itcast、值为python的header self.set_header(\"itcast\", \"python\") def get(self): print \"执行了get()\" stu = { \"name\":\"zhangsan\", \"age\":24, \"gender\":1, } stu_json = json.dumps(stu) self.write(stu_json) self.set_header(\"itcast\", \"i love python\") # 注意此处重写了header中的itcast字段 def post(self): print \"执行了post()\" stu = { \"name\":\"zhangsan\", \"age\":24, \"gender\":1, } stu_json = json.dumps(stu) self.write(stu_json) ","date":"2020-12-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E6%B7%B1%E5%85%A5tornado/:3:3","tags":["Python学习之路"],"title":"Python学习之路-Tornado基础:深入Tornado","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E6%B7%B1%E5%85%A5tornado/"},{"categories":["Tornado"],"content":"set_status(status_code, reason=None) 为响应设置状态码。 参数说明： status_code int类型，状态码，若reason为None，则状态码必须为下表中的。 reason string类型，描述状态码的词组，若为None，则会被自动填充为下表中的内容。 Code Enum Name Details 100 CONTINUE HTTP/1.1 RFC 7231, Section 6.2.1 101 SWITCHING_PROTOCOLS HTTP/1.1 RFC 7231, Section 6.2.2 102 PROCESSING WebDAV RFC 2518, Section 10.1 200 OK HTTP/1.1 RFC 7231, Section 6.3.1 201 CREATED HTTP/1.1 RFC 7231, Section 6.3.2 202 ACCEPTED HTTP/1.1 RFC 7231, Section 6.3.3 203 NON_AUTHORITATIVE_INFORMATION HTTP/1.1 RFC 7231, Section 6.3.4 204 NO_CONTENT HTTP/1.1 RFC 7231, Section 6.3.5 205 RESET_CONTENT HTTP/1.1 RFC 7231, Section 6.3.6 206 PARTIAL_CONTENT HTTP/1.1 RFC 7233, Section 4.1 207 MULTI_STATUS WebDAV RFC 4918, Section 11.1 208 ALREADY_REPORTED WebDAV Binding Extensions RFC 5842, Section 7.1 (Experimental) 226 IM_USED Delta Encoding in HTTP RFC 3229, Section 10.4.1 300 MULTIPLE_CHOICES HTTP/1.1 RFC 7231, Section 6.4.1 301 MOVED_PERMANENTLY HTTP/1.1 RFC 7231, Section 6.4.2 302 FOUND HTTP/1.1 RFC 7231, Section 6.4.3 303 SEE_OTHER HTTP/1.1 RFC 7231, Section 6.4.4 304 NOT_MODIFIED HTTP/1.1 RFC 7232, Section 4.1 305 USE_PROXY HTTP/1.1 RFC 7231, Section 6.4.5 307 TEMPORARY_REDIRECT HTTP/1.1 RFC 7231, Section 6.4.7 308 PERMANENT_REDIRECT Permanent Redirect RFC 7238, Section 3 (Experimental) 400 BAD_REQUEST HTTP/1.1 RFC 7231, Section 6.5.1 401 UNAUTHORIZED HTTP/1.1 Authentication RFC 7235, Section 3.1 402 PAYMENT_REQUIRED HTTP/1.1 RFC 7231, Section 6.5.2 403 FORBIDDEN HTTP/1.1 RFC 7231, Section 6.5.3 404 NOT_FOUND HTTP/1.1 RFC 7231, Section 6.5.4 405 METHOD_NOT_ALLOWED HTTP/1.1 RFC 7231, Section 6.5.5 406 NOT_ACCEPTABLE HTTP/1.1 RFC 7231, Section 6.5.6 407 PROXY_AUTHENTICATION_REQUIRED HTTP/1.1 Authentication RFC 7235, Section 3.2 408 REQUEST_TIMEOUT HTTP/1.1 RFC 7231, Section 6.5.7 409 CONFLICT HTTP/1.1 RFC 7231, Section 6.5.8 410 GONE HTTP/1.1 RFC 7231, Section 6.5.9 411 LENGTH_REQUIRED HTTP/1.1 RFC 7231, Section 6.5.10 412 PRECONDITION_FAILED HTTP/1.1 RFC 7232, Section 4.2 413 REQUEST_ENTITY_TOO_LARGE HTTP/1.1 RFC 7231, Section 6.5.11 414 REQUEST_URI_TOO_LONG HTTP/1.1 RFC 7231, Section 6.5.12 415 UNSUPPORTED_MEDIA_TYPE HTTP/1.1 RFC 7231, Section 6.5.13 416 REQUEST_RANGE_NOT_SATISFIABLE HTTP/1.1 Range Requests RFC 7233, Section 4.4 417 EXPECTATION_FAILED HTTP/1.1 RFC 7231, Section 6.5.14 422 UNPROCESSABLE_ENTITY WebDAV RFC 4918, Section 11.2 423 LOCKED WebDAV RFC 4918, Section 11.3 424 FAILED_DEPENDENCY WebDAV RFC 4918, Section 11.4 426 UPGRADE_REQUIRED HTTP/1.1 RFC 7231, Section 6.5.15 428 PRECONDITION_REQUIRED Additional HTTP Status Codes RFC 6585 429 TOO_MANY_REQUESTS Additional HTTP Status Codes RFC 6585 431 REQUEST_HEADER_FIELDS_TOO_LARGE Additional HTTP Status Codes RFC 6585 500 INTERNAL_SERVER_ERROR HTTP/1.1 RFC 7231, Section 6.6.1 501 NOT_IMPLEMENTED HTTP/1.1 RFC 7231, Section 6.6.2 502 BAD_GATEWAY HTTP/1.1 RFC 7231, Section 6.6.3 503 SERVICE_UNAVAILABLE HTTP/1.1 RFC 7231, Section 6.6.4 504 GATEWAY_TIMEOUT HTTP/1.1 RFC 7231, Section 6.6.5 505 HTTP_VERSION_NOT_SUPPORTED HTTP/1.1 RFC 7231, Section 6.6.6 506 VARIANT_ALSO_NEGOTIATES Transparent Content Negotiation in HTTP RFC 2295, Section 8.1 (Experimental) 507 INSUFFICIENT_STORAGE WebDAV RFC 4918, Section 11.5 508 LOOP_DETECTED WebDAV Binding Extensions RFC 5842, Section 7.2 (Experimental) 510 NOT_EXTENDED An HTTP Extension Framework RFC 2774, Section 7 (Experimental) 511 NETWORK_AUTHENTICATION_REQUIRED Additional HTTP Status Codes RFC 6585, Section 6 class Err404Handler(RequestHandler): \"\"\"对应/err/404\"\"\" def get(self): self.write(\"hello itcast\") self.set_status(404) # 标准状态码，不用设置reason class Err210Handler(RequestHandler): \"\"\"对应/err/210\"\"\" def get(self): self.write(\"hello itcast\") self.set_status(210, \"itcast error\") # 非标准状态码，设置了reason class Err211Handler(RequestHandler): \"\"\"对应/err/211\"\"\" def get(self): self.write(\"hello itcast\") self.set_status(211) # 非标准状态码，未设置reason，错误 ","date":"2020-12-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E6%B7%B1%E5%85%A5tornado/:3:4","tags":["Python学习之路"],"title":"Python学习之路-Tornado基础:深入Tornado","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E6%B7%B1%E5%85%A5tornado/"},{"categories":["Tornado"],"content":"redirect(url) 告知浏览器跳转到url。 class IndexHandler(RequestHandler): \"\"\"对应/\"\"\" def get(self): self.write(\"主页\") class LoginHandler(RequestHandler): \"\"\"对应/login\"\"\" def get(self): self.write('\u003cform method=\"post\"\u003e\u003cinput type=\"submit\" value=\"登陆\"\u003e\u003c/form\u003e') def post(self): self.redirect(\"/\") ","date":"2020-12-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E6%B7%B1%E5%85%A5tornado/:3:5","tags":["Python学习之路"],"title":"Python学习之路-Tornado基础:深入Tornado","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E6%B7%B1%E5%85%A5tornado/"},{"categories":["Tornado"],"content":"send_error(status_code=500, **kwargs) 抛出HTTP错误状态码status_code，默认为500，kwargs为可变命名参数。使用send_error抛出错误后tornado会调用write_error()方法进行处理，并返回给浏览器处理后的错误页面。 class IndexHandler(RequestHandler): def get(self): self.write(\"主页\") self.send_error(404, content=\"出现404错误\") 注意 默认的write\\_error()方法不会处理send\\_error抛出的kwargs参数，即上面的代码中content=\"出现404错误\"是没有意义的。 尝试下面的代码会出现什么问题？ class IndexHandler(RequestHandler): def get(self): self.write(\"主页\") self.send_error(404, content=\"出现404错误\") self.write(\"结束\") # 我们在send_error再次向输出缓冲区写内容 注意 使用send_error()方法后就不要再向输出缓冲区写内容了！ ","date":"2020-12-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E6%B7%B1%E5%85%A5tornado/:3:6","tags":["Python学习之路"],"title":"Python学习之路-Tornado基础:深入Tornado","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E6%B7%B1%E5%85%A5tornado/"},{"categories":["Tornado"],"content":"write_error(status_code, **kwargs) 用来处理send_error抛出的错误信息并返回给浏览器错误信息页面。可以重写此方法来定制自己的错误显示页面。 class IndexHandler(RequestHandler): def get(self): err_code = self.get_argument(\"code\", None) # 注意返回的是unicode字符串，下同 err_title = self.get_argument(\"title\", \"\") err_content = self.get_argument(\"content\", \"\") if err_code: self.send_error(err_code, title=err_title, content=err_content) else: self.write(\"主页\") def write_error(self, status_code, **kwargs): self.write(u\"\u003ch1\u003e出错了，程序员GG正在赶过来！\u003c/h1\u003e\") self.write(u\"\u003cp\u003e错误名：%s\u003c/p\u003e\" % kwargs[\"title\"]) self.write(u\"\u003cp\u003e错误详情：%s\u003c/p\u003e\" % kwargs[\"content\"]) ","date":"2020-12-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E6%B7%B1%E5%85%A5tornado/:3:7","tags":["Python学习之路"],"title":"Python学习之路-Tornado基础:深入Tornado","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E6%B7%B1%E5%85%A5tornado/"},{"categories":["Tornado"],"content":"接口与调用顺序 下面的接口方法是由tornado框架进行调用的，我们可以选择性的重写这些方法。 ","date":"2020-12-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E6%B7%B1%E5%85%A5tornado/:4:0","tags":["Python学习之路"],"title":"Python学习之路-Tornado基础:深入Tornado","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E6%B7%B1%E5%85%A5tornado/"},{"categories":["Tornado"],"content":"initialize() 对应每个请求的处理类Handler在构造一个实例后首先执行initialize()方法。在讲输入时提到，**路由映射中的第三个字典型参数会作为该方法的命名参数传递，**如： class ProfileHandler(RequestHandler): def initialize(self, database): self.database = database def get(self): ... app = Application([ (r'/user/(.*)', ProfileHandler, dict(database=database)), ]) 此方法通常用来初始化参数（对象属性），很少使用。 ","date":"2020-12-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E6%B7%B1%E5%85%A5tornado/:4:1","tags":["Python学习之路"],"title":"Python学习之路-Tornado基础:深入Tornado","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E6%B7%B1%E5%85%A5tornado/"},{"categories":["Tornado"],"content":"prepare() 预处理，即在执行对应请求方式的HTTP方法（如get、post等）前先执行，注意：不论以何种HTTP方式请求，都会执行prepare()方法。 以预处理请求体中的json数据为例： import json class IndexHandler(RequestHandler): def prepare(self): if self.request.headers.get(\"Content-Type\").startswith(\"application/json\"): self.json_dict = json.loads(self.request.body) else: self.json_dict = None def post(self): if self.json_dict: for key, value in self.json_dict.items(): self.write(\"\u003ch3\u003e%s\u003c/h3\u003e\u003cp\u003e%s\u003c/p\u003e\" % (key, value)) def put(self): if self.json_dict: for key, value in self.json_dict.items(): self.write(\"\u003ch3\u003e%s\u003c/h3\u003e\u003cp\u003e%s\u003c/p\u003e\" % (key, value)) ","date":"2020-12-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E6%B7%B1%E5%85%A5tornado/:4:2","tags":["Python学习之路"],"title":"Python学习之路-Tornado基础:深入Tornado","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E6%B7%B1%E5%85%A5tornado/"},{"categories":["Tornado"],"content":"HTTP方法 方法 描述 get 请求指定的页面信息，并返回实体主体。 head 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头 post 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 delete 请求服务器删除指定的内容。 patch 请求修改局部数据。 put 从客户端向服务器传送的数据取代指定的文档的内容。 options 返回给定URL支持的所有HTTP方法。 ","date":"2020-12-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E6%B7%B1%E5%85%A5tornado/:4:3","tags":["Python学习之路"],"title":"Python学习之路-Tornado基础:深入Tornado","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E6%B7%B1%E5%85%A5tornado/"},{"categories":["Tornado"],"content":"on_finish() 在请求处理结束后调用，即在调用HTTP方法后调用。通常该方法用来进行资源清理释放或处理日志等。注意：请尽量不要在此方法中进行响应输出。 ","date":"2020-12-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E6%B7%B1%E5%85%A5tornado/:4:4","tags":["Python学习之路"],"title":"Python学习之路-Tornado基础:深入Tornado","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E6%B7%B1%E5%85%A5tornado/"},{"categories":["Tornado"],"content":"调用顺序 我们通过一段程序来看上面这些接口的调用顺序。 class IndexHandler(RequestHandler): def initialize(self): print \"调用了initialize()\" def prepare(self): print \"调用了prepare()\" def set_default_headers(self): print \"调用了set_default_headers()\" def write_error(self, status_code, **kwargs): print \"调用了write_error()\" def get(self): print \"调用了get()\" def post(self): print \"调用了post()\" self.send_error(200) # 注意此出抛出了错误 def on_finish(self): print \"调用了on_finish()\" 在正常情况未抛出错误时，调用顺序为： set_defautl_headers() initialize() prepare() HTTP方法 on_finish() 在有错误抛出时，调用顺序为： set_default_headers() initialize() prepare() HTTP方法 set_default_headers() write_error() on_finish() ","date":"2020-12-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E6%B7%B1%E5%85%A5tornado/:5:0","tags":["Python学习之路"],"title":"Python学习之路-Tornado基础:深入Tornado","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E6%B7%B1%E5%85%A5tornado/"},{"categories":["Tornado"],"content":"安装 ","date":"2020-12-12","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E5%88%9D%E8%AF%86tornado/:1:0","tags":["Python学习之路"],"title":"Python学习之路-Tornado基础:初识Tornado","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E5%88%9D%E8%AF%86tornado/"},{"categories":["Tornado"],"content":"自动安装 $ pip install tornado ","date":"2020-12-12","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E5%88%9D%E8%AF%86tornado/:1:1","tags":["Python学习之路"],"title":"Python学习之路-Tornado基础:初识Tornado","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E5%88%9D%E8%AF%86tornado/"},{"categories":["Tornado"],"content":"手动安装 下载安装包tornado-4.3.tar.gz（https://pypi.python.org/packages/source/t/tornado/tornado-4.3.tar.gz） $ tar xvzf tornado-4.3.tar.gz $ cd tornado-4.3 $ python setup.py build $ sudo python setup.py install ","date":"2020-12-12","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E5%88%9D%E8%AF%86tornado/:1:2","tags":["Python学习之路"],"title":"Python学习之路-Tornado基础:初识Tornado","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E5%88%9D%E8%AF%86tornado/"},{"categories":["Tornado"],"content":"关于使用平台的说明 Tornado should run on any Unix-like platform, although for the best performance and scalability only Linux (with epoll) and BSD (with kqueue) are recommended for production deployment (even though Mac OS X is derived from BSD and supports kqueue, its networking performance is generally poor so it is recommended only for development use). Tornado will also run on Windows, although this configuration is not officially supported and is recommended only for development use. Tornado应该运行在类Unix平台，在线上部署时为了最佳的性能和扩展性，仅推荐Linux和BSD（因为充分利用Linux的epoll工具和BSD的kqueue工具，是Tornado不依靠多进程/多线程而达到高性能的原因）。 对于Mac OS X，虽然也是衍生自BSD并且支持kqueue，但是其网络性能通常不太给力，因此仅推荐用于开发。 对于Windows，Tornado官方没有提供配置支持，但是也可以运行起来，不过仅推荐在开发中使用。 ","date":"2020-12-12","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E5%88%9D%E8%AF%86tornado/:2:0","tags":["Python学习之路"],"title":"Python学习之路-Tornado基础:初识Tornado","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E5%88%9D%E8%AF%86tornado/"},{"categories":["Tornado"],"content":"前言 ","date":"2020-12-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80hellotornado/:1:0","tags":["Python学习之路"],"title":"Python学习之路-Tornado基础:HelloTornado","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80hellotornado/"},{"categories":["Tornado"],"content":"回想Django的部署方式 以Django为代表的python web应用部署时采用wsgi协议与服务器对接（被服务器托管），而这类服务器通常都是基于多线程的，也就是说每一个网络请求服务器都会有一个对应的线程来用web应用（如Django）进行处理。 ","date":"2020-12-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80hellotornado/:1:1","tags":["Python学习之路"],"title":"Python学习之路-Tornado基础:HelloTornado","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80hellotornado/"},{"categories":["Tornado"],"content":"考虑两类应用场景 用户量大，高并发 如秒杀抢购、双十一某宝购物、春节抢火车票 大量的HTTP持久连接 使用同一个TCP连接来发送和接收多个HTTP请求/应答，而不是为每一个新的请求/应答打开新的连接的方法。 对于HTTP 1.0，可以在请求的包头（Header）中添加Connection: Keep-Alive。 对于HTTP 1.1，所有的连接默认都是持久连接。 对于这两种场景，通常基于多线程的服务器很难应对。 ","date":"2020-12-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80hellotornado/:1:2","tags":["Python学习之路"],"title":"Python学习之路-Tornado基础:HelloTornado","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80hellotornado/"},{"categories":["Tornado"],"content":"C10K问题 对于前文提出的这种高并发问题，我们通常用C10K这一概念来描述。C10K—— Concurrently handling ten thousand connections，即并发10000个连接。对于单台服务器而言，根本无法承担，而采用多台服务器分布式又意味着高昂的成本。如何解决C10K问题？ ","date":"2020-12-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80hellotornado/:1:3","tags":["Python学习之路"],"title":"Python学习之路-Tornado基础:HelloTornado","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80hellotornado/"},{"categories":["Tornado"],"content":"Tornado Tornado在设计之初就考虑到了性能因素，旨在解决C10K问题，这样的设计使得其成为一个拥有非常高性能的解决方案（服务器与框架的集合体）。 ","date":"2020-12-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80hellotornado/:1:4","tags":["Python学习之路"],"title":"Python学习之路-Tornado基础:HelloTornado","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80hellotornado/"},{"categories":["Tornado"],"content":"Tornado是为何物 ","date":"2020-12-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80hellotornado/:2:0","tags":["Python学习之路"],"title":"Python学习之路-Tornado基础:HelloTornado","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80hellotornado/"},{"categories":["Tornado"],"content":"简介 Tornado全称Tornado Web Server，是一个用Python语言写成的Web服务器兼Web应用框架，由FriendFeed公司在自己的网站FriendFeed中使用，被Facebook收购以后框架在2009年9月以开源软件形式开放给大众。 ","date":"2020-12-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80hellotornado/:2:1","tags":["Python学习之路"],"title":"Python学习之路-Tornado基础:HelloTornado","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80hellotornado/"},{"categories":["Tornado"],"content":"特点 作为Web框架，是一个轻量级的Web框架，类似于另一个Python web框架Web.py，其拥有异步非阻塞IO的处理方式。 作为Web服务器，Tornado有较为出色的抗负载能力，官方用nginx反向代理的方式部署Tornado和其它Python web应用框架进行对比，结果最大浏览量超过第二名近40%。 ","date":"2020-12-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80hellotornado/:2:2","tags":["Python学习之路"],"title":"Python学习之路-Tornado基础:HelloTornado","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80hellotornado/"},{"categories":["Tornado"],"content":"性能 Tornado有着优异的性能。它试图解决C10k问题，即处理大于或等于一万的并发。Tornado框架和服务器一起组成一个WSGI的全栈替代品。单独在WSGI容器中使用tornado网络框架或者tornaod http服务器，有一定的局限性，为了最大化的利用tornado的性能，推荐同时使用tornaod的网络框架和HTTP服务器 ","date":"2020-12-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80hellotornado/:2:3","tags":["Python学习之路"],"title":"Python学习之路-Tornado基础:HelloTornado","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80hellotornado/"},{"categories":["Tornado"],"content":"与Django对比 ","date":"2020-12-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80hellotornado/:3:0","tags":["Python学习之路"],"title":"Python学习之路-Tornado基础:HelloTornado","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80hellotornado/"},{"categories":["Tornado"],"content":"Django Django是走大而全的方向，注重的是高效开发，它最出名的是其全自动化的管理后台：只需要使用起ORM，做简单的对象定义，它就能自动生成数据库结构、以及全功能的管理后台。 Django提供的方便，也意味着Django内置的ORM跟框架内的其他模块耦合程度高，应用程序必须使用Django内置的ORM，否则就不能享受到框架内提供的种种基于其ORM的便利。 session功能 后台管理 ORM ","date":"2020-12-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80hellotornado/:3:1","tags":["Python学习之路"],"title":"Python学习之路-Tornado基础:HelloTornado","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80hellotornado/"},{"categories":["Tornado"],"content":"Tornado Tornado走的是少而精的方向，注重的是性能优越，它最出名的是异步非阻塞的设计方式。 HTTP服务器 异步编程 WebSockets ","date":"2020-12-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80hellotornado/:3:2","tags":["Python学习之路"],"title":"Python学习之路-Tornado基础:HelloTornado","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80hellotornado/"},{"categories":["Django"],"content":"认证 ","date":"2020-10-17","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD/:1:0","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:其他功能","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD/"},{"categories":["Django"],"content":"使用 可以在配置文件中配置全局默认的认证方案 REST_FRAMEWORK = { 'DEFAULT_AUTHENTICATION_CLASSES': ( 'rest_framework.authentication.BasicAuthentication', # 基本认证 'rest_framework.authentication.SessionAuthentication', # session认证 ) } 也可以在每个视图中通过设置authentication_classess属性来设置 from rest_framework.authentication import SessionAuthentication, BasicAuthentication from rest_framework.views import APIView class ExampleView(APIView): authentication_classes = (SessionAuthentication, BasicAuthentication) ... ","date":"2020-10-17","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD/:1:1","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:其他功能","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD/"},{"categories":["Django"],"content":"返回值 认证失败会有两种可能的返回值： 401 Unauthorized 未认证 403 Permission Denied 权限被禁止 ","date":"2020-10-17","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD/:1:2","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:其他功能","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD/"},{"categories":["Django"],"content":"权限 ","date":"2020-10-17","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD/:2:0","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:其他功能","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD/"},{"categories":["Django"],"content":"简介 权限控制可以限制用户对于视图的访问和对于具体数据对象的访问。 在执行视图的dispatch()方法前，会先进行视图访问权限的判断 在通过get_object()获取具体对象时，会进行对象访问权限的判断 ","date":"2020-10-17","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD/:2:1","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:其他功能","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD/"},{"categories":["Django"],"content":"使用 可以在配置文件中设置默认的权限管理类，如 REST_FRAMEWORK = { 'DEFAULT_PERMISSION_CLASSES': ( 'rest_framework.permissions.IsAuthenticated', ) } 如果未指明，则采用如下默认配置 'DEFAULT_PERMISSION_CLASSES': ( 'rest_framework.permissions.AllowAny', ) 也可以在具体的视图中通过permission_classes属性来设置，如 from rest_framework.permissions import IsAuthenticated from rest_framework.views import APIView class ExampleView(APIView): permission_classes = (IsAuthenticated,) ... ","date":"2020-10-17","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD/:2:2","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:其他功能","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD/"},{"categories":["Django"],"content":"提供的权限 AllowAny 允许所有用户 IsAuthenticated 仅通过认证的用户 IsAdminUser 仅管理员用户 IsAuthenticatedOrReadOnly 认证的用户可以完全操作，否则只能get读取 ","date":"2020-10-17","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD/:2:3","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:其他功能","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD/"},{"categories":["Django"],"content":"举例 from rest_framework.authentication import SessionAuthentication from rest_framework.permissions import IsAuthenticated from rest_framework.generics import RetrieveAPIView class BookDetailView(RetrieveAPIView): queryset = BookInfo.objects.all() serializer_class = BookInfoSerializer authentication_classes = [SessionAuthentication] permission_classes = [IsAuthenticated] ","date":"2020-10-17","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD/:2:4","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:其他功能","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD/"},{"categories":["Django"],"content":"自定义权限 如需自定义权限，需继承rest_framework.permissions.BasePermission父类，并实现以下两个任何一个方法或全部 .has_permission(self, request, view) 是否可以访问视图， view表示当前视图对象 .has_object_permission(self, request, view, obj) 是否可以访问数据对象， view表示当前视图， obj为数据对象 例如： class MyPermission(BasePermission): def has_object_permission(self, request, view, obj): \"\"\"控制对obj对象的访问权限，此案例决绝所有对对象的访问\"\"\" return False class BookInfoViewSet(ModelViewSet): queryset = BookInfo.objects.all() serializer_class = BookInfoSerializer permission_classes = [IsAuthenticated, MyPermission] ","date":"2020-10-17","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD/:2:5","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:其他功能","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD/"},{"categories":["Django"],"content":"限流 ","date":"2020-10-17","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD/:3:0","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:其他功能","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD/"},{"categories":["Django"],"content":"简介 可以对接口访问的频次进行限制，以减轻服务器压力。 ","date":"2020-10-17","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD/:3:1","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:其他功能","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD/"},{"categories":["Django"],"content":"使用 可以在配置文件中，使用DEFAULT_THROTTLE_CLASSES 和 DEFAULT_THROTTLE_RATES进行全局配置， REST_FRAMEWORK = { 'DEFAULT_THROTTLE_CLASSES': ( 'rest_framework.throttling.AnonRateThrottle', 'rest_framework.throttling.UserRateThrottle' ), 'DEFAULT_THROTTLE_RATES': { 'anon': '100/day', 'user': '1000/day' } } DEFAULT_THROTTLE_RATES 可以使用 second, minute, hour 或day来指明周期。 也可以在具体视图中通过throttle_classess属性来配置，如 from rest_framework.throttling import UserRateThrottle from rest_framework.views import APIView class ExampleView(APIView): throttle_classes = (UserRateThrottle,) ... ","date":"2020-10-17","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD/:3:2","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:其他功能","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD/"},{"categories":["Django"],"content":"可选限流类 AnonRateThrottle：限制所有匿名未认证用户，使用IP区分用户。使用DEFAULT_THROTTLE_RATES['anon'] 来设置频次 UserRateThrottle：限制认证用户，使用User id 来区分。使用DEFAULT_THROTTLE_RATES['user'] 来设置频次 ScopedRateThrottle：限制用户对于每个视图的访问频次，使用ip或user id。 ","date":"2020-10-17","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD/:3:3","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:其他功能","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD/"},{"categories":["Django"],"content":"过滤 ","date":"2020-10-17","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD/:4:0","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:其他功能","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD/"},{"categories":["Django"],"content":"简介 对于列表数据可能需要根据字段进行过滤，我们可以通过添加django-fitlter扩展来增强支持。 pip insall django-filter ","date":"2020-10-17","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD/:4:1","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:其他功能","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD/"},{"categories":["Django"],"content":"使用 在配置文件中增加过滤后端的设置： INSTALLED_APPS = [ ... 'django_filters', # 需要注册应用， ] REST_FRAMEWORK = { 'DEFAULT_FILTER_BACKENDS': ('django_filters.rest_framework.DjangoFilterBackend',) } 在视图中添加filter_fields属性，指定可以过滤的字段 class BookListView(ListAPIView): queryset = BookInfo.objects.all() serializer_class = BookInfoSerializer filter_fields = ('btitle', 'bread') # 127.0.0.1:8000/books/?btitle=西游记 ","date":"2020-10-17","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD/:4:2","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:其他功能","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD/"},{"categories":["Django"],"content":"排序 ","date":"2020-10-17","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD/:5:0","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:其他功能","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD/"},{"categories":["Django"],"content":"简介 对于列表数据，REST framework提供了OrderingFilter过滤器来帮助我们快速指明数据按照指定字段进行排序。 ","date":"2020-10-17","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD/:5:1","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:其他功能","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD/"},{"categories":["Django"],"content":"使用 在类视图中设置filter_backends，使用rest_framework.filters.OrderingFilter过滤器，REST framework会在请求的查询字符串参数中检查是否包含了ordering参数，如果包含了ordering参数，则按照ordering参数指明的排序字段对数据集进行排序。 前端可以传递的ordering参数的可选字段值需要在ordering_fields中指明。 ","date":"2020-10-17","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD/:5:2","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:其他功能","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD/"},{"categories":["Django"],"content":"分页 ","date":"2020-10-17","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD/:6:0","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:其他功能","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD/"},{"categories":["Django"],"content":"简介 REST framework提供了分页的支持。 ","date":"2020-10-17","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD/:6:1","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:其他功能","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD/"},{"categories":["Django"],"content":"使用 我们可以在配置文件中设置全局的分页方式，如： REST_FRAMEWORK = { 'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination', 'PAGE_SIZE': 100 # 每页数目 } 也可通过自定义Pagination类，来为视图添加不同分页行为。在视图中通过pagination_clas属性来指明。 class LargeResultsSetPagination(PageNumberPagination): page_size = 1000 page_size_query_param = 'page_size' max_page_size = 10000 class BookDetailView(RetrieveAPIView): queryset = BookInfo.objects.all() serializer_class = BookInfoSerializer pagination_class = LargeResultsSetPagination 注意：如果在视图内关闭分页功能，只需在视图内设置 pagination_class = None ","date":"2020-10-17","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD/:6:2","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:其他功能","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD/"},{"categories":["Django"],"content":"可选分页器 PageNumberPagination 前端访问网址形式： GET http://api.example.org/books/?page=4 可以在子类中定义的属性： page_size 每页数目 page_query_param 前端发送的页数关键字名，默认为\"page” page_size_query_param 前端发送的每页数目关键字名，默认为None max_page_size 前端最多能设置的每页数量 from rest_framework.pagination import PageNumberPagination class StandardPageNumberPagination(PageNumberPagination): page_size_query_param = 'page_size' max_page_size = 10 class BookListView(ListAPIView): queryset = BookInfo.objects.all().order_by('id') serializer_class = BookInfoSerializer pagination_class = StandardPageNumberPagination # 127.0.0.1/books/?page=1\u0026page_size=2 LimitOffsetPagination 前端访问网址形式： GET http://api.example.org/books/?limit=100\u0026offset=400 可以在子类中定义的属性： default_limit 默认限制，默认值与PAGE_SIZE设置一直 limit_query_param limit参数名，默认’limit’ offset_query_param offset参数名，默认’offset’ max_limit 最大limit限制，默认None from rest_framework.pagination import LimitOffsetPagination class BookListView(ListAPIView): queryset = BookInfo.objects.all().order_by('id') serializer_class = BookInfoSerializer pagination_class = LimitOffsetPagination # 127.0.0.1:8000/books/?offset=3\u0026limit=2 ","date":"2020-10-17","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD/:6:3","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:其他功能","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD/"},{"categories":["Django"],"content":"版本 ","date":"2020-10-17","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD/:7:0","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:其他功能","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD/"},{"categories":["Django"],"content":"简介 REST framework提供了版本号的支持。在需要获取请求的版本号时，可以通过request.version来获取。默认版本功能未开启，request.version 返回None。 ","date":"2020-10-17","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD/:7:1","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:其他功能","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD/"},{"categories":["Django"],"content":"使用 开启版本支持功能，需要在配置文件中设置DEFAULT_VERSIONING_CLASS REST_FRAMEWORK = { 'DEFAULT_VERSIONING_CLASS': 'rest_framework.versioning.NamespaceVersioning' } 其他可选配置： DEFAULT_VERSION 默认版本号，默认值为None ALLOWED_VERSIONS 允许请求的版本号，默认值为None VERSION_PARAM 识别版本号参数的名称，默认值为’version’ ","date":"2020-10-17","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD/:7:2","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:其他功能","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD/"},{"categories":["Django"],"content":"支持的版本处理方式 AcceptHeaderVersioning 请求头中传递的Accept携带version GET /bookings/ HTTP/1.1 Host: example.com Accept: application/json; version=1.0 URLPathVersioning URL路径中携带 urlpatterns = [ url( r'^(?P\u003cversion\u003e(v1|v2))/bookings/$', bookings_list, name='bookings-list' ), url( r'^(?P\u003cversion\u003e(v1|v2))/bookings/(?P\u003cpk\u003e[0-9]+)/$', bookings_detail, name='bookings-detail' ) ] NamespaceVersioning 命名空间中定义 # bookings/urls.py urlpatterns = [ url(r'^$', bookings_list, name='bookings-list'), url(r'^(?P\u003cpk\u003e[0-9]+)/$', bookings_detail, name='bookings-detail') ] # urls.py urlpatterns = [ url(r'^v1/bookings/', include('bookings.urls', namespace='v1')), url(r'^v2/bookings/', include('bookings.urls', namespace='v2')) ] HostNameVersioning 主机域名携带 GET /bookings/ HTTP/1.1 Host: v1.example.com Accept: application/json QueryParameterVersioning 查询字符串携带 GET /something/?version=0.1 HTTP/1.1 Host: example.com Accept: application/json ","date":"2020-10-17","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD/:7:3","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:其他功能","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD/"},{"categories":["Django"],"content":"异常处理 ","date":"2020-10-17","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD/:8:0","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:其他功能","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD/"},{"categories":["Django"],"content":"简介 REST framework提供了异常处理，我们可以自定义异常处理函数。 ","date":"2020-10-17","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD/:8:1","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:其他功能","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD/"},{"categories":["Django"],"content":"使用 自定义异常处理函数 from rest_framework.views import exception_handler def custom_exception_handler(exc, context): # 先调用REST framework默认的异常处理方法获得标准错误响应对象 response = exception_handler(exc, context) # 在此处补充自定义的异常处理 if response is not None: response.data['status_code'] = response.status_code return response 在配置文件中声明自定义的异常处理 REST_FRAMEWORK = { 'EXCEPTION_HANDLER': 'my_project.my_app.utils.custom_exception_handler' } 如果未声明，会采用默认的方式，如下 REST_FRAMEWORK = { 'EXCEPTION_HANDLER': 'rest_framework.views.exception_handler' } 例如： 补充上处理关于数据库的异常 from rest_framework.views import exception_handler as drf_exception_handler from rest_framework import status from django.db import DatabaseError def exception_handler(exc, context): response = drf_exception_handler(exc, context) if response is None: view = context['view'] if isinstance(exc, DatabaseError): print('[%s]: %s' % (view, exc)) response = Response({'detail': '服务器内部错误'}, status=status.HTTP_507_INSUFFICIENT_STORAGE) return response ","date":"2020-10-17","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD/:8:2","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:其他功能","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD/"},{"categories":["Django"],"content":"REST framework定义的异常 APIException 所有异常的父类 ParseError 解析错误 AuthenticationFailed 认证失败 NotAuthenticated 尚未认证 PermissionDenied 权限决绝 NotFound 未找到 MethodNotAllowed 请求方式不支持 NotAcceptable 要获取的数据格式不支持 Throttled 超过限流次数 ValidationError 校验失败 ","date":"2020-10-17","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD/:8:3","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:其他功能","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD/"},{"categories":["Django"],"content":"自动生成接口文档 ","date":"2020-10-17","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD/:9:0","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:其他功能","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD/"},{"categories":["Django"],"content":"简介 REST framework可以自动帮助我们生成接口文档。接口文档以网页的方式呈现。自动接口文档能生成的是继承自APIView及其子类的视图。 ","date":"2020-10-17","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD/:9:1","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:其他功能","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD/"},{"categories":["Django"],"content":"使用 安装依赖 REST framewrok生成接口文档需要coreapi库的支持。 pip install coreapi 设置接口文档访问路径 在总路由中添加接口文档路径。 文档路由对应的视图配置为rest_framework.documentation.include_docs_urls， 参数title为接口文档网站的标题。 from rest_framework.documentation import include_docs_urls urlpatterns = [ ... url(r'^docs/', include_docs_urls(title='My API title')) ] 文档描述说明的定义位置 单一方法的视图，可直接使用类视图的文档字符串，如 class BookListView(generics.ListAPIView): \"\"\" 返回所有图书信息. \"\"\" 包含多个方法的视图，在类视图的文档字符串中，分开方法定义，如 class BookListCreateView(generics.ListCreateAPIView): \"\"\" get: 返回所有图书信息. post: 新建图书. \"\"\" 对于视图集ViewSet，仍在类视图的文档字符串中封开定义，但是应使用action名称区分，如 class BookInfoViewSet(mixins.ListModelMixin, mixins.RetrieveModelMixin, GenericViewSet): \"\"\" list: 返回图书列表数据 retrieve: 返回图书详情数据 latest: 返回最新的图书数据 read: 修改图书的阅读量 \"\"\" 访问接口文档网页 浏览器访问 127.0.0.1:8000/docs/，即可看到自动生成的接口文档。 两点说明 视图集ViewSet中的retrieve名称，在接口文档网站中叫做read 参数的Description需要在模型类或序列化器类的字段中以help_text选项定义 ","date":"2020-10-17","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD/:9:2","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:其他功能","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD/"},{"categories":["Django"],"content":"视图概览 ","date":"2020-10-10","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%A7%86%E5%9B%BE/:1:0","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:视图","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%A7%86%E5%9B%BE/"},{"categories":["Django"],"content":"简介 REST framework 提供了众多的通用视图基类与扩展类，以简化视图的编写。 ","date":"2020-10-10","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%A7%86%E5%9B%BE/:1:1","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:视图","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%A7%86%E5%9B%BE/"},{"categories":["Django"],"content":"视图的继承关系 ","date":"2020-10-10","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%A7%86%E5%9B%BE/:1:2","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:视图","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%A7%86%E5%9B%BE/"},{"categories":["Django"],"content":"视图的方法与属性 ","date":"2020-10-10","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%A7%86%E5%9B%BE/:1:3","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:视图","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%A7%86%E5%9B%BE/"},{"categories":["Django"],"content":"视图说明 ","date":"2020-10-10","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%A7%86%E5%9B%BE/:2:0","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:视图","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%A7%86%E5%9B%BE/"},{"categories":["Django"],"content":"两个基类 APIView 简介 rest_framework.views.APIView APIView是REST framework提供的所有视图的基类，继承自Django的View父类。 APIView与View的不同之处在于： 传入到视图方法中的是REST framework的Request对象，而不是Django的HttpRequeset对象； 视图方法可以返回REST framework的Response对象，视图会为响应数据设置（render）符合前端要求的格式； 任何APIException异常都会被捕获到，并且处理成合适的响应信息； 在进行dispatch()分发前，会对请求进行身份认证、权限检查、流量控制。 支持定义的属性 authentication_classes 列表或元祖，身份认证类 permissoin_classes 列表或元祖，权限检查类 throttle_classes 列表或元祖，流量控制类 在APIView中仍以常规的类视图定义方法来实现get() 、post() 或者其他请求方式的方法。 举例： from rest_framework.views import APIView from rest_framework.response import Response # url(r'^books/$', views.BookListView.as_view()), class BookListView(APIView): def get(self, request): books = BookInfo.objects.all() serializer = BookInfoSerializer(books, many=True) return Response(serializer.data) GenericAPIView 简介 rest_framework.generics.GenericAPIView 继承自APIVIew，增加了对于列表视图和详情视图可能用到的通用支持方法。通常使用时，可搭配一个或多个Mixin扩展类。 支持定义的属性 列表视图与详情视图通用： queryset 列表视图的查询集 serializer_class 视图使用的序列化器 列表视图使用： pagination_class 分页控制类 filter_backends 过滤控制后端 详情页视图使用： lookup_field 查询单一数据库对象时使用的条件字段，默认为'pk’ lookup_url_kwarg 查询单一数据时URL中的参数关键字名称，默认与look_field相同 提供的方法 列表视图与详情视图通用： get_queryset(self) 返回视图使用的查询集，是列表视图与详情视图获取数据的基础，默认返回queryset属性，可以重写，例如： def get_queryset(self): user = self.request.user return user.accounts.all() get_serializer_class(self) 返回序列化器类，默认返回serializer_class，可以重写，例如： def get_serializer_class(self): if self.request.user.is_staff: return FullAccountSerializer return BasicAccountSerializer get_serializer(self, *args, **kwargs) 返回序列化器对象，被其他视图或扩展类使用，如果我们在视图中想要获取序列化器对象，可以直接调用此方法。 注意，在提供序列化器对象的时候，REST framework会向对象的context属性补充三个数据：request、format、view，这三个数据对象可以在定义序列化器时使用。 详情视图使用： get_object(self) 返回详情视图所需的模型类数据对象，默认使用lookup_field参数来过滤queryset。 在试图中可以调用该方法获取详情信息的模型类对象。 若详情访问的模型类对象不存在，会返回404。 该方法会默认使用APIView提供的check_object_permissions方法检查当前对象是否有权限被访问。 ","date":"2020-10-10","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%A7%86%E5%9B%BE/:2:1","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:视图","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%A7%86%E5%9B%BE/"},{"categories":["Django"],"content":"五个扩展类 ListModelMixin 简介 列表视图扩展类，提供list(request, *args, **kwargs)方法快速实现列表视图，返回200状态码。 该Mixin的list方法会对数据进行过滤和分页。 源代码 class ListModelMixin(object): \"\"\" List a queryset. \"\"\" def list(self, request, *args, **kwargs): # 过滤 queryset = self.filter_queryset(self.get_queryset()) # 分页 page = self.paginate_queryset(queryset) if page is not None: serializer = self.get_serializer(page, many=True) return self.get_paginated_response(serializer.data) # 序列化 serializer = self.get_serializer(queryset, many=True) return Response(serializer.data) CreateModelMixin 简介 创建视图扩展类，提供create(request, *args, **kwargs)方法快速实现创建资源的视图，成功返回201状态码。 如果序列化器对前端发送的数据验证失败，返回400错误。 源代码 class CreateModelMixin(object): \"\"\" Create a model instance. \"\"\" def create(self, request, *args, **kwargs): # 获取序列化器 serializer = self.get_serializer(data=request.data) # 验证 serializer.is_valid(raise_exception=True) # 保存 self.perform_create(serializer) headers = self.get_success_headers(serializer.data) return Response(serializer.data, status=status.HTTP_201_CREATED, headers=headers) def perform_create(self, serializer): serializer.save() def get_success_headers(self, data): try: return {'Location': str(data[api_settings.URL_FIELD_NAME])} except (TypeError, KeyError): return {} RetrieveModelMixin 简介 详情视图扩展类，提供retrieve(request, *args, **kwargs)方法，可以快速实现返回一个存在的数据对象。如果存在，返回200， 否则返回404。 源代码 class RetrieveModelMixin(object): \"\"\" Retrieve a model instance. \"\"\" def retrieve(self, request, *args, **kwargs): # 获取对象，会检查对象的权限 instance = self.get_object() # 序列化 serializer = self.get_serializer(instance) return Response(serializer.data) UpdateModelMixin 简介 更新视图扩展类，提供update(request, *args, **kwargs)方法，可以快速实现更新一个存在的数据对象。 同时也提供partial_update(request, *args, **kwargs)方法，可以实现局部更新。 成功返回200，序列化器校验数据失败时，返回400错误。 源代码 class UpdateModelMixin(object): \"\"\" Update a model instance. \"\"\" def update(self, request, *args, **kwargs): partial = kwargs.pop('partial', False) instance = self.get_object() serializer = self.get_serializer(instance, data=request.data, partial=partial) serializer.is_valid(raise_exception=True) self.perform_update(serializer) if getattr(instance, '_prefetched_objects_cache', None): # If 'prefetch_related' has been applied to a queryset, we need to # forcibly invalidate the prefetch cache on the instance. instance._prefetched_objects_cache = {} return Response(serializer.data) def perform_update(self, serializer): serializer.save() def partial_update(self, request, *args, **kwargs): kwargs['partial'] = True return self.update(request, *args, **kwargs) DestroyModelMixin 简介 删除视图扩展类，提供destroy(request, *args, **kwargs)方法，可以快速实现删除一个存在的数据对象。成功返回204，不存在返回404。 源代码 class DestroyModelMixin(object): \"\"\" Destroy a model instance. \"\"\" def destroy(self, request, *args, **kwargs): instance = self.get_object() self.perform_destroy(instance) return Response(status=status.HTTP_204_NO_CONTENT) def perform_destroy(self, instance): instance.delete() ","date":"2020-10-10","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%A7%86%E5%9B%BE/:2:2","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:视图","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%A7%86%E5%9B%BE/"},{"categories":["Django"],"content":"几个可用子类视图 CreateAPIView 说明 提供 post 方法，继承自： GenericAPIView、CreateModelMixin ListAPIView 提供 get 方法，继承自：GenericAPIView、ListModelMixin RetireveAPIView 提供 get 方法，继承自: GenericAPIView、RetrieveModelMixin DestoryAPIView 提供 delete 方法，继承自：GenericAPIView、DestoryModelMixin UpdateAPIView 提供 put 和 patch 方法，继承自：GenericAPIView、UpdateModelMixin RetrieveUpdateAPIView 提供 get、put、patch方法，继承自： GenericAPIView、RetrieveModelMixin、UpdateModelMixin RetrieveUpdateDestoryAPIView 提供 get、put、patch、delete方法，继承自：GenericAPIView、RetrieveModelMixin、UpdateModelMixin、DestoryModelMixin ","date":"2020-10-10","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%A7%86%E5%9B%BE/:2:3","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:视图","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%A7%86%E5%9B%BE/"},{"categories":["Django"],"content":"视图集ViewSet ","date":"2020-10-10","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%A7%86%E5%9B%BE/:3:0","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:视图","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%A7%86%E5%9B%BE/"},{"categories":["Django"],"content":"简介 使用视图集ViewSet，可以将一系列逻辑相关的动作放到一个类中： list() 提供一组数据 retrieve() 提供单个数据 create() 创建数据 update() 保存数据 destory() 删除数据 ViewSet视图集类不再实现get()、post()等方法，而是实现动作 action 如 list() 、create() 等。 视图集只在使用as_view()方法的时候，才会将action动作与具体请求方式对应上。如： class BookInfoViewSet(viewsets.ViewSet): def list(self, request): ... def retrieve(self, request, pk=None): ... 在设置路由时，我们可以如下操作 urlpatterns = [ url(r'^books/$', BookInfoViewSet.as_view({'get':'list'}), url(r'^books/(?P\u003cpk\u003e\\d+)/$', BookInfoViewSet.as_view({'get': 'retrieve'}) ] ","date":"2020-10-10","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%A7%86%E5%9B%BE/:3:1","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:视图","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%A7%86%E5%9B%BE/"},{"categories":["Django"],"content":"action属性 在视图集中，我们可以通过action对象属性来获取当前请求视图集时的action动作是哪个。 例如： def get_serializer_class(self): if self.action == 'create': return OrderCommitSerializer else: return OrderDataSerializer ","date":"2020-10-10","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%A7%86%E5%9B%BE/:3:2","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:视图","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%A7%86%E5%9B%BE/"},{"categories":["Django"],"content":"常用视图集父类 ViewSet 继承自APIView，作用也与APIView基本类似，提供了身份认证、权限校验、流量管理等。 在ViewSet中，没有提供任何动作action方法，需要我们自己实现action方法。 GenericViewSet 继承自GenericAPIView，作用也与GenericAPIVIew类似，提供了get_object、get_queryset等方法便于列表视图与详情信息视图的开发。 ModelViewSet 继承自GenericAPIVIew，同时包括了ListModelMixin、RetrieveModelMixin、CreateModelMixin、UpdateModelMixin、DestoryModelMixin。 ReadOnlyModelViewSet 继承自GenericAPIVIew，同时包括了ListModelMixin、RetrieveModelMixin。 ","date":"2020-10-10","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%A7%86%E5%9B%BE/:3:3","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:视图","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%A7%86%E5%9B%BE/"},{"categories":["Django"],"content":"视图集中定义附加action动作 在视图集中，除了上述默认的方法动作外，还可以添加自定义动作。 添加自定义动作需要使用rest_framework.decorators.action装饰器。 以action装饰器装饰的方法名会作为action动作名，与list、retrieve等同。 action装饰器可以接收两个参数： methods: 该action支持的请求方式，列表传递 detail 表示是action中要处理的是否是视图资源的对象（即是否通过url路径获取主键） True 表示使用通过URL获取的主键对应的数据对象 False 表示不使用URL获取主键 ","date":"2020-10-10","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%A7%86%E5%9B%BE/:3:4","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:视图","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%A7%86%E5%9B%BE/"},{"categories":["Django"],"content":"路由Routers ","date":"2020-10-10","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%A7%86%E5%9B%BE/:4:0","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:视图","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%A7%86%E5%9B%BE/"},{"categories":["Django"],"content":"简介 对于视图集ViewSet，我们除了可以自己手动指明请求方式与动作action之间的对应关系外，还可以使用Routers来帮助我们快速实现路由信息。 REST framework提供了两个router SimpleRouter DefaultRouter ","date":"2020-10-10","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%A7%86%E5%9B%BE/:4:1","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:视图","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%A7%86%E5%9B%BE/"},{"categories":["Django"],"content":"使用方法 创建router对象，并注册视图集，例如 from rest_framework import routers router = routers.SimpleRouter() router.register(r'books', BookInfoViewSet, base_name='book') register(prefix, viewset, base_name) prefix 该视图集的路由前缀 viewset 视图集 base_name 路由名称的前缀 如上述代码会形成的路由如下： ^books/$ name: book-list ^books/{pk}/$ name: book-detail 添加路由数据，可以有两种方式： urlpatterns = [ ... ] urlpatterns += router.urls 或 urlpatterns = [ ... url(r'^', include(router.urls)) ] ","date":"2020-10-10","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%A7%86%E5%9B%BE/:4:2","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:视图","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%A7%86%E5%9B%BE/"},{"categories":["Django"],"content":"视图集中包含附加action的 class BookInfoViewSet(mixins.ListModelMixin, mixins.RetrieveModelMixin, GenericViewSet): queryset = BookInfo.objects.all() serializer_class = BookInfoSerializer @action(methods=['get'], detail=False) def latest(self, request): ... @action(methods=['put'], detail=True) def read(self, request, pk): ... 此视图集会形成的路由： ^books/latest/$ name: book-latest ^books/{pk}/read/$ name: book-read ","date":"2020-10-10","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%A7%86%E5%9B%BE/:4:3","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:视图","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%A7%86%E5%9B%BE/"},{"categories":["Django"],"content":"路由router形成URL的方式 1） SimpleRouter 2）DefaultRouter DefaultRouter与SimpleRouter的区别是，DefaultRouter会多附带一个默认的API根视图，返回一个包含所有列表视图的超链接响应数据。 ","date":"2020-10-10","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%A7%86%E5%9B%BE/:4:4","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:视图","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%A7%86%E5%9B%BE/"},{"categories":["Django"],"content":"Request ","date":"2020-10-10","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%A7%86%E5%9B%BE/:5:0","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:视图","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%A7%86%E5%9B%BE/"},{"categories":["Django"],"content":"简介 REST framework 传入视图的request对象不再是Django默认的HttpRequest对象，而是REST framework提供的扩展了HttpRequest类的Request类的对象。 REST framework 提供了Parser解析器，在接收到请求后会自动根据Content-Type指明的请求数据类型（如JSON、表单等）将请求数据进行parse解析，解析为类字典对象保存到Request对象中。 Request对象的数据是自动根据前端发送数据的格式进行解析之后的结果。 无论前端发送的哪种格式的数据，我们都可以以统一的方式读取数据。 ","date":"2020-10-10","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%A7%86%E5%9B%BE/:5:1","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:视图","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%A7%86%E5%9B%BE/"},{"categories":["Django"],"content":"常用属性 .data：request.data 返回解析之后的请求体数据。类似于Django中标准的request.POST和 request.FILES属性，但提供如下特性： 包含了解析之后的文件和非文件数据 包含了对POST、PUT、PATCH请求方式解析后的数据 利用了REST framework的parsers解析器，不仅支持表单类型数据，也支持JSON数据 .query_params：request.query_params与Django标准的request.GET相同，只是更换了更正确的名称而已。 ","date":"2020-10-10","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%A7%86%E5%9B%BE/:5:2","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:视图","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%A7%86%E5%9B%BE/"},{"categories":["Django"],"content":"Response ","date":"2020-10-10","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%A7%86%E5%9B%BE/:6:0","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:视图","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%A7%86%E5%9B%BE/"},{"categories":["Django"],"content":"简介 rest_framework.response.Response REST framework提供了一个响应类Response，使用该类构造响应对象时，响应的具体数据内容会被转换（render渲染）成符合前端需求的类型。 REST framework提供了Renderer 渲染器，用来根据请求头中的Accept（接收数据类型声明）来自动转换响应数据到对应格式。如果前端请求中未进行Accept声明，则会采用默认方式处理响应数据，我们可以通过配置来修改默认响应格式。 REST_FRAMEWORK = { 'DEFAULT_RENDERER_CLASSES': ( # 默认响应渲染类 'rest_framework.renderers.JSONRenderer', # json渲染器 'rest_framework.renderers.BrowsableAPIRenderer', # 浏览API渲染器 ) } ","date":"2020-10-10","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%A7%86%E5%9B%BE/:6:1","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:视图","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%A7%86%E5%9B%BE/"},{"categories":["Django"],"content":"构造方式 Response(data, status=None, template_name=None, headers=None, content_type=None) data数据不要是render处理之后的数据，只需传递python的内建类型数据即可，REST framework会使用renderer渲染器处理data。 data不能是复杂结构的数据，如Django的模型类对象，对于这样的数据我们可以使用Serializer序列化器序列化处理后（转为了Python字典类型）再传递给data参数。 参数说明： data: 为响应准备的序列化处理后的数据； status: 状态码，默认200； template_name: 模板名称，如果使用HTMLRenderer 时需指明； headers: 用于存放响应头信息的字典； content_type: 响应数据的Content-Type，通常此参数无需传递，REST framework会根据前端所需类型数据来设置该参数。 ","date":"2020-10-10","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%A7%86%E5%9B%BE/:6:2","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:视图","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%A7%86%E5%9B%BE/"},{"categories":["Django"],"content":"常用属性 .data：传给response对象的序列化后，但尚未render处理的数据 .status_code：状态码的数字 .content：经过render处理后的响应数据 ","date":"2020-10-10","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%A7%86%E5%9B%BE/:6:3","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:视图","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%A7%86%E5%9B%BE/"},{"categories":["Django"],"content":"状态码 ","date":"2020-10-10","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%A7%86%E5%9B%BE/:7:0","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:视图","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%A7%86%E5%9B%BE/"},{"categories":["Django"],"content":"简介 为了方便设置状态码，REST framewrok在rest_framework.status模块中提供了常用状态码常量。 ","date":"2020-10-10","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%A7%86%E5%9B%BE/:7:1","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:视图","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%A7%86%E5%9B%BE/"},{"categories":["Django"],"content":"常见状态码 信息告知 HTTP_100_CONTINUE HTTP_101_SWITCHING_PROTOCOLS 成功 HTTP_200_OK HTTP_201_CREATED HTTP_202_ACCEPTED HTTP_203_NON_AUTHORITATIVE_INFORMATION HTTP_204_NO_CONTENT HTTP_205_RESET_CONTENT HTTP_206_PARTIAL_CONTENT HTTP_207_MULTI_STATUS 重定向 HTTP_300_MULTIPLE_CHOICES HTTP_301_MOVED_PERMANENTLY HTTP_302_FOUND HTTP_303_SEE_OTHER HTTP_304_NOT_MODIFIED HTTP_305_USE_PROXY HTTP_306_RESERVED HTTP_307_TEMPORARY_REDIRECT 客户端错误 HTTP_400_BAD_REQUEST HTTP_401_UNAUTHORIZED HTTP_402_PAYMENT_REQUIRED HTTP_403_FORBIDDEN HTTP_404_NOT_FOUND HTTP_405_METHOD_NOT_ALLOWED HTTP_406_NOT_ACCEPTABLE HTTP_407_PROXY_AUTHENTICATION_REQUIRED HTTP_408_REQUEST_TIMEOUT HTTP_409_CONFLICT HTTP_410_GONE HTTP_411_LENGTH_REQUIRED HTTP_412_PRECONDITION_FAILED HTTP_413_REQUEST_ENTITY_TOO_LARGE HTTP_414_REQUEST_URI_TOO_LONG HTTP_415_UNSUPPORTED_MEDIA_TYPE HTTP_416_REQUESTED_RANGE_NOT_SATISFIABLE HTTP_417_EXPECTATION_FAILED HTTP_422_UNPROCESSABLE_ENTITY HTTP_423_LOCKED HTTP_424_FAILED_DEPENDENCY HTTP_428_PRECONDITION_REQUIRED HTTP_429_TOO_MANY_REQUESTS HTTP_431_REQUEST_HEADER_FIELDS_TOO_LARGE HTTP_451_UNAVAILABLE_FOR_LEGAL_REASONS 服务器错误 HTTP_500_INTERNAL_SERVER_ERROR HTTP_501_NOT_IMPLEMENTED HTTP_502_BAD_GATEWAY HTTP_503_SERVICE_UNAVAILABLE HTTP_504_GATEWAY_TIMEOUT HTTP_505_HTTP_VERSION_NOT_SUPPORTED HTTP_507_INSUFFICIENT_STORAGE HTTP_511_NETWORK_AUTHENTICATION_REQUIRED ","date":"2020-10-10","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%A7%86%E5%9B%BE/:7:2","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:视图","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%A7%86%E5%9B%BE/"},{"categories":["Django"],"content":"序列化器的作用 进行数据的校验 对数据对象进行转换 ","date":"2020-09-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-serializer%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8/:1:0","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:Serializer序列化器","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-serializer%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8/"},{"categories":["Django"],"content":"定义Serializer ","date":"2020-09-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-serializer%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8/:2:0","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:Serializer序列化器","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-serializer%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8/"},{"categories":["Django"],"content":"定义方法 Django REST framework中的Serializer使用类来定义，须继承自rest_framework.serializers.Serializer。 例如，我们已有了一个数据库模型类BookInfo class BookInfo(models.Model): btitle = models.CharField(max_length=20, verbose_name='名称') bpub_date = models.DateField(verbose_name='发布日期', null=True) bread = models.IntegerField(default=0, verbose_name='阅读量') bcomment = models.IntegerField(default=0, verbose_name='评论量') image = models.ImageField(upload_to='booktest', verbose_name='图片', null=True) 我们想为这个模型类提供一个序列化器，可以定义如下： class BookInfoSerializer(serializers.Serializer): \"\"\"图书数据序列化器\"\"\" id = serializers.IntegerField(label='ID', read_only=True) btitle = serializers.CharField(label='名称', max_length=20) bpub_date = serializers.DateField(label='发布日期', required=False) bread = serializers.IntegerField(label='阅读量', required=False) bcomment = serializers.IntegerField(label='评论量', required=False) image = serializers.ImageField(label='图片', required=False) **注意：serializer不是只能为数据库模型类定义，也可以为非数据库模型类的数据定义。**serializer是独立于数据库之外的存在。 ","date":"2020-09-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-serializer%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8/:2:1","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:Serializer序列化器","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-serializer%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8/"},{"categories":["Django"],"content":"字段与选项 常用字段类型 字段 字段构造方式 BooleanField BooleanField() NullBooleanField NullBooleanField() CharField CharField(max_length=None, min_length=None, allow_blank=False, trim_whitespace=True) EmailField EmailField(max_length=None, min_length=None, allow_blank=False) RegexField RegexField(regex, max_length=None, min_length=None, allow_blank=False) SlugField SlugField(maxlength=50, min_length=None, allow_blank=False) 正则字段，验证正则模式 [a-zA-Z0-9-]+ URLField URLField(max_length=200, min_length=None, allow_blank=False) UUIDField UUIDField(format='hex_verbose’) format: 1) 'hex_verbose' 如\"5ce0e9a5-5ffa-654b-cee0-1238041fb31a\" 2） 'hex' 如 \"5ce0e9a55ffa654bcee01238041fb31a\" 3）'int' - 如: \"123456789012312313134124512351145145114\" 4）'urn' 如: \"urn:uuid:5ce0e9a5-5ffa-654b-cee0-1238041fb31a\" IPAddressField IPAddressField(protocol='both’, unpack_ipv4=False, **options) IntegerField IntegerField(max_value=None, min_value=None) FloatField FloatField(max_value=None, min_value=None) DecimalField DecimalField(max_digits, decimal_places, coerce_to_string=None, max_value=None, min_value=None) max_digits: 最多位数 decimal_palces: 小数点位置 DateTimeField DateTimeField(format=api_settings.DATETIME_FORMAT, input_formats=None) DateField DateField(format=api_settings.DATE_FORMAT, input_formats=None) TimeField TimeField(format=api_settings.TIME_FORMAT, input_formats=None) DurationField DurationField() ChoiceField ChoiceField(choices) choices与Django的用法相同 MultipleChoiceField MultipleChoiceField(choices) FileField FileField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL) ImageField ImageField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL) ListField ListField(child=, min_length=None, max_length=None) DictField DictField(child=) 选项参数 参数名称 作用 max_length 最大长度 min_lenght 最小长度 allow_blank 是否允许为空 trim_whitespace 是否截断空白字符 max_value 最小值 min_value 最大值 通用参数 参数名称 说明 read_only 表明该字段仅用于序列化输出，默认False write_only 表明该字段仅用于反序列化输入，默认False required 表明该字段在反序列化时必须输入，默认True default 反序列化时使用的默认值 allow_null 表明该字段是否允许传入None，默认False validators 该字段使用的验证器 error_messages 包含错误编号与错误信息的字典 label 用于HTML展示API页面时，显示的字段名称 help_text 用于HTML展示API页面时，显示的字段帮助提示信息 ","date":"2020-09-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-serializer%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8/:2:2","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:Serializer序列化器","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-serializer%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8/"},{"categories":["Django"],"content":"创建Serializer对象 定义好Serializer类后，就可以创建Serializer对象了。 Serializer的构造方法为： Serializer(instance=None, data=empty, **kwarg) 说明： 1）用于序列化时，将模型类对象传入instance参数 2）用于反序列化时，将要被反序列化的数据传入data参数 3）除了instance和data参数外，在构造Serializer对象时，还可通过context参数额外添加数据，如 serializer = AccountSerializer(account, context={'request': request}) 通过context参数附加的数据，可以通过Serializer对象的context属性获取。 ","date":"2020-09-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-serializer%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8/:2:3","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:Serializer序列化器","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-serializer%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8/"},{"categories":["Django"],"content":"序列化使用 ","date":"2020-09-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-serializer%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8/:3:0","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:Serializer序列化器","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-serializer%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8/"},{"categories":["Django"],"content":"简介 我们在django shell中来学习序列化器的使用。 python manage.py shell ","date":"2020-09-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-serializer%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8/:3:1","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:Serializer序列化器","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-serializer%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8/"},{"categories":["Django"],"content":"基本使用 先查询出一个图书对象 from booktest.models import BookInfo book = BookInfo.objects.get(id=2) 构造序列化器对象 from booktest.serializers import BookInfoSerializer serializer = BookInfoSerializer(book) 获取序列化数据，通过data属性可以获取序列化后的数据 serializer.data # {'id': 2, 'btitle': '天龙八部', 'bpub_date': '1986-07-24', 'bread': 36, 'bcomment': 40, 'image': None} 如果要被序列化的是包含多条数据的查询集QuerySet，可以通过添加many=True参数补充说明 book_qs = BookInfo.objects.all() serializer = BookInfoSerializer(book_qs, many=True) serializer.data # [OrderedDict([('id', 2), ('btitle', '天龙八部'), ('bpub_date', '1986-07-24'), ('bread', 36), ('bcomment', 40), ('image', N]), OrderedDict([('id', 3), ('btitle', '笑傲江湖'), ('bpub_date', '1995-12-24'), ('bread', 20), ('bcomment', 80), ('image'ne)]), OrderedDict([('id', 4), ('btitle', '雪山飞狐'), ('bpub_date', '1987-11-11'), ('bread', 58), ('bcomment', 24), ('ima None)]), OrderedDict([('id', 5), ('btitle', '西游记'), ('bpub_date', '1988-01-01'), ('bread', 10), ('bcomment', 10), ('im', 'booktest/xiyouji.png')])] ","date":"2020-09-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-serializer%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8/:3:2","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:Serializer序列化器","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-serializer%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8/"},{"categories":["Django"],"content":"关联对象嵌套序列化 如果需要序列化的数据中包含有其他关联对象，则对关联对象数据的序列化需要指明。 例如，在定义英雄数据的序列化器时，外键hbook（即所属的图书）字段如何序列化？ 我们先定义HeroInfoSerialzier除外键字段外的其他部分 class HeroInfoSerializer(serializers.Serializer): \"\"\"英雄数据序列化器\"\"\" GENDER_CHOICES = ( (0, 'male'), (1, 'female') ) id = serializers.IntegerField(label='ID', read_only=True) hname = serializers.CharField(label='名字', max_length=20) hgender = serializers.ChoiceField(choices=GENDER_CHOICES, label='性别', required=False) hcomment = serializers.CharField(label='描述信息', max_length=200, required=False, allow_null=True) 对于关联字段，可以采用以下几种方式： PrimaryKeyRelatedField，此字段将被序列化为关联对象的主键。 hbook = serializers.PrimaryKeyRelatedField(label='图书', read_only=True) 或 hbook = serializers.PrimaryKeyRelatedField(label='图书', queryset=BookInfo.objects.all()) 指明字段时需要包含read_only=True或者queryset参数： 包含read_only=True参数时，该字段将不能用作反序列化使用 包含queryset参数时，将被用作反序列化时参数校验使用 使用效果： from booktest.serializers import HeroInfoSerializer from booktest.models import HeroInfo hero = HeroInfo.objects.get(id=6) serializer = HeroInfoSerializer(hero) serializer.data # {'id': 6, 'hname': '乔峰', 'hgender': 1, 'hcomment': '降龙十八掌', 'hbook': 2} StringRelatedField，此字段将被序列化为关联对象的字符串表示方式（即__str__方法的返回值） hbook = serializers.StringRelatedField(label='图书') 使用效果 {'id': 6, 'hname': '乔峰', 'hgender': 1, 'hcomment': '降龙十八掌', 'hbook': '天龙八部'} HyperlinkedRelatedField，此字段将被序列化为获取关联对象数据的接口链接 hbook = serializers.HyperlinkedRelatedField(label='图书', read_only=True, view_name='books-detail') 必须指明view_name参数，以便DRF根据视图名称寻找路由，进而拼接成完整URL。 使用效果 {'id': 6, 'hname': '乔峰', 'hgender': 1, 'hcomment': '降龙十八掌', 'hbook': 'http://127.0.0.1:8000/books/2/'} 我们暂时还没有定义视图，此方式不再演示。 SlugRelatedField，此字段将被序列化为关联对象的指定字段数据 hbook = serializers.SlugRelatedField(label='图书', read_only=True, slug_field='bpub_date') slug_field指明使用关联对象的哪个字段，使用效果 {'id': 6, 'hname': '乔峰', 'hgender': 1, 'hcomment': '降龙十八掌', 'hbook': datetime.date(1986, 7, 24)} 使用关联对象的序列化器 hbook = BookInfoSerializer() 使用效果 {'id': 6, 'hname': '乔峰', 'hgender': 1, 'hcomment': '降龙十八掌', 'hbook': OrderedDict([('id', 2), ('btitle', '天龙八部')te', '1986-07-24'), ('bread', 36), ('bcomment', 40), ('image', None)])} 重写to_representation方法 序列化器的每个字段实际都是由该字段类型的to_representation方法决定格式的，可以通过重写该方法来决定格式。 注意，to_representations方法不仅局限在控制关联对象格式上，适用于各个序列化器字段类型。 自定义一个新的关联字段： class BookRelateField(serializers.RelatedField): \"\"\"自定义用于处理图书的字段\"\"\" def to_representation(self, value): return 'Book: %d%s' % (value.id, value.btitle) 指明hbook为BookRelateField类型 hbook = BookRelateField(read_only=True) 使用效果 {'id': 6, 'hname': '乔峰', 'hgender': 1, 'hcomment': '降龙十八掌', 'hbook': 'Book: 2 天龙八部'} ","date":"2020-09-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-serializer%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8/:3:3","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:Serializer序列化器","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-serializer%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8/"},{"categories":["Django"],"content":"many参数 如果关联的对象数据不是只有一个，而是包含多个数据，如想序列化图书BookInfo数据，每个BookInfo对象关联的英雄HeroInfo对象可能有多个，此时关联字段类型的指明仍可使用上述几种方式，只是在声明关联字段时，多补充一个many=True参数即可。 此处仅拿PrimaryKeyRelatedField类型来举例，其他相同。 在BookInfoSerializer中添加关联字段： class BookInfoSerializer(serializers.Serializer): \"\"\"图书数据序列化器\"\"\" id = serializers.IntegerField(label='ID', read_only=True) btitle = serializers.CharField(label='名称', max_length=20) bpub_date = serializers.DateField(label='发布日期', required=False) bread = serializers.IntegerField(label='阅读量', required=False) bcomment = serializers.IntegerField(label='评论量', required=False) image = serializers.ImageField(label='图片', required=False) heroinfo_set = serializers.PrimaryKeyRelatedField(read_only=True, many=True) # 新增 使用效果： from booktest.serializers import BookInfoSerializer from booktest.models import BookInfo book = BookInfo.objects.get(id=2) serializer = BookInfoSerializer(book) serializer.data # {'id': 2, 'btitle': '天龙八部', 'bpub_date': '1986-07-24', 'bread': 36, 'bcomment': 40, 'image': None, 'heroinfo_set': [6,8, 9]} ","date":"2020-09-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-serializer%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8/:3:4","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:Serializer序列化器","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-serializer%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8/"},{"categories":["Django"],"content":"反序列化使用 ","date":"2020-09-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-serializer%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8/:4:0","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:Serializer序列化器","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-serializer%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8/"},{"categories":["Django"],"content":"验证 使用序列化器进行反序列化时，需要对数据进行验证后，才能获取验证成功的数据或保存成模型类对象。 在获取反序列化的数据前，必须调用**is_valid()**方法进行验证，验证成功返回True，否则返回False。 验证失败，可以通过序列化器对象的errors属性获取错误信息，返回字典，包含了字段和字段的错误。如果是非字段错误，可以通过修改REST framework配置中的NON_FIELD_ERRORS_KEY来控制错误字典中的键名。 验证成功，可以通过序列化器对象的validated_data属性获取数据。 在定义序列化器时，指明每个字段的序列化类型和选项参数，本身就是一种验证行为。 如我们前面定义过的BookInfoSerializer class BookInfoSerializer(serializers.Serializer): \"\"\"图书数据序列化器\"\"\" id = serializers.IntegerField(label='ID', read_only=True) btitle = serializers.CharField(label='名称', max_length=20) bpub_date = serializers.DateField(label='发布日期', required=False) bread = serializers.IntegerField(label='阅读量', required=False) bcomment = serializers.IntegerField(label='评论量', required=False) image = serializers.ImageField(label='图片', required=False) 通过构造序列化器对象，并将要反序列化的数据传递给data构造参数，进而进行验证 from booktest.serializers import BookInfoSerializer data = {'bpub_date': 123} serializer = BookInfoSerializer(data=data) serializer.is_valid() # 返回False serializer.errors # {'btitle': [ErrorDetail(string='This field is required.', code='required')], 'bpub_date': [ErrorDetail(string='Date has wrong format. Use one of these formats instead: YYYY[-MM[-DD]].', code='invalid')]} serializer.validated_data # {} data = {'btitle': 'python'} serializer = BookInfoSerializer(data=data) serializer.is_valid() # True serializer.errors # {} serializer.validated_data # OrderedDict([('btitle', 'python')]) is_valid()方法还可以在验证失败时抛出异常serializers.ValidationError，可以通过传递raise_exception=True参数开启，REST framework接收到此异常，会向前端返回HTTP 400 Bad Request响应。 # Return a 400 response if the data was invalid. serializer.is_valid(raise_exception=True) 如果觉得这些还不够，需要再补充定义验证行为，可以使用以下三种方法： validate_\u003cfield_name\u003e，对\u003cfield_name\u003e字段进行验证，如 class BookInfoSerializer(serializers.Serializer): \"\"\"图书数据序列化器\"\"\" ... def validate_btitle(self, value): if 'django' not in value.lower(): raise serializers.ValidationError(\"图书不是关于Django的\") return value 测试 from booktest.serializers import BookInfoSerializer data = {'btitle': 'python'} serializer = BookInfoSerializer(data=data) serializer.is_valid() # False serializer.errors # {'btitle': [ErrorDetail(string='图书不是关于Django的', code='invalid')]} validate，在序列化器中需要同时对多个字段进行比较验证时，可以定义validate方法来验证，如 class BookInfoSerializer(serializers.Serializer): \"\"\"图书数据序列化器\"\"\" ... def validate(self, attrs): bread = attrs['bread'] bcomment = attrs['bcomment'] if bread \u003c bcomment: raise serializers.ValidationError('阅读量小于评论量') return attrs 测试 from booktest.serializers import BookInfoSerializer data = {'btitle': 'about django', 'bread': 10, 'bcomment': 20} s = BookInfoSerializer(data=data) s.is_valid() # False s.errors # {'non_field_errors': [ErrorDetail(string='阅读量小于评论量', code='invalid')]} validators，在字段中添加validators选项参数，也可以补充验证行为，如 def about_django(value): if 'django' not in value.lower(): raise serializers.ValidationError(\"图书不是关于Django的\") class BookInfoSerializer(serializers.Serializer): \"\"\"图书数据序列化器\"\"\" id = serializers.IntegerField(label='ID', read_only=True) btitle = serializers.CharField(label='名称', max_length=20, validators=[about_django]) bpub_date = serializers.DateField(label='发布日期', required=False) bread = serializers.IntegerField(label='阅读量', required=False) bcomment = serializers.IntegerField(label='评论量', required=False) image = serializers.ImageField(label='图片', required=False) 测试： from booktest.serializers import BookInfoSerializer data = {'btitle': 'python'} serializer = BookInfoSerializer(data=data) serializer.is_valid() # False serializer.errors # {'btitle': [ErrorDetail(string='图书不是关于Django的', code='invalid')]} REST framework提供的validators: UniqueValidator 单字段唯一，如 from rest_framework.validators import UniqueValidator slug = SlugField( max_length=100, validators=[UniqueValidator(queryset=BlogPost.objects.all())] ) UniqueTogetherValidation 联合唯一，如 from rest_framework.validators import UniqueTogetherValidator class ExampleSerializer(serializers.Serializer): # ... class Meta: validators = [ UniqueTogetherValidator( queryset=ToDoItem.objects.all(), fields=('list', 'position') ) ","date":"2020-09-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-serializer%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8/:4:1","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:Serializer序列化器","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-serializer%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8/"},{"categories":["Django"],"content":"保存 如果在验证成功后，想要基于validated_data完成数据对象的创建，可以通过实现create()和update()两个方法来实现。 class BookInfoSerializer(serializers.Serializer): \"\"\"图书数据序列化器\"\"\" ... def create(self, validated_data): \"\"\"新建\"\"\" return BookInfo(**validated_data) def update(self, instance, validated_data): \"\"\"更新，instance为要更新的对象实例\"\"\" instance.btitle = validated_data.get('btitle', instance.btitle) instance.bpub_date = validated_data.get('bpub_date', instance.bpub_date) instance.bread = validated_data.get('bread', instance.bread) instance.bcomment = validated_data.get('bcomment', instance.bcomment) return instance 如果需要在返回数据对象的时候，也将数据保存到数据库中，则可以进行如下修改 class BookInfoSerializer(serializers.Serializer): \"\"\"图书数据序列化器\"\"\" ... def create(self, validated_data): \"\"\"新建\"\"\" return BookInfo.objects.create(**validated_data) def update(self, instance, validated_data): \"\"\"更新，instance为要更新的对象实例\"\"\" instance.btitle = validated_data.get('btitle', instance.btitle) instance.bpub_date = validated_data.get('bpub_date', instance.bpub_date) instance.bread = validated_data.get('bread', instance.bread) instance.bcomment = validated_data.get('bcomment', instance.bcomment) instance.save() return instance 实现了上述两个方法后，在反序列化数据的时候，就可以通过save()方法返回一个数据对象实例了 book = serializer.save() 如果创建序列化器对象的时候，没有传递instance实例，则调用save()方法的时候，create()被调用，相反，如果传递了instance实例，则调用save()方法的时候，update()被调用。 from db.serializers import BookInfoSerializer data = {'btitle': '封神演义'} serializer = BookInfoSerializer(data=data) serializer.is_valid() # True serializer.save() # \u003cBookInfo: 封神演义\u003e from db.models import BookInfo book = BookInfo.objects.get(id=2) data = {'btitle': '倚天剑'} serializer = BookInfoSerializer(book, data=data) serializer.is_valid() # True serializer.save() # \u003cBookInfo: 倚天剑\u003e book.btitle # '倚天剑' ","date":"2020-09-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-serializer%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8/:4:2","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:Serializer序列化器","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-serializer%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8/"},{"categories":["Django"],"content":"两点说明 在对序列化器进行save()保存时，可以额外传递数据，这些数据可以在create()和update()中的validated_data参数获取到 serializer.save(owner=request.user) 默认序列化器必须传递所有required的字段，否则会抛出验证异常。但是我们可以使用partial参数来允许部分字段更新 # Update `comment` with partial data serializer = CommentSerializer(comment, data={'content': u'foo bar'}, partial=True) ","date":"2020-09-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-serializer%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8/:4:3","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:Serializer序列化器","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-serializer%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8/"},{"categories":["Django"],"content":"模型类序列化器ModelSerializer ","date":"2020-09-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-serializer%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8/:5:0","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:Serializer序列化器","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-serializer%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8/"},{"categories":["Django"],"content":"简介 如果我们想要使用序列化器对应的是Django的模型类，DRF为我们提供了ModelSerializer模型类序列化器来帮助我们快速创建一个Serializer类。 ModelSerializer与常规的Serializer相同，但提供了： 基于模型类自动生成一系列字段 基于模型类自动为Serializer生成validators，比如unique_together 包含默认的create()和update()的实现 ","date":"2020-09-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-serializer%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8/:5:1","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:Serializer序列化器","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-serializer%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8/"},{"categories":["Django"],"content":"定义 比如我们创建一个BookInfoSerializer class BookInfoSerializer(serializers.ModelSerializer): \"\"\"图书数据序列化器\"\"\" class Meta: model = BookInfo fields = '__all__' model 指明参照哪个模型类 fields 指明为模型类的哪些字段生成 我们可以在python manage.py shell中查看自动生成的BookInfoSerializer的具体实现 \u003e\u003e\u003e from booktest.serializers import BookInfoSerializer \u003e\u003e\u003e serializer = BookInfoSerializer() \u003e\u003e\u003e serializer BookInfoSerializer(): id = IntegerField(label='ID', read_only=True) btitle = CharField(label='名称', max_length=20) bpub_date = DateField(allow_null=True, label='发布日期', required=False) bread = IntegerField(label='阅读量', max_value=2147483647, min_value=-2147483648, required=False) bcomment = IntegerField(label='评论量', max_value=2147483647, min_value=-2147483648, required=False) image = ImageField(allow_null=True, label='图片', max_length=100, required=False) ","date":"2020-09-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-serializer%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8/:5:2","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:Serializer序列化器","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-serializer%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8/"},{"categories":["Django"],"content":"指定字段 使用fields来明确字段，__all__表名包含所有字段，也可以写明具体哪些字段，如 class BookInfoSerializer(serializers.ModelSerializer): \"\"\"图书数据序列化器\"\"\" class Meta: model = BookInfo fields = ('id', 'btitle', 'bpub_date') 使用exclude可以明确排除掉哪些字段 class BookInfoSerializer(serializers.ModelSerializer): \"\"\"图书数据序列化器\"\"\" class Meta: model = BookInfo exclude = ('image',) 默认ModelSerializer使用主键作为关联字段，但是我们可以使用depth来简单的生成嵌套表示，depth应该是整数，表明嵌套的层级数量。如： class HeroInfoSerializer2(serializers.ModelSerializer): class Meta: model = HeroInfo fields = '__all__' depth = 1 形成的序列化器如下： HeroInfoSerializer(): id = IntegerField(label='ID', read_only=True) hname = CharField(label='名称', max_length=20) hgender = ChoiceField(choices=((0, 'male'), (1, 'female')), label='性别', required=False, validators=[\u003cdjango.core.valators.MinValueValidator object\u003e, \u003cdjango.core.validators.MaxValueValidator object\u003e]) hcomment = CharField(allow_null=True, label='描述信息', max_length=200, required=False) hbook = NestedSerializer(read_only=True): id = IntegerField(label='ID', read_only=True) btitle = CharField(label='名称', max_length=20) bpub_date = DateField(allow_null=True, label='发布日期', required=False) bread = IntegerField(label='阅读量', max_value=2147483647, min_value=-2147483648, required=False) bcomment = IntegerField(label='评论量', max_value=2147483647, min_value=-2147483648, required=False) image = ImageField(allow_null=True, label='图片', max_length=100, required=False) 显示指明字段，如： class HeroInfoSerializer(serializers.ModelSerializer): hbook = BookInfoSerializer() class Meta: model = HeroInfo fields = ('id', 'hname', 'hgender', 'hcomment', 'hbook') 指明只读字段，可以通过read_only_fields指明只读字段，即仅用于序列化输出的字段 class BookInfoSerializer(serializers.ModelSerializer): \"\"\"图书数据序列化器\"\"\" class Meta: model = BookInfo fields = ('id', 'btitle', 'bpub_date'， 'bread', 'bcomment') read_only_fields = ('id', 'bread', 'bcomment') ","date":"2020-09-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-serializer%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8/:5:3","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:Serializer序列化器","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-serializer%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8/"},{"categories":["Django"],"content":"添加额外参数 我们可以使用extra_kwargs参数为ModelSerializer添加或修改原有的选项参数 class BookInfoSerializer(serializers.ModelSerializer): \"\"\"图书数据序列化器\"\"\" class Meta: model = BookInfo fields = ('id', 'btitle', 'bpub_date', 'bread', 'bcomment') extra_kwargs = { 'bread': {'min_value': 0, 'required': True}, 'bcomment': {'min_value': 0, 'required': True}, } # BookInfoSerializer(): # id = IntegerField(label='ID', read_only=True) # btitle = CharField(label='名称', max_length=20) # bpub_date = DateField(allow_null=True, label='发布日期', required=False) # bread = IntegerField(label='阅读量', max_value=2147483647, min_value=0, required=True) # bcomment = IntegerField(label='评论量', max_value=2147483647, min_value=0, required=True) ","date":"2020-09-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-serializer%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8/:5:4","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:Serializer序列化器","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-serializer%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8/"},{"categories":["Django"],"content":"环境安装与配置 DRF需要以下依赖： Python (2.7, 3.2, 3.3, 3.4, 3.5, 3.6) Django (1.10, 1.11, 2.0) DRF是以Django扩展应用的方式提供的，所以我们可以直接利用已有的Django环境而无需从新创建。（若没有Django环境，需要先创建环境安装Django） ","date":"2020-09-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-drf%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/:1:0","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:工程搭建","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-drf%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/"},{"categories":["Django"],"content":"安装DRF pip install djangorestframework ","date":"2020-09-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-drf%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/:1:1","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:工程搭建","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-drf%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/"},{"categories":["Django"],"content":"添加rest_framework应用 我们利用在Django框架学习中创建的demo工程，在settings.py的INSTALLED_APPS中添加’rest_framework’。 INSTALLED_APPS = [ ... 'rest_framework', ] 接下来就可以使用DRF进行开发了。 ","date":"2020-09-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-drf%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/:1:2","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:工程搭建","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-drf%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/"},{"categories":["Django"],"content":"见识DRF的魅力 我们仍以在学习Django框架时使用的图书英雄为案例，使用Django REST framework快速实现图书的REST API。 ","date":"2020-09-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-drf%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/:2:0","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:工程搭建","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-drf%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/"},{"categories":["Django"],"content":"创建序列化器 在booktest应用中新建serializers.py用于保存该应用的序列化器。 创建一个BookInfoSerializer用于序列化与反序列化。 class BookInfoSerializer(serializers.ModelSerializer): \"\"\"图书数据序列化器\"\"\" class Meta: model = BookInfo fields = '__all__' model 指明该序列化器处理的数据字段从模型类BookInfo参考生成 fields 指明该序列化器包含模型类中的哪些字段，'all‘指明包含所有字段 ","date":"2020-09-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-drf%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/:2:1","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:工程搭建","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-drf%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/"},{"categories":["Django"],"content":"编写视图 在booktest应用的views.py中创建视图BookInfoViewSet，这是一个视图集合。 from rest_framework.viewsets import ModelViewSet from .serializers import BookInfoSerializer from .models import BookInfo class BookInfoViewSet(ModelViewSet): queryset = BookInfo.objects.all() serializer_class = BookInfoSerializer queryset 指明该视图集在查询数据时使用的查询集 serializer_class 指明该视图在进行序列化或反序列化时使用的序列化器 ","date":"2020-09-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-drf%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/:2:2","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:工程搭建","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-drf%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/"},{"categories":["Django"],"content":"定义路由 在booktest应用的urls.py中定义路由信息。 from . import views from rest_framework.routers import DefaultRouter urlpatterns = [ ... ] router = DefaultRouter() # 可以处理视图的路由器 router.register(r'books', views.BookInfoViewSet) # 向路由器中注册视图集 urlpatterns += router.urls # 将路由器中的所以路由信息追到到django的路由列表中 ","date":"2020-09-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-drf%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/:2:3","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:工程搭建","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-drf%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/"},{"categories":["Django"],"content":"运行测试 运行当前程序（与运行Django一样） python manage.py runserver 在浏览器中输入网址127.0.0.1:8000，可以看到DRF提供的API Web浏览页面： 1）点击链接127.0.0.1:8000/books/ 可以访问获取所有数据的接口，呈现如下页面： 2）在页面底下表单部分填写图书信息，可以访问添加新图书的接口，保存新书： 点击POST后，返回如下页面信息： 3）在浏览器中输入网址127.0.0.1:8000/books/1/，可以访问获取单一图书信息的接口（id为1的图书），呈现如下页面： 4）在页面底部表单中填写图书信息，可以访问修改图书的接口： 点击PUT，返回如下页面信息： 5）点击DELETE按钮，可以访问删除图书的接口： 返回，如下页面： 至此，是不是发现Django REST framework很好用！ ","date":"2020-09-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-drf%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/:2:4","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:工程搭建","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-drf%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/"},{"categories":["Django"],"content":"Web应用模式 在开发Web应用中，有两种应用模式： 前后端不分离 前后端分离 ","date":"2020-09-12","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86drf/:1:0","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:初识DRF","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86drf/"},{"categories":["Django"],"content":"前后端不分离 在前后端不分离的应用模式中，前端页面看到的效果都是由后端控制，由后端渲染页面或重定向，也就是后端需要控制前端的展示，前端与后端的耦合度很高。 这种应用模式比较适合纯网页应用，但是当后端对接App时，App可能并不需要后端返回一个HTML网页，而仅仅是数据本身，所以后端原本返回网页的接口不再适用于前端App应用，为了对接App后端还需再开发一套接口。 ","date":"2020-09-12","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86drf/:1:1","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:初识DRF","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86drf/"},{"categories":["Django"],"content":"前后端分离 在前后端分离的应用模式中，后端仅返回前端所需的数据，不再渲染HTML页面，不再控制前端的效果。至于前端用户看到什么效果，从后端请求的数据如何加载到前端中，都由前端自己决定，网页有网页的处理方式，App有App的处理方式，但无论哪种前端，所需的数据基本相同，后端仅需开发一套逻辑对外提供数据即可。 在前后端分离的应用模式中 ，前端与后端的耦合度相对较低。 在前后端分离的应用模式中，我们通常将后端开发的每个视图都称为一个接口，或者API，前端通过访问接口来对数据进行增删改查。 ","date":"2020-09-12","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86drf/:1:2","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:初识DRF","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86drf/"},{"categories":["Django"],"content":"简介 在序列化与反序列化时，虽然操作的数据不尽相同，但是执行的过程却是相似的，也就是说这部分代码是可以复用简化编写的。 在开发REST API的视图中，虽然每个视图具体操作的数据不同，但增、删、改、查的实现流程基本套路化，所以这部分代码也是可以复用简化编写的： 增：校验请求数据 -\u003e 执行反序列化过程 -\u003e 保存数据库 -\u003e 将保存的对象序列化并返回 删：判断要删除的数据是否存在 -\u003e 执行数据库删除 改：判断要修改的数据是否存在 -\u003e 校验请求的数据 -\u003e 执行反序列化过程 -\u003e 保存数据库 -\u003e 将保存的对象序列化并返回 查：查询数据库 -\u003e 将数据序列化并返回 Django REST framework可以帮助我们简化上述两部分的代码编写，大大提高REST API的开发速度。 ","date":"2020-09-12","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86drf/:2:0","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:初识DRF","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86drf/"},{"categories":["Django"],"content":"是什么 Django REST framework 框架是一个用于构建Web API 的强大而又灵活的工具。 通常简称为DRF框架 或 REST framework。 DRF框架是建立在Django框架基础之上，由Tom Christie大牛二次开发的开源项目。 ","date":"2020-09-12","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86drf/:2:1","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:初识DRF","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86drf/"},{"categories":["Django"],"content":"特点 提供了定义序列化器Serializer的方法，可以快速根据 Django ORM 或者其它库自动序列化/反序列化； 提供了丰富的类视图、Mixin扩展类，简化视图的编写； 丰富的定制层级：函数视图、类视图、视图集合到自动生成 API，满足各种需要； 多种身份认证和权限认证方式的支持； 内置了限流系统； 直观的 API web 界面； 可扩展性，插件丰富 资料： 官方文档 Github源码 ","date":"2020-09-12","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86drf/:2:2","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:初识DRF","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86drf/"},{"categories":["Django"],"content":"认识RESTful ","date":"2020-09-12","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86drf/:3:0","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:初识DRF","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86drf/"},{"categories":["Django"],"content":"简介 在前后端分离的应用模式里，后端API接口如何定义？ 例如对于后端数据库中保存了商品的信息，前端可能需要对商品数据进行增删改查，那相应的每个操作后端都需要提供一个API接口： POST /add-goods 增加商品 POST /delete-goods 删除商品 POST /update-goods 修改商品 GET /get-goods 查询商品信息 对于接口的请求方式与路径，每个后端开发人员可能都有自己的定义方式，风格迥异。 是否存在一种统一的定义方式，被广大开发人员接受认可的方式呢？ 这就是被普遍采用的API的RESTful设计风格。 ","date":"2020-09-12","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86drf/:3:1","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:初识DRF","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86drf/"},{"categories":["Django"],"content":"起源 REST这个词，是Roy Thomas Fielding在他2000年的博士论文中提出的。 Fielding是一个非常重要的人，他是HTTP协议（1.0版和1.1版）的主要设计者、Apache服务器软件的作者之一、Apache基金会的第一任主席。所以，他的这篇论文一经发表，就引起了关注，并且立即对互联网开发产生了深远的影响。 ","date":"2020-09-12","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86drf/:3:2","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:初识DRF","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86drf/"},{"categories":["Django"],"content":"名称 Fielding将他对互联网软件的架构原则，定名为REST，即Representational State Transfer的缩写。维基百科称其为“具象状态传输”，国内大部分人理解为“表现层状态转化”。 RESTful是一种开发理念。维基百科说：REST是设计风格而不是标准。 REST描述的是在网络中client和server的一种交互形式；REST本身不实用，实用的是如何设计 RESTful API（REST风格的网络接口）,一种万维网软件架构风格。 我们先来具体看下RESTful风格的url,比如我要查询商品信息，那么 非REST的url：http://…/queryGoods?id=1001\u0026type=t01 REST的url: http://…/t01/goods/1001 可以看出**REST特点：url简洁，将参数通过url传到服务器，**而传统的url比较啰嗦，而且现实中浏览器地址栏会拼接一大串字符，想必你们都见过吧。但是采用REST的风格就会好很多，现在很多的网站已经采用这种风格了，这也是潮流方向，典型的就是url的短化转换。 那么，到底什么是RESTFul架构： 如果一个架构符合REST原则，就称它为RESTful架构。 要理解RESTful架构，理解Representational State Transfer这三个单词的意思。 具象的，就是指表现层，要表现的对象也就是“资源”，什么是资源呢？网站就是资源共享的东西，客户端（浏览器）访问web服务器，所获取的就叫资源。比如html，txt，json，图片，视频等等。 表现，比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。 浏览器通过URL确定一个资源，但是如何确定它的具体表现形式呢？应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对\"表现层\"的描述。 状态转换， 就是客户端和服务器互动的一个过程，在这个过程中, 势必涉及到数据和状态的变化, 这种变化叫做状态转换。 互联网通信协议HTTP协议，客户端访问必然使用HTTP协议**，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生\"状态转化”（State Transfer）。** HTTP协议实际上含有4个表示操作方式的动词，分别是 GET,POST,PUT,DELETE,他们分别对应四种操作。GET用于获取资源，POST用于新建资源，PUT用于更新资源，DElETE用于删除资源。GET和POST是表单提交的两种基本方式，比较常见，而PUT和DElETE不太常用。 而且HTTP协议是一种无状态协议，这样就必须把所有的状态都保存在服务器端**。**因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生\"状态转化”（State Transfer） ","date":"2020-09-12","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86drf/:3:3","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:初识DRF","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86drf/"},{"categories":["Django"],"content":"总结 综合上面的解释，RESTful架构就是： 每一个URL代表一种资源； 客户端和服务器之间，传递这种资源的某种表现层； 客户端通过四个HTTP动词，对服务器端资源进行操作，实现\"表现层状态转化”。 ","date":"2020-09-12","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86drf/:3:4","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:初识DRF","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86drf/"},{"categories":["Django"],"content":"RESTful设计方法 ","date":"2020-09-12","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86drf/:4:0","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:初识DRF","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86drf/"},{"categories":["Django"],"content":"域名 应该尽量将API部署在专用域名之下。 https://api.example.com 如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。 https://example.org/api/ ","date":"2020-09-12","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86drf/:4:1","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:初识DRF","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86drf/"},{"categories":["Django"],"content":"版本（Versioning） 应该将API的版本号放入URL。 http://www.example.com/app/1.0/foo http://www.example.com/app/1.1/foo http://www.example.com/app/2.0/foo 另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。Github采用这种做法。 因为不同的版本，可以理解成同一种资源的不同表现形式，所以应该采用同一个URL。版本号可以在HTTP请求头信息的Accept字段中进行区分（参见Versioning REST Services）： Accept: vnd.example-com.foo+json; version=1.0 Accept: vnd.example-com.foo+json; version=1.1 Accept: vnd.example-com.foo+json; version=2.0 ","date":"2020-09-12","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86drf/:4:2","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:初识DRF","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86drf/"},{"categories":["Django"],"content":"路径（Endpoint） 路径又称\"终点”（endpoint），表示API的具体网址，每个网址代表一种资源（resource） (1) 资源作为网址，只能有名词，不能有动词，而且所用的名词往往与数据库的表名对应。 举例来说，以下是不好的例子: /getProducts /listOrders /retreiveClientByOrder?orderId=1 对于一个简洁结构，你应该始终用名词。 此外，利用的HTTP方法可以分离网址中的资源名称的操作。 GET /products ：将返回所有产品清单 POST /products ：将产品新建到集合 GET /products/4 ：将获取产品 4 PATCH（或）PUT /products/4 ：将更新产品 4 (2) API中的名词应该使用复数。无论子资源或者所有资源。 举例来说，获取产品的API可以这样定义 获取单个产品：http://127.0.0.1:8080/AppName/rest/products/1 获取所有产品: http://127.0.0.1:8080/AppName/rest/products ","date":"2020-09-12","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86drf/:4:3","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:初识DRF","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86drf/"},{"categories":["Django"],"content":"HTTP动词 对于资源的具体操作类型，由HTTP动词表示。 常用的HTTP动词有下面四个（括号里是对应的SQL命令）。 GET（SELECT）：从服务器取出资源（一项或多项）。 POST（CREATE）：在服务器新建一个资源。 PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。 DELETE（DELETE）：从服务器删除资源。 还有三个不常用的HTTP动词。 PATCH（UPDATE）：在服务器更新(更新)资源（客户端提供改变的属性）。 HEAD：获取资源的元数据。 OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。 下面是一些例子。 GET /zoos：列出所有动物园 POST /zoos：新建一个动物园（上传文件） GET /zoos/ID：获取某个指定动物园的信息 PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息） PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息） DELETE /zoos/ID：删除某个动物园 GET /zoos/ID/animals：列出某个指定动物园的所有动物 DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物 ","date":"2020-09-12","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86drf/:4:4","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:初识DRF","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86drf/"},{"categories":["Django"],"content":"过滤信息（Filtering） 如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。 下面是一些常见的参数。 ?limit=10：指定返回记录的数量 ?offset=10：指定返回记录的开始位置。 ?page=2\u0026per_page=100：指定第几页，以及每页的记录数。 ?sortby=name\u0026order=asc：指定返回结果按照哪个属性排序，以及排序顺序。 ?animal_type_id=1：指定筛选条件 参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET /zoos/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。 ","date":"2020-09-12","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86drf/:4:5","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:初识DRF","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86drf/"},{"categories":["Django"],"content":"状态码（Status Codes） 服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。 200 OK - [GET]：服务器成功返回用户请求的数据 201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。 202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务） 204 NO CONTENT - [DELETE]：用户删除数据成功。 400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作 401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。 403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。 404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。 406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。 410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。 422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。 500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。 状态码的完全列表参见这里或这里。 ","date":"2020-09-12","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86drf/:4:6","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:初识DRF","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86drf/"},{"categories":["Django"],"content":"错误处理（Error handling） 如果状态码是4xx，服务器就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。 { error: \"Invalid API key\" } ","date":"2020-09-12","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86drf/:4:7","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:初识DRF","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86drf/"},{"categories":["Django"],"content":"返回结果 针对不同操作，服务器向用户返回的结果应该符合以下规范。 GET /collection：返回资源对象的列表（数组） GET /collection/resource：返回单个资源对象 POST /collection：返回新生成的资源对象 PUT /collection/resource：返回完整的资源对象 PATCH /collection/resource：返回完整的资源对象 DELETE /collection/resource：返回一个空文档 ","date":"2020-09-12","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86drf/:4:8","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:初识DRF","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86drf/"},{"categories":["Django"],"content":"超媒体（Hypermedia API） RESTful API最好做到Hypermedia（即返回结果中提供链接，连向其他API方法），使得用户不查文档，也知道下一步应该做什么。 比如，Github的API就是这种设计，访问api.github.com会得到一个所有可用API的网址列表。 { \"current_user_url\": \"https://api.github.com/user\", \"authorizations_url\": \"https://api.github.com/authorizations\", // ... } 从上面可以看到，如果想获取当前用户的信息，应该去访问api.github.com/user，然后就得到了下面结果。 { \"message\": \"Requires authentication\", \"documentation_url\": \"https://developer.github.com/v3\" } 上面代码表示，服务器给出了提示信息，以及文档的网址。 ","date":"2020-09-12","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86drf/:4:9","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:初识DRF","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86drf/"},{"categories":["Django"],"content":"其他 服务器返回的数据格式，应该尽量使用JSON，避免使用XML。 ","date":"2020-09-12","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86drf/:4:10","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:初识DRF","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86drf/"},{"categories":["Django"],"content":"核心任务 在开发REST API接口时，视图中做的最主要有三件事： 将请求的数据（如JSON格式）转换为模型类对象 操作数据库 将模型类对象转换为响应的数据（如JSON格式） ","date":"2020-09-12","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86drf/:5:0","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:初识DRF","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86drf/"},{"categories":["Django"],"content":"序列化Serialization 维基百科中对于序列化的定义： 序列化（serialization）在计算机科学的资料处理中，是指将数据结构或物件状态转换成可取用格式（例如存成档案，存于缓冲，或经由网络中传送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。依照序列化格式重新获取字节的结果时，可以利用它来产生与原始物件相同语义的副本。对于许多物件，像是使用大量参照的复杂物件，这种序列化重建的过程并不容易。面向对象中的物件序列化，并不概括之前原始物件所关联的函式。这种过程也称为物件编组（marshalling）。从一系列字节提取数据结构的反向操作，是反序列化（也称为解编组, deserialization, unmarshalling）。 序列化在计算机科学中通常有以下定义: 在数据储存与传送的部分是指将一个对象存储至一个储存媒介，例如档案或是记亿体缓冲等，或者透过网络传送资料时进行编码的过程，可以是字节或是XML等格式。而字节的或XML编码格式可以还原完全相等的对象。这程序被应用在不同应用程序之间传送对象，以及服务器将对象储存到档案或数据库。相反的过程又称为反序列化。 简而言之，我们可以将序列化理解为： 将程序中的一个数据结构类型转换为其他格式（字典、JSON、XML等），例如将Django中的模型类对象装换为JSON字符串，这个转换过程我们称为序列化。 如： queryset = BookInfo.objects.all() book_list = [] # 序列化 for book in queryset: book_list.append({ 'id': book.id, 'btitle': book.btitle, 'bpub_date': book.bpub_date, 'bread': book.bread, 'bcomment': book.bcomment, 'image': book.image.url if book.image else '' }) return JsonResponse(book_list, safe=False) 反之，将其他格式（字典、JSON、XML等）转换为程序中的数据，例如将JSON字符串转换为Django中的模型类对象，这个过程我们称为反序列化。 如： json_bytes = request.body json_str = json_bytes.decode() # 反序列化 book_dict = json.loads(json_str) book = BookInfo.objects.create( btitle=book_dict.get('btitle'), bpub_date=datetime.strptime(book_dict.get('bpub_date'), '%Y-%m-%d').date() ) 我们可以看到，在开发REST API时，视图中要频繁的进行序列化与反序列化的编写。 ","date":"2020-09-12","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86drf/:5:1","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:初识DRF","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86drf/"},{"categories":["Django"],"content":"总结 在开发REST API接口时，我们在视图中需要做的最核心的事是： 将数据库数据序列化为前端所需要的格式，并返回； 将前端发送的数据反序列化为模型类对象，并保存到数据库中。 ","date":"2020-09-12","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86drf/:5:2","tags":["Python学习之路"],"title":"Python学习之路-DRF基础:初识DRF","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86drf/"},{"categories":["Django"],"content":"简介 假设我们要设计一个新闻网站，我们需要编写展示给用户的页面，网页上展示的新闻信息是从哪里来的呢？是从数据库中查找到新闻的信息，\u0008然后把它展示在页面上。但是我们的网站上的新闻每天都要更新，这就意味着对数据库的增、删、改、查操作，那么我们需要每天写sql语句\u0008操作数据库吗? 如果这样的话，是不是非常繁琐，所以我们可以设计一个页面，通过对这个页面的操作来实现对新闻数据库的增删改查操作。那么问题来了，老板说我们需要在建立一个新网站，是不是还要设计一个页面来实现对新网站数据库的增删改查操作，但是这样的页面具有一个很大的重复性，那有没有一种方法能够让我们很快的生成管理数据库表的页面呢？有，那就是我们接下来要给大家讲的Django的后台管理。Django能够根据定义的模型类自动地生成管理页面。 使用Django的管理模块，需要按照如下步骤操作： 管理界面本地化 创建管理员 注册模型类 自定义管理页面 ","date":"2020-09-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-admin%E7%AB%99%E7%82%B9/:1:0","tags":["Python学习之路"],"title":"Python学习之路-Django基础:Admin站点","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-admin%E7%AB%99%E7%82%B9/"},{"categories":["Django"],"content":"使用Admin站点 ","date":"2020-09-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-admin%E7%AB%99%E7%82%B9/:2:0","tags":["Python学习之路"],"title":"Python学习之路-Django基础:Admin站点","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-admin%E7%AB%99%E7%82%B9/"},{"categories":["Django"],"content":"管理界面本地化 在settings.py中设置语言和时区 LANGUAGE_CODE = 'zh-hans' # 使用中国语言 TIME_ZONE = 'Asia/Shanghai' # 使用中国上海时间 ","date":"2020-09-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-admin%E7%AB%99%E7%82%B9/:2:1","tags":["Python学习之路"],"title":"Python学习之路-Django基础:Admin站点","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-admin%E7%AB%99%E7%82%B9/"},{"categories":["Django"],"content":"创建超级管理员 创建管理员的命令如下，按提示输入用户名、邮箱、密码。 python manage.py createsuperuser 打开浏览器，在地址栏中输入如下地址后回车。 http://127.0.0.1:8000/admin/ 输入前面创建的用户名、密码完成登录。 登录成功后界面如下，但是并没有我们自己应用模型的入口，接下来进行第三步操作。 提示 如果想要修改密码可以执行python manage.py changepassword 用户名 ","date":"2020-09-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-admin%E7%AB%99%E7%82%B9/:2:2","tags":["Python学习之路"],"title":"Python学习之路-Django基础:Admin站点","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-admin%E7%AB%99%E7%82%B9/"},{"categories":["Django"],"content":"App应用配置 在每个应用目录中都包含了apps.py文件，用于保存该应用的相关信息。在创建应用时，Django会向apps.py文件中写入一个该应用的配置类，如 from django.apps import AppConfig class BooktestConfig(AppConfig): name = 'booktest' 我们将此类添加到工程settings.py中的INSTALLED_APPS列表中，表明注册安装具备此配置属性的应用。 AppConfig.name 属性表示这个配置类是加载到哪个应用的，每个配置类必须包含此属性，默认自动生成。 AppConfig.verbose_name 属性用于设置该应用的直观可读的名字，此名字在Django提供的Admin管理站点中会显示，如 from django.apps import AppConfig class BooktestConfig(AppConfig): name = 'booktest' verbose_name = '图书管理' ","date":"2020-09-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-admin%E7%AB%99%E7%82%B9/:2:3","tags":["Python学习之路"],"title":"Python学习之路-Django基础:Admin站点","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-admin%E7%AB%99%E7%82%B9/"},{"categories":["Django"],"content":"注册模型类 登录后台管理后，默认没有我们创建的应用中定义的模型类，需要在自己应用中的admin.py文件中注册，才可以在后台管理中看到，并进行增删改查操作。打开booktest/admin.py文件，编写如下代码： from django.contrib import admin from booktest.models import BookInfo,HeroInfo admin.site.register(BookInfo) admin.site.register(HeroInfo) 到浏览器中刷新页面，可以看到模型类BookInfo和HeroInfo的管理了。点击类名称\"BookInfo”（图书）可以进入列表页，默认只有一列。在列表页中点击\"增加\"可以进入增加页，Django会根据模型类的不同，生成不同的表单控件，按提示填写表单内容后点击\"保存”，完成数据创建，创建成功后返回列表页。在列表页中点击某行的第一列可以进入修改页。按照提示进行内容的修改，修改成功后进入列表页。在修改页点击“删除”可以删除一项。删除：在列表页勾选想要删除的复选框，可以删除多项。点击执行后进入确认页面，删除后回来列表页面。 ","date":"2020-09-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-admin%E7%AB%99%E7%82%B9/:2:4","tags":["Python学习之路"],"title":"Python学习之路-Django基础:Admin站点","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-admin%E7%AB%99%E7%82%B9/"},{"categories":["Django"],"content":"定义与使用Admin管理类 Django提供的Admin站点的展示效果可以通过自定义ModelAdmin类来进行控制。 定义管理类需要继承自admin.ModelAdmin类，如下 from django.contrib import admin class BookInfoAdmin(admin.ModelAdmin): pass 使用管理类有两种方式： 注册参数 admin.site.register(BookInfo,BookInfoAdmin) 装饰器 @admin.register(BookInfo) class BookInfoAdmin(admin.ModelAdmin): pass ","date":"2020-09-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-admin%E7%AB%99%E7%82%B9/:2:5","tags":["Python学习之路"],"title":"Python学习之路-Django基础:Admin站点","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-admin%E7%AB%99%E7%82%B9/"},{"categories":["Django"],"content":"调整列表页展示 ","date":"2020-09-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-admin%E7%AB%99%E7%82%B9/:3:0","tags":["Python学习之路"],"title":"Python学习之路-Django基础:Admin站点","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-admin%E7%AB%99%E7%82%B9/"},{"categories":["Django"],"content":"页大小 每页中显示多少条数据，默认为每页显示100条数据，属性如下： list_per_page=100 打开booktest/admin.py文件，修改AreaAdmin类如下： class BookInfoAdmin(admin.ModelAdmin): list_per_page = 2 在浏览器中查看区域信息的列表页面 ","date":"2020-09-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-admin%E7%AB%99%E7%82%B9/:3:1","tags":["Python学习之路"],"title":"Python学习之路-Django基础:Admin站点","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-admin%E7%AB%99%E7%82%B9/"},{"categories":["Django"],"content":"“操作选项\"的位置 顶部显示的属性，设置为True在顶部显示，设置为False不在顶部显示，默认为True。 actions_on_top=True 底部显示的属性，设置为True在底部显示，设置为False不在底部显示，默认为False。 actions_on_bottom=False 打开booktest/admin.py文件，修改BookInfoAdmin类如下： class BookInfoAdmin(admin.ModelAdmin): ... actions_on_top = True actions_on_bottom = True 在浏览器中刷新效果如下图： ","date":"2020-09-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-admin%E7%AB%99%E7%82%B9/:3:2","tags":["Python学习之路"],"title":"Python学习之路-Django基础:Admin站点","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-admin%E7%AB%99%E7%82%B9/"},{"categories":["Django"],"content":"列表中的列 属性如下： list_display=[模型字段1,模型字段2,...] 打开booktest/admin.py文件，修改BookInfoAdmin类如下： class BookInfoAdmin(admin.ModelAdmin): ... list_display = ['id','btitle'] 点击列头可以进行升序或降序排列。 ","date":"2020-09-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-admin%E7%AB%99%E7%82%B9/:3:3","tags":["Python学习之路"],"title":"Python学习之路-Django基础:Admin站点","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-admin%E7%AB%99%E7%82%B9/"},{"categories":["Django"],"content":"将方法作为列 列可以是模型字段，还可以是模型方法，要求方法有返回值。通过设置short_description属性，可以设置在admin站点中显示的列名。 打开booktest/models.py文件，修改BookInfo类如下： class BookInfo(models.Model): ... def pub_date(self): return self.bpub_date.strftime('%Y年%m月%d日') pub_date.short_description = '发布日期' # 设置方法字段在admin中显示的标题 打开booktest/admin.py文件，修改BookInfoAdmin类如下： class BookInfoAdmin(admin.ModelAdmin): ... list_display = ['id','atitle','pub_date'] 方法列是不能排序的，如果需要排序需要为方法指定排序依据。 admin_order_field=模型类字段 打开booktest/models.py文件，修改BookInfo类如下： class BookInfo(models.Model): ... def pub_date(self): return self.bpub_date.strftime('%Y年%m月%d日') pub_date.short_description = '发布日期' pub_date.admin_order_field = 'bpub_date' ","date":"2020-09-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-admin%E7%AB%99%E7%82%B9/:3:4","tags":["Python学习之路"],"title":"Python学习之路-Django基础:Admin站点","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-admin%E7%AB%99%E7%82%B9/"},{"categories":["Django"],"content":"关联对象 无法直接访问关联对象的属性或方法，可以在模型类中封装方法，访问关联对象的成员。 打开booktest/models.py文件，修改HeroInfo类如下： class HeroInfo(models.Model): ... def read(self): return self.hbook.bread read.short_description = '图书阅读量' 打开booktest/admin.py文件，修改HeroInfoAdmin类如下： class HeroInfoAdmin(admin.ModelAdmin): ... list_display = ['id', 'hname', 'hbook', 'read'] ","date":"2020-09-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-admin%E7%AB%99%E7%82%B9/:3:5","tags":["Python学习之路"],"title":"Python学习之路-Django基础:Admin站点","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-admin%E7%AB%99%E7%82%B9/"},{"categories":["Django"],"content":"右侧栏过滤器 属性如下，只能接收字段，会将对应字段的值列出来，用于快速过滤。一般用于有重复值的字段。 list_filter=[] 打开booktest/admin.py文件，修改HeroInfoAdmin类如下： class HeroInfoAdmin(admin.ModelAdmin): ... list_filter = ['hbook', 'hgender'] ","date":"2020-09-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-admin%E7%AB%99%E7%82%B9/:3:6","tags":["Python学习之路"],"title":"Python学习之路-Django基础:Admin站点","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-admin%E7%AB%99%E7%82%B9/"},{"categories":["Django"],"content":"搜索框 属性如下，用于对指定字段的值进行搜索，支持模糊查询。列表类型，表示在这些字段上进行搜索。 search_fields=[] 打开booktest/admin.py文件，修改HeroInfoAdmin类如下： class HeroInfoAdmin(admin.ModelAdmin): ... search_fields = ['hname'] ","date":"2020-09-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-admin%E7%AB%99%E7%82%B9/:3:7","tags":["Python学习之路"],"title":"Python学习之路-Django基础:Admin站点","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-admin%E7%AB%99%E7%82%B9/"},{"categories":["Django"],"content":"调整编辑页展示 ","date":"2020-09-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-admin%E7%AB%99%E7%82%B9/:4:0","tags":["Python学习之路"],"title":"Python学习之路-Django基础:Admin站点","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-admin%E7%AB%99%E7%82%B9/"},{"categories":["Django"],"content":"显示字段 属性如下： fields=[] 点击某行ID的链接，可以转到修改页面： 打开booktest/admin.py文件，修改BookInfoAdmin类如下： class BookInfoAdmin(admin.ModelAdmin): ... fields = ['btitle', 'bpub_date'] ","date":"2020-09-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-admin%E7%AB%99%E7%82%B9/:4:1","tags":["Python学习之路"],"title":"Python学习之路-Django基础:Admin站点","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-admin%E7%AB%99%E7%82%B9/"},{"categories":["Django"],"content":"分组显示 属性如下： fieldset=( ('组1标题',{'fields':('字段1','字段2')}), ('组2标题',{'fields':('字段3','字段4')}), ) 打开booktest/admin.py文件，修改BookInfoAdmin类如下： class BookInfoAdmin(admin.ModelAdmin): ... # fields = ['btitle', 'bpub_date'] fieldsets = ( ('基本', {'fields': ['btitle', 'bpub_date']}), ('高级', { 'fields': ['bread', 'bcomment'], 'classes': ('collapse',) # 是否折叠显示 }) ) 说明：fields与fieldsets两者选一使用。 3. 关联对象 在一对多的关系中，可以在一端的编辑页面中编辑多端的对象，嵌入多端对象的方式包括表格、块两种。 类型InlineModelAdmin：表示在模型的编辑页面嵌入关联模型的编辑。 子类TabularInline：以表格的形式嵌入。 子类StackedInline：以块的形式嵌入。 打开booktest/admin.py文件，创建HeroInfoStackInline类。 class HeroInfoStackInline(admin.StackedInline): model = HeroInfo # 要编辑的对象 extra = 1 # 附加编辑的数量 打开booktest/admin.py文件，修改BookInfoAdmin类如下： class BookInfoAdmin(admin.ModelAdmin): ... inlines = [HeroInfoStackInline] 可以用表格的形式嵌入。 打开booktest/admin.py文件，创建HeroInfoTabularInline类。 class HeroInfoTabularInline(admin.TabularInline): model = HeroInfo extra = 1 打开booktest/admin.py文件，修改BookInfoAdmin类如下： class BookInfoAdmin(admin.ModelAdmin): ... inlines = [HeroInfoTabularInline] ","date":"2020-09-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-admin%E7%AB%99%E7%82%B9/:4:2","tags":["Python学习之路"],"title":"Python学习之路-Django基础:Admin站点","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-admin%E7%AB%99%E7%82%B9/"},{"categories":["Django"],"content":"调整站点信息 Admin站点的名称信息也是可以自定义的。 admin.site.site_header 设置网站页头 admin.site.site_title 设置页面标题 admin.site.index_title 设置首页标语 在booktest/admin.py文件中添加一下信息 from django.contrib import admin admin.site.site_header = '传智书城' admin.site.site_title = '传智书城MIS' admin.site.index_title = '欢迎使用传智书城MIS' ","date":"2020-09-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-admin%E7%AB%99%E7%82%B9/:5:0","tags":["Python学习之路"],"title":"Python学习之路-Django基础:Admin站点","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-admin%E7%AB%99%E7%82%B9/"},{"categories":["Django"],"content":"上传图片 ","date":"2020-09-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-admin%E7%AB%99%E7%82%B9/:6:0","tags":["Python学习之路"],"title":"Python学习之路-Django基础:Admin站点","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-admin%E7%AB%99%E7%82%B9/"},{"categories":["Django"],"content":"简介 Django有提供文件系统支持，在Admin站点中可以轻松上传图片。 使用Admin站点保存图片，需要安装Python的图片操作包 pip install Pillow ","date":"2020-09-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-admin%E7%AB%99%E7%82%B9/:6:1","tags":["Python学习之路"],"title":"Python学习之路-Django基础:Admin站点","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-admin%E7%AB%99%E7%82%B9/"},{"categories":["Django"],"content":"配置 默认情况下，Django会将上传的图片保存在本地服务器上，需要配置保存的路径。 我们可以将上传的文件保存在静态文件目录中，如我们之前设置的static_files目录中在settings.py 文件中添加如下上传保存目录信息 MEDIA_ROOT=os.path.join(BASE_DIR,\"static_files/media\") ","date":"2020-09-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-admin%E7%AB%99%E7%82%B9/:6:2","tags":["Python学习之路"],"title":"Python学习之路-Django基础:Admin站点","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-admin%E7%AB%99%E7%82%B9/"},{"categories":["Django"],"content":"为模型类添加ImageField字段 我们为之前的BookInfo模型类添加一个ImageFiled class BookInfo(models.Model): ... image = models.ImageField(upload_to='booktest', verbose_name='图片', null=True) upload_to 选项指明该字段的图片保存在MEDIA_ROOT目录中的哪个子目录 进行数据库迁移操作 python manage.py makemigrations python manage.py migrate ","date":"2020-09-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-admin%E7%AB%99%E7%82%B9/:6:3","tags":["Python学习之路"],"title":"Python学习之路-Django基础:Admin站点","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-admin%E7%AB%99%E7%82%B9/"},{"categories":["Django"],"content":"使用Admin站点上传图片 进入Admin站点的图书管理页面，选择一个图书，能发现多出来一个上传图片的字段 选择一张图片并保存后，图片会被保存在**static_files/media/booktest/**目录下。 在数据库中，我们能看到image字段被设置为图片的路径 ","date":"2020-09-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-admin%E7%AB%99%E7%82%B9/:6:4","tags":["Python学习之路"],"title":"Python学习之路-Django基础:Admin站点","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-admin%E7%AB%99%E7%82%B9/"},{"categories":["Django"],"content":"ORM框架 ","date":"2020-08-29","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%95%B0%E6%8D%AE%E5%BA%93/:1:0","tags":["Python学习之路"],"title":"Python学习之路-Django基础:数据库","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["Django"],"content":"简介 O是object，也就类对象的意思，R是relation，翻译成中文是关系，也就是关系数据库中数据表的意思，M是mapping，是映射的意思。在ORM框架中，它帮我们把类和数据表进行了一个映射，可以让我们通过类和类对象就能操作它所对应的表格中的数据。ORM框架还有一个功能，它可以根据我们设计的类自动帮我们生成数据库中的表格，省去了我们自己建表的过程。 django中内嵌了ORM框架，不需要直接面向数据库编程，而是定义模型类，通过模型类和对象完成数据表的增删改查操作。 使用django进行数据库开发的步骤如下： 配置数据库连接信息 在models.py中定义模型类 迁移 通过类和对象完成数据增删改查操作 ","date":"2020-08-29","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%95%B0%E6%8D%AE%E5%BA%93/:1:1","tags":["Python学习之路"],"title":"Python学习之路-Django基础:数据库","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["Django"],"content":"配置 在settings.py中保存了数据库的连接配置信息，Django默认初始配置使用sqlite数据库。 DATABASES = { 'default': { 'ENGINE': 'django.db.backends.sqlite3', 'NAME': os.path.join(BASE_DIR, 'db.sqlite3'), } } 使用MySQL数据库首先需要安装驱动程序 pip install PyMySQL 在Django的工程同名子目录的__init__.py文件中添加如下语句 from pymysql import install_as_MySQLdb install_as_MySQLdb() 作用是让Django的ORM能以mysqldb的方式来调用PyMySQL。 修改DATABASES配置信息 DATABASES = { 'default': { 'ENGINE': 'django.db.backends.mysql', 'HOST': '127.0.0.1', # 数据库主机 'PORT': 3306, # 数据库端口 'USER': 'root', # 数据库用户名 'PASSWORD': 'mysql', # 数据库用户密码 'NAME': 'django_demo' # 数据库名字 } } 在MySQL中创建数据库 create database django_demo default charset=utf8; ","date":"2020-08-29","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%95%B0%E6%8D%AE%E5%BA%93/:1:2","tags":["Python学习之路"],"title":"Python学习之路-Django基础:数据库","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["Django"],"content":"定义模型类 简介 模型类被定义在\"应用/models.py\"文件中。，模型类必须继承自Model类，位于包django.db.models中。 定义 创建应用booktest，在models.py 文件中定义模型类。 from django.db import models #定义图书模型类BookInfo class BookInfo(models.Model): btitle = models.CharField(max_length=20, verbose_name='名称') bpub_date = models.DateField(verbose_name='发布日期') bread = models.IntegerField(default=0, verbose_name='阅读量') bcomment = models.IntegerField(default=0, verbose_name='评论量') is_delete = models.BooleanField(default=False, verbose_name='逻辑删除') class Meta: db_table = 'tb_books' # 指明数据库表名 verbose_name = '图书' # 在admin站点中显示的名称 verbose_name_plural = verbose_name # 显示的复数名称 def __str__(self): \"\"\"定义每个数据对象的显示信息\"\"\" return self.btitle #定义英雄模型类HeroInfo class HeroInfo(models.Model): GENDER_CHOICES = ( (0, 'male'), (1, 'female') ) hname = models.CharField(max_length=20, verbose_name='名称') hgender = models.SmallIntegerField(choices=GENDER_CHOICES, default=0, verbose_name='性别') hcomment = models.CharField(max_length=200, null=True, verbose_name='描述信息') hbook = models.ForeignKey(BookInfo, on_delete=models.CASCADE, verbose_name='图书') # 外键 is_delete = models.BooleanField(default=False, verbose_name='逻辑删除') class Meta: db_table = 'tb_heros' verbose_name = '英雄' verbose_name_plural = verbose_name def __str__(self): return self.hname 数据库表名 模型类如果未指明表名，Django默认以 小写app应用名_小写模型类名 为数据库表名。 可通过db_table 指明数据库表名。 关于主键 django会为表创建自动增长的主键列，每个模型只能有一个主键列，如果使用选项设置某属性为主键列后django不会再创建自动增长的主键列。 默认创建的主键列属性为id，可以使用pk代替，pk全拼为primary key。 属性命名限制 不能是python的保留关键字。 不允许使用连续的下划线，这是由django的查询方式决定的。 定义属性时需要指定字段类型，通过字段类型的参数指定选项，语法如下： 属性=models.字段类型(选项) 字段类型 类型 说明 AutoField 自动增长的IntegerField，通常不用指定，不指定时Django会自动创建属性名为id的自动增长属性 BooleanField 布尔字段，值为True或False NullBooleanField 支持Null、True、False三种值 CharField 字符串，参数max_length表示最大字符个数 TextField 大文本字段，一般超过4000个字符时使用 IntegerField 整数 DecimalField 十进制浮点数， 参数max_digits表示总位数， 参数decimal_places表示小数位数 FloatField 浮点数 DateField 日期， 参数auto_now表示每次保存对象时，自动设置该字段为当前时间，用于\"最后一次修改\"的时间戳，它总是使用当前日期，默认为False； 参数auto_now_add表示当对象第一次被创建时自动设置当前时间，用于创建的时间戳，它总是使用当前日期，默认为False; 参数auto_now_add和auto_now是相互排斥的，组合将会发生错误 TimeField 时间，参数同DateField DateTimeField 日期时间，参数同DateField FileField 上传文件字段 ImageField 继承于FileField，对上传的内容进行校验，确保是有效的图片 选项 选项 说明 null 如果为True，表示允许为空，默认值是False blank 如果为True，则该字段允许为空白，默认值是False db_column 字段的名称，如果未指定，则使用属性的名称 db_index 若值为True, 则在表中会为此字段创建索引，默认值是False default 默认 primary_key 若为True，则该字段会成为模型的主键字段，默认值是False，一般作为AutoField的选项使用 unique 如果为True, 这个字段在表中必须有唯一值，默认值是False null是数据库范畴的概念，blank是表单验证范畴的 外键 在设置外键时，需要通过on_delete选项指明主表删除数据时，对于外键引用表数据如何处理，在django.db.models中包含了可选常量： CASCADE 级联，删除主表数据时连通一起删除外键表中数据 PROTECT 保护，通过抛出ProtectedError异常，来阻止删除主表中被外键应用的数据 SET_NULL 设置为NULL，仅在该字段null=True允许为null时可用 SET_DEFAULT 设置为默认值，仅在该字段设置了默认值时可用 SET() 设置为特定值或者调用特定方法，如 from django.conf import settings from django.contrib.auth import get_user_model from django.db import models def get_sentinel_user(): return get_user_model().objects.get_or_create(username='deleted')[0] class MyModel(models.Model): user = models.ForeignKey( settings.AUTH_USER_MODEL, on_delete=models.SET(get_sentinel_user), ) DO_NOTHING 不做任何操作，如果数据库前置指明级联性，此选项会抛出IntegrityError异常 迁移 将模型类同步到数据库中。 生成迁移文件 python manage.py makemigrations 同步到数据库中 python manage.py migrate ","date":"2020-08-29","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%95%B0%E6%8D%AE%E5%BA%93/:1:3","tags":["Python学习之路"],"title":"Python学习之路-Django基础:数据库","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["Django"],"content":"数据库操作 增加 增加数据有两种方法。 save，通过创建模型类对象，执行对象的save()方法保存到数据库中。 \u003e\u003e\u003e from datetime import date \u003e\u003e\u003e book = BookInfo( btitle='西游记', bput_date=date(1988,1,1), bread=10, bcomment=10 ) \u003e\u003e\u003e book.save() \u003e\u003e\u003e hero = HeroInfo( hname='孙悟空', hgender=0, hbook=book ) \u003e\u003e\u003e hero.save() \u003e\u003e\u003e hero2 = HeroInfo( hname='猪八戒', hgender=0, hbook_id=book.id ) \u003e\u003e\u003e hero2.save() create，通过模型类.objects.create()保存。 \u003e\u003e\u003e HeroInfo.objects.create( hname='沙悟净', hgender=0, hbook=book ) \u003cHeroInfo: 沙悟净\u003e 查询 基本查询 get 查询单一结果，如果不存在会抛出模型类.DoesNotExist异常。 all 查询多个结果。 count 查询结果数量。 \u003e\u003e\u003e BookInfo.objects.all() \u003cQuerySet [\u003cBookInfo: 射雕英雄传\u003e, \u003cBookInfo: 天龙八部\u003e, \u003cBookInfo: 笑傲江湖\u003e, \u003cBookInfo: 雪山飞狐\u003e, \u003cBookInfo: 西游记\u003e]\u003e \u003e\u003e\u003e book = BookInfo.objects.get(btitle='西游记') \u003e\u003e\u003e book.id 5 \u003e\u003e\u003e BookInfo.objects.get(id=3) \u003cBookInfo: 笑傲江湖\u003e \u003e\u003e\u003e BookInfo.objects.get(pk=3) \u003cBookInfo: 笑傲江湖\u003e \u003e\u003e\u003e BookInfo.objects.get(id=100) Traceback (most recent call last): File \"\u003cconsole\u003e\", line 1, in \u003cmodule\u003e File \"/Users/delron/.virtualenv/dj/lib/python3.6/site-packages/django/db/models/manager.py\", line 85, in manager_method return getattr(self.get_queryset(), name)(*args, **kwargs) File \"/Users/delron/.virtualenv/dj/lib/python3.6/site-packages/django/db/models/query.py\", line 380, in get self.model._meta.object_name db.models.DoesNotExist: BookInfo matching query does not exist. \u003e\u003e\u003e BookInfo.objects.count() 6 过滤查询 实现SQL中的where功能，包括 filter 过滤出多个结果 exclude 排除掉符合条件剩下的结果 get 过滤单一结果 对于过滤条件的使用，上述三个方法相同，故仅以filter进行讲解。 过滤条件的表达语法如下： 属性名称__比较运算符=值 # 属性名称和比较运算符间使用两个下划线，所以属性名不能包括多个下划线 相等 exact：表示判等。 例：查询编号为1的图书。 BookInfo.objects.filter(id__exact=1) 可简写为： BookInfo.objects.filter(id=1) 模糊查询 contains：是否包含。 说明 如果要包含%无需转义，直接写即可。 例：查询书名包含’传’的图书。 BookInfo.objects.filter(btitle__contains='传') startswith、endswith：以指定值开头或结尾。 例：查询书名以’部’结尾的图书 BookInfo.objects.filter(btitle__endswith='部') 说明 以上运算符都区分大小写，在这些运算符前加上i表示不区分大小写，如iexact、icontains、istartswith、iendswith. 空查询 isnull：是否为null。 例：查询书名不为空的图书。 BookInfo.objects.filter(btitle__isnull=False) 范围查询 in：是否包含在范围内。 例：查询编号为1或3或5的图书 BookInfo.objects.filter(id__in=[1, 3, 5]) 比较查询 gt 大于 (greater then) gte 大于等于 (greater then equal) lt 小于 (less then) lte 小于等于 (less then equal) 例：查询编号大于3的图书 BookInfo.objects.filter(id__gt=3) 不等于的运算符，使用exclude()过滤器。 例：查询编号不等于3的图书 BookInfo.objects.exclude(id=3) 日期查询 year、month、day、week_day、hour、minute、second：对日期时间类型的属性进行运算。 例：查询1980年发表的图书。 BookInfo.objects.filter(bpub_date__year=1980) 例：查询1980年1月1日后发表的图书。 BookInfo.objects.filter(bpub_date__gt=date(1990, 1, 1)) F对象 之前的查询都是对象的属性与常量值比较，两个属性怎么比较呢？ 答：使用F对象，被定义在django.db.models中。 语法如下： F(属性名) 例：查询阅读量大于等于评论量的图书。 from django.db.models import F BookInfo.objects.filter(bread__gte=F('bcomment')) 可以在F对象上使用算数运算。 例：查询阅读量大于2倍评论量的图书。 BookInfo.objects.filter(bread__gt=F('bcomment') * 2) Q对象 多个过滤器逐个调用表示逻辑与关系，同sql语句中where部分的and关键字。 例：查询阅读量大于20，并且编号小于3的图书。 BookInfo.objects.filter(bread__gt=20,id__lt=3) 或 BookInfo.objects.filter(bread__gt=20).filter(id__lt=3) 如果需要实现逻辑或or的查询，需要使用Q()对象结合|运算符，Q对象被义在django.db.models中。 语法如下： Q(属性名__运算符=值) 例：查询阅读量大于20的图书，改写为Q对象如下。 from django.db.models import Q BookInfo.objects.filter(Q(bread__gt=20)) Q对象可以使用\u0026、|连接，\u0026表示逻辑与，|表示逻辑或。 例：查询阅读量大于20，或编号小于3的图书，只能使用Q对象实现 BookInfo.objects.filter(Q(bread__gt=20) | Q(pk__lt=3)) Q对象前可以使用~操作符，表示非not。 例：查询编号不等于3的图书。 BookInfo.objects.filter(~Q(pk=3)) 聚合函数 使用aggregate()过滤器调用聚合函数。聚合函数包括：Avg 平均，Count 数量，Max 最大，Min 最小，Sum 求和，被定义在django.db.models中。 例：查询图书的总阅读量。 from django.db.models import Sum BookInfo.objects.aggregate(Sum('bread')) 注意aggregate的返回值是一个字典类型，格式如下： {'属性名__聚合类小写':值} 如:{'bread__sum':3} 使用count时一般不使用aggregate()过滤器。 例：查询图书总数。 BookInfo.objects.count() 注意count函数的返回值是一个数字。 排序 使用order_by对结果进行排序 BookInfo.objects.all().order_by('bread') # 升序 BookInfo.objects.all().order_by('-bread') # 降序 关联查询 由一到多的访问语法： 一对应的模型类对象.多对应的模型类名小写_set 例： b = BookInfo.objects.get(id=1) b.heroinfo_set.all() 由多到一的访问语法: 多对应的模型类对象.多对应的模型类中的关系类属性名 例： h = HeroInfo.objects.get(id=1) h.hbook 访问一对应的模型类关联对象的id语法: 多对应的模型类对象.关联类属性_id 例： h = HeroInfo.objects.get(id=1) h.hbook_id 关联过滤查询 由多模型类条件查询一模型类数据: 语法如下： 关联模型类名小写__属性名__条件运算符=值","date":"2020-08-29","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%95%B0%E6%8D%AE%E5%BA%93/:1:4","tags":["Python学习之路"],"title":"Python学习之路-Django基础:数据库","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["Django"],"content":"查询集 QuerySet 概念 Django的ORM中存在查询集的概念。 查询集，也称查询结果集、QuerySet，表示从数据库中获取的对象集合。 当调用如下过滤器方法时，Django会返回查询集（而不是简单的列表）： all()：返回所有数据。 filter()：返回满足条件的数据。 exclude()：返回满足条件之外的数据。 order_by()：对结果进行排序。 对查询集可以再次调用过滤器进行过滤，如 BookInfo.objects.filter(bread__gt=30).order_by('bpub_date') 也就意味着查询集可以含有零个、一个或多个过滤器。过滤器基于所给的参数限制查询的结果。 从SQL的角度讲，查询集与select语句等价，过滤器像where、limit、order by子句。 判断某一个查询集中是否有数据： exists()：判断查询集中是否有数据，如果有则返回True，没有则返回False。 两大特性 惰性执行 创建查询集不会访问数据库，直到调用数据时，才会访问数据库，调用数据的情况包括迭代、序列化、与if合用 例如，当执行如下语句时，并未进行数据库查询，只是创建了一个查询集qs qs = BookInfo.objects.all() 继续执行遍历迭代操作后，才真正的进行了数据库的查询 for book in qs: print(book.btitle) 缓存 使用同一个查询集，第一次使用时会发生数据库的查询，然后Django会把结果缓存下来，再次使用这个查询集时会使用缓存的数据，减少了数据库的查询次数。 情况一：如下是两个查询集，无法重用缓存，每次查询都会与数据库进行一次交互，增加了数据库的负载。 from booktest.models import BookInfo [book.id for book in BookInfo.objects.all()] [book.id for book in BookInfo.objects.all()] 情况二：经过存储后，可以重用查询集，第二次使用缓存中的数据。 qs=BookInfo.objects.all() [book.id for book in qs] [book.id for book in qs] 限制查询集 可以对查询集进行取下标或切片操作，等同于sql中的limit和offset子句。 注意 不支持负数索引。 对查询集进行切片后返回一个新的查询集，不会立即执行查询。 如果获取一个对象，直接使用[0]，等同于[0:1].get()，但是如果没有数据，[0]引发IndexError异常，[0:1].get()如果没有数据引发DoesNotExist异常。 示例：获取第1、2项，运行查看。 qs = BookInfo.objects.all()[0:2] ","date":"2020-08-29","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%95%B0%E6%8D%AE%E5%BA%93/:1:5","tags":["Python学习之路"],"title":"Python学习之路-Django基础:数据库","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["Django"],"content":"管理器Manager 简介 管理器是Django的模型进行数据库操作的接口，Django应用的每个模型类都拥有至少一个管理器。 我们在通过模型类的objects属性提供的方法操作数据库时，即是在使用一个管理器对象objects。当没有为模型类定义管理器时，Django会为每一个模型类生成一个名为objects的管理器，它是models.Manager类的对象。 自定义管理器 我们可以自定义管理器，并应用到我们的模型类上。 注意 一旦为模型类指明自定义的过滤器后，Django不再生成默认管理对象objects。 自定义管理器类主要用于两种情况： 修改原始查询集，重写all()方法。 打开booktest/models.py文件，定义类BookInfoManager #图书管理器 class BookInfoManager(models.Manager): def all(self): #默认查询未删除的图书信息 #调用父类的成员语法为：super().方法名 return super().filter(is_delete=False) 在模型类BookInfo中定义管理器 class BookInfo(models.Model): ... books = BookInfoManager() 使用方法 BookInfo.books.all() 在管理器类中补充定义新的方法 打开booktest/models.py文件，定义方法create。 class BookInfoManager(models.Manager): #创建模型类，接收参数为属性赋值 def create_book(self, title, pub_date): #创建模型类对象self.model可以获得模型类 book = self.model() book.btitle = title book.bpub_date = pub_date book.bread=0 book.bcommet=0 book.is_delete = False # 将数据插入进数据表 book.save() return book 为模型类BookInfo定义管理器books语法如下 class BookInfo(models.Model): ... books = BookInfoManager() 调用语法如下： book=BookInfo.books.create_book(\"abc\",date(1980,1,1)) ","date":"2020-08-29","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%95%B0%E6%8D%AE%E5%BA%93/:1:6","tags":["Python学习之路"],"title":"Python学习之路-Django基础:数据库","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["Django"],"content":"模板 ","date":"2020-08-22","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%A8%A1%E6%9D%BF/:1:0","tags":["Python学习之路"],"title":"Python学习之路-Django基础:模板","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%A8%A1%E6%9D%BF/"},{"categories":["Django"],"content":"配置 在工程中创建模板目录templates。在settings.py配置文件中修改TEMPLATES配置项的DIRS值： TEMPLATES = [ { 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': [os.path.join(BASE_DIR, 'templates')], # 此处修改 'APP_DIRS': True, 'OPTIONS': { 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', ], }, }, ] ","date":"2020-08-22","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%A8%A1%E6%9D%BF/:1:1","tags":["Python学习之路"],"title":"Python学习之路-Django基础:模板","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%A8%A1%E6%9D%BF/"},{"categories":["Django"],"content":"定义 在templates目录中新建一个模板文件，如index.html ","date":"2020-08-22","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%A8%A1%E6%9D%BF/:1:2","tags":["Python学习之路"],"title":"Python学习之路-Django基础:模板","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%A8%A1%E6%9D%BF/"},{"categories":["Django"],"content":"模板渲染 调用模板分为两步骤： 找到模板 loader.get_template(模板文件在模板目录中的相对路径) -\u003e 返回模板对象 渲染模板 模板对象.render(context=None, request=None) -\u003e 返回渲染后的html文本字符串 context 为模板变量字典，默认值为None request 为请求对象，默认值为None 例如，定义一个视图 from django.http import HttpResponse from django.template import loader def index(request): # 1.获取模板 template=loader.get_template('index.html') context={'city': '北京'} # 2.渲染模板 return HttpResponse(template.render(context)) Django提供了一个函数render可以简写上述代码。 render(request对象, 模板文件路径, 模板数据字典) from django.shortcuts import render def index(request): context={'city': '北京'} return render(request,'index.html',context) ","date":"2020-08-22","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%A8%A1%E6%9D%BF/:1:3","tags":["Python学习之路"],"title":"Python学习之路-Django基础:模板","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%A8%A1%E6%9D%BF/"},{"categories":["Django"],"content":"模板语法 变量 变量名必须由字母、数字、下划线（不能以下划线开头）和点组成。 语法如下： {{变量}} 模板变量可以使python的内建类型，也可以是对象。 def index(request): context = { 'city': '北京', 'adict': { 'name': '西游记', 'author': '吴承恩' }, 'alist': [1, 2, 3, 4, 5] } return render(request, 'index.html', context) 模板语句 for循环： if条件： 比较运算符： 布尔运算符： 注意 运算符左右两侧不能紧挨变量或常量，必须有空格。 过滤器 语法如下: 使用管道符号|来应用过滤器，用于进行计算、转换操作，可以使用在变量、标签中。 如果过滤器需要参数，则使用冒号:传递参数。 变量|过滤器:参数 列举几个如下： safe，禁用转义，告诉模板这个变量是安全的，可以解释执行 length，长度，返回字符串包含字符的个数，或列表、元组、字典的元素个数。 default，默认值，如果变量不存在时则返回默认值。 data|default:‘默认值’ date，日期，用于对日期类型的值进行字符串格式化，常用的格式化字符如下： Y表示年，格式为4位，y表示两位的年。 m表示月，格式为01,02,12等。 d表示日, 格式为01,02等。 j表示日，格式为1,2等。 H表示时，24进制，h表示12进制的时。 i表示分，为0-59。 s表示秒，为0-59。 value|date:“Y年m月j日 H时i分s秒” 注释 单行注释语法如下： 多行注释使用comment标签，语法如下： 继承 简介 模板继承和类的继承含义是一样的，主要是为了提高代码重用，减轻开发人员的工作量。 父模板 如果发现在多个模板中某些内容相同，那就应该把这段内容定义到父模板中。 标签block：用于在父模板中预留区域，留给子模板填充差异性的内容，名字不能相同。 为了更好的可读性，建议给endblock标签写上名字，这个名字与对应的block名字相同。父模板中也可以使用上下文中传递过来的数据。 子模板 标签extends：继承，写在子模板文件的第一行。 子模版不用填充父模版中的所有预留区域，如果子模版没有填充，则使用父模版定义的默认值。 填充父模板中指定名称的预留区域。 实际填充内容 ","date":"2020-08-22","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%A8%A1%E6%9D%BF/:1:4","tags":["Python学习之路"],"title":"Python学习之路-Django基础:模板","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%A8%A1%E6%9D%BF/"},{"categories":["Django"],"content":"类视图 ","date":"2020-08-15","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/:1:0","tags":["Python学习之路"],"title":"Python学习之路-Django基础:类视图与中间件","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"categories":["Django"],"content":"引入 以函数的方式定义的视图称为函数视图，函数视图便于理解。但是遇到一个视图对应的路径提供了多种不同HTTP请求方式的支持时，便需要在一个函数中编写不同的业务逻辑，代码可读性与复用性都不佳。 def register(request): \"\"\"处理注册\"\"\" # 获取请求方法，判断是GET/POST请求 if request.method == 'GET': # 处理GET请求，返回注册页面 return render(request, 'register.html') else: # 处理POST请求，实现注册逻辑 return HttpResponse('这里实现注册逻辑') ","date":"2020-08-15","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/:1:1","tags":["Python学习之路"],"title":"Python学习之路-Django基础:类视图与中间件","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"categories":["Django"],"content":"简介 在Django中也可以使用类来定义一个视图，称为类视图。 ","date":"2020-08-15","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/:1:2","tags":["Python学习之路"],"title":"Python学习之路-Django基础:类视图与中间件","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"categories":["Django"],"content":"实例 使用类视图可以将视图对应的不同请求方式以类中的不同方法来区别定义。如下所示 from django.views.generic import View class RegisterView(View): \"\"\"类视图：处理注册\"\"\" def get(self, request): \"\"\"处理GET请求，返回注册页面\"\"\" return render(request, 'register.html') def post(self, request): \"\"\"处理POST请求，实现注册逻辑\"\"\" return HttpResponse('这里实现注册逻辑') ","date":"2020-08-15","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/:1:3","tags":["Python学习之路"],"title":"Python学习之路-Django基础:类视图与中间件","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"categories":["Django"],"content":"好处 代码可读性好，类视图相对于函数视图有更高的复用性， 如果其他地方需要用到某个类视图的某个特定逻辑，直接继承该类视图即可 ","date":"2020-08-15","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/:1:4","tags":["Python学习之路"],"title":"Python学习之路-Django基础:类视图与中间件","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"categories":["Django"],"content":"使用 定义类视图需要继承自Django提供的父类View，可使用from django.views.generic import View或者from django.views.generic.base import View 导入，定义方式如上所示。 配置路由时，使用类视图的as_view()方法来添加。 urlpatterns = [ # 视图函数：注册 # url(r'^register/$', views.register, name='register'), # 类视图：注册 url(r'^register/$', views.RegisterView.as_view(), name='register'), ] ","date":"2020-08-15","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/:1:5","tags":["Python学习之路"],"title":"Python学习之路-Django基础:类视图与中间件","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"categories":["Django"],"content":"原理 @classonlymethod def as_view(cls, **initkwargs): \"\"\" Main entry point for a request-response process. \"\"\" ...省略代码... def view(request, *args, **kwargs): self = cls(**initkwargs) if hasattr(self, 'get') and not hasattr(self, 'head'): self.head = self.get self.request = request self.args = args self.kwargs = kwargs # 调用dispatch方法，按照不同请求方式调用不同请求方法 return self.dispatch(request, *args, **kwargs) ...省略代码... # 返回真正的函数视图 return view def dispatch(self, request, *args, **kwargs): # Try to dispatch to the right method; if a method doesn't exist, # defer to the error handler. Also defer to the error handler if the # request method isn't on the approved list. if request.method.lower() in self.http_method_names: handler = getattr(self, request.method.lower(), self.http_method_not_allowed) else: handler = self.http_method_not_allowed return handler(request, *args, **kwargs) ","date":"2020-08-15","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/:1:6","tags":["Python学习之路"],"title":"Python学习之路-Django基础:类视图与中间件","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"categories":["Django"],"content":"使用装饰器 为类视图添加装饰器，可以使用两种方法。 为了理解方便，我们先来定义一个为函数视图准备的装饰器（在设计装饰器时基本都以函数视图作为考虑的被装饰对象），及一个要被装饰的类视图。 def my_decorator(func): def wrapper(request, *args, **kwargs): print('自定义装饰器被调用了') print('请求路径%s' % request.path) return func(request, *args, **kwargs) return wrapper class DemoView(View): def get(self, request): print('get方法') return HttpResponse('ok') def post(self, request): print('post方法') return HttpResponse('ok') ","date":"2020-08-15","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/:1:7","tags":["Python学习之路"],"title":"Python学习之路-Django基础:类视图与中间件","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"categories":["Django"],"content":"在URL配置中装饰 urlpatterns = [ url(r'^demo/$', my_decorate(DemoView.as_view())) ] 此种方式最简单，但因装饰行为被放置到了url配置中，单看视图的时候无法知道此视图还被添加了装饰器，不利于代码的完整性，不建议使用。 注意 此种方式会为类视图中的所有请求方法都加上装饰器行为（因为是在视图入口处，分发请求方式前）。 ","date":"2020-08-15","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/:1:8","tags":["Python学习之路"],"title":"Python学习之路-Django基础:类视图与中间件","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"categories":["Django"],"content":"在类视图中装饰 在类视图中使用为函数视图准备的装饰器时，不能直接添加装饰器，需要使用method_decorator将其转换为适用于类视图方法的装饰器。method_decorator装饰器使用name参数指明被装饰的方法 # 为全部请求方法添加装饰器 @method_decorator(my_decorator, name='dispatch') class DemoView(View): def get(self, request): print('get方法') return HttpResponse('ok') def post(self, request): print('post方法') return HttpResponse('ok') # 为特定请求方法添加装饰器 @method_decorator(my_decorator, name='get') class DemoView(View): def get(self, request): print('get方法') return HttpResponse('ok') def post(self, request): print('post方法') return HttpResponse('ok') 如果需要为类视图的多个方法添加装饰器，但又不是所有的方法（为所有方法添加装饰器参考上面例子），可以直接在需要添加装饰器的方法上使用method_decorator，如下所示 from django.utils.decorators import method_decorator # 为特定请求方法添加装饰器 class DemoView(View): @method_decorator(my_decorator) # 为get方法添加了装饰器 def get(self, request): print('get方法') return HttpResponse('ok') @method_decorator(my_decorator) # 为post方法添加了装饰器 def post(self, request): print('post方法') return HttpResponse('ok') def put(self, request): # 没有为put方法添加装饰器 print('put方法') return HttpResponse('ok') ","date":"2020-08-15","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/:1:9","tags":["Python学习之路"],"title":"Python学习之路-Django基础:类视图与中间件","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"categories":["Django"],"content":"Mixin扩展类 使用面向对象多继承的特性，可以通过定义父类（作为扩展类），在父类中定义想要向类视图补充的方法，类视图继承这些扩展父类，便可实现代码复用。 定义的扩展父类名称通常以Mixin结尾。 举例如下： class ListModelMixin(object): \"\"\" list扩展类 \"\"\" def list(self, request, *args, **kwargs): ... class CreateModelMixin(object): \"\"\" create扩展类 \"\"\" def create(self, request, *args, **kwargs): ... class BooksView(CreateModelMixin, ListModelMixin, View): \"\"\" 同时继承两个扩展类，复用list和create方法 \"\"\" def get(self, request): self.list(request) ... def post(self, request): self.create(request) ... class SaveOrderView(CreateModelMixin, View): \"\"\" 继承CreateModelMixin扩展类，复用create方法 \"\"\" def post(self, request): self.create(request) ... ","date":"2020-08-15","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/:1:10","tags":["Python学习之路"],"title":"Python学习之路-Django基础:类视图与中间件","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"categories":["Django"],"content":"中间件 ","date":"2020-08-15","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/:2:0","tags":["Python学习之路"],"title":"Python学习之路-Django基础:类视图与中间件","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"categories":["Django"],"content":"简介 Django中的中间件是一个轻量级、底层的插件系统，可以介入Django的请求和响应处理过程，修改Django的输入或输出。中间件的设计为开发者提供了一种无侵入式的开发方式，增强了Django框架的健壮性。 我们可以使用中间件，在Django处理视图的不同阶段对输入或输出进行干预。 ","date":"2020-08-15","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/:2:1","tags":["Python学习之路"],"title":"Python学习之路-Django基础:类视图与中间件","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"categories":["Django"],"content":"定义方法 定义一个中间件工厂函数，然后返回一个可以别调用的中间件。中间件工厂函数需要接收一个可以调用的get_response对象。返回的中间件也是一个可以被调用的对象，并且像视图一样需要接收一个request对象参数，返回一个response对象。 def simple_middleware(get_response): # 此处编写的代码仅在Django第一次配置和初始化的时候执行一次。 def middleware(request): # 此处编写的代码会在每个请求处理视图前被调用。 response = get_response(request) # 此处编写的代码会在每个请求处理视图之后被调用。 return response return middleware 例如，在users应用中新建一个middleware.py文件， def my_middleware(get_response): print('init 被调用') def middleware(request): print('before request 被调用') response = get_response(request) print('after response 被调用') return response return middleware 定义好中间件后，需要在settings.py 文件中添加注册中间件 MIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'django.middleware.common.CommonMiddleware', # 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware', 'users.middleware.my_middleware', # 添加中间件 ] 定义一个视图进行测试 def demo_view(request): print('view 视图被调用') return HttpResponse('OK') 执行结果 注意 Django运行在调试模式下，中间件init部分有可能被调用两次。 ","date":"2020-08-15","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/:2:2","tags":["Python学习之路"],"title":"Python学习之路-Django基础:类视图与中间件","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"categories":["Django"],"content":"多个中间件的执行顺序 在请求视图被处理前，中间件由上至下依次执行 在请求视图被处理后，中间件由下至上依次执行 定义两个中间件，示例： def my_middleware(get_response): print('init 被调用') def middleware(request): print('before request 被调用') response = get_response(request) print('after response 被调用') return response return middleware def my_middleware2(get_response): print('init2 被调用') def middleware(request): print('before request 2 被调用') response = get_response(request) print('after response 2 被调用') return response return middleware 注册添加两个中间件 MIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'django.middleware.common.CommonMiddleware', # 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware', 'users.middleware.my_middleware', # 添加 'users.middleware.my_middleware2', # 添加 ] 执行结果 init2 被调用 init 被调用 before request 被调用 before request 2 被调用 view 视图被调用 after response 2 被调用 after response 被调用 ","date":"2020-08-15","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/:2:3","tags":["Python学习之路"],"title":"Python学习之路-Django基础:类视图与中间件","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"categories":["Django"],"content":"请求 ","date":"2020-08-08","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/:1:0","tags":["Python学习之路"],"title":"Python学习之路-Django基础:请求与响应","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/"},{"categories":["Django"],"content":"简介 回想一下，利用HTTP协议向服务器传参有几种途径？ 提取URL的特定部分，如/weather/beijing/2018，可以在服务器端的路由中用正则表达式截取； 查询字符串（query string)，形如key1=value1\u0026key2=value2； 请求体（body）中发送的数据，比如表单数据、json、xml； 在http报文的头（header）中。 ","date":"2020-08-08","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/:1:1","tags":["Python学习之路"],"title":"Python学习之路-Django基础:请求与响应","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/"},{"categories":["Django"],"content":"URL路径参数 在定义路由URL时，可以使用正则表达式提取参数的方法从URL中获取请求参数，Django会将提取的参数直接传递到视图的传入参数中。 未命名参数按定义顺序传递， 如 url(r'^weather/([a-z]+)/(\\d{4})/$', views.weather), def weather(request, city, year): print('city=%s' % city) print('year=%s' % year) return HttpResponse('OK') 命名参数按名字传递，如 url(r'^weather/(?P\u003ccity\u003e[a-z]+)/(?P\u003cyear\u003e\\d{4})/$', views.weather), def weather(request, year, city): print('city=%s' % city) print('year=%s' % year) return HttpResponse('OK') ","date":"2020-08-08","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/:1:2","tags":["Python学习之路"],"title":"Python学习之路-Django基础:请求与响应","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/"},{"categories":["Django"],"content":"Django中的QueryDict对象 定义在django.http.QueryDict，HttpRequest对象的属性GET、POST都是QueryDict类型的对象，与python字典不同，QueryDict类型的对象用来处理同一个键带有多个值的情况 方法 get()：根据键获取值 如果一个键同时拥有多个值将获取最后一个值 如果键不存在则返回None值，可以设置默认值进行后续处理 dict.get('键',默认值) 可简写为 dict['键'] getlist()：根据键获取值，值以列表返回，可以获取指定键的所有值 如果键不存在则返回空列表[]，可以设置默认值进行后续处理 dict.getlist('键',默认值) ","date":"2020-08-08","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/:1:3","tags":["Python学习之路"],"title":"Python学习之路-Django基础:请求与响应","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/"},{"categories":["Django"],"content":"查询字符串Query String 获取请求路径中的查询字符串参数（形如?k1=v1\u0026k2=v2），可以通过request.GET属性获取，返回QueryDict对象。 # /qs/?a=1\u0026b=2\u0026a=3 def qs(request): a = request.GET.get('a') b = request.GET.get('b') alist = request.GET.getlist('a') print(a) # 3 print(b) # 2 print(alist) # ['1', '3'] return HttpResponse('OK') 注意 查询字符串不区分请求方式，即假使客户端进行POST方式的请求，依然可以通过request.GET获取请求中的查询字符串数据。 ","date":"2020-08-08","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/:1:4","tags":["Python学习之路"],"title":"Python学习之路-Django基础:请求与响应","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/"},{"categories":["Django"],"content":"请求体 简介 请求体数据格式不固定，可以是表单类型字符串，可以是JSON字符串，可以是XML字符串，应区别对待。 可以发送请求体数据的请求方式有POST、PUT、PATCH、DELETE。 Django默认开启了CSRF防护，会对上述请求方式进行CSRF防护验证，在测试时可以关闭CSRF防护机制，方法为在settings.py文件中注释掉CSRF中间件，如： 表单类型 Form Data 前端发送的表单类型的请求体数据，可以通过request.POST属性获取，返回QueryDict对象。 def get_body(request): a = request.POST.get('a') b = request.POST.get('b') alist = request.POST.getlist('a') print(a) print(b) print(alist) return HttpResponse('OK') 注意 request.POST只能用来获取POST方式的请求体表单数据 非表单类型 Non-Form Data 非表单类型的请求体数据，Django无法自动解析，可以通过request.body属性获取最原始的请求体数据，自己按照请求体格式（JSON、XML等）进行解析。request.body返回bytes类型。 例如要获取请求体中的如下JSON数据 {\"a\": 1, \"b\": 2} 可以进行如下方法操作： import json def get_body_json(request): json_str = request.body json_str = json_str.decode() # python3.6 无需执行此步 req_data = json.loads(json_str) print(req_data['a']) print(req_data['b']) return HttpResponse('OK') ","date":"2020-08-08","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/:1:5","tags":["Python学习之路"],"title":"Python学习之路-Django基础:请求与响应","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/"},{"categories":["Django"],"content":"请求头 可以通过request.META属性获取请求头headers中的数据，request.META为字典类型。 常见的请求头如： CONTENT_LENGTH – The length of the request body (as a string). CONTENT_TYPE – The MIME type of the request body. HTTP_ACCEPT – Acceptable content types for the response. HTTP_ACCEPT_ENCODING – Acceptable encodings for the response. HTTP_ACCEPT_LANGUAGE – Acceptable languages for the response. HTTP_HOST – The HTTP Host header sent by the client. HTTP_REFERER – The referring page, if any. HTTP_USER_AGENT – The client’s user-agent string. QUERY_STRING – The query string, as a single (unparsed) string. REMOTE_ADDR – The IP address of the client. REMOTE_HOST – The hostname of the client. REMOTE_USER – The user authenticated by the Web server, if any. REQUEST_METHOD – A string such as \"GET\" or \"POST\". SERVER_NAME – The hostname of the server. SERVER_PORT – The port of the server (as a string). 具体使用如: def get_headers(request): print(request.META['CONTENT_TYPE']) return HttpResponse('OK') ","date":"2020-08-08","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/:1:6","tags":["Python学习之路"],"title":"Python学习之路-Django基础:请求与响应","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/"},{"categories":["Django"],"content":"其他常用HttpRequest对象属性 method：一个字符串，表示请求使用的HTTP方法，常用值包括：‘GET’、‘POST’。 user：请求的用户对象。 path：一个字符串，表示请求的页面的完整路径，不包含域名和参数部分。 encoding：一个字符串，表示提交的数据的编码方式。 如果为None则表示使用浏览器的默认设置，一般为utf-8。 这个属性是可写的，可以通过修改它来修改访问表单数据使用的编码，接下来对属性的任何访问将使用新的encoding值。 FILES：一个类似于字典的对象，包含所有的上传文件。 ","date":"2020-08-08","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/:1:7","tags":["Python学习之路"],"title":"Python学习之路-Django基础:请求与响应","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/"},{"categories":["Django"],"content":"响应 ","date":"2020-08-08","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/:2:0","tags":["Python学习之路"],"title":"Python学习之路-Django基础:请求与响应","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/"},{"categories":["Django"],"content":"简介 视图在接收请求并处理后，必须返回HttpResponse对象或子对象。HttpRequest对象由Django创建，HttpResponse对象由开发人员创建。 ","date":"2020-08-08","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/:2:1","tags":["Python学习之路"],"title":"Python学习之路-Django基础:请求与响应","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/"},{"categories":["Django"],"content":"HttpResponse 可以使用django.http.HttpResponse来构造响应对象。 HttpResponse(content=响应体, content_type=响应体数据类型, status=状态码) 也可通过HttpResponse对象属性来设置响应体、状态码： content：表示返回的内容。 status_code：返回的HTTP响应状态码。 响应头可以直接将HttpResponse对象当做字典进行响应头键值对的设置： response = HttpResponse() response['Itcast'] = 'Python' # 自定义响应头Itcast, 值为Python 示例： from django.http import HttpResponse def demo_view(request): return HttpResponse('itcast python', status=400) 或者 response = HttpResponse('itcast python') response.status_code = 400 response['Itcast'] = 'Python' return response ","date":"2020-08-08","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/:2:2","tags":["Python学习之路"],"title":"Python学习之路-Django基础:请求与响应","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/"},{"categories":["Django"],"content":"HttpResponse子类 Django提供了一系列HttpResponse的子类，可以快速设置状态码 HttpResponseRedirect 301 HttpResponsePermanentRedirect 302 HttpResponseNotModified 304 HttpResponseBadRequest 400 HttpResponseNotFound 404 HttpResponseForbidden 403 HttpResponseNotAllowed 405 HttpResponseGone 410 HttpResponseServerError 500 ","date":"2020-08-08","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/:2:3","tags":["Python学习之路"],"title":"Python学习之路-Django基础:请求与响应","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/"},{"categories":["Django"],"content":"JsonResponse 若要返回json数据，可以使用JsonResponse来构造响应对象，作用： 帮助我们将数据转换为json字符串 设置响应头Content-Type为 application/json from django.http import JsonResponse def demo_view(request): return JsonResponse({'city': 'beijing', 'subject': 'python'}) ","date":"2020-08-08","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/:2:4","tags":["Python学习之路"],"title":"Python学习之路-Django基础:请求与响应","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/"},{"categories":["Django"],"content":"redirect重定向 from django.shortcuts import redirect def demo_view(request): return redirect('/index.html') ","date":"2020-08-08","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/:2:5","tags":["Python学习之路"],"title":"Python学习之路-Django基础:请求与响应","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/"},{"categories":["Django"],"content":"Cookie ","date":"2020-08-08","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/:3:0","tags":["Python学习之路"],"title":"Python学习之路-Django基础:请求与响应","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/"},{"categories":["Django"],"content":"简介 Cookie，有时也用其复数形式Cookies，指某些网站为了辨别用户身份、进行session跟踪而储存在用户本地终端上的数据（通常经过加密）。Cookie最早是网景公司的前雇员Lou Montulli在1993年3月的发明。Cookie是由服务器端生成，发送给User-Agent（一般是浏览器），浏览器会将Cookie的key/value保存到某个目录下的文本文件内，下次请求同一网站时就发送该Cookie给服务器（前提是浏览器设置为启用cookie）。Cookie名称和值可以由服务器端开发自己定义，这样服务器可以知道该用户是否是合法用户以及是否需要重新登录等。服务器可以利用Cookies包含信息的任意性来筛选并经常性维护这些信息，以判断在HTTP传输中的状态。Cookies最典型记住用户名。 Cookie是存储在浏览器中的一段纯文本信息，建议不要存储敏感信息如密码，因为电脑上的浏览器可能被其它人使用。 ","date":"2020-08-08","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/:3:1","tags":["Python学习之路"],"title":"Python学习之路-Django基础:请求与响应","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/"},{"categories":["Django"],"content":"特点 Cookie以键值对的格式进行信息的存储。 Cookie基于域名安全，不同域名的Cookie是不能互相访问的，如访问itcast.cn时向浏览器中写了Cookie信息，使用同一浏览器访问baidu.com时，无法访问到itcast.cn写的Cookie信息。 当浏览器请求某网站时，会将浏览器存储的跟网站相关的所有Cookie信息提交给网站服务器。 ","date":"2020-08-08","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/:3:2","tags":["Python学习之路"],"title":"Python学习之路-Django基础:请求与响应","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/"},{"categories":["Django"],"content":"设置 可以通过HttpResponse对象中的set_cookie方法来设置cookie。 HttpResponse.set_cookie(cookie名, value=cookie值, max_age=cookie有效期) max_age 单位为秒，默认为None。如果是临时cookie，可将max_age设置为None。 示例： def demo_view(request): response = HttpResponse('ok') response.set_cookie('itcast1', 'python1') # 临时cookie response.set_cookie('itcast2', 'python2', max_age=3600) # 有效期一小时 return response ","date":"2020-08-08","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/:3:3","tags":["Python学习之路"],"title":"Python学习之路-Django基础:请求与响应","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/"},{"categories":["Django"],"content":"读取 可以通过HttpRequest对象的COOKIES属性来读取本次请求携带的cookie值。request.COOKIES为字典类型。 def demo_view(request): cookie1 = request.COOKIES.get('itcast1') print(cookie1) return HttpResponse('OK') ","date":"2020-08-08","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/:3:4","tags":["Python学习之路"],"title":"Python学习之路-Django基础:请求与响应","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/"},{"categories":["Django"],"content":"Session ","date":"2020-08-08","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/:4:0","tags":["Python学习之路"],"title":"Python学习之路-Django基础:请求与响应","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/"},{"categories":["Django"],"content":"启用Session Django项目默认启用Session。 可以在settings.py文件中查看 如需禁用session，将上图中的session中间件注释掉即可。 ","date":"2020-08-08","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/:4:1","tags":["Python学习之路"],"title":"Python学习之路-Django基础:请求与响应","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/"},{"categories":["Django"],"content":"存储方式 在settings.py文件中，可以设置session数据的存储方式，可以保存在数据库、本地缓存等。 ","date":"2020-08-08","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/:4:2","tags":["Python学习之路"],"title":"Python学习之路-Django基础:请求与响应","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/"},{"categories":["Django"],"content":"数据库 存储在数据库中，如下设置可以写，也可以不写，这是默认存储方式。 SESSION_ENGINE='django.contrib.sessions.backends.db' 如果存储在数据库中，需要在项INSTALLED_APPS中安装Session应用。 数据库中的表，表结构如下 由表结构可知，操作Session包括三个数据：键，值，过期时间。 ","date":"2020-08-08","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/:4:3","tags":["Python学习之路"],"title":"Python学习之路-Django基础:请求与响应","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/"},{"categories":["Django"],"content":"本地缓存 存储在本机内存中，如果丢失则不能找回，比数据库的方式读写更快。 SESSION_ENGINE='django.contrib.sessions.backends.cache' ","date":"2020-08-08","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/:4:4","tags":["Python学习之路"],"title":"Python学习之路-Django基础:请求与响应","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/"},{"categories":["Django"],"content":"混合存储 优先从本机内存中存取，如果没有则从数据库中存取。 SESSION_ENGINE='django.contrib.sessions.backends.cached_db' ","date":"2020-08-08","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/:4:5","tags":["Python学习之路"],"title":"Python学习之路-Django基础:请求与响应","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/"},{"categories":["Django"],"content":"Redis 在redis中保存session，需要引入第三方扩展，我们可以使用django-redis来解决。 安装扩展 pip install django-redis 配置，在settings.py文件中做如下设置 CACHES = { \"default\": { \"BACKEND\": \"django_redis.cache.RedisCache\", \"LOCATION\": \"redis://127.0.0.1:6379/1\", \"OPTIONS\": { \"CLIENT_CLASS\": \"django_redis.client.DefaultClient\", } } } SESSION_ENGINE = \"django.contrib.sessions.backends.cache\" SESSION_CACHE_ALIAS = \"default\" 注意 如果redis的ip地址不是本地回环127.0.0.1，而是其他地址，访问Django时，可能出现Redis连接错误。 解决方法：修改redis的配置文件，添加特定ip地址。 打开redis的配置文件 sudo vim /etc/redis/redis.conf 在如下配置项进行修改（如要添加192.168.1.1地址） 重新启动redis服务 sudo service redis-server restart ","date":"2020-08-08","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/:4:6","tags":["Python学习之路"],"title":"Python学习之路-Django基础:请求与响应","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/"},{"categories":["Django"],"content":"操作 通过HttpRequest对象的session属性进行会话的读写操作。 以键值对的格式写session。 request.session['键']=值 根据键读取值。 request.session.get('键',默认值) 清除所有session，在存储中删除值部分。 request.session.clear() 清除session数据，在存储中删除session的整条数据。 request.session.flush() 删除session中的指定键及值，在存储中只删除某个键及对应的值。 del request.session['键'] 设置session的有效期 request.session.set_expiry(value) 如果value是一个整数，session将在value秒没有活动后过期。 如果value为0，那么用户session的Cookie将在用户的浏览器关闭时过期。 如果value为None，那么session有效期将采用系统默认值，默认为两周，可以通过在settings.py中设置SESSION_COOKIE_AGE来设置全局默认值。 ","date":"2020-08-08","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/:4:7","tags":["Python学习之路"],"title":"Python学习之路-Django基础:请求与响应","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/"},{"categories":["Django"],"content":"配置文件 ","date":"2020-08-01","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E4%B8%8E%E8%B7%AF%E7%94%B1/:1:0","tags":["Python学习之路"],"title":"Python学习之路-Django基础:配置、静态文件与路由","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E4%B8%8E%E8%B7%AF%E7%94%B1/"},{"categories":["Django"],"content":"BASE_DIR BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) 当前工程的根目录，Django会依此来定位工程内的相关文件，我们也可以使用该参数来构造文件路径。 ","date":"2020-08-01","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E4%B8%8E%E8%B7%AF%E7%94%B1/:1:1","tags":["Python学习之路"],"title":"Python学习之路-Django基础:配置、静态文件与路由","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E4%B8%8E%E8%B7%AF%E7%94%B1/"},{"categories":["Django"],"content":"DEBUG 调试模式，创建工程后初始值为True，即默认工作在调试模式下。 作用： 修改代码文件，程序自动重启 Django程序出现异常时，向前端显示详细的错误追踪信息，例如 而非调试模式下，仅返回Server Error (500) 注意：部署线上运行的Django不要运行在调式模式下，记得修改DEBUG=False。 ","date":"2020-08-01","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E4%B8%8E%E8%B7%AF%E7%94%B1/:1:2","tags":["Python学习之路"],"title":"Python学习之路-Django基础:配置、静态文件与路由","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E4%B8%8E%E8%B7%AF%E7%94%B1/"},{"categories":["Django"],"content":"本地语言与时区 Django支持本地化处理，即显示语言与时区支持本地化。 本地化是将显示的语言、时间等使用本地的习惯，这里的本地化就是进行中国化，中国大陆地区使用简体中文，时区使用亚洲/上海时区，注意这里不使用北京时区表示。 初始化的工程默认语言和时区为英语和UTC标准时区 LANGUAGE_CODE = 'en-us' # 语言 TIME_ZONE = 'UTC' # 时区 将语言和时区修改为中国大陆信息 LANGUAGE_CODE = 'zh-hans' TIME_ZONE = 'Asia/Shanghai' ","date":"2020-08-01","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E4%B8%8E%E8%B7%AF%E7%94%B1/:1:3","tags":["Python学习之路"],"title":"Python学习之路-Django基础:配置、静态文件与路由","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E4%B8%8E%E8%B7%AF%E7%94%B1/"},{"categories":["Django"],"content":"静态文件 ","date":"2020-08-01","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E4%B8%8E%E8%B7%AF%E7%94%B1/:2:0","tags":["Python学习之路"],"title":"Python学习之路-Django基础:配置、静态文件与路由","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E4%B8%8E%E8%B7%AF%E7%94%B1/"},{"categories":["Django"],"content":"简介 项目中的CSS、图片、js都是静态文件。一般会将静态文件放到一个单独的目录中，以方便管理。在html页面中调用时，也需要指定静态文件的路径，Django中提供了一种解析的方式配置静态文件路径。静态文件可以放在项目根目录下，也可以放在应用的目录下，由于有些静态文件在项目中是通用的，所以推荐放在项目的根目录下，方便管理。 为了提供静态文件，需要配置两个参数： STATICFILES_DIRS 存放查找静态文件的目录 STATIC_URL 访问静态文件的URL前缀 ","date":"2020-08-01","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E4%B8%8E%E8%B7%AF%E7%94%B1/:2:1","tags":["Python学习之路"],"title":"Python学习之路-Django基础:配置、静态文件与路由","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E4%B8%8E%E8%B7%AF%E7%94%B1/"},{"categories":["Django"],"content":"示例 在项目根目录下创建static_files目录来保存静态文件。在demo/settings.py中修改静态文件的两个参数为 STATIC_URL = '/static/' STATICFILES_DIRS = [ os.path.join(BASE_DIR, 'static_files'), ] 此时在static_files添加的任何静态文件都可以使用网址 /static/文件在static_files中的路径 来访问了。 例如，我们向static_files目录中添加一个index.html文件，在浏览器中就可以使用127.0.0.1:8000/static/index.html来访问。 或者我们在static_files目录中添加了一个子目录和文件goods/detail.html，在浏览器中就可以使用127.0.0.1:8000/static/goods/detail.html来访问。 注意 Django 仅在调试模式下（DEBUG=True）能对外提供静态文件。 当DEBUG=False工作在生产模式时，Django不再对外提供静态文件，需要是用collectstatic命令来收集静态文件并交由其他静态文件服务器来提供。（详细在部署时会讲） ","date":"2020-08-01","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E4%B8%8E%E8%B7%AF%E7%94%B1/:2:2","tags":["Python学习之路"],"title":"Python学习之路-Django基础:配置、静态文件与路由","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E4%B8%8E%E8%B7%AF%E7%94%B1/"},{"categories":["Django"],"content":"路由说明 ","date":"2020-08-01","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E4%B8%8E%E8%B7%AF%E7%94%B1/:3:0","tags":["Python学习之路"],"title":"Python学习之路-Django基础:配置、静态文件与路由","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E4%B8%8E%E8%B7%AF%E7%94%B1/"},{"categories":["Django"],"content":"定义位置 Django的主要路由信息定义在工程同名目录下的urls.py文件中，该文件是Django解析路由的入口。 每个子应用为了保持相对独立，可以在各个子应用中定义属于自己的urls.py来保存该应用的路由。然后用主路由文件包含各应用的子路由数据。 除了上述方式外，也可将工程的全部路由信息都定义在主路由文件中，子应用不再设置urls.py。如： from django.conf.urls import url from django.contrib import admin import users.views urlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^users/index/$', users.views.index) ] ","date":"2020-08-01","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E4%B8%8E%E8%B7%AF%E7%94%B1/:3:1","tags":["Python学习之路"],"title":"Python学习之路-Django基础:配置、静态文件与路由","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E4%B8%8E%E8%B7%AF%E7%94%B1/"},{"categories":["Django"],"content":"解析顺序 Django在接收到一个请求时，从主路由文件中的urlpatterns列表中以由上至下的顺序查找对应路由规则，如果发现规则为include包含，则再进入被包含的urls中的urlpatterns列表由上至下进行查询。 值得关注的由上至下的顺序，有可能会使上面的路由屏蔽掉下面的路由，带来非预期结果。例如： urlpatterns = [ url(r'^say', views.say), url(r'^sayhello', views.sayhello), ] 即使访问sayhello/路径，预期应该进入sayhello视图执行，但实际优先查找到了say路由规则也与sayhello/路径匹配，实际进入了say视图执行。 提示 需要注意定义路由的顺序，避免出现屏蔽效应。 ","date":"2020-08-01","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E4%B8%8E%E8%B7%AF%E7%94%B1/:3:2","tags":["Python学习之路"],"title":"Python学习之路-Django基础:配置、静态文件与路由","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E4%B8%8E%E8%B7%AF%E7%94%B1/"},{"categories":["Django"],"content":"路由命名 在定义路由的时候，可以为路由命名，方便查找特定视图的具体路径信息。 在使用include函数定义路由时，可以使用namespace参数定义路由的命名空间，如 url(r'^users/', include('users.urls', namespace='users')), 命名空间表示，凡是users.urls中定义的路由，均属于namespace指明的users名下。 命名空间的作用：避免不同应用中的路由使用了相同的名字发生冲突，使用命名空间区别开。 在定义普通路由时，可以使用name参数指明路由的名字，如 urlpatterns = [ url(r'^index/$', views.index, name='index'), url(r'^say', views.say, name='say'), ] ","date":"2020-08-01","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E4%B8%8E%E8%B7%AF%E7%94%B1/:3:3","tags":["Python学习之路"],"title":"Python学习之路-Django基础:配置、静态文件与路由","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E4%B8%8E%E8%B7%AF%E7%94%B1/"},{"categories":["Django"],"content":"reverse反解析 使用reverse函数，可以根据路由名称，返回具体的路径，如： from django.urls import reverse # 注意导包路径 def index(request): return HttpResponse(\"hello the world!\") def say(request): url = reverse('users:index') # 返回 /users/index/ print(url) return HttpResponse('say') 对于未指明namespace的，reverse(路由name)；对于指明namespace的，reverse(命名空间namespace:路由name) ","date":"2020-08-01","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E4%B8%8E%E8%B7%AF%E7%94%B1/:3:4","tags":["Python学习之路"],"title":"Python学习之路-Django基础:配置、静态文件与路由","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E4%B8%8E%E8%B7%AF%E7%94%B1/"},{"categories":["Django"],"content":"结尾斜线/的说明 Django中定义路由时，通常以斜线/结尾，其好处是用户访问不以斜线/结尾的相同路径时，Django会把用户重定向到以斜线/结尾的路径上，而不会返回404不存在。如 urlpatterns = [ url(r'^index/$', views.index, name='index'), ] 用户访问 index 或者 index/ 网址，均能访问到index视图。 说明 虽然路由结尾带/能带来上述好处，但是却违背了HTTP中URL表示资源位置路径的设计理念。 是否结尾带/以所属公司定义风格为准。 ","date":"2020-08-01","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E4%B8%8E%E8%B7%AF%E7%94%B1/:3:5","tags":["Python学习之路"],"title":"Python学习之路-Django基础:配置、静态文件与路由","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E4%B8%8E%E8%B7%AF%E7%94%B1/"},{"categories":["Django"],"content":"环境安装 ","date":"2020-07-25","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/:1:0","tags":["Python学习之路"],"title":"Python学习之路-Django基础:工程搭建","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/"},{"categories":["Django"],"content":"创建虚拟环境 mkvirtualenv django_1.11.10 -p python3 ","date":"2020-07-25","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/:1:1","tags":["Python学习之路"],"title":"Python学习之路-Django基础:工程搭建","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/"},{"categories":["Django"],"content":"安装Django 使用Django 1.11.10版本 pip install django==1.11.10 ","date":"2020-07-25","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/:1:2","tags":["Python学习之路"],"title":"Python学习之路-Django基础:工程搭建","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/"},{"categories":["Django"],"content":"创建工程 在使用Flask框架时，项目工程目录的组织与创建是需要我们自己手动创建完成的。在django中，项目工程目录可以借助django提供的命令帮助我们创建。 ","date":"2020-07-25","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/:2:0","tags":["Python学习之路"],"title":"Python学习之路-Django基础:工程搭建","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/"},{"categories":["Django"],"content":"创建 创建工程的命令为： django-admin startproject 工程名称 例如：想要在桌面的DjangoProject目录中创建一个名为demo的项目工程，可执行如下命令： cd ~/Desktop/DjangoProject django-admin startproject demo 执行后，会多出一个新目录名为demo，此即为新创建的工程目录。 ","date":"2020-07-25","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/:2:1","tags":["Python学习之路"],"title":"Python学习之路-Django基础:工程搭建","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/"},{"categories":["Django"],"content":"工程目录说明 查看创建的工程目录 与项目同名的目录，此处为demo。 settings.py 是项目的整体配置文件。 urls.py 是项目的URL配置文件。 wsgi.py 是项目与WSGI兼容的Web服务器入口。 manage.py 是项目管理文件，通过它管理项目。 ","date":"2020-07-25","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/:2:2","tags":["Python学习之路"],"title":"Python学习之路-Django基础:工程搭建","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/"},{"categories":["Django"],"content":"运行开发服务器 在开发阶段，为了能够快速预览到开发的效果，django提供了一个纯python编写的轻量级web服务器，仅在开发阶段使用。运行服务器命令如下： python manage.py runserver ip:端口 或： python manage.py runserver 可以不写IP和端口，默认IP是127.0.0.1，默认端口为8000。 在浏览器中输入网址“127.0.0.1:8000”便可看到效果。 提示 django默认工作在调式Debug模式下，如果增加、修改、删除文件，服务器会自动重启。按ctrl+c停止服务器。 ","date":"2020-07-25","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/:2:3","tags":["Python学习之路"],"title":"Python学习之路-Django基础:工程搭建","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/"},{"categories":["Django"],"content":"创建子应用 在Web应用中，通常有一些业务功能模块是在不同的项目中都可以复用的，故在开发中通常将工程项目拆分为不同的子功能模块，各功能模块间可以保持相对的独立，在其他工程项目中需要用到某个特定功能模块时，可以将该模块代码整体复制过去，达到复用。 在Flask框架中也有类似子功能应用模块的概念，即蓝图Blueprint。 Django的视图编写是放在子应用中的。 ","date":"2020-07-25","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/:3:0","tags":["Python学习之路"],"title":"Python学习之路-Django基础:工程搭建","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/"},{"categories":["Django"],"content":"创建 在django中，创建子应用模块目录仍然可以通过命令来操作，即： python manage.py startapp 子应用名称 manage.py 为上述创建工程时自动生成的管理文件。 例如，在刚才创建的demo工程中，想要创建一个用户users子应用模块，可执行： cd ~/Desktop/code/demo python manage.py startapp users 执行后，可以看到工程目录中多出了一个名为users的子目录。 ","date":"2020-07-25","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/:3:1","tags":["Python学习之路"],"title":"Python学习之路-Django基础:工程搭建","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/"},{"categories":["Django"],"content":"子应用目录说明 查看此时的工程目录，结构如下： admin.py 文件跟网站的后台管理站点配置相关。 apps.py 文件用于配置当前子应用的相关信息。 migrations 目录用于存放数据库迁移历史文件。 models.py 文件用户保存数据库模型类。 tests.py 文件用于开发测试用例，编写单元测试。 views.py 文件用于编写Web应用视图。 ","date":"2020-07-25","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/:3:2","tags":["Python学习之路"],"title":"Python学习之路-Django基础:工程搭建","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/"},{"categories":["Django"],"content":"注册安装子应用 创建出来的子应用目录文件虽然被放到了工程项目目录中，但是django工程并不能立即直接使用该子应用，需要注册安装后才能使用。 在工程配置文件settings.py中，INSTALLED_APPS项保存了工程中已经注册安装的子应用，初始工程中的INSTALLED_APPS如下： 注册安装一个子应用的方法，即是将子应用的配置信息文件apps.py中的Config类添加到INSTALLED_APPS列表中。 例如，将刚创建的users子应用添加到工程中，可在INSTALLED_APPS列表中添加**‘users.apps.UsersConfig’**。 ","date":"2020-07-25","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/:3:3","tags":["Python学习之路"],"title":"Python学习之路-Django基础:工程搭建","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/"},{"categories":["Django"],"content":"创建视图 同Flask框架一样，Django也用视图来编写Web应用的业务逻辑。Django的视图是定义在子应用的views.py中的。 ","date":"2020-07-25","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/:4:0","tags":["Python学习之路"],"title":"Python学习之路-Django基础:工程搭建","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/"},{"categories":["Django"],"content":"创建 打开刚创建的users模块，在views.py中编写视图代码。 from django.http import HttpResponse def index(request): \"\"\" index视图 :param request: 包含了请求信息的请求对象 :return: 响应对象 \"\"\" return HttpResponse(\"Hello Django\") 说明 视图函数的第一个传入参数必须定义，用于接收Django构造的包含了请求数据的HttpReqeust对象，通常名为request。视图函数的返回值必须为一个响应对象，不能像Flask一样直接返回一个字符串，可以将要返回的字符串数据放到一个HTTPResponse对象中。 ","date":"2020-07-25","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/:4:1","tags":["Python学习之路"],"title":"Python学习之路-Django基础:工程搭建","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/"},{"categories":["Django"],"content":"定义路由URL 在子应用中新建一个urls.py文件用于保存该应用的路由。 在users/urls.py文件中定义路由信息。 from django.conf.urls import url from . import views # urlpatterns是被django自动识别的路由列表变量 urlpatterns = [ # 每个路由信息都需要使用url函数来构造 # url(路径, 视图) url(r'^index/$', views.index), ] 在工程总路由demo/urls.py中添加子应用的路由数据。 from django.conf.urls import url, include from django.contrib import admin urlpatterns = [ url(r'^admin/', admin.site.urls), # django默认包含的 # 添加 url(r'^users/', include('users.urls')), ] 使用include来将子应用users里的全部路由包含进工程路由中；r'^users/' 决定了users子应用的所有路由都已**/users/**开头，如我们刚定义的视图index，其最终的完整访问路径为**/users/index/**。 include函数除了可以传递字符串之外，也可以直接传递应用的urls模块，如 from django.conf.urls import url, include from django.contrib import admin import users.urls # 先导入应用的urls模块 urlpatterns = [ url(r'^admin/', admin.site.urls), # url(r'^users/', include('users.urls')), url(r'^users/', include(users.urls)), # 添加应用的路由 ] 启动运行 重新启动django程序 python manage.py runserver 在浏览器中输入网址127.0.0.1:8000/users/index/ 可看到返回的信息 ","date":"2020-07-25","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/:4:2","tags":["Python学习之路"],"title":"Python学习之路-Django基础:工程搭建","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/"},{"categories":["Django"],"content":"简介 Django，发音为[`dʒæŋɡəʊ]，是用python语言写的开源web开发框架，并遵循MVC设计。劳伦斯出版集团为了开发以新闻内容为主的网站，而开发出来了这个框架，于2005年7月在BSD许可证下发布。这个名称来源于比利时的爵士音乐家DjangoReinhardt，他是一个吉普赛人，主要以演奏吉它为主，还演奏过小提琴等。由于Django在近年来的迅速发展，应用越来越广泛，被著名IT开发杂志SDTimes评选为2013SDTimes100，位列\"API、库和框架\"分类第6位，被认为是该领域的佼佼者。 Django的主要目的是简便、快速的开发数据库驱动的网站。它强调代码复用，多个组件可以很方便的以\"插件\"形式服务于整个框架，Django有许多功能强大的第三方插件，你甚至可以很方便的开发出自己的工具包。这使得Django具有很强的可扩展性。它还强调快速开发和DRY(DoNotRepeatYourself)原则。 ","date":"2020-07-18","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellodjango/:1:0","tags":["Python学习之路"],"title":"Python学习之路-Django基础:HelloDjango","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellodjango/"},{"categories":["Django"],"content":"特点 ","date":"2020-07-18","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellodjango/:2:0","tags":["Python学习之路"],"title":"Python学习之路-Django基础:HelloDjango","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellodjango/"},{"categories":["Django"],"content":"重量级框架 对比Flask框架，Django原生提供了众多的功能组件，让开发更简便快速。 提供项目工程管理的自动化脚本工具 数据库ORM支持（对象关系映射，英语：Object Relational Mapping） 模板 表单 Admin管理站点 文件管理 认证权限 session机制 缓存 ","date":"2020-07-18","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellodjango/:2:1","tags":["Python学习之路"],"title":"Python学习之路-Django基础:HelloDjango","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellodjango/"},{"categories":["Django"],"content":"MVT模式 有一种程序设计模式叫MVC，其核心思想是分工、解耦，让不同的代码块之间降低耦合，增强代码的可扩展性和可移植性，实现向后兼容。 提示 MVC的全拼为Model-View-Controller，最早由TrygveReenskaug在1978年提出，是施乐帕罗奥多研究中心(Xerox PARC)在20世纪80年代为程序语言Smalltalk发明的一种软件设计模式，是为了将传统的输入（input）、处理（processing）、输出（output）任务运用到图形化用户交互模型中而设计的。随着标准输入输出设备的出现，开发人员只需要将精力集中在业务逻辑的分析与实现上。后来被推荐为Oracle旗下Sun公司Java EE平台的设计模式，并且受到越来越多的使用ColdFusion和PHP的开发者的欢迎。现在虽然不再使用原来的分工方式，但是这种分工的思想被沿用下来，广泛应用于软件工程中，是一种典型并且应用广泛的软件架构模式。后来，MVC的思想被应用在了Ｗeb开发方面，被称为Ｗeb MVC框架。 MVC模式说明 M全拼为Model，主要封装对数据库层的访问，对数据库中的数据进行增、删、改、查操作。 V全拼为View，用于封装结果，生成页面展示的html内容。 C全拼为Controller，用于接收请求，处理业务逻辑，与Model和View交互，返回结果。 Django的MVT M全拼为Model，与MVC中的M功能相同，负责和数据库交互，进行数据处理。 V全拼为View，与MVC中的C功能相同，接收请求，进行业务处理，返回应答。 T全拼为Template，与MVC中的V功能相同，负责封装构造要返回的html。 注：差异就在于黑线黑箭头标识出来的部分 ","date":"2020-07-18","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellodjango/:2:2","tags":["Python学习之路"],"title":"Python学习之路-Django基础:HelloDjango","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellodjango/"},{"categories":["Web"],"content":"Python Web 框架要点 ","date":"2020-07-11","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-pythonweb/:1:0","tags":["Python学习之路"],"title":"Python学习之路-Django基础:PythonWeb","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-pythonweb/"},{"categories":["Web"],"content":"处理流程 图片来源于未来的小牛的CSDN博客 ","date":"2020-07-11","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-pythonweb/:1:1","tags":["Python学习之路"],"title":"Python学习之路-Django基础:PythonWeb","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-pythonweb/"},{"categories":["Web"],"content":"意义 用于搭建Web应用程序，免去不同Web应用相同代码部分的重复编写，只需关心Web应用核心的业务逻辑实现 ","date":"2020-07-11","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-pythonweb/:1:2","tags":["Python学习之路"],"title":"Python学习之路-Django基础:PythonWeb","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-pythonweb/"},{"categories":["Web"],"content":"Web应用程序的本质 接收并解析HTTP请求，获取具体的请求信息，处理本次HTTP请求，即完成本次请求的业务逻辑处理，构造并返回处理结果——HTTP响应。 ","date":"2020-07-11","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-pythonweb/:1:3","tags":["Python学习之路"],"title":"Python学习之路-Django基础:PythonWeb","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-pythonweb/"},{"categories":["Web"],"content":"Web框架学习方法 如何搭建工程程序 工程的组建 工程的配置 路由定义 视图函数定义 如何获取请求数据（操作request对象） 如何构造响应数据（构造response对象） 如何使用中间层 框架提供的其他功能组件的使用 数据库 模板 admin ","date":"2020-07-11","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-pythonweb/:1:4","tags":["Python学习之路"],"title":"Python学习之路-Django基础:PythonWeb","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-pythonweb/"},{"categories":["Flask"],"content":"部署环境 基于MacOS 10.15.4系统，使用 Gunicorn + Nginx 进行布署，云服务器为阿里云 ","date":"2020-07-04","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/:1:0","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:项目部署","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/"},{"categories":["Flask"],"content":"服务器选择 ","date":"2020-07-04","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/:2:0","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:项目部署","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/"},{"categories":["Flask"],"content":"阿里云服务器 地址 个人免费试用 进入控制台,查看实例创建情况 给安全组配置规则，添加5000端口(一并加上5001端口) 利用命令行进行远程服务器登录 ssh 用户名@ip地址 ","date":"2020-07-04","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/:2:1","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:项目部署","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/"},{"categories":["Flask"],"content":"相关环境安装 以下操作都在远程服务器上进行操作 先更新 apt 相关源 sudo apt-get update mysql安装 apt-get install mysql-server apt-get install libmysqlclient-dev redis安装 sudo apt-get install redis-server 安装虚拟环境 pip install virtualenv pip install virtualenvwrapper 使得安装的virtualenvwrapper生效，编辑~/.bashrc文件，内容如下: export WORKON_HOME=$HOME/.virtualenvs export PROJECT_HOME=$HOME/workspace source /usr/local/bin/virtualenvwrapper.sh 使编辑后的文件生效 source ~/.bashrc ","date":"2020-07-04","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/:3:0","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:项目部署","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/"},{"categories":["Flask"],"content":"requirements文件 Python 项目中可以包含一个 requirements.txt 文件，用于记录所有依赖包及其精确的版本号，以便在新环境中进行部署操作。 在虚拟环境使用以下命令将当前虚拟环境中的依赖包以版本号生成至文件中： pip freeze \u003e requirements.txt 当需要创建这个虚拟环境的完全副本，可以创建一个新的虚拟环境，并在其上运行以下命令： pip install -r requirements.txt 在安装 Flask-MySQLdb 的时候可能会报错，可能是依赖包没有安装，执行以下命令安装依赖包： sudo apt-get build-dep python-mysqldb ","date":"2020-07-04","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/:4:0","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:项目部署","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/"},{"categories":["Flask"],"content":"Nginx 采用 C 语言编写 实现分流、转发、负载均衡 ","date":"2020-07-04","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/:5:0","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:项目部署","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/"},{"categories":["Flask"],"content":"相关操作 安装 $ sudo apt-get install nginx 运行及停止 /etc/init.d/nginx start #启动 /etc/init.d/nginx stop #停止 配置文件 编辑文件:/etc/nginx/sites-available/default # 如果是多台服务器的话，则在此配置，并修改 location 节点下面的 proxy_pass upstream flask { server 127.0.0.1:5000; server 127.0.0.1:5001; } server { # 监听80端口 listen 80 default_server; listen [::]:80 default_server; root /var/www/html; index index.html index.htm index.nginx-debian.html; server_name _; location / { # 请求转发到gunicorn服务器 proxy_pass http://127.0.0.1:5000; # 请求转发到多个gunicorn服务器 # proxy_pass http://flask; # 设置请求头，并将头信息传递给服务器端 proxy_set_header Host $host; # 设置请求头，传递原始请求ip给 gunicorn 服务器 proxy_set_header X-Real-IP $remote_addr; } } ","date":"2020-07-04","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/:5:1","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:项目部署","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/"},{"categories":["Flask"],"content":"Gunicorn Gunicorn（绿色独角兽）是一个Python WSGI的HTTP服务器 从Ruby的独角兽（Unicorn ）项目移植 该Gunicorn服务器与各种Web框架兼容，实现非常简单，轻量级的资源消耗 Gunicorn直接用命令启动，不需要编写配置文件 ","date":"2020-07-04","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/:6:0","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:项目部署","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/"},{"categories":["Flask"],"content":"相关操作 安装 pip install gunicorn 查看选项 gunicorn -h 运行 # -w: 表示进程（worker） -b：表示绑定ip地址和端口号（bind） gunicorn -w 2 -b 127.0.0.1:5000 运行文件名称:Flask程序实例名 参考阅读： Gunicorn相关配置：https://blog.csdn.net/y472360651/article/details/78538188 ","date":"2020-07-04","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/:6:1","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:项目部署","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/"},{"categories":["Flask"],"content":"其他操作 拷贝本地代码到远程 scp -r 本地文件路径 root@39.106.21.198:远程保存路径 ","date":"2020-07-04","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/:7:0","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:项目部署","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/"},{"categories":["Flask"],"content":"前言 上一篇完成了博客前台的相关内容，接下来进行博客后台的相关开发。 ","date":"2020-06-27","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%8F%B0/:1:0","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:博客后台","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%8F%B0/"},{"categories":["Flask"],"content":"管理员登录 ","date":"2020-06-27","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%8F%B0/:2:0","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:博客后台","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%8F%B0/"},{"categories":["Flask"],"content":"需求分析 管理员用户进行登录，并且根据不同的情况报出不同的错误信息，如果当前已登录用户是管理员，在访问登录页面时直接跳转到后台管理主页。登录界面可以直接使用 Form 表单提交(也可以采用 ajax 的方式) ","date":"2020-06-27","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%8F%B0/:2:1","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:博客后台","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%8F%B0/"},{"categories":["Flask"],"content":"代码准备 在 templates 目录下创建 admin 文件夹，将 static/admin/目录下 login.html 与 index.html 拖动到 admin 目录下 ","date":"2020-06-27","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%8F%B0/:2:2","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:博客后台","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%8F%B0/"},{"categories":["Flask"],"content":"代码实现 在 admin/views.py 中，添加登录视图函数 @admin_blu.route('/login') def admin_login(): return render_template('admin/login.html') 访问测试 修改上一步视图函数，添加 post 请求方式，并添加登录相关逻辑 @admin_blu.route('/login', methods=[\"GET\", \"POST\"]) def admin_login(): if request.method == \"GET\": return render_template('admin/login.html') # 取到登录的参数 username = request.form.get(\"username\") password = request.form.get(\"password\") if not all([username, password]): return render_template('admin/login.html', errmsg=\"参数不足\") try: user = User.query.filter(User.mobile == username).first() except Exception as e: current_app.logger.error(e) return render_template('admin/login.html', errmsg=\"数据查询失败\") if not user: return render_template('admin/login.html', errmsg=\"用户不存在\") if not user.check_passowrd(password): return render_template('admin/login.html', errmsg=\"密码错误\") if not user.is_admin: return render_template('admin/login.html', errmsg=\"用户权限错误\") session[\"user_id\"] = user.id session[\"nick_name\"] = user.nick_name session[\"mobile\"] = user.mobile session[\"is_admin\"] = True # TODO 跳转到后台管理主页,暂未实现 return \"登录成功，需要跳转到主页\" ","date":"2020-06-27","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%8F%B0/:2:3","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:博客后台","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%8F%B0/"},{"categories":["Flask"],"content":"管理后台主页 ","date":"2020-06-27","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%8F%B0/:3:0","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:博客后台","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%8F%B0/"},{"categories":["Flask"],"content":"需求分析 为后台主页提供专门的视图函数，需要带入当前管理员用户相关信息以便在界面进行展示 ","date":"2020-06-27","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%8F%B0/:3:1","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:博客后台","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%8F%B0/"},{"categories":["Flask"],"content":"代码实现 在 modules/admin/views.py 文件中添加视图函数 @admin_blu.route('/index') @user_login_data def admin_index(): user = g.user return render_template('admin/index.html', user=user.to_dict()) 访问测试 完善登录视图函数跳转界面逻辑 @admin_blu.route('/login', methods=[\"GET\", \"POST\"]) def admin_login(): ... # 跳转到后台管理主页 return redirect(url_for('admin.admin_index')) 完善如果已登录的管理员用户访问登录页面直接跳转到主页逻辑 def admin_login(): if request.method == \"GET\": # 去 session 中取指定的值 user_id = session.get(\"user_id\", None) is_admin = session.get(\"is_admin\", False) # 如果用户id存在，并且是管理员，那么直接跳转管理后台主页 if user_id and is_admin: return redirect(url_for('admin.admin_index')) return render_template('admin/login.html') ... ","date":"2020-06-27","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%8F%B0/:3:2","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:博客后台","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%8F%B0/"},{"categories":["Flask"],"content":"后台访问权限控制 ","date":"2020-06-27","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%8F%B0/:4:0","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:博客后台","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%8F%B0/"},{"categories":["Flask"],"content":"需求分析 解决普通用户登录之后直接访问后台具体的视图函数的问题，如果是普通用户访问后台的视图函数，直接跳转到项目主页，不再执行后续的逻辑判断，后台后续要实现多个视图函数，如果每一个函数内部都去判断用户权限，那么代码重复率高，冗余代码较多，所以得有一个统一判断入口，后台模块中，除了登录页面，后台的其他页面都要判断是否具有管理员权限，采用的方式为：请求勾子中的 before_request，来请求之前进行判断 ","date":"2020-06-27","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%8F%B0/:4:1","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:博客后台","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%8F%B0/"},{"categories":["Flask"],"content":"代码实现 在 modules/admin/__init__.py 文件中，添加请求勾子函数 @admin_blu.before_request def before_request(): # 判断如果不是登录页面的请求 if not request.url.endswith(url_for(\"admin.admin_login\")): user_id = session.get(\"user_id\") is_admin = session.get(\"is_admin\", False) if not user_id or not is_admin: # 判断当前是否有用户登录，或者是否是管理员，如果不是，直接重定向到项目主页 return redirect('/') 完善退出登录相关代码，在退出登录时候，也要清空是否是管理员的相关数据，在 modules/passport/views.py 中 @passport_blu.route(\"/logout\", methods=['POST']) def logout(): \"\"\" 清除session中的对应登录之后保存的信息 :return: \"\"\" session.pop('user_id', None) session.pop('nick_name', None) session.pop('mobile', None) session.pop('is_admin', None) # 返回结果 return jsonify(errno=RET.OK, errmsg=\"OK\") ","date":"2020-06-27","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%8F%B0/:4:2","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:博客后台","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%8F%B0/"},{"categories":["Flask"],"content":"用户统计 ","date":"2020-06-27","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%8F%B0/:5:0","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:博客后台","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%8F%B0/"},{"categories":["Flask"],"content":"需求分析 展示当前总人数，月活跃人数，日活跃人数，使用图表的形式展示活跃曲线 ","date":"2020-06-27","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%8F%B0/:5:1","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:博客后台","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%8F%B0/"},{"categories":["Flask"],"content":"实现准备 将 static/admin/user_count.html 拖到 templates/admin/ 目录下 ","date":"2020-06-27","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%8F%B0/:5:2","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:博客后台","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%8F%B0/"},{"categories":["Flask"],"content":"代码实现 实现思路： 月新增数：获取到本月第1天0点0分0秒的时间对象，然后查询最后一次登录比其大的所有数据 日新增数：获取到当日0点0分0秒时间对象，然后查询最后一次登录比其大的所有数据 图表查询：遍历查询数据每一天的数据(当前天数，减去某些天) 后端查询数据实现 @admin_blu.route('/user_count') def user_count(): # 查询总人数 total_count = 0 try: total_count = User.query.filter(User.is_admin == False).count() except Exception as e: current_app.logger.error(e) # 查询月新增数 mon_count = 0 try: now = time.localtime() mon_begin = '%d-%02d-01' % (now.tm_year, now.tm_mon) mon_begin_date = datetime.strptime(mon_begin, '%Y-%m-%d') mon_count = User.query.filter(User.is_admin == False, User.create_time \u003e= mon_begin_date).count() except Exception as e: current_app.logger.error(e) # 查询日新增数 day_count = 0 try: day_begin = '%d-%02d-%02d' % (now.tm_year, now.tm_mon, now.tm_mday) day_begin_date = datetime.strptime(day_begin, '%Y-%m-%d') day_count = User.query.filter(User.is_admin == False, User.create_time \u003e day_begin_date).count() except Exception as e: current_app.logger.error(e) # 查询图表信息 # 获取到当天00:00:00时间 now_date = datetime.strptime(datetime.now().strftime('%Y-%m-%d'), '%Y-%m-%d') # 定义空数组，保存数据 active_date = [] active_count = [] # 依次添加数据，再反转 for i in range(0, 31): begin_date = now_date - timedelta(days=i) end_date = now_date - timedelta(days=(i - 1)) active_date.append(begin_date.strftime('%Y-%m-%d')) count = 0 try: count = User.query.filter(User.is_admin == False, User.last_login \u003e= day_begin, User.last_login \u003c day_end).count() except Exception as e: current_app.logger.error(e) active_count.append(count) active_date.reverse() active_count.reverse() data = {\"total_count\": total_count, \"mon_count\": mon_count, \"day_count\": day_count, \"active_date\": active_date, \"active_count\": active_count} return render_template('admin/user_count.html', data=data) ","date":"2020-06-27","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%8F%B0/:5:3","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:博客后台","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%8F%B0/"},{"categories":["Flask"],"content":"用户列表 ","date":"2020-06-27","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%8F%B0/:6:0","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:博客后台","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%8F%B0/"},{"categories":["Flask"],"content":"需求 按用户最后一次登录倒序分页展示用户列表 ","date":"2020-06-27","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%8F%B0/:6:1","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:博客后台","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%8F%B0/"},{"categories":["Flask"],"content":"实现准备 将 static/admin/user_list.html 拖到 templates/admin/ 目录下 ","date":"2020-06-27","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%8F%B0/:6:2","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:博客后台","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%8F%B0/"},{"categories":["Flask"],"content":"代码实现 后端逻辑 @admin_blu.route('/user_list') def user_list(): \"\"\"获取用户列表\"\"\" # 获取参数 page = request.args.get(\"p\", 1) try: page = int(page) except Exception as e: current_app.logger.error(e) page = 1 # 设置变量默认值 users = [] current_page = 1 total_page = 1 # 查询数据 try: paginate = User.query.filter(User.is_admin == False).order_by(User.last_login.desc()).paginate(page, constants.ADMIN_USER_PAGE_MAX_COUNT, False) users = paginate.items current_page = paginate.page total_page = paginate.pages except Exception as e: current_app.logger.error(e) # 将模型列表转成字典列表 users_list = [] for user in users: users_list.append(user.to_admin_dict()) context = {\"total_page\": total_page, \"current_page\": current_page, \"users\": users_list} return render_template('admin/user_list.html', data=context) ","date":"2020-06-27","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%8F%B0/:6:3","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:博客后台","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%8F%B0/"},{"categories":["Flask"],"content":"文章版式编辑 ","date":"2020-06-27","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%8F%B0/:7:0","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:博客后台","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%8F%B0/"},{"categories":["Flask"],"content":"需求分析 以分页的形式按文章创建时间倒序展示出文章数据 可以使用关键这这对文章标题进行搜索 点击编辑进入编辑详情页面 ","date":"2020-06-27","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%8F%B0/:7:1","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:博客后台","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%8F%B0/"},{"categories":["Flask"],"content":"实现准备 将 static/admin/ 目录下的 blog_edit.html 以及 blog_edit_detail.html 拖到 templates/admin/ 目录下 ","date":"2020-06-27","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%8F%B0/:7:2","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:博客后台","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%8F%B0/"},{"categories":["Flask"],"content":"代码实现 在 admin/views.py 文件中添加视图函数以返回文章列表 @admin_blu.route('/blog_edit') def blog_edit(): \"\"\"返回文章列表\"\"\" page = request.args.get(\"p\", 1) keywords = request.args.get(\"keywords\", \"\") try: page = int(page) except Exception as e: current_app.logger.error(e) page = 1 blog_list = [] current_page = 1 total_page = 1 try: filters = [] # 如果有关键词 if keywords: # 添加关键词的检索选项 filters.append(blog.title.contains(keywords)) # 查询 paginate = blog.query.filter(*filters) \\ .order_by(blog.create_time.desc()) \\ .paginate(page, constants.ADMIN_blog_PAGE_MAX_COUNT, False) blog_list = paginate.items current_page = paginate.page total_page = paginate.pages except Exception as e: current_app.logger.error(e) blog_dict_list = [] for blog in blog_list: blog_dict_list.append(blog.to_basic_dict()) context = {\"total_page\": total_page, \"current_page\": current_page, \"blog_list\": blog_dict_list} return render_template('admin/blog_edit.html', data=context) ","date":"2020-06-27","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%8F%B0/:7:3","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:博客后台","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%8F%B0/"},{"categories":["Flask"],"content":"新闻版式编辑详情 ","date":"2020-06-27","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%8F%B0/:8:0","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:博客后台","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%8F%B0/"},{"categories":["Flask"],"content":"编辑详情界面数据 在 admin/views.py 中添加新闻编辑详情视图函数，接收新闻id为参数 @admin_blu.route('/blog_edit_detail') def blog_edit_detail(): \"\"\"新闻编辑详情\"\"\" # 获取参数 blog_id = request.args.get(\"blog_id\") if not blog_id: return render_template('admin/blog_edit_detail.html', data={\"errmsg\": \"未查询到此新闻\"}) # 查询新闻 blog = None try: blog = blog.query.get(blog_id) except Exception as e: current_app.logger.error(e) if not blog: return render_template('admin/blog_edit_detail.html', data={\"errmsg\": \"未查询到此新闻\"}) # 查询分类的数据 categories = Category.query.all() categories_li = [] for category in categories: c_dict = category.to_dict() c_dict[\"is_selected\"] = False if category.id == blog.category_id: c_dict[\"is_selected\"] = True categories_li.append(c_dict) # 移除`最新`分类 categories_li.pop(0) data = {\"blog\": blog.to_dict(), \"categories\": categories_li} return render_template('admin/blog_edit_detail.html', data=data) ","date":"2020-06-27","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%8F%B0/:8:1","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:博客后台","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%8F%B0/"},{"categories":["Flask"],"content":"新闻编辑提交 修改视图函数，使其能够接受POST请求执行保存编辑操作，并实现其代码 @admin_blu.route('/blog_edit_detail', methods=[\"GET\", \"POST\"]) def blog_edit_detail(): \"\"\"新闻编辑详情\"\"\" if request.method == \"GET\": ... return render_template('admin/blog_edit_detail.html', data=data) blog_id = request.form.get(\"blog_id\") title = request.form.get(\"title\") digest = request.form.get(\"digest\") content = request.form.get(\"content\") index_image = request.files.get(\"index_image\") category_id = request.form.get(\"category_id\") # 1.1 判断数据是否有值 if not all([title, digest, content, category_id]): return jsonify(errno=RET.PARAMERR, errmsg=\"参数有误\") blog = None try: blog = blog.query.get(blog_id) except Exception as e: current_app.logger.error(e) if not blog: return jsonify(errno=RET.NODATA, errmsg=\"未查询到新闻数据\") # 1.2 尝试读取图片 if index_image: try: index_image = index_image.read() except Exception as e: current_app.logger.error(e) return jsonify(errno=RET.PARAMERR, errmsg=\"参数有误\") # 2. 将标题图片上传到七牛 try: key = storage(index_image) except Exception as e: current_app.logger.error(e) return jsonify(errno=RET.THIRDERR, errmsg=\"上传图片错误\") blog.index_image_url = constants.QINIU_DOMIN_PREFIX + key # 3. 设置相关数据 blog.title = title blog.digest = digest blog.content = content blog.category_id = category_id # 4. 保存到数据库 try: db.session.commit() except Exception as e: current_app.logger.error(e) db.session.rollback() return jsonify(errno=RET.DBERR, errmsg=\"保存数据失败\") # 5. 返回结果 return jsonify(errno=RET.OK, errmsg=\"编辑成功\") ","date":"2020-06-27","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%8F%B0/:8:2","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:博客后台","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%8F%B0/"},{"categories":["Flask"],"content":"新闻分类管理 ","date":"2020-06-27","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%8F%B0/:9:0","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:博客后台","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%8F%B0/"},{"categories":["Flask"],"content":"需求分析 可以修改当前新闻分类名，可以添加新闻分类 ","date":"2020-06-27","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%8F%B0/:9:1","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:博客后台","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%8F%B0/"},{"categories":["Flask"],"content":"实现准备 将 static/admin/blog_type.html 文件拖到 templates/admin/ 目录下 ","date":"2020-06-27","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%8F%B0/:9:2","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:博客后台","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%8F%B0/"},{"categories":["Flask"],"content":"代码实现 在 admin/views.py 文件中添加视图函数以返回分类列表 @admin_blu.route('/blog_category') def get_blog_category(): # 获取所有的分类数据 categories = Category.query.all() # 定义列表保存分类数据 categories_dicts = [] for category in categories: # 获取字典 cate_dict = category.to_dict() # 拼接内容 categories_dicts.append(cate_dict) categories_dicts.pop(0) # 返回内容 return render_template('admin/blog_type.html', data={\"categories\": categories_dicts}) ","date":"2020-06-27","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%8F%B0/:9:3","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:博客后台","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%8F%B0/"},{"categories":["Flask"],"content":"前言 前一篇完成了项目开发前的所有准备工作，本篇将完成整个博客的前台相关工作。 ","date":"2020-06-20","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%89%8D%E5%8F%B0/:1:0","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:博客前台","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%89%8D%E5%8F%B0/"},{"categories":["Flask"],"content":"首页 ","date":"2020-06-20","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%89%8D%E5%8F%B0/:2:0","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:博客前台","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%89%8D%E5%8F%B0/"},{"categories":["Flask"],"content":"前言 首页主要为我们提供各个分类入口已经按时间顺序的文章列表和列表排行等数据，是进入博客中第一眼看到的，接下来就来实现吧。 ","date":"2020-06-20","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%89%8D%E5%8F%B0/:2:1","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:博客前台","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%89%8D%E5%8F%B0/"},{"categories":["Flask"],"content":"排行展示 前言 在请求根路由时去数据库查询按点击量排行的10条文章 后端实现 @index_blu.route('/') def index(): ... # 获取点击排行数据 blog_list = None try: blog_list = Blog.query.order_by(Blog.clicks.desc()).limit(constants.CLICK_RANK_MAX_BLOG) except Exception as e: current_app.logger.error(e) click_blog_list = [] for blog in blog_list if blog_list else []: click_blog_list.append(blog.to_basic_dict()) data = { \"user_blog\": user.to_dict() if user else None, \"click_blog_list\": click_blog_list, } return render_template('blog/index.html', data=data) ","date":"2020-06-20","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%89%8D%E5%8F%B0/:2:2","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:博客前台","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%89%8D%E5%8F%B0/"},{"categories":["Flask"],"content":"分类展示 前言 分类展示是将博客按我们想要的分类进行分割的一个关键部分，需要我们通过分类将其展示出来。 后端实现 在请求根路由的时候去查询博客分类，并默认设置第1个分类选中 @index_blu.route('/') def index(): ... # 获取博客分类数据 categories = Category.query.all() # 定义列表保存分类数据 categories_dicts = [] for category in enumerate(categories): # 拼接内容 categories_dicts.append(category.to_dict()) data = { \"user_blog\": user.to_dict() if user else None, \"click_blog_list\": click_blog_list, \"categories\": categories_dicts } return render_template('blog/index.html', data=data) ","date":"2020-06-20","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%89%8D%E5%8F%B0/:2:3","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:博客前台","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%89%8D%E5%8F%B0/"},{"categories":["Flask"],"content":"文章列表 前言 文章列表是整个博客最重要的一部分，当我们点击分类时需要去获取当前分类下的文章数据，当我们点击标签时需要去获取当前标签下的文章数据。在展示的时候需要更新文章列表界面，不需要整体页面刷新，所以文章数据也使用 ajax 的方式去请求后台接口进行获取。 接口设计 URL：/blog_list 请求方式：GET 传入参数：JSON格式 参数 参数名 类型 是否必须 参数说明 cid string 是 分类id page int 否 页数，不传即获取第1页 per_page int 否 每页多少条数据，如果不传，默认10条 返回类型：JSON 参数名 类型 是否必须 参数说明 errno int 是 错误码 errmsg string 是 错误信息 cid string 是 当前文章数据的分类id totalPage int 否 总页数 currentPage int 否 当前页数 blogList list 否 列表数据 blogList.title string 是 标题 blogList.source string 是 来源 blogList.digest string 是 摘要 blogList.create_time string 是 时间 blogList.index_image_url string 是 索引图 后端实现 在index/views.py中定义视图函数。在查询的时候，如果用户分类id传0，则不添加分类查询条件 @index_blu.route('/bloglist') def get_blog_list(): \"\"\" 获取指定分类的博客列表 :return: 包含文章列表的jsonify对象 \"\"\" # 1. 获取参数 args_dict = request.args page = args_dict.get(\"p\", '1') per_page = args_dict.get(\"per_page\", constants.HOME_PAGE_MAX_BLOG) category_id = args_dict.get(\"cid\", '1') # 2. 校验参数 try: page = int(page) per_page = int(per_page) except Exception as e: current_app.logger.error(e) return jsonify(errno=RET.PARAMERR, errmsg=\"参数错误\") # 3. 查询数据并分页 filters = [] # 如果分类id不为1，那么添加分类id的过滤 if category_id != \"1\": filters.append(Blog.category_id == category_id) try: paginate = Blog.query.filter(*filters).order_by(Blog.create_time.desc()).paginate(page, per_page, False) # 获取查询出来的数据 items = paginate.items # 获取到总页数 total_page = paginate.pages current_page = paginate.page except Exception as e: current_app.logger.error(e) return jsonify(errno=RET.DBERR, errmsg=\"数据查询失败\") blog_list = [] for blog in items: blog_list.append(blog.to_basic_dict()) # 4. 返回数据 return jsonify(errno=RET.OK, errmsg=\"OK\", totalPage=total_page, currentPage=current_page, blogList=blog_list, cid=category_id) ","date":"2020-06-20","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%89%8D%E5%8F%B0/:2:4","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:博客前台","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%89%8D%E5%8F%B0/"},{"categories":["Flask"],"content":"详情页 ","date":"2020-06-20","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%89%8D%E5%8F%B0/:3:0","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:博客前台","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%89%8D%E5%8F%B0/"},{"categories":["Flask"],"content":"前言 博客详情页是整个博客的精髓所在，我们需要完成：基类模板抽取、使用装饰器的形式完成用户数据的查询并传递到视图函数中、查询博客详情页数据并使用模板语言进行数据的展示、写出文章评论的后端逻辑、写出文章点赞的后端逻辑等功能。 ","date":"2020-06-20","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%89%8D%E5%8F%B0/:3:1","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:博客前台","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%89%8D%E5%8F%B0/"},{"categories":["Flask"],"content":"准备工作 博客详情页面的前端页面为 blog/detail.html，创建博客详情页的模块blog，并在该模块下创建视图函数存储的 py 文件 views.py 创建蓝图 from flask import Blueprint blog_blu = Blueprint(\"blog\", __name__, url_prefix='/blog') from . import views 注册蓝图 def create_app(config_name): ... # 注册蓝图 from blog.modules.index import index_blu app.register_blueprint(index_blu) from blog.modules.passport import passport_blu app.register_blueprint(passport_blu) from blog.modules.blog import blog_blu app.register_blueprint(blog_blu) ... return app 提供文章详情页访问的视图函数，将文章详情页界面移动到模板文件夹，视图函数需要接受文章 id 作为参数，以便后续查询文章详情数据 @blog_blu.route('/\u003cint:blog_id\u003e') def blog_detail(blog_id): return render_template('blog/detail.html') ","date":"2020-06-20","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%89%8D%E5%8F%B0/:3:2","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:博客前台","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%89%8D%E5%8F%B0/"},{"categories":["Flask"],"content":"数据展示 文章内容数据，查询文章数据并返回 @blog_blu.route('/\u003cint:blog_id\u003e') @user_login_data def blog_detail(blog_id): try: blog = blog.query.get(blog_id) except Exception as e: current_app.logger.error(e) abort(404) if not blog: # 返回数据未找到的页面 abort(404) blog.clicks += 1 data = { \"blog\": blog.to_dict(), \"user_blog\": g.user.to_dict() if g.user else None, } return render_template('blog/detail.html', data=data) ","date":"2020-06-20","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%89%8D%E5%8F%B0/:3:3","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:博客前台","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%89%8D%E5%8F%B0/"},{"categories":["Flask"],"content":"文章排行 查询文章点击量数据，并返回 @blog_blu.route('/\u003cint:blog_id\u003e') @user_login_data def blog_detail(blog_id): ... # 获取点击排行数据 blog_list = None try: blog_list = blog.query.order_by(blog.clicks.desc()).limit(constants.CLICK_RANK_MAX_blog) except Exception as e: current_app.logger.error(e) click_blog_list = [] for blog in blog_list if blog_list else []: click_blog_list.append(blog.to_basic_dict()) data = { \"blog\": blog.to_dict(), \"click_blog_list\": click_blog_list, \"user_blog\": g.user.to_dict() if g.user else None, } return render_template('blog/detail.html', data=data)\\ ","date":"2020-06-20","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%89%8D%E5%8F%B0/:3:4","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:博客前台","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%89%8D%E5%8F%B0/"},{"categories":["Flask"],"content":"文章评论 需求分析 用户如果在登录的情况下，可以进行评论，未登录，点击评论弹出登录框。用户可以直接评论当前文章 后端实现 接口设计 URL：/blog/blog_comment 请求方式：POST 传入参数：JSON格式 参数 参数名 类型 是否必须 参数说明 blog_id int 是 文章id comment string 是 评论内容 parent_id int 否 回复的评论的id 返回类型：JSON 参数名 类型 是否必须 参数说明 errno int 是 错误码 errmsg string 是 错误信息 代码实现 在 blog/views.py 文件中添加评论文章的视图函数 @blog_blu.route('/blog_comment', methods=[\"POST\"]) @user_login_data def add_blog_comment(): \"\"\"添加评论\"\"\" user = g.user if not user: return jsonify(errno=RET.SESSIONERR, errmsg=\"用户未登录\") # 获取参数 data_dict = request.json blog_id = data_dict.get(\"blog_id\") comment_str = data_dict.get(\"comment\") parent_id = data_dict.get(\"parent_id\") if not all([blog_id, comment_str]): return jsonify(errno=RET.PARAMERR, errmsg=\"参数不足\") try: blog = blog.query.get(blog_id) except Exception as e: current_app.logger.error(e) return jsonify(errno=RET.DBERR, errmsg=\"查询数据失败\") if not blog: return jsonify(errno=RET.NODATA, errmsg=\"该文章不存在\") # 初始化模型，保存数据 comment = Comment() comment.user_id = user.id comment.blog_id = blog_id comment.content = comment_str if parent_id: comment.parent_id = parent_id # 保存到数据库 try: db.session.add(comment) db.session.commit() except Exception as e: current_app.logger.error(e) return jsonify(errno=RET.DBERR, errmsg=\"保存评论数据失败\") # 返回响应 return jsonify(errno=RET.OK, errmsg=\"评论成功\", data=comment.to_dict()) 文章评论列表 在文章详情的视图函数中，添加查询当前文章评论的逻辑 @blog_blu.route('/\u003cint:blog_id\u003e') @user_login_data def blog_detail(blog_id): ... # 获取当前文章的评论 comments = [] try: comments = Comment.query.filter(Comment.blog_id == blog_id).order_by(Comment.create_time.desc()).all() except Exception as e: current_app.logger.error(e) comment_list = [] for item in comments: comment_dict = item.to_dict() comment_list.append(comment_dict) is_collected = False # 判断用户是否收藏过该文章 if g.user: if blog in g.user.collection_blog: is_collected = True data = { \"blog\": blog.to_dict(), \"click_blog_list\": click_blog_list, \"is_collected\": is_collected, \"user_blog\": g.user.to_dict() if g.user else None, \"comments\": comment_list } return render_template('blog/detail.html', data=data) 评论点赞功能 需求分析 后端提供点赞和取消点赞功能 当用户点击未点赞按钮，执行点赞逻辑，向后端发起点赞请求，取消点赞则反之 在文章显示完成之后，底部评论会根据当前登录用户显示是否点赞图标 接口设计 URL：/blog/comment_like 请求方式：POST 传入参数：JSON格式 参数 参数名 类型 是否必须 参数说明 comment_id int 是 评论id blog_id int 是 文章id action string 是 点赞操作类型：add(点赞)，remove(取消点赞) 返回类型：JSON 参数名 类型 是否必须 参数说明 errno int 是 错误码 errmsg string 是 错误信息 后端代码实现 在 blog/views.py 中添加点赞/取消点赞视图函数 @blog_blu.route('/comment_like', methods=[\"POST\"]) @user_login_data def set_comment_like(): \"\"\"评论点赞\"\"\" if not g.user: return jsonify(errno=RET.SESSIONERR, errmsg=\"用户未登录\") # 获取参数 comment_id = request.json.get(\"comment_id\") blog_id = request.json.get(\"blog_id\") action = request.json.get(\"action\") # 判断参数 if not all([comment_id, blog_id, action]): return jsonify(errno=RET.PARAMERR, errmsg=\"参数错误\") if action not in (\"add\", \"remove\"): return jsonify(errno=RET.PARAMERR, errmsg=\"参数错误\") # 查询评论数据 try: comment = Comment.query.get(comment_id) except Exception as e: current_app.logger.error(e) return jsonify(errno=RET.DBERR, errmsg=\"查询数据失败\") if not comment: return jsonify(errno=RET.NODATA, errmsg=\"评论数据不存在\") if action == \"add\": comment_like = CommentLike.query.filter_by(comment_id=comment_id, user_id=g.user.id).first() if not comment_like: comment_like = CommentLike() comment_like.comment_id = comment_id comment_like.user_id = g.user.id db.session.add(comment_like) # 增加点赞条数 comment.like_count += 1 else: # 删除点赞数据 comment_like = CommentLike.query.filter_by(comment_id=comment_id, user_id=g.user.id).first() if comment_like: db.session.delete(comment_like) # 减小点赞条数 comment.like_count -= 1 try: db.session.commit() except Exception as e: current_app.logger.error(e) db.session.rollback() return jsonify(errno=RET.DBERR, errmsg=\"操作失败\") return jsonify(errno=RET.OK, errmsg=\"操作成功\") ","date":"2020-06-20","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%89%8D%E5%8F%B0/:3:5","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:博客前台","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%89%8D%E5%8F%B0/"},{"categories":["Flask"],"content":"404 页面 ","date":"2020-06-20","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%89%8D%E5%8F%B0/:4:0","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:博客前台","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%89%8D%E5%8F%B0/"},{"categories":["Flask"],"content":"需求 在用户访问一些不存在网址的时候弹出404页面 ","date":"2020-06-20","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%89%8D%E5%8F%B0/:4:1","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:博客前台","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%89%8D%E5%8F%B0/"},{"categories":["Flask"],"content":"实现逻辑 可以使用 app.errorhandle(code_or_exception) 装饰器 ","date":"2020-06-20","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%89%8D%E5%8F%B0/:4:2","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:博客前台","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%89%8D%E5%8F%B0/"},{"categories":["Flask"],"content":"代码实现 将 static/blog/404.html 文件拖到 templates/blog/ 目录下，并继承于基类模板 在 blog/__init__.py 文件中的 create_app 函数中添加以下逻辑 def create_app(config_name): ... @app.errorhandler(404) @user_login_data def page_not_found(_): user = g.user data = {\"user_blog\": user.to_dict() if user else None} return render_template('blog/404.html', data=data) return app 在浏览器里面输入网址进行测试 ","date":"2020-06-20","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%89%8D%E5%8F%B0/:4:3","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:博客前台","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%8D%9A%E5%AE%A2%E5%89%8D%E5%8F%B0/"},{"categories":["Flask"],"content":"前言 前面几篇学习了Flask的基础知识，从今天开始开发一个个人博客项目来练练手。 ","date":"2020-06-13","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/:1:0","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:开发准备","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/"},{"categories":["Flask"],"content":"项目分析 关于个人博客的Web项目，主要为自己提供一个记录与技术输出的平台。 以个人编写或者转载优秀的文章作为博文的主要来源 基于 Flask 框架，以 前后端不分离 的形式实现具体业务逻辑 ","date":"2020-06-13","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/:2:0","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:开发准备","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/"},{"categories":["Flask"],"content":"技术实现 基于Python 3.7.7 + Flask框架实现 数据存储使用Redis + MySQL 实现 第三方扩展：七牛云(文件存储平台) 布署：基于macOS 10.15.4系统，使用 Gunicorn + Nginx 进行布署 ","date":"2020-06-13","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/:2:1","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:开发准备","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/"},{"categories":["Flask"],"content":"功能模块 博客模块 首页博客列表 博客详情 关于模块 个人信息展示 联系模块 联系我功能 后台管理 博文的管理 访问数据统计 ","date":"2020-06-13","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/:2:2","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:开发准备","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/"},{"categories":["Flask"],"content":"具体需求 首页 根据近期文章列表展示 翻页加载更多数据 点击新窗口跳转到文章详情页 顶部显示博客各大版块 右侧显示最新文章、归档、分类、标签云与RSS订阅相关信息 文章详情 文章内容 html 数据展示 可以评论该文章 右侧显示文章目录、最新文章、归档、分类、标签云与RSS订阅 关于页 展示作者相关信息 联系页 填写相关信息提供联系作者功能 后台-登录 提供后台登录页面 后台-用户统计 登录到后台界面之后展示用户统计界面 显示各类用户访问数据 展示当前月访问新增人数 展示当前日访问新增人数 后台-发布文章 \u0008提供markdown编辑器进行文章实时预览 发布文章 草稿文章 文章信息展示 进入默认展示所有文章数据 可以根据文章标题搜索文章 文章分类管理 展示所有分类列表 可以添加/修改分类 ","date":"2020-06-13","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/:2:3","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:开发准备","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/"},{"categories":["Flask"],"content":"项目框架搭建 ","date":"2020-06-13","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/:3:0","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:开发准备","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/"},{"categories":["Flask"],"content":"创建项目 新建项目，虚拟环境选择python3版本，创建 manage.py 文件 from flask import Flask app = Flask(__name__) @app.route('/') def hello_world(): return 'Hello World!' if __name__ == '__main__': app.run() ","date":"2020-06-13","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/:3:1","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:开发准备","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/"},{"categories":["Flask"],"content":"使用 GIT 管理源代码 git相关内容可以查看之前的相关文章 本地提交 初始化git Desktop % cd flaskblog flaskblog % git init Initialized empty Git repository in /Users/huliang/Desktop/flaskblog/.git/ 配置当前项目git提交信息(可省略此步，如不配置则使用全局配置) flaskblog % git config user.email xxx@xxx.com flaskblog % git config user.name xxxx 添加忽略文件 flaskblog % touch .gitignore 设置忽略文件内容(后续根据需要再添加) .idea *.py[cod] 添加所有文件到暂存区 flaskblog % git add . 提交到本地仓库并填写注释 flaskblog % git commit -m'初次提交' 远程提交 使用GitHub：https://github.com/ 作为在线 git 源代码仓库 在GitHub上创建名为flaskblog的仓库 创建完成后将本地项目提交至仓库中 flaskblog % cd flaskblog flaskblog % git remote add origin xxx/flaskblog.git flaskblog % git push -u origin master ","date":"2020-06-13","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/:3:2","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:开发准备","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/"},{"categories":["Flask"],"content":"项目基本配置 Config类 先在当前类中定义配置的类，并从中加载配置 ... app = Flask(__name__) class Config(object): \"\"\"工程配置信息\"\"\" DEBUG = True app.config.from_object(Config) ... 运行测试 SQLAlchemy 导入数据库扩展，并在配置中填写相关配置 from flask_sqlalchemy import SQLAlchemy ... class Config(object): \"\"\"工程配置信息\"\"\" DEBUG = True # 数据库的配置信息 SQLALCHEMY_DATABASE_URI = \"mysql://root:mysql@127.0.0.1:3306/flaskblog\" SQLALCHEMY_TRACK_MODIFICATIONS = False app.config.from_object(Config) db = SQLAlchemy(app) 在终端创建数据库 mysql\u003e create database flaskblog charset utf8; 运行测试 Redis 创建redis存储对象，并在配置中填写相关配置 import redis ... class Config(object): \"\"\"工程配置信息\"\"\" ... # redis配置 REDIS_HOST = \"127.0.0.1\" REDIS_PORT = 6379 app.config.from_object(Config) db = SQLAlchemy(app) redis_store = redis.StrictRedis(host=Config.REDIS_HOST, port=Config.REDIS_PORT) 运行测试 CSRF 包含请求体的请求都需要开启CSRF from flask_wtf.csrf import CSRFProtect ... app.config.from_object(Config) ... CSRFProtect(app) CSRFProtect只做验证工作，cookie中的 csrf_token 和表单中的 csrf_token 需要我们自己实现 Session 利用 flask-session扩展，将 session 数据保存到 Redis 中 from flask_session import Session ... class Config(object): \"\"\"工程配置信息\"\"\" SECRET_KEY = \"EjpNVSNQTyGi1VvWECj9TvC/+kq3oujee2kTfQUs8yCM6xX9Yjq52v54g+HVoknA\" ... # flask_session的配置信息 SESSION_TYPE = \"redis\" # 指定 session 保存到 redis 中 SESSION_USE_SIGNER = True # 让 cookie 中的 session_id 被加密签名处理 SESSION_REDIS = redis.StrictRedis(host=REDIS_HOST, port=REDIS_PORT) # 使用 redis 的实例 PERMANENT_SESSION_LIFETIME = 86400 # session 的有效期，单位是秒 app.config.from_object(Config) ... Session(app) 运行测试 Flask-Script与数据库迁移扩展 from flask_script import Manager from flask_migrate import Migrate, MigrateCommand ... manager = Manager(app) Migrate(app, db) manager.add_command('db', MigrateCommand) ... if __name__ == '__main__': manager.run() 运行测试 ","date":"2020-06-13","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/:3:3","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:开发准备","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/"},{"categories":["Flask"],"content":"代码抽取 目标 将特定逻辑代码抽取到指定的类中，各司其职，放便后续项目维护 配置文件 在与 manage.py 同级目录下创建 config.py 文件，用作于项目的配置文件 import redis class Config(object): \"\"\"工程配置信息\"\"\" SECRET_KEY = \"EjpNVSNQTyGi1VvWECj9TvC/+kq3oujee2kTfQUs8yCM6xX9Yjq52v54g+HVoknA\" DEBUG = True # 数据库的配置信息 SQLALCHEMY_DATABASE_URI = \"mysql://root:mysql@127.0.0.1:3306/flaskblog\" SQLALCHEMY_TRACK_MODIFICATIONS = True # redis配置 REDIS_HOST = \"127.0.0.1\" REDIS_PORT = 6379 # session 配置 SESSION_TYPE = \"redis\" # 指定 session 保存到 redis 中 SESSION_USE_SIGNER = True # 让 cookie 中的 session_id 被加密签名处理 SESSION_REDIS = redis.StrictRedis(host=REDIS_HOST, port=REDIS_PORT) # 使用 redis 的实例 PERMANENT_SESSION_LIFETIME = 86400 # session 的有效期，单位是秒 在 manager.py 中引入 Config 类，直接使用 from config import Config app = Flask(__name__) # 配置 app.config.from_object(Config) 运行测试 业务逻辑独立 在整个项目文件夹中，除了启动文件 manage.py 和配置文件 config.py 放在根目录，其他具体业务逻辑文件都放在一个单独的文件夹内，与 manage.py 同级 创建 blog Package，与 manage.py 同级 manage.py 只做最基本的启动工作，将 app 的创建操作移动到 blog 的 __init__.py 文件中 import redis from flask import Flask from flask_sqlalchemy import SQLAlchemy from flask_wtf.csrf import CSRFProtect from flask_session import Session from config import Config app = Flask(__name__) # 配置 app.config.from_object(Config) # 配置数据库 db = SQLAlchemy(app) # 配置redis redis_store = redis.StrictRedis(host=Config.REDIS_HOST, port=Config.REDIS_PORT) # 开启csrf保护 CSRFProtect(app) # 设置session保存位置 Session(app) manage.py 的代码为 from flask_script import Manager from flask_migrate import Migrate, MigrateCommand from blog import app, db # Flask-script manager = Manager(app) # 数据库迁移 Migrate(app, db) manager.add_command('db', MigrateCommand) @app.route('/index') def index(): return 'index' if __name__ == '__main__': manager.run() 运行测试 项目多种配置 一个web程序在开发阶段可能与生产阶段所需要的配置信息可能不一样，所以为了实现此功能，可以给不同情况创建不同的配置类，比如开发阶段使用的配置类名为 DevelopementConfig，生产阶段使用的配置类名为 ProdutionConfig，修改 config.py 文件的配置文件如下 import redis class Config(object): \"\"\"工程配置信息\"\"\" SECRET_KEY = \"EjpNVSNQTyGi1VvWECj9TvC/+kq3oujee2kTfQUs8yCM6xX9Yjq52v54g+HVoknA\" # 数据库的配置信息 SQLALCHEMY_DATABASE_URI = \"mysql://root:mysql@127.0.0.1:3306/flaskblog\" SQLALCHEMY_TRACK_MODIFICATIONS = False # redis配置 REDIS_HOST = \"127.0.0.1\" REDIS_PORT = 6379 # flask_session的配置信息 SESSION_TYPE = \"redis\" # 指定 session 保存到 redis 中 SESSION_USE_SIGNER = True # 让 cookie 中的 session_id 被加密签名处理 SESSION_REDIS = redis.StrictRedis(host=REDIS_HOST, port=REDIS_PORT) # 使用 redis 的实例 PERMANENT_SESSION_LIFETIME = 86400 # session 的有效期，单位是秒 class DevelopementConfig(Config): \"\"\"开发模式下的配置\"\"\" DEBUG = True class ProductionConfig(Config): \"\"\"生产模式下的配置\"\"\" pass 接下来思考如何能才更快速的针对不同的布署环境去使用不同的配置 工厂类方法 要在不同环境下去使用不同的配置，那么可以在 manage.py 文件中给 blog 包传入不同的配置信息，让 ihome 去根据传入指定配置去创建 app，所以可以在 blog 的 __init__.py 文件中添加一个工厂方法，根据传入的配置不同创建其对应的应用实例 在 config.py 文件中添加以下代码 # 定义配置字典 config = { \"development\": DevelopementConfig, \"production\": ProductionConfig } 修改 blog 文件夹下 __init__.py，添加 create_app 的工厂方法 def create_app(config_name): \"\"\"通过传入不同的配置名字，初始化其对应配置的应用实例\"\"\" pass 修改 manage.py 文件中的代码 from blog import create_app, db # 创建 app，并传入配置模式：development / production app = create_app('development') 将 __init__.py 文件中创建 app 实例的方法移动到 create_app 方法中 from config import config # 数据库 db = SQLAlchemy() redis_store = None def create_app(config_name): \"\"\"通过传入不同的配置名字，初始化其对应配置的应用实例\"\"\" app = Flask(__name__) # 配置 app.config.from_object(config[config_name]) # 配置数据库 db.init_app(app) # 配置redis global redis_store redis_store = redis.StrictRedis(host=config[config_name].REDIS_HOST, port=config[config_name].REDIS_PORT) # 开启csrf保护 CSRFProtect(app) # 设置session保存位置 Session(app) return app ","date":"2020-06-13","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/:3:4","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:开发准备","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/"},{"categories":["Flask"],"content":"日志 ","date":"2020-06-13","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/:4:0","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:开发准备","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/"},{"categories":["Flask"],"content":"简介 日志是一种可以追踪某些软件运行时所发生事件的方法。软件开发人员可以向他们的代码中调用日志记录相关的方法来表明发生了某些事情。一个事件可以用一个可包含可选变量数据的消息来描述。此外，事件也有重要性的概念，这个重要性也可以被称为严重性级别（level） ","date":"2020-06-13","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/:4:1","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:开发准备","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/"},{"categories":["Flask"],"content":"作用 通过log的分析，可以方便用户了解系统或软件、应用的运行情况；如果你的应用log足够丰富，也可以分析以往用户的操作行为、类型喜好、地域分布或其他更多信息；如果一个应用的log同时也分了多个级别，那么可以很轻易地分析得到该应用的健康状况，及时发现问题并快速定位、解决问题，补救损失。 简单来讲就是我们通过记录和分析日志可以了解一个系统或软件程序运行情况是否正常，也可以在应用程序出现故障时快速定位问题。不仅在开发中，在运维中日志也很重要 日志的作用可以简单总结为以下几点：程序调试、了解软件程序运行情况，是否正常、软件程序运行故障分析与问题定位、如果应用的日志信息足够详细和丰富，还可以用来做用户行为分析 ","date":"2020-06-13","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/:4:2","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:开发准备","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/"},{"categories":["Flask"],"content":"等级 我们先来思考下下面的两个问题： 作为开发人员，在开发一个应用程序时需要什么日志信息？在应用程序正式上线后需要什么日志信息？ 作为应用运维人员，在部署开发环境时需要什么日志信息？在部署生产环境时需要什么日志信息？ 在软件开发阶段或部署开发环境时，为了尽可能详细的查看应用程序的运行状态来保证上线后的稳定性，我们可能需要把该应用程序所有的运行日志全部记录下来进行分析，这是非常耗费机器性能的。当应用程序正式发布或在生产环境部署应用程序时，我们通常只需要记录应用程序的异常信息、错误信息等，这样既可以减小服务器的I/O压力，也可以更加方便的进行故障排查。那么，怎样才能在不改动应用程序代码的情况下实现在不同的环境记录不同详细程度的日志呢？这就是日志等级的作用了，我们通过配置文件指定我们需要的日志等级就可以了。不同的应用程序所定义的日志等级可能会有所差别，分的详细点的会包含以下几个等级： FATAL/CRITICAL = 重大的，危险的 ERROR = 错误 WARNING = 警告 INFO = 信息 DEBUG = 调试 NOTSET = 没有设置 ","date":"2020-06-13","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/:4:3","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:开发准备","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/"},{"categories":["Flask"],"content":"字段信息与日志格式 输出一条日志时，日志内容和日志级别是需要开发人员明确指定的。对于而其它字段信息，只需要是否显示在日志中就可以了。 ","date":"2020-06-13","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/:4:4","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:开发准备","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/"},{"categories":["Flask"],"content":"功能的实现 Python 自身提供了一个用于记录日志的标准库模块：logging。 logging 模块 简介 logging 模块定义的函数和类为应用程序和库的开发实现了一个灵活的事件日志系统。logging 模块是 Python 的一个标准库模块，由标准库模块提供日志记录 API 的关键好处是所有 Python 模块都可以使用这个日志记录功能。 日志级别 logging模块默认定义了以下几个日志等级，它允许开发人员自定义其他日志级别，但是这是不被推荐的，尤其是在开发供别人使用的库时，因为这会导致日志级别的混乱。 DEBUG 最详细的日志信息，典型应用场景是 问题诊断 INFO 信息详细程度仅次于DEBUG，通常只记录关键节点信息，用于确认一切都是按照我们预期的那样进行工作 WARNING 当某些不期望的事情发生时记录的信息（如，磁盘可用空间较低），但是此时应用程序还是正常运行的 ERROR 由于一个更严重的问题导致某些功能不能正常运行时记录的信息 FATAL/CRITICAL 整个系统即将/完全崩溃 开发应用程序或部署开发环境时，可以使用 DEBUG 或 INFO 级别的日志获取尽可能详细的日志信息来进行开发或部署调试；应用上线或部署生产环境时，应该使用 WARNING 或 ERROR 或 CRITICAL 级别的日志来降低机器的I/O压力和提高获取错误日志信息的效率。 提示 日志级别的指定通常都是在应用程序的配置文件中进行指定的。 使用方式介绍 loggers 提供应用程序代码直接使用的接口 handlers 用于将日志记录发送到指定的目的位置 filters 提供更细粒度的日志过滤功能，用于决定哪些日志记录将会被输出（其它的日志记录将会被忽略） formatters 用于控制日志信息的最终输出格式 # 设置日志的记录等级 logging.basicConfig(level=logging.DEBUG) # 调试debug级 # 创建日志记录器，指明日志保存的路径、每个日志文件的最大大小、保存的日志文件个数上限 file_log_handler = RotatingFileHandler(\"logs/log\", maxBytes=1024*1024*100, backupCount=10) # 创建日志记录的格式 日志等级 输入日志信息的文件名 行数 日志信息 formatter = logging.Formatter('%(levelname)s%(filename)s:%(lineno)d%(message)s') # 为刚创建的日志记录器设置日志记录格式 file_log_handler.setFormatter(formatter) # 为全局的日志工具对象（flask app使用的）添加日志记录器 logging.getLogger().addHandler(file_log_handler) 函数记录 最简单的日志输出 先来试着分别输出一条不同日志级别的日志记录： import logging logging.debug(\"This is a debug log.\") logging.info(\"This is a info log.\") logging.warning(\"This is a warning log.\") logging.error(\"This is a error log.\") logging.critical(\"This is a critical log.\") 也可以这样写： logging.log(logging.DEBUG, \"This is a debug log.\") logging.log(logging.INFO, \"This is a info log.\") logging.log(logging.WARNING, \"This is a warning log.\") logging.log(logging.ERROR, \"This is a error log.\") logging.log(logging.CRITICAL, \"This is a critical log.\") 修改配置改变输出内容 logging.basicConfig(level=logging.DEBUG) 切记 设置 Configurations 中的 Working directory 为当前项目 ","date":"2020-06-13","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/:4:5","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:开发准备","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/"},{"categories":["Flask"],"content":"集成日志到当前项目 在 config.py 文件中在不同的环境的配置下添加日志级别 class Config(object): ... # 默认日志等级 LOG_LEVEL = logging.DEBUG class ProductionConfig(Config): \"\"\"生产模式下的配置\"\"\" LOG_LEVEL = logging.ERROR 在 blog 目录下的 init.py 文件中添加日志配置的相关方法 def setup_log(config_name): \"\"\"配置日志\"\"\" # 设置日志的记录等级 logging.basicConfig(level=config[config_name].LOG_LEVEL) # 调试debug级 # 创建日志记录器，指明日志保存的路径、每个日志文件的最大大小、保存的日志文件个数上限 file_log_handler = RotatingFileHandler(\"logs/log\", maxBytes=1024 * 1024 * 100, backupCount=10) # 创建日志记录的格式 日志等级 输入日志信息的文件名 行数 日志信息 formatter = logging.Formatter('%(levelname)s%(filename)s:%(lineno)d%(message)s') # 为刚创建的日志记录器设置日志记录格式 file_log_handler.setFormatter(formatter) # 为全局的日志工具对象（flask app使用的）添加日志记录器 logging.getLogger().addHandler(file_log_handler) 在 create_app 方法中调用上一步创建的方法，并传入 config_name def create_app(config_name): ... # 配置项目日志 setup_log(config_name) app = Flask(__name__) ... 在项目根目录下创建日志目录文件夹 logs 提示 运行项目，当前项目日志已输出到 logs 的目录下自动创建的 log 文件中 在 logs 文件夹下创建 .gitkeep 文件，以便能将 logs 文件夹添加到远程仓库，并在 .gitignore 文件中添加忽略提交生成的日志文件 logs/log* 在 Flask框架 中，其自己对 Python 的 logging 进行了封装，在 Flask 应用程序中，可以以如下方式进行输出 log: current_app.logger.debug('debug') current_app.logger.error('error') ","date":"2020-06-13","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/:4:6","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:开发准备","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/"},{"categories":["Flask"],"content":"蓝图 项目的蓝图模块可以按以下方式来分： 按功能模块来分，比如：文章模块、关于模块 按接口版本来分，某个版本的接口放一个文件夹下面 因为本项目是前后端不分离的项目，界面数据大部分都使用模板的形式进行渲染，很少涉及到通过接口的形式返回数据，所以本项目使用按功能模块来划分蓝图。 在 blog 目录下创建 modules Package，modules 存放当前项目所有的模块 在 modules 文件夹下创建 index 文件夹， 并在此文件夹下创建 views.py 文件，将 manage.py 中定义的路由拷贝至该文件中 @app.route('/index') def index(): return 'index' 暂时忽略报错，此处的index文件夹就是一个模块 到这一步 manage.py 中内容基本上都抽取完成，剩余内容如下： from flask_script import Manager from flask_migrate import Migrate, MigrateCommand from info import create_app, db app = create_app('development') # 添加扩展命令行 manager = Manager(app) # 数据库迁移 Migrate(app, db) manager.add_command('db', MigrateCommand) if __name__ == '__main__': manager.run() 在 index 文件夹中的 __init__.py创建其自已的蓝图 from flask import Blueprint index_blu = Blueprint(\"index\", __name__) from . import views 在 views.py 中导入蓝图，并使用该蓝图注册路由 from . import index_blu @index_blu.route('/index') def index(): return 'index' 将上一步创建出来的蓝图注册到 app 中 def create_app(config_name): ... # 注册蓝图 from info.modules.index import index_blu app.register_blueprint(index_blu) return app 运行测试 ","date":"2020-06-13","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/:5:0","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:开发准备","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/"},{"categories":["Flask"],"content":"数据库表 ","date":"2020-06-13","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/:6:0","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:开发准备","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/"},{"categories":["Flask"],"content":"分析 根据需求分析需要4个表格： 文章(Post)： 字段 类型 条件 备注 title CharField max_length=100 标题 body TextField - 正文 created_time DateTimeField - 创建时间 last_modified_time DateTimeField - 最后修改时间 abstract CharField max_length=200, blank=True 摘要 category ForeignKey Category, on_delete=models.CASCADE 分类 tags ManyToManyField Tag, blank=True 标签 author ForeignKey User, on_delete=models.CASCADE 作者 分类(Category)： 字段 类型 条件 备注 name CharField max_length=100 分类名 标签(Tag)： 字段 类型 条件 备注 name CharField max_length=100 标签名 用户(Info)： 字段 类型 条件 备注 name CharField max_length=50 作者名 homepage CharField max_length=100 主页 ","date":"2020-06-13","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/:6:1","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:开发准备","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/"},{"categories":["Flask"],"content":"数据库表迁移 确认当前配置的数据库是否存在 mysql\u003e use flaskblog; 将 constants.py 和 models.py 文件拷贝到项目的 blog 目录下 提示 constants.py 是当前项目中要使用的一些常量，预先定义好的，models.py 文件中需要使用到该文件中的一些常量 并在 manage.py 中导入 models form info import models 提示 在迁移的时候以便能读取到对应模型 执行数据库迁移 flaskblog % python manage.py db init flaskblog % python manage.py db migrate -m\"initial\" flaskblog % python manage.py db upgrade 查看数据库表是否创建完成 mysql\u003e show tables; 执行导入初始分类的 SQL 语句 mysql\u003e source info_info_category.sql 提示 生成的迁移文件不需要提交到 git 保存，所以需要在 .gitignore 文件中添加以下内容以便忽略迁移所生成的系列文件 migrations ","date":"2020-06-13","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/:6:2","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:开发准备","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/"},{"categories":["Flask"],"content":"测试数据的添加 先添加分类测试数据 mysql\u003e source 路径/flaskblog_category.sql 再添加新闻测试数据 mysql\u003e source 路径/flaskblog_blog.sql ","date":"2020-06-13","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/:6:3","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:开发准备","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/"},{"categories":["Flask"],"content":"静态文件导入 在项目 blog 目录下创建 static 文件夹 将前端人员开发好的 blog 和 admin 两个静态文件夹拖入到项目 news文件夹内代表新闻前台页面 admin文件夹内代表新闻的后台页面 运行项目，使用浏览器访问：http://127.0.0.1:5000/static/blog/index.html 查看效果 ","date":"2020-06-13","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/:7:0","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:开发准备","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/"},{"categories":["Flask"],"content":"注册根路由 ","date":"2020-06-13","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/:8:0","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:开发准备","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/"},{"categories":["Flask"],"content":"创建模板目录 在 static 同级目录创建 templates 文件夹，并在此目录下创建 post 文件夹用于存放新闻前台模板文件。(此步可以省略，只是在 Pycharm 中标识该目录为模板目录)设置 templates 目录成模板目录属性，操作方式：右键点击 templates 目录，选择 Mark Directory as -\u003e Template Folder如果没有设置模板语言，会弹出是否设置模板语言，点击 Yes，跳转到模板语言设置界面，设置模板语言为 Jinja2 ","date":"2020-06-13","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/:8:1","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:开发准备","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/"},{"categories":["Flask"],"content":"添加模板并创建根路由视图函数 使用 Pycharm 将 static/news/index.html 文件移动到 templates/news/ 目录下，并在 index.py 中添加根路由访问视图 from . import index_blu from flask import render_template @index_blu.route('/') def index(): return render_template('news/index.html') 运行，访问根路由测试 ","date":"2020-06-13","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/:8:2","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:开发准备","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/"},{"categories":["Flask"],"content":"网站图标展示 自定义视图函数，访问网站图标，send_static_file 是系统访问静态文件所调用的方法 @index_blu.route('/favicon.ico') def favicon(): return current_app.send_static_file('news/favicon.ico') ","date":"2020-06-13","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/:9:0","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:开发准备","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/"},{"categories":["Flask"],"content":"为什么需要蓝图 随着flask程序越来越复杂,我们需要对程序进行模块化的处理,之前学习过python的模块化管理,于是针对一个简单的flask程序进行模块化处理 ","date":"2020-06-06","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E8%93%9D%E5%9B%BE/:1:0","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:蓝图","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E8%93%9D%E5%9B%BE/"},{"categories":["Flask"],"content":"简介 简单来说，Blueprint 是一个存储操作方法的容器，这些操作在这个Blueprint 被注册到一个应用之后就可以被调用，Flask 可以通过Blueprint来组织URL以及处理请求。 ","date":"2020-06-06","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E8%93%9D%E5%9B%BE/:2:0","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:蓝图","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E8%93%9D%E5%9B%BE/"},{"categories":["Flask"],"content":"Flask中的蓝图 Flask使用Blueprint让应用实现模块化，在Flask中，Blueprint具有如下属性： 一个应用可以具有多个Blueprint 可以将一个Blueprint注册到任何一个未使用的URL下比如 “/”、“/sample”或者子域名 在一个应用中，一个模块可以注册多次 Blueprint可以单独具有自己的模板、静态文件或者其它的通用操作方法，它并不是必须要实现应用的视图和函数的 在一个应用初始化时，就应该要注册需要使用的Blueprint 但是一个Blueprint并不是一个完整的应用，它不能独立于应用运行，而必须要注册到某一个应用中。 ","date":"2020-06-06","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E8%93%9D%E5%9B%BE/:3:0","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:蓝图","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E8%93%9D%E5%9B%BE/"},{"categories":["Flask"],"content":"初识蓝图 蓝图/Blueprint对象用起来和一个应用/Flask对象差不多，最大的区别在于一个 蓝图对象没有办法独立运行，必须将它注册到一个应用对象上才能生效。使用蓝图可以分为三个步骤： 创建一个蓝图对象 admin=Blueprint('admin',__name__) 在这个蓝图对象上进行操作,注册路由,指定静态文件夹,注册模版过滤器 @admin.route('/') def admin_home(): return 'admin_home' 在应用对象上注册这个蓝图对象 app.register_blueprint(admin,url\\_prefix='/admin') 当这个应用启动后,通过/admin/可以访问到蓝图中定义的视图函数 ","date":"2020-06-06","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E8%93%9D%E5%9B%BE/:4:0","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:蓝图","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E8%93%9D%E5%9B%BE/"},{"categories":["Flask"],"content":"运行机制 蓝图是保存了一组将来可以在应用对象上执行的操作，注册路由就是一种操作，当在应用对象上调用 route 装饰器注册路由时,这个操作将修改对象的url_map路由表，然而蓝图对象根本没有路由表，当我们在蓝图对象上调用route装饰器注册路由时,它只是在内部的一个延迟操作记录列表defered_functions中添加了一个项，当执行应用对象的 register_blueprint() 方法时，应用对象将从蓝图对象的 defered_functions 列表中取出每一项，并以自身作为参数执行该匿名函数，即调用应用对象的 add_url_rule() 方法，这将真正的修改应用对象的路由表 ","date":"2020-06-06","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E8%93%9D%E5%9B%BE/:5:0","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:蓝图","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E8%93%9D%E5%9B%BE/"},{"categories":["Flask"],"content":"url前缀 当我们在应用对象上注册一个蓝图时，可以指定一个url_prefix关键字参数（这个参数默认是/），在应用最终的路由表 url_map中，在蓝图上注册的路由URL自动被加上了这个前缀，这个可以保证在多个蓝图中使用相同的URL规则而不会最终引起冲突，只要在注册蓝图时将不同的蓝图挂接到不同的自路径即可，例： url_for('admin.index') # /admin/ ","date":"2020-06-06","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E8%93%9D%E5%9B%BE/:6:0","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:蓝图","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E8%93%9D%E5%9B%BE/"},{"categories":["Flask"],"content":"注册静态路由 和应用对象不同，蓝图对象创建时不会默认注册静态目录的路由。需要我们在 创建时指定 static_folder 参数。下面的示例将蓝图所在目录下的static_admin目录设置为静态目录 admin = Blueprint(\"admin\",__name__,static_folder='static_admin') app.register_blueprint(admin,url_prefix='/admin') 现在就可以使用/admin/static_admin/ 访问static_admin目录下的静态文件了 定制静态目录URL规则 ：可以在创建蓝图对象时使用 static_url_path 来改变静态目录的路由。下面的示例将为 static_admin 文件夹的路由设置为 /lib admin = Blueprint(\"admin\",__name__,static_folder='static_admin',static_url_path='/lib') app.register_blueprint(admin,url_prefix='/admin') ","date":"2020-06-06","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E8%93%9D%E5%9B%BE/:7:0","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:蓝图","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E8%93%9D%E5%9B%BE/"},{"categories":["Flask"],"content":"设置模版目录 蓝图对象默认的模板目录为系统的模版目录，可以在创建蓝图对象时使用 template_folder 关键字参数设置模板目录 admin = Blueprint('admin',__name__,template_folder='my_templates') 注意 如果在 templates 中存在和 my_templates 同名文件，则系统会优先使用 templates 中的文件 ","date":"2020-06-06","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E8%93%9D%E5%9B%BE/:8:0","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:蓝图","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E8%93%9D%E5%9B%BE/"},{"categories":["Flask"],"content":"ORM ","date":"2020-05-30","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E5%BA%93/:1:0","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:数据库","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["Flask"],"content":"简介 ORM全拼Object-Relation Mapping，中文意为 对象-关系映射。主要实现模型对象到关系数据库数据的映射. ","date":"2020-05-30","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E5%BA%93/:1:1","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:数据库","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["Flask"],"content":"优点 只需要面向对象编程, 不需要面向数据库编写代码。对数据库的操作都转化成对类属性和方法的操作，不用编写各种数据库的sql语句。 实现了数据模型与数据库的解耦，屏蔽了不同数据库操作上的差异。不在关注用的是mysql、oracle…等。通过简单的配置就可以轻松更换数据库, 而不需要修改代码. ","date":"2020-05-30","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E5%BA%93/:1:2","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:数据库","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["Flask"],"content":"缺点 相比较直接使用SQL语句操作数据库,有性能损失。 根据对象的操作转换成SQL语句,根据查询的结果转化成对象, 在映射过程中有性能损失。 ","date":"2020-05-30","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E5%BA%93/:1:3","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:数据库","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["Flask"],"content":"SQLALchemy SQLALchemy实际上是对数据库的抽象，让开发者不用直接和SQL语句打交道，而是通过Python对象来操作数据库，在舍弃一些性能开销的同时，换来的是开发效率的较大提升。SQLAlchemy是一个关系型数据库框架，它提供了高层的 ORM和底层的原生数据库的操作。flask-sqlalchemy是一个简化了SQLAlchemy操作的flask扩展。 文档地址：http://docs.jinkan.org/docs/flask-sqlalchemy 安装 安装 flask-sqlalchemy pip install flask-sqlalchemy 如果连接的是 mysql 数据库，需要安装 mysqldb pip install flask-mysqldb 数据库连接设置 在 Flask-SQLAlchemy 中，数据库使用URL指定，而且程序使用的数据库必须保存到Flask配置对象的 SQLALCHEMY_DATABASE_URI 键中 app.config['SQLALCHEMY_DATABASE_URI'] = 'mysql://root:mysql@127.0.0.1:3306/test' 其他设置： # 动态追踪修改设置，如未设置只会提示警告 app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = True #查询时会显示原始SQL语句 app.config['SQLALCHEMY_ECHO'] = True 配置完成需要去 MySQL 中创建项目所使用的数据库 $ mysql -uroot -pmysql $ create database test charset utf8; 其他配置 名字 备注 SQLALCHEMY_DATABASE_URI 用于连接的数据库 URI 。例如:sqlite:////tmp/test.dbmysql://username:password@server/db SQLALCHEMY_BINDS 一个映射 binds 到连接 URI 的字典。更多 binds 的信息见用 Binds 操作多个数据库。 SQLALCHEMY_ECHO 如果设置为Ture， SQLAlchemy 会记录所有 发给 stderr 的语句，这对调试有用。(打印sql语句) SQLALCHEMY_RECORD_QUERIES 可以用于显式地禁用或启用查询记录。查询记录 在调试或测试模式自动启用。更多信息见get_debug_queries()。 SQLALCHEMY_NATIVE_UNICODE 可以用于显式禁用原生 unicode 支持。当使用 不合适的指定无编码的数据库默认值时，这对于 一些数据库适配器是必须的（比如 Ubuntu 上 某些版本的 PostgreSQL ）。 SQLALCHEMY_POOL_SIZE 数据库连接池的大小。默认是引擎默认值（通常 是 5 ） SQLALCHEMY_POOL_TIMEOUT 设定连接池的连接超时时间。默认是 10 。 SQLALCHEMY_POOL_RECYCLE 多少秒后自动回收连接。这对 MySQL 是必要的， 它默认移除闲置多于 8 小时的连接。注意如果 使用了 MySQL ， Flask-SQLALchemy 自动设定 这个值为 2 小时。 连接其他数据库 完整连接 URI 列表请跳转到 SQLAlchemy 下面的文档 (Supported Databases) 。这里给出一些 常见的连接字符串。 Postgres: postgresql://scott:tiger@localhost/mydatabase MySQL: mysql://scott:tiger@localhost/mydatabase Oracle: - oracle://scott:tiger@127.0.0.1:1521/sidname SQLite （注意开头的四个斜线）: sqlite:////absolute/path/to/foo.db 常用的字段类型 类型名 python中类型 说明 Integer int 普通整数，一般是32位 SmallInteger int 取值范围小的整数，一般是16位 BigInteger int或long 不限制精度的整数 Float float 浮点数 Numeric decimal.Decimal 普通整数，一般是32位 String str 变长字符串 Text str 变长字符串，对较长或不限长度的字符串做了优化 Unicode unicode 变长Unicode字符串 UnicodeText unicode 变长Unicode字符串，对较长或不限长度的字符串做了优化 Boolean bool 布尔值 Date datetime.date 时间 Time datetime.datetime 日期和时间 LargeBinary str 二进制文件 常用的列选项 选项名 说明 primary_key 如果为True，代表表的主键 unique 如果为True，代表这列不允许出现重复的值 index 如果为True，为这列创建索引，提高查询效率 nullable 如果为True，允许有空值，如果为False，不允许有空值 default 常用的关系选项 选项名 说明 backref 在关系的另一模型中添加反向引用 primary join 明确指定两个模型之间使用的联结条件 uselist 如果为False，不使用列表，而使用标量值 order_by 指定关系中记录的排序方式 secondary 指定多对多关系中关系表的名字 secondary join 在SQLAlchemy中无法自行决定时，指定多对多关系中的二级联结条件 数据库基本操作 在Flask-SQLAlchemy中，插入、修改、删除操作，均由数据库会话管理。会话用 db.session 表示。在准备把数据写入数据库前，要先将数据添加到会话中然后调用 commit() 方法提交会话。 在 Flask-SQLAlchemy 中，查询操作是通过 query 对象操作数据。最基本的查询是返回表中所有数据，可以通过过滤器进行更精确的数据库查询。 在视图函数中定义模型类 from flask import Flask from flask_sqlalchemy import SQLAlchemy app = Flask(__name__) #设置连接数据库的URL app.config['SQLALCHEMY_DATABASE_URI'] = 'mysql://root:mysql@127.0.0.1:3306/test' app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = True #查询时会显示原始SQL语句 app.config['SQLALCHEMY_ECHO'] = True db = SQLAlchemy(app) class Role(db.Model): # 定义表名 __tablename__ = 'roles' # 定义列对象 id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(64), unique=True) user = db.relationship('User', backref='role') #repr()方法显示一个可读字符串 def __repr__(self): return 'Role:%s'% self.name class User(db.Model): __tablename__ = 'users' id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(64), unique=True, index=True) email = db.Column(db.String(64),unique=True) password = db.Column(db.String(64)) role_id = db.Column(db.Integer, db.ForeignKey('roles.id')) def __repr__(self): return 'User:%s'%self.name if __name__ == '__main__': app.run(debug=True) 模型之前的关联 一对多 class Role(db.Model): ... #关键代码 user = db.relationship('User', backref='role', lazy='dynamic') ... class User(db.Model): ... role_id = db.Column(db.Integer, db.ForeignKey('roles.id')) 其中realtionship描述了Role和User的关系。在此文中，第一个参数为对应参照的类\"User” 第二个参数backref为类User申明新属性的方法 第三个参数lazy决定了什么时候SQLALchemy从数据库中加载数据 如果设置为子查询方式(subquery)，则会在加载完Role对象后，就立即加载与其关联的对象，这样会让总查询数量减少，但如果返回的条目数量很多，就会比较慢 设置为 subquery 的话，role.us","date":"2020-05-30","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E5%BA%93/:1:4","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:数据库","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["Flask"],"content":"数据库迁移 ","date":"2020-05-30","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E5%BA%93/:2:0","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:数据库","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["Flask"],"content":"简介 在开发过程中，需要修改数据库模型，而且还要在修改之后更新数据库。最直接的方式就是删除旧表，但这样会丢失数据。更好的解决办法是使用数据库迁移框架，它可以追踪数据库模式的变化，然后把变动应用到数据库中。在Flask中可以使用Flask-Migrate扩展，来实现数据迁移。并且集成到Flask-Script中，所有操作通过命令就能完成。为了导出数据库迁移命令，Flask-Migrate提供了一个MigrateCommand类，可以附加到flask-script的manager对象上。 ","date":"2020-05-30","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E5%BA%93/:2:1","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:数据库","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["Flask"],"content":"使用 首先要在虚拟环境中安装Flask-Migrate。 pip install flask-migrate 代码文件内容： #coding=utf-8 from flask import Flask from flask_sqlalchemy import SQLAlchemy from flask_migrate import Migrate,MigrateCommand from flask_script import Shell,Manager app = Flask(__name__) manager = Manager(app) app.config['SQLALCHEMY_DATABASE_URI'] = 'mysql://root:mysql@127.0.0.1:3306/Flask_test' app.config['SQLALCHEMY_COMMIT_ON_TEARDOWN'] = True app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = True db = SQLAlchemy(app) #第一个参数是Flask的实例，第二个参数是Sqlalchemy数据库实例 migrate = Migrate(app,db) #manager是Flask-Script的实例，这条语句在flask-Script中添加一个db命令 manager.add_command('db',MigrateCommand) #定义模型Role class Role(db.Model): # 定义表名 __tablename__ = 'roles' # 定义列对象 id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(64), unique=True) user = db.relationship('User', backref='role') #repr()方法显示一个可读字符串， def __repr__(self): return 'Role:'.format(self.name) #定义用户 class User(db.Model): __talbe__ = 'users' id = db.Column(db.Integer, primary_key=True) username = db.Column(db.String(64), unique=True, index=True) #设置外键 role_id = db.Column(db.Integer, db.ForeignKey('roles.id')) def __repr__(self): return 'User:'.format(self.username) if __name__ == '__main__': manager.run() 创建迁移仓库 #这个命令会创建migrations文件夹，所有迁移文件都放在里面。 python database.py db init 创建迁移脚本 自动创建迁移脚本有两个函数： upgrade()：函数把迁移中的改动应用到数据库中。 downgrade()：函数则将改动删除。 自动创建的迁移脚本会根据模型定义和数据库当前状态的差异，生成upgrade()和downgrade()函数的内容。对比不一定完全正确，有可能会遗漏一些细节，需要进行检查 python database.py db migrate -m 'initial migration' 更新数据库 python database.py db upgrade 返回以前的版本 可以根据history命令找到版本号,然后传给downgrade命令: python app.py db history 输出格式：\u003cbase\u003e -\u003e 版本号 (head), initial migration 回滚到指定版本 python app.py db downgrade 版本号 ","date":"2020-05-30","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E5%BA%93/:2:2","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:数据库","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["Flask"],"content":"信号机制 ","date":"2020-05-30","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E5%BA%93/:3:0","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:数据库","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["Flask"],"content":"简介 Flask信号(signals, or event hooking)允许特定的发送端通知订阅者发生了什么（既然知道发生了什么，那我们可以根据自己业务需求实现自己的逻辑）。Flask提供了一些信号（核心信号）且其它的扩展提供更多的信号。信号依赖于Blinker库。 flask内置信号列表：http://docs.jinkan.org/docs/flask/api.html#id17 template_rendered = _signals.signal('template-rendered') request_started = _signals.signal('request-started') request_finished = _signals.signal('request-finished') request_tearing_down = _signals.signal('request-tearing-down') got_request_exception = _signals.signal('got-request-exception') appcontext_tearing_down = _signals.signal('appcontext-tearing-down') appcontext_pushed = _signals.signal('appcontext-pushed') appcontext_popped = _signals.signal('appcontext-popped') message_flashed = _signals.signal('message-flashed') ","date":"2020-05-30","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E5%BA%93/:3:1","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:数据库","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["Flask"],"content":"应用场景 Flask-User 这个扩展中定义了名为 user_logged_in 的信号，当用户成功登入之后，这个信号会被发送。我们可以订阅该信号去追踪登录次数和登录IP： from flask import request from flask_user.signals import user_logged_in @user_logged_in.connect_via(app) def track_logins(sender, user, **extra): user.login_count += 1 user.last_login_ip = request.remote_addr db.session.add(user) db.session.commit() ","date":"2020-05-30","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E5%BA%93/:3:2","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:数据库","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["Flask"],"content":"Flask-SQLAlchemy 信号支持 在 Flask-SQLAlchemy 模块中，0.10 版本开始支持信号，可以连接到信号来获取到底发生什么了的通知。存在于下面两个信号： models_committed：这个信号在修改的模型提交到数据库时发出。发送者是发送修改的应用，模型 和 操作描述符 以 (model, operation) 形式作为元组，这样的元组列表传递给接受者的 changes 参数。该模型是发送到数据库的模型实例，当一个模型已经插入，操作是 ‘insert’ ，而已删除是 ‘delete’ ，如果更新了任何列，会是 ‘update’ 。 before_models_committed：除了刚好在提交发送前发生，与 models_committed 完全相同。 from flask_sqlalchemy import models_committed # 给 models_committed 信号添加一个订阅者，即为当前 app @models_committed.connect_via(app) def models_committed(a, changes): print(a, changes) ","date":"2020-05-30","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E5%BA%93/:3:3","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:数据库","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["Flask"],"content":"前言 在前面的学习中，视图函数的主要作用是生成请求的响应，这是最简单的请求。实际上，视图函数有两个作用：处理业务逻辑和返回响应内容。在大型应用中，把业务逻辑和表现内容放在一起，会增加代码的复杂度和维护成本。本次学到的模板，它的作用即是承担视图函数的另一个作用，即返回响应内容。 ","date":"2020-05-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/:1:0","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:模板","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/"},{"categories":["Flask"],"content":"简介 ","date":"2020-05-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/:2:0","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:模板","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/"},{"categories":["Flask"],"content":"什么是模板 模板其实是一个包含响应文本的文件，其中用占位符(变量)表示动态部分，告诉模板引擎其具体的值需要从使用的数据中获取，使用真实值替换变量，再返回最终得到的字符串，这个过程称为“渲染”。Flask是使用 Jinja2 这个模板引擎来渲染模板 ","date":"2020-05-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/:2:1","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:模板","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/"},{"categories":["Flask"],"content":"好处 视图函数只负责业务逻辑和数据处理(业务逻辑方面)，而模板则取到视图函数的数据结果进行展示(视图展示方面)，代码结构清晰，耦合度低。 ","date":"2020-05-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/:2:2","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:模板","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/"},{"categories":["Flask"],"content":"Jinja2 ","date":"2020-05-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/:3:0","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:模板","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/"},{"categories":["Flask"],"content":"简介 Jinja2是 Python 下一个被广泛应用的模板引擎，是由Python实现的模板语言，他的设计思想来源于 Django 的模板引擎，并扩展了其语法和一系列强大的功能，其是Flask内置的模板语言。 ","date":"2020-05-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/:3:1","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:模板","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/"},{"categories":["Flask"],"content":"模板语言 模板语言是一种被设计来自动生成文档的简单文本格式，在模板语言中，一般都会把一些变量传给模板，替换模板的特定位置上预先定义好的占位变量名。 ","date":"2020-05-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/:3:2","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:模板","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/"},{"categories":["Flask"],"content":"渲染模版函数 Flask提供的 render_template 函数封装了该模板引擎，render_template 函数的第一个参数是模板的文件名，后面的参数都是键值对，表示模板中变量对应的真实值。 ","date":"2020-05-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/:4:0","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:模板","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/"},{"categories":["Flask"],"content":"使用 ","date":"2020-05-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/:5:0","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:模板","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/"},{"categories":["Flask"],"content":"代码块 {{}} 来表示变量名，这种 {{}} 语法叫做变量代码块 Jinja2 模版中的变量代码块可以是任意 Python 类型或者对象，只要它能够被 Python 的 str() 方法转换为一个字符串就可以，比如，可以通过下面的方式显示一个字典或者列表中的某个元素： 用 {%%} 定义的控制代码块，可以实现一些语言层次的功能，比如循环或者if语句 ","date":"2020-05-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/:5:1","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:模板","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/"},{"categories":["Flask"],"content":"注释 使用 {# #} 进行注释，注释的内容不会在html中被渲染出来 实操 在项目下创建 templates 文件夹，用于存放所有的模板文件，并在目录下创建一个模板html文件 temp_demo1.html 创建视图函数，将该模板内容进行渲染返回 @app.route('/') def index(): return render_template('temp_demo1.html') 代码中传入字符串，列表，字典到模板中 @app.route('/') def index(): # 往模板中传入的数据 my_str = 'Hello 模板' my_int = 1101 my_array = [1, 2, 3, 4, 5, 6] my_dict = { 'name': 'xiaoliang', 'age': 18 } return render_template('temp_demo1.html', my_str=my_str, my_int=my_int, my_array=my_array, my_dict=my_dict ) 模板中代码 运行效果 \u003c!DOCTYPE html\u003e我的模板html内容Hello 模板1101[1, 2, 3, 4, 5, 6]{'name': 'xiaoliang', 'age': 18} 相关运算，取值 结果 my_int + 10 的和为：1111 my_int + my_array第0个值的和为：1102 my_array 第0个值为：1 my_array 第1个值为：2 my_dict 中 name 的值为：xiaoliang my_dict 中 age 的值为：18 ","date":"2020-05-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/:5:2","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:模板","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/"},{"categories":["Flask"],"content":"过滤器 ","date":"2020-05-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/:6:0","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:模板","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/"},{"categories":["Flask"],"content":"本质 过滤器的本质就是函数。有时候我们不仅仅只是需要输出变量的值，我们还需要修改变量的显示，甚至格式化、运算等等，而在模板中是不能直接调用 Python 中的某些方法，那么这就用到了过滤器。 ","date":"2020-05-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/:6:1","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:模板","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/"},{"categories":["Flask"],"content":"使用方式 过滤器的使用方式为：变量名 | 过滤器。 如果没有任何参数传给过滤器,则可以把括号省略掉 ","date":"2020-05-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/:6:2","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:模板","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/"},{"categories":["Flask"],"content":"链式调用 在 jinja2 中，过滤器是可以支持链式调用的，示例如下： ","date":"2020-05-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/:6:3","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:模板","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/"},{"categories":["Flask"],"content":"常见内建过滤器 字符串操作 safe：禁用转义 capitalize：把变量值的首字母转成大写，其余字母转小写 lower：把值转成小写 upper：把值转成大写 title：把值中的每个单词的首字母都转成大写 reverse：字符串反转 format：格式化输出 striptags：渲染之前把值中所有的HTML标签都删掉 truncate: 字符串截断 列表操作 first：取第一个元素 last：取最后一个元素 length：获取列表长度 sum：列表求和 sort：列表排序 语句块过滤 ","date":"2020-05-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/:6:4","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:模板","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/"},{"categories":["Flask"],"content":"自定义过滤器 过滤器的本质是函数。当模板内置的过滤器不能满足需求，可以自定义过滤器。自定义过滤器有两种实现方式： 一种是通过Flask应用对象的 add_template_filter 方法 通过装饰器来实现自定义过滤器 自定义的过滤器名称如果和内置的过滤器重名，会覆盖内置的过滤器。 ","date":"2020-05-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/:6:5","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:模板","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/"},{"categories":["Flask"],"content":"控制代码块 控制代码块主要包含两个： - if/else if /else / endif - for / endfor if语句 Jinja2 语法中的if语句跟 Python 中的 if 语句相似,后面的布尔值或返回布尔值的表达式将决定代码中的哪个流程会被执行: 过滤器可以被用在 if 语句中: 循环 我们可以在 Jinja2 中使用循环来迭代任何列表或者生成器函数 循环和if语句可以组合使用，以模拟 Python 循环中的 continue 功能，下面这个循环将只会渲染post.text不为None的那些post： 在一个 for 循环块中你可以访问这些特殊的变量: 变量 描述 loop.index 当前循环迭代的次数（从 1 开始） loop.index0 当前循环迭代的次数（从 0 开始） loop.revindex 到循环结束需要迭代的次数（从 1 开始） loop.revindex0 到循环结束需要迭代的次数（从 0 开始） loop.first 如果是第一次迭代，为 True 。 loop.last 如果是最后一次迭代，为 True 。 loop.length 序列中的项目数。 loop.cycle 在一串序列间期取值的辅助函数。见下面示例程序。 在循环内部,你可以使用一个叫做loop的特殊变量来获得关于for循环的一些信息，比如：要是我们想知道当前被迭代的元素序号，并模拟Python中的enumerate函数做的事情，则可以使用loop变量的index属性,例如: 会输出这样的结果 1, Post title 2, Second Post cycle函数会在每次循环的时候,返回其参数中的下一个元素,可以拿上面的例子来说明: 会输出这样的结果： odd Post Title even Second Post ","date":"2020-05-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/:6:6","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:模板","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/"},{"categories":["Flask"],"content":"代码复用 ","date":"2020-05-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/:7:0","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:模板","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/"},{"categories":["Flask"],"content":"简介 在模板中，可能会遇到以下情况： 多个模板具有完全相同的顶部和底部内容 多个模板中具有相同的模板代码内容，但是内容中部分值不一样 多个模板中具有完全相同的 html 代码块内容 像遇到这种情况，可以使用 JinJa2 模板中的 宏、继承、包含来进行实现 ","date":"2020-05-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/:7:1","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:模板","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/"},{"categories":["Flask"],"content":"宏 简介 把它看作 Jinja2 中的一个函数，它会返回一个模板或者 HTML 字符串，为了避免反复地编写同样的模板代码，出现代码冗余，可以把他们写成函数以进行重用，需要在多处重复使用的模板代码片段可以写入单独的文件，再包含在所有模板中，以避免重复。 使用 定义宏 调用宏 这会输出 把宏单独抽取出来，封装成html文件，其它模板中导入使用，文件名可以自定义macro.html 在其它模板文件中先导入，再调用 ","date":"2020-05-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/:7:2","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:模板","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/"},{"categories":["Flask"],"content":"继承 简介 模板继承是为了重用模板中的公共内容。一般Web开发中，继承主要使用在网站的顶部菜单、底部。这些内容可以定义在父模板中，子模板直接继承，而不需要重复书写。 使用 标签定义的内容 相当于在父模板中挖个坑，当子模板继承父模板时，可以进行填充。 子模板使用 extends 指令声明这个模板继承自哪个模板 父模板中定义的块在子模板中被重新定义，在子模板中调用父模板的内容可以使用super() 父模板 base.html 子模板 extends指令声明这个模板继承自哪 注意点 不支持多继承 为了便于阅读，在子模板中使用extends时，尽量写在模板的第一行。 不能在一个模板文件中定义多个相同名字的block标签。 当在页面中使用多个block标签时，建议给结束标签起个名字，当多个block嵌套时，阅读性更好。 ","date":"2020-05-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/:7:3","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:模板","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/"},{"categories":["Flask"],"content":"包含 简介 Jinja2模板中，除了宏和继承，还支持一种代码重用的功能，叫包含(Include)。它的功能是将另一个模板整个加载到当前模板中，并直接渲染。 使用 include的使用 包含在使用时，如果包含的模板文件不存在时，程序会抛出TemplateNotFound异常，可以加上 ignore missing 关键字。如果包含的模板文件不存在，会忽略这条include语句。 include 的使用加上关键字ignore missing ","date":"2020-05-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/:7:4","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:模板","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/"},{"categories":["Flask"],"content":"特有的变量和函数 ","date":"2020-05-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/:8:0","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:模板","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/"},{"categories":["Flask"],"content":"简介 可以在自己的模板中访问一些 Flask 默认内置的函数和对象 ","date":"2020-05-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/:8:1","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:模板","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/"},{"categories":["Flask"],"content":"config 你可以从模板中直接访问Flask当前的config对象: ","date":"2020-05-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/:8:2","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:模板","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/"},{"categories":["Flask"],"content":"request 就是flask中代表当前请求的request对象： ","date":"2020-05-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/:8:3","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:模板","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/"},{"categories":["Flask"],"content":"session 为Flask的session对象 ","date":"2020-05-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/:8:4","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:模板","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/"},{"categories":["Flask"],"content":"g变量 在视图函数中设置g变量的 name 属性的值，然后在模板中直接可以取出 ","date":"2020-05-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/:8:5","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:模板","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/"},{"categories":["Flask"],"content":"url_for() url_for会根据传入的路由器函数名,返回该路由对应的URL,在模板中始终使用url_for()就可以安全的修改路由绑定的URL,则不比担心模板中渲染出错的链接: 如果我们定义的路由URL是带有参数的,则可以把它们作为关键字参数传入url_for(),Flask会把他们填充进最终生成的URL中: ","date":"2020-05-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/:8:6","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:模板","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/"},{"categories":["Flask"],"content":"get_flashed_messages() 这个函数会返回之前在flask中通过flask()传入的消息的列表，flash函数的作用很简单,可以把由Python字符串表示的消息加入一个消息队列中，再使用get_flashed_message()函数取出它们并消费掉： ","date":"2020-05-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/:8:7","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:模板","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/"},{"categories":["Flask"],"content":"Web表单 ","date":"2020-05-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/:9:0","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:模板","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/"},{"categories":["Flask"],"content":"简介 Web 表单是 Web 应用程序的基本功能。它是HTML页面中负责数据采集的部件。表单有三个部分组成：表单标签、表单域、表单按钮。表单允许用户输入数据，负责HTML页面数据采集，通过表单将用户输入的数据提交给服务器。在Flask中，为了处理web表单，我们可以使用 Flask-WTF 扩展，它封装了 WTForms，并且它有验证表单数据的功能 ","date":"2020-05-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/:9:1","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:模板","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/"},{"categories":["Flask"],"content":"WTForms支持的HTML标准字段 字段对象 说明 StringField 文本字段 TextAreaField 多行文本字段 PasswordField 密码文本字段 HiddenField 隐藏文件字段 DateField 文本字段，值为 datetime.date 文本格式 DateTimeField 文本字段，值为 datetime.datetime 文本格式 IntegerField 文本字段，值为整数 DecimalField 文本字段，值为decimal.Decimal FloatField 文本字段，值为浮点数 BooleanField 复选框，值为True 和 False RadioField 一组单选框 SelectField 下拉列表 SelectMutipleField 下拉列表，可选择多个值 FileField 文件上传字段 SubmitField 表单提交按钮 FormField 把表单作为字段嵌入另一个表单 FieldList 一组指定类型的字段 ","date":"2020-05-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/:9:2","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:模板","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/"},{"categories":["Flask"],"content":"WTForms常用验证函数 验证函数 说明 DataRequired 确保字段中有数据 EqualTo 比较两个字段的值，常用于比较两次密码输入 Length 验证输入的字符串长度 NumberRange 验证输入的值在数字范围内 URL 验证URL AnyOf 验证输入值在可选列表中 NoneOf 验证输入值不在可选列表中 使用 Flask-WTF 需要配置参数 SECRET_KEY。 CSRF_ENABLED是为了CSRF（跨站请求伪造）保护。 SECRET_KEY用来生成加密令牌，当CSRF激活的时候，该设置会根据设置的密匙生成加密令牌。 ","date":"2020-05-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/:9:3","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:模板","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/"},{"categories":["Flask"],"content":"CSRF ","date":"2020-05-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/:10:0","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:模板","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/"},{"categories":["Flask"],"content":"简介 CSRF全拼为Cross Site Request Forgery，译为跨站请求伪造。CSRF指攻击者盗用了你的身份，以你的名义发送恶意请求。包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账……，造成的问题：个人隐私泄露以及财产安全。 ","date":"2020-05-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/:10:1","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:模板","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/"},{"categories":["Flask"],"content":"防止 CSRF 攻击 在客户端向后端请求界面数据的时候，后端会往响应中的 cookie 中设置 csrf_token 的值 在 Form 表单中添加一个隐藏的的字段，值也是 csrf_token 在用户点击提交的时候，会带上这两个值向后台发起请求 后端接受到请求，以会以下几件事件： 从 cookie中取出 csrf_token 从 表单数据中取出来隐藏的 csrf_token 的值 进行对比 如果比较之后两值一样，那么代表是正常的请求，如果没取到或者比较不一样，代表不是正常的请求，不执行下一步操作 ","date":"2020-05-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/:10:2","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:模板","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/"},{"categories":["Flask"],"content":"在 Flask 项目中解决 CSRF 攻击 在 Flask 中， Flask-wtf 扩展有一套完善的 csrf 防护体系，对于我们开发者来说，使用起来非常简单 在 FlaskForm 中实现校验 设置应用程序的 secret_key，用于加密生成的 csrf_token 的值 app.secret_key = \"#此处可以写随机字符串#\" 在模板的表单中添加以下代码 设置完毕，cookie 中的 csrf_token 不需要我们关心，会自动帮我们设置 单独使用 设置应用程序的 secret_key，用于加密生成的 csrf_token 的值 app.secret_key = \"#此处可以写随机字符串#\" 导入 flask_wtf.csrf 中的 CSRFProtect 类，进行初始化，并在初始化的时候关联 app from flask.ext.wtf import CSRFProtect CSRFProtect(app) 如果模板中有表单，不需要做任何事。与之前一样: 但如果模板中没有表单，你仍需要 CSRF 令牌: ","date":"2020-05-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/:10:3","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:模板","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/"},{"categories":["Flask"],"content":"路由 ","date":"2020-05-16","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E8%A7%86%E5%9B%BE%E5%8F%8A%E8%B7%AF%E7%94%B1/:1:0","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:视图及路由","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E8%A7%86%E5%9B%BE%E5%8F%8A%E8%B7%AF%E7%94%B1/"},{"categories":["Flask"],"content":"作用 指定路由地址 # 指定访问路径为 demo1 @app.route('/demo1') def demo1(): return 'demo1' 给路由传参示例 有时我们需要将同一类 URL 映射到同一个视图函数处理，比如：使用同一个视图函数来显示不同用户的个人信息。 # 路由传递参数 @app.route('/user/\u003cuser_id\u003e') def user_info(user_id): return 'hello %s' % user_id 路由传递的参数默认当做 string 处理，也可以指定参数的类型 # 路由传递参数 @app.route('/user/\u003cint:user_id\u003e') def user_info(user_id): return 'hello %d' % user_id 提示 这里指定int，尖括号中的内容是动态的，在此暂时可以理解为接受int类型的值，实际上int代表使用IntegerConverter去处理 url 传入的参数 指定请求方式 在 Flask 中，定义一个路由，默认的请求方式为： GET OPTIONS(自带) HEAD(自带) 如果想添加请求方试，那么可以如下指定： @app.route('/demo2', methods=['GET', 'POST']) def demo2(): # 直接从请求中取到请求方式并返回 return request.method ","date":"2020-05-16","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E8%A7%86%E5%9B%BE%E5%8F%8A%E8%B7%AF%E7%94%B1/:1:1","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:视图及路由","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E8%A7%86%E5%9B%BE%E5%8F%8A%E8%B7%AF%E7%94%B1/"},{"categories":["Flask"],"content":"正则匹配路由 在 web 开发中，可能会出现限制用户访问规则的场景，那么这个时候就需要用到正则匹配，根据自己的规则去限定请求参数再进行访问，具体实现步骤为： 导入转换器基类：在 Flask 中，所有的路由的匹配规则都是使用转换器对象进行记录 自定义转换器：自定义类继承于转换器基类 添加转换器到默认的转换器字典中 使用自定义转换器实现自定义匹配规则 代码实现 导入转换器基类 from werkzeug.routing import BaseConverter 自定义转换器 # 自定义正则转换器 class RegexConverter(BaseConverter): def __init__(self, url_map, *args): super(RegexConverter, self).__init__(url_map) # 将接受的第1个参数当作匹配规则进行保存 self.regex = args[0] 添加转换器到默认的转换器字典中，并指定转换器使用时名字为: re app = Flask(__name__) # 将自定义转换器添加到转换器字典中，并指定转换器使用时名字为: re app.url_map.converters['re'] = RegexConverter 使用转换器去实现自定义匹配规则，当前此处定义的规则是：3位数字 @app.route('/user/\u003cre(\"[0-9]{3}\"):user_id\u003e') def user_info(user_id): return \"user_id 为 %s\" % user_id 运行测试：http://127.0.0.1:5000/user/123 ，如果访问的url不符合规则，会提示找不到页面 自定义转换器其他两个函数实现 继承于自定义转换器之后，还可以实现 to_python 和 to_url 这两个函数去对匹配参数做进一步处理： to_python： 该函数参数中的 value 值代表匹配到的值，可输出进行查看，匹配完成之后，对匹配到的参数作最后一步处理再返回，比如：转成 int 类型的值再返回： class RegexConverter(BaseConverter): def __init__(self, url_map, *args): super(RegexConverter, self).__init__(url_map) # 将接受的第1个参数当作匹配规则进行保存 self.regex = args[0] def to_python(self, value): return int(value) 运行测试，在视图函数中可以查看参数的类型，由之前默认的 str 已变成 int 类型的值 to_url: 在使用 url_for 去获取视图函数所对应的 url 的时候，会调用此方法对 url_for 后面传入的视图函数参数做进一步处理，具体可参见 Flask 的 app.py 中写的示例代码：ListConverter 系统自带转换器 DEFAULT_CONVERTERS = { 'default': UnicodeConverter, 'string': UnicodeConverter, 'any': AnyConverter, 'path': PathConverter, 'int': IntegerConverter, 'float': FloatConverter, 'uuid': UUIDConverter, } 系统自带的转换器具体使用方式在每种转换器的注释代码中有写，请留意每种转换器初始化的参数。 ","date":"2020-05-16","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E8%A7%86%E5%9B%BE%E5%8F%8A%E8%B7%AF%E7%94%B1/:1:2","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:视图及路由","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E8%A7%86%E5%9B%BE%E5%8F%8A%E8%B7%AF%E7%94%B1/"},{"categories":["Flask"],"content":"装饰器路由 两大核心 Flask有两大核心：Werkzeug和Jinja2 - Werkzeug实现路由、调试和Web服务器网关接口 - Jinja2实现了模板。 Werkzeug Werkzeug是一个遵循WSGI协议的python函数库 - 其内部实现了很多Web框架底层的东西，比如request和response对象； - 与WSGI规范的兼容；支持Unicode； - 支持基本的会话管理和签名Cookie； - 集成URL请求路由等。 Werkzeug库的 routing 模块负责实现 URL 解析。不同的 URL 对应不同的视图函数，routing模块会对请求信息的URL进行解析，匹配到URL对应的视图函数，执行该函数以此生成一个响应信息。routing模块内部有： Rule类：用来构造不同的URL模式的对象，路由URL规则 Map类：存储所有的URL规则和一些配置参数 BaseConverter的子类：负责定义匹配规则 MapAdapter类：负责协调Rule做具体的匹配的工作 ","date":"2020-05-16","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E8%A7%86%E5%9B%BE%E5%8F%8A%E8%B7%AF%E7%94%B1/:1:3","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:视图及路由","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E8%A7%86%E5%9B%BE%E5%8F%8A%E8%B7%AF%E7%94%B1/"},{"categories":["Flask"],"content":"视图 ","date":"2020-05-16","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E8%A7%86%E5%9B%BE%E5%8F%8A%E8%B7%AF%E7%94%B1/:2:0","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:视图及路由","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E8%A7%86%E5%9B%BE%E5%8F%8A%E8%B7%AF%E7%94%B1/"},{"categories":["Flask"],"content":"作用 返回JSON 在使用 Flask 写一个接口时候需要给客户端返回 JSON 数据，在 Flask 中可以直接使用 jsonify 生成一个 JSON 的响应 # 返回JSON @app.route('/demo3') def demo3(): json_dict = { \"user_id\": 10, \"user_name\": \"laowang\" } return jsonify(json_dict) 提示 不推荐使用json.dumps转成 JSON 字符串直接返回，因为返回的数据要符合HTTP协议规范，如果是JSON需要指定 content-type:application/json 重定向 重定向到 百度 官网 # 重定向 @app.route('/demo4') def demo4(): return redirect('http://www.baidu.com') 重定向到自己写的视图函数，可以直接填写自己 url 路径，也可以使用 url_for 生成指定视图函数所对应的 url @app.route('/demo5') def demo5(): return 'demo5' # 重定向 @app.route('/demo6') def demo6(): return redirect(url_for('demo5')) 重定向到带有参数的视图函数，在 url_for 函数中传入参数 # 路由传递参数 @app.route('/user/\u003cint:user_id\u003e') def user_info(user_id): return 'hello %d' % user_id # 重定向 @app.route('/demo7') def demo7(): # 使用 url_for 生成指定视图函数所对应的 url return redirect(url_for('user_info', user_id=100)) 自定义状态码 在 Flask 中，可以很方便的返回自定义状态码，以实现不符合 http 协议的状态码，例如：status code: 666 @app.route('/demo8') def demo8(): return '状态码为 666', 666 ","date":"2020-05-16","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E8%A7%86%E5%9B%BE%E5%8F%8A%E8%B7%AF%E7%94%B1/:2:1","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:视图及路由","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E8%A7%86%E5%9B%BE%E5%8F%8A%E8%B7%AF%E7%94%B1/"},{"categories":["Flask"],"content":"请求勾子 ","date":"2020-05-16","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E8%A7%86%E5%9B%BE%E5%8F%8A%E8%B7%AF%E7%94%B1/:3:0","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:视图及路由","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E8%A7%86%E5%9B%BE%E5%8F%8A%E8%B7%AF%E7%94%B1/"},{"categories":["Flask"],"content":"为什么 在客户端和服务器交互的过程中，有些准备工作或扫尾工作需要处理，比如： 在请求开始时，建立数据库连接； 在请求开始时，根据需求进行权限校验； 在请求结束时，指定数据的交互格式； ","date":"2020-05-16","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E8%A7%86%E5%9B%BE%E5%8F%8A%E8%B7%AF%E7%94%B1/:3:1","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:视图及路由","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E8%A7%86%E5%9B%BE%E5%8F%8A%E8%B7%AF%E7%94%B1/"},{"categories":["Flask"],"content":"怎么用 为了让每个视图函数避免编写重复功能的代码，Flask提供了通用设施的功能，即请求钩子。请求钩子是通过装饰器的形式实现，Flask支持如下四种请求钩子： before_first_request：在处理第一个请求前执行 before_request：在每次请求前执行，如果在某修饰的函数中返回了一个响应，视图函数将不再被调用 after_request：如果没有抛出错误，在每次请求后执行，接受一个参数：视图函数作出的响应，在此函数中可以对响应值在返回之前做最后一步修改处理，需要将参数中的响应在此参数中进行返回 teardown_request：在每次请求后执行，接受一个参数：错误信息，如果有相关错误抛出 ","date":"2020-05-16","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E8%A7%86%E5%9B%BE%E5%8F%8A%E8%B7%AF%E7%94%B1/:3:2","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:视图及路由","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E8%A7%86%E5%9B%BE%E5%8F%8A%E8%B7%AF%E7%94%B1/"},{"categories":["Flask"],"content":"代码测试 from flask import Flask from flask import abort app = Flask(__name__) # 在第一次请求之前调用，可以在此方法内部做一些初始化操作 @app.before_first_request def before_first_request(): print(\"before_first_request\") # 在每一次请求之前调用，这时候已经有请求了，可能在这个方法里面做请求的校验 # 如果请求的校验不成功，可以直接在此方法中进行响应，直接return之后那么就不会执行视图函数 @app.before_request def before_request(): print(\"before_request\") # 在执行完视图函数之后会调用，并且会把视图函数所生成的响应传入,可以在此方法中对响应做最后一步统一的处理 @app.after_request def after_request(response): print(\"after_request\") response.headers[\"Content-Type\"] = \"application/json\" return response # 请每一次请求之后都会调用，会接受一个参数，参数是服务器出现的错误信息 @app.teardown_request def teardown_request(e): print(\"teardown_request\") @app.route('/') def index(): return 'index' if __name__ == '__main__': app.run(debug=True) 在第1次请求时的打印： before_first_request before_request after_request teardown_request 在第2次请求时的打印： before_request after_request teardown_request ","date":"2020-05-16","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E8%A7%86%E5%9B%BE%E5%8F%8A%E8%B7%AF%E7%94%B1/:3:3","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:视图及路由","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E8%A7%86%E5%9B%BE%E5%8F%8A%E8%B7%AF%E7%94%B1/"},{"categories":["Flask"],"content":"request ","date":"2020-05-16","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E8%A7%86%E5%9B%BE%E5%8F%8A%E8%B7%AF%E7%94%B1/:4:0","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:视图及路由","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E8%A7%86%E5%9B%BE%E5%8F%8A%E8%B7%AF%E7%94%B1/"},{"categories":["Flask"],"content":"简介 request 就是flask中代表当前请求的 request 对象，其中一个请求上下文变量(理解成全局变量，在视图函数中直接使用可以取到当前本次请求)，常用的属性如下： 属性 说明 类型 data 记录请求的数据，并转换为字符串 * form 记录请求中的表单数据 MultiDict args 记录请求中的查询参数 MultiDict cookies 记录请求中的cookie信息 Dict headers 记录请求中的报文头 EnvironHeaders method 记录请求使用的HTTP方法 GET/POST url 记录请求的URL地址 string files 记录请求上传的文件 * ","date":"2020-05-16","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E8%A7%86%E5%9B%BE%E5%8F%8A%E8%B7%AF%E7%94%B1/:4:1","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:视图及路由","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E8%A7%86%E5%9B%BE%E5%8F%8A%E8%B7%AF%E7%94%B1/"},{"categories":["Flask"],"content":"示例 获取上传的图片并保存到本地 @app.route('/', methods=['POST']) def index(): pic = request.files.get('pic') pic.save('./static/p.png') return 'index' ","date":"2020-05-16","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E8%A7%86%E5%9B%BE%E5%8F%8A%E8%B7%AF%E7%94%B1/:4:2","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:视图及路由","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E8%A7%86%E5%9B%BE%E5%8F%8A%E8%B7%AF%E7%94%B1/"},{"categories":["Flask"],"content":"状态保持 ","date":"2020-05-16","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E8%A7%86%E5%9B%BE%E5%8F%8A%E8%B7%AF%E7%94%B1/:5:0","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:视图及路由","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E8%A7%86%E5%9B%BE%E5%8F%8A%E8%B7%AF%E7%94%B1/"},{"categories":["Flask"],"content":"原因 因为 http 是一种无状态协议，浏览器请求服务器是无状态的。 ","date":"2020-05-16","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E8%A7%86%E5%9B%BE%E5%8F%8A%E8%B7%AF%E7%94%B1/:5:1","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:视图及路由","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E8%A7%86%E5%9B%BE%E5%8F%8A%E8%B7%AF%E7%94%B1/"},{"categories":["Flask"],"content":"无状态 指一次用户请求时，浏览器、服务器无法知道之前这个用户做过什么，每次请求都是一次新的请求。 ","date":"2020-05-16","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E8%A7%86%E5%9B%BE%E5%8F%8A%E8%B7%AF%E7%94%B1/:5:2","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:视图及路由","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E8%A7%86%E5%9B%BE%E5%8F%8A%E8%B7%AF%E7%94%B1/"},{"categories":["Flask"],"content":"无状态原因 浏览器与服务器是使用 socket 套接字进行通信的，服务器将请求结果返回给浏览器之后，会关闭当前的 socket 连接，而且服务器也会在处理页面完毕之后销毁页面对象。 ","date":"2020-05-16","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E8%A7%86%E5%9B%BE%E5%8F%8A%E8%B7%AF%E7%94%B1/:5:3","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:视图及路由","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E8%A7%86%E5%9B%BE%E5%8F%8A%E8%B7%AF%E7%94%B1/"},{"categories":["Flask"],"content":"实现状态保持的方式 在客户端存储信息使用Cookie 在服务器端存储信息使用Session 提示 无状态协议：协议对于事务处理没有记忆能力，对同一个 url 请求没有上下文关系，每次的请求都是独立的，它的执行情况和结果与前面的请求和之后的请求是无直接关系的，它不会受前面的请求应答情况直接影响，也不会直接影响后面的请求应答情况，服务器中没有保存客户端的状态，客户端必须每次带上自己的状态去请求服务器 Cookie 简介 指某些网站为了辨别用户身份、进行会话跟踪而储存在用户本地的数据（通常经过加密）。Cookie最早是网景公司的前雇员Lou Montulli在1993年3月的发明。Cookie是由服务器端生成，发送给客户端浏览器，浏览器会将Cookie的key/value保存，下次请求同一网站时就发送该Cookie给服务器（前提是浏览器设置为启用cookie）。Cookie的key/value可以由服务器端自己定义。 提示 Cookie是存储在浏览器中的一段纯文本信息，建议不要存储敏感信息如密码，因为电脑上的浏览器可能被其它人使用，Cookie基于域名安全，不同域名的Cookie是不能互相访问的，如访问baidu.com时向浏览器中写了Cookie信息，使用同一浏览器访问google.com时，无法访问到baidu.com写的Cookie信息。浏览器的同源策略，当浏览器请求某网站时，会将本网站下所有Cookie信息提交给服务器，所以在request中可以读取Cookie信息 设置 from flask imoprt Flask,make_response @app.route('/cookie') def set_cookie(): resp = make_response('this is to set cookie') resp.set_cookie('username', 'xiaoliang') return resp 设置过期时间 @app.route('/cookie') def set_cookie(): response = make_response('this is to set cookie') response.set_cookie('username', 'xiaoliang', max_age=3600) return response 获取 from flask import Flask,request #获取cookie @app.route('/request') def resp_cookie(): resp = request.cookies.get('username') return resp Session 简介 对于敏感、重要的信息，建议要存储在服务器端，不能存储在浏览器中，如用户名、余额、等级、验证码等信息。在服务器端进行状态保持的方案就是Session 提示 Session依赖于Cookie 获取 session:请求上下文对象，用于处理http请求中的一些数据内容 @app.route('/index1') def index1(): session['username'] = 'xiaoliang' return redirect(url_for('index')) @app.route('/') def index(): return session.get('username') ","date":"2020-05-16","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E8%A7%86%E5%9B%BE%E5%8F%8A%E8%B7%AF%E7%94%B1/:5:4","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:视图及路由","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E8%A7%86%E5%9B%BE%E5%8F%8A%E8%B7%AF%E7%94%B1/"},{"categories":["Flask"],"content":"上下文 ","date":"2020-05-16","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E8%A7%86%E5%9B%BE%E5%8F%8A%E8%B7%AF%E7%94%B1/:6:0","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:视图及路由","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E8%A7%86%E5%9B%BE%E5%8F%8A%E8%B7%AF%E7%94%B1/"},{"categories":["Flask"],"content":"简介 相当于一个容器，保存了 Flask 程序运行过程中的一些信息。Flask中有两种上下文，请求上下文和应用上下文 ","date":"2020-05-16","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E8%A7%86%E5%9B%BE%E5%8F%8A%E8%B7%AF%E7%94%B1/:6:1","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:视图及路由","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E8%A7%86%E5%9B%BE%E5%8F%8A%E8%B7%AF%E7%94%B1/"},{"categories":["Flask"],"content":"请求上下文(request context) 简介 在 flask 中，可以直接在视图函数中使用request这个对象进行获取相关数据，而request就是请求上下文的对象，保存了当前本次请求的相关数据，请求上下文对象有：request、session request 封装了HTTP请求的内容，针对的是http请求。举例：user = request.args.get(‘user’)，获取的是get请求的参数。 session 用来记录请求会话中的信息，针对的是用户信息。举例：session[‘name’] = user.id，可以记录用户信息。还可以通过session.get(‘name’)获取用户信息。 ","date":"2020-05-16","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E8%A7%86%E5%9B%BE%E5%8F%8A%E8%B7%AF%E7%94%B1/:6:2","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:视图及路由","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E8%A7%86%E5%9B%BE%E5%8F%8A%E8%B7%AF%E7%94%B1/"},{"categories":["Flask"],"content":"应用上下文(application context) 简介 它的字面意思是 应用上下文，但它不是一直存在的，它只是request context 中的一个对 app 的代理(人)，所谓local proxy。它的作用主要是帮助 request 获取当前的应用，它是伴 request 而生，随 request 而灭的。应用上下文对象有：current_app，g current_app 应用程序上下文,用于存储应用程序中的变量，可以通过current_app.name打印当前app的名称，也可以在current_app中存储一些变量，例如： 应用的启动脚本是哪个文件，启动时指定了哪些参数 加载了哪些配置文件，导入了哪些配置 连了哪个数据库 有哪些public的工具类、常量 应用跑再哪个机器上，IP多少，内存多大 current_app.name current_app.test_value='value' g变量 g 作为 flask 程序全局的一个临时变量,充当者中间媒介的作用,我们可以通过它传递一些数据，g 保存的是当前请求的全局变量，不同的请求会有不同的全局变量，通过不同的thread id区别 g.name='abc' 注意 不同的请求，会有不同的全局变量 两者区别 请求上下文：保存了客户端和服务器交互的数据 应用上下文：flask 应用程序运行过程中，保存的一些配置信息，比如程序名、数据库连接、应用信息等 ","date":"2020-05-16","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E8%A7%86%E5%9B%BE%E5%8F%8A%E8%B7%AF%E7%94%B1/:6:3","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:视图及路由","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E8%A7%86%E5%9B%BE%E5%8F%8A%E8%B7%AF%E7%94%B1/"},{"categories":["Flask"],"content":"Flask-Script 扩展 ","date":"2020-05-16","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E8%A7%86%E5%9B%BE%E5%8F%8A%E8%B7%AF%E7%94%B1/:7:0","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:视图及路由","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E8%A7%86%E5%9B%BE%E5%8F%8A%E8%B7%AF%E7%94%B1/"},{"categories":["Flask"],"content":"为什么 通过使用Flask-Script扩展，我们可以在Flask服务器启动的时候，通过命令行的方式传入参数。而不仅仅通过app.run()方法中传参，比如我们可以通过： python hello.py runserver -host ip地址 以上代码告诉服务器在哪个网络接口监听来自客户端的连接。默认情况下，服务器只监听来自服务器所在的计算机发起的连接，即localhost连接。 我们可以通过python hello.py runserver –help来查看参数。 ","date":"2020-05-16","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E8%A7%86%E5%9B%BE%E5%8F%8A%E8%B7%AF%E7%94%B1/:7:1","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:视图及路由","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E8%A7%86%E5%9B%BE%E5%8F%8A%E8%B7%AF%E7%94%B1/"},{"categories":["Flask"],"content":"代码实现 安装 Flask-Script 扩展 pip install flask-script 集成 Flask-Script from flask import Flask from flask_script import Manager app = Flask(__name__) # 把 Manager 类和应用程序实例进行关联 manager = Manager(app) @app.route('/') def index(): return 'Hello flask-script' if __name__ == \"__main__\": manager.run() 提示 Flask-Script 还可以为当前应用程序添加脚本命令 ","date":"2020-05-16","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E8%A7%86%E5%9B%BE%E5%8F%8A%E8%B7%AF%E7%94%B1/:7:2","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:视图及路由","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80%E8%A7%86%E5%9B%BE%E5%8F%8A%E8%B7%AF%E7%94%B1/"},{"categories":["Flask"],"content":"前言 Web(World Wide Web)诞生最初的目的，是为了利用互联网交流工作文档。web网站发展至今，特别是服务器端，涉及到的知识、内容，非常广泛。这对程序员的要求会越来越高。如果采用成熟，稳健的框架，那么一些基础的工作，比如，安全性，数据流控制等都可以让框架来处理，那么程序开发人员可以把精力放在具体的业务逻辑上面。使用框架的优点： 稳定性和可扩展性强 可以降低开发难度，提高开发效率。 总结一句话：避免重复造轮子。在 Python 中常用的 Web 框架有：flask、django、tornado等 ","date":"2020-05-09","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80helloflask/:1:0","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:HelloFlask","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80helloflask/"},{"categories":["Flask"],"content":"简介 Flask诞生于2010年，是Armin ronacher（人名）用 Python 语言基于 Werkzeug 工具箱编写的轻量级Web开发框架。Flask 本身相当于一个内核，其他几乎所有的功能都要用到扩展（邮件扩展Flask-Mail，用户认证Flask-Login，数据库Flask-SQLAlchemy），都需要用第三方的扩展来实现。比如可以用 Flask 扩展加入ORM、窗体验证工具，文件上传、身份验证等。Flask 没有默认使用的数据库，你可以选择 MySQL，也可以用 NoSQL。其 WSGI 工具箱采用 Werkzeug（路由模块），模板引擎则使用 Jinja2。这两个也是 Flask 框架的核心。 ","date":"2020-05-09","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80helloflask/:2:0","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:HelloFlask","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80helloflask/"},{"categories":["Flask"],"content":"相关文档 英文文档（https://flask.palletsprojects.com/） 中文文档（http://docs.jinkan.org/docs/flask/） ","date":"2020-05-09","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80helloflask/:3:0","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:HelloFlask","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80helloflask/"},{"categories":["Flask"],"content":"Hello Flask 创建项目文件夹 mkdir hello_flask 创建虚拟环境 pipenv install 使用虚拟环境 pipenv shell 安装flask (hello_flask) % hello_flask % pip install flask==1.1.1 创建项目文件 (hello_flask) % touch helloflask.py 编辑项目 使用vim编辑 (hello_flask) % vim helloflask.py 内容如下： from flask import Flask app = Flask(__name__) @app.route('/') def index(): return 'Hello Flask' if __name__ == '__main__': app.run() 运行项目 (hello_flask) % python helloflask.py 运行成功时会看到输出的提示信息： * Serving Flask app \"helloflask\" (lazy loading) * Environment: production WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead. * Debug mode: off * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit) 这时候打开浏览器输入http://127.0.0.1:5000/看到Hello Flask就说明运行成功了 目前已经实现了一个最简单的 Flask 应用程序，只使用了7行代码，接来对 Flask 程序的创建，运行配置做进一步的了解 ","date":"2020-05-09","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80helloflask/:4:0","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:HelloFlask","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80helloflask/"},{"categories":["Flask"],"content":"相关配置参数 ","date":"2020-05-09","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80helloflask/:5:0","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:HelloFlask","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80helloflask/"},{"categories":["Flask"],"content":"初始化参数 Flask 程序实例在创建的时候，需要默认传入当前 Flask 程序所指定的包(模块)，接下来就来详细查看一下 Flask 应用程序在创建的时候一些需要我们关注的参数： import_name：Flask程序所在的包(模块)，传 __name__ 就可以，其可以决定 Flask 在访问静态文件时查找的路径 static_path：静态文件访问路径(不推荐使用，使用 static_url_path 代替) static_url_path：静态文件访问路径，可以不传，默认为：/ + static_folder static_folder：静态文件存储的文件夹，可以不传，默认为 static template_folder：模板文件存储的文件夹，可以不传，默认为 templates ","date":"2020-05-09","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80helloflask/:5:1","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:HelloFlask","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80helloflask/"},{"categories":["Flask"],"content":"程序加载配置 在 Flask 程序运行的时候，可以给 Flask 设置相关配置，比如：配置 Debug 模式，配置数据库连接地址等等，设置 Flask 配置有以下三种方式： 从配置对象中加载(常用)：app.config.form_object() 从配置文件中加载：app.config.form_pyfile() 从环境变量中加载(了解)：app.config.from_envvar() 以下演练以设置应用程序的 DEBUG(调试模式) 为例，设置应用为调式模式这后，可以实现以下功能： 程序代码修改后可以自动重启服务器 在服务器出现相关错误的时候可以直接将错误信息进行抛出到控制台打印 使用方式 配置对象 从配置对象中加载，创建配置的类，代码如下： # 配置对象，里面定义需要给 APP 添加的一系列配置 class Config(object): DEBUG = True # 创建 Flask 类的对象,指向程序所在的包的名称 app = Flask(__name__) # 从配置对象中加载配置 app.config.from_object(Config) 运行测试，在修改代码之后直接保存，会自动重启服务器 配置文件 创建配置文件 config.ini，在配置文件中添加配置DEBUG = True 使用代码去加载配置 # 创建 Flask 类的对象,指向程序所在的包的名称 app = Flask(__name__) # 从配置文件中加载配置 app.config.from_pyfile('config.ini') 环境变量(了解) 编辑运行的相关配置 使用代码去加载配置 # 创建 Flask 类的对象,指向程序所在的包的名称 app = Flask(__name__) # 加载指定环境变量名称所对应的相关配置 app.config.from_envvar('FLASKCONFIG') 读取配置 app.config.get() 在视图函数中使用 current_app.config.get() 提示 Flask 应用程序将一些常用的配置设置成了应用程序对象的属性，也可以通过属性直接设置/获取某些配置：app.debug = True app.run的参数 可以指定运行的主机IP地址，端口，是否开启调试模式等 app.run(host=\"0.0.0.0\", port=5000, debug = True) ","date":"2020-05-09","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80helloflask/:5:2","tags":["Python学习之路"],"title":"Python学习之路-Flask基础:HelloFlask","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E5%9F%BA%E7%A1%80helloflask/"},{"categories":["Python"],"content":"简介 Python中的拷贝机制有两种，一种是深拷贝一种是浅拷贝，下面深入学习一下： ","date":"2020-04-25","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/:1:0","tags":["Python学习之路"],"title":"Python学习之路-深拷贝与浅拷贝","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/"},{"categories":["Python"],"content":"浅拷贝 ","date":"2020-04-25","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/:2:0","tags":["Python学习之路"],"title":"Python学习之路-深拷贝与浅拷贝","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/"},{"categories":["Python"],"content":"简介 浅拷贝是对于一个对象的顶层拷贝，通俗的理解是：拷贝了引用，并没有拷贝内容。 ","date":"2020-04-25","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/:2:1","tags":["Python学习之路"],"title":"Python学习之路-深拷贝与浅拷贝","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/"},{"categories":["Python"],"content":"例子 \u003e\u003e\u003e a = [1,2,3] \u003e\u003e\u003e b = a \u003e\u003e\u003e id(a) 4382391344 \u003e\u003e\u003e id(b) 4382391344 a和b指向的数据的内存地址相同，说明变量在赋值时就是将数据的引用复制了一份给另一个变量 ","date":"2020-04-25","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/:2:2","tags":["Python学习之路"],"title":"Python学习之路-深拷贝与浅拷贝","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/"},{"categories":["Python"],"content":"深拷贝 ","date":"2020-04-25","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/:3:0","tags":["Python学习之路"],"title":"Python学习之路-深拷贝与浅拷贝","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/"},{"categories":["Python"],"content":"简介 深拷贝是对于一个对象所有层次的拷贝(递归) ","date":"2020-04-25","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/:3:1","tags":["Python学习之路"],"title":"Python学习之路-深拷贝与浅拷贝","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/"},{"categories":["Python"],"content":"例子 \u003e\u003e\u003e c = copy.deepcopy(a) \u003e\u003e\u003e id(a) 4382391344 \u003e\u003e\u003e id(c) 4383457680 \u003e\u003e\u003e id(a[0]) 4379642784 \u003e\u003e\u003e id(b[0]) 4379642784 \u003e\u003e\u003e id(c[0]) 4379642784 浅拷贝列表里的元素也是直接拷贝的引用，深拷贝则是进行了深层次的拷贝，所有内存地址都不一样 ","date":"2020-04-25","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/:3:2","tags":["Python学习之路"],"title":"Python学习之路-深拷贝与浅拷贝","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/"},{"categories":["Python"],"content":"copy 浅拷贝可以使用copy.copy来实现。对不可变类型和可变类型的copy不同，copy.copy对于可变类型会进行浅拷贝，对于不可变类型不会拷贝仅仅是指向。 \u003e\u003e\u003e a.append(4) \u003e\u003e\u003e a [1, 2, 3, 4] \u003e\u003e\u003e b [1, 2, 3, 4] \u003e\u003e\u003e d [1, 2, 3] ","date":"2020-04-25","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/:4:0","tags":["Python学习之路"],"title":"Python学习之路-深拷贝与浅拷贝","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/"},{"categories":["Python"],"content":"copy.copy和copy.deepcopy的区别 \u003e\u003e\u003e a = [1,2,3] \u003e\u003e\u003e b = (a,) \u003e\u003e\u003e c = [b,] \u003e\u003e\u003e d = copy.copy(c) \u003e\u003e\u003e c [([1, 2, 3],)] \u003e\u003e\u003e d [([1, 2, 3],)] \u003e\u003e\u003e a.append(4) \u003e\u003e\u003e c [([1, 2, 3, 4],)] \u003e\u003e\u003e d [([1, 2, 3, 4],)] \u003e\u003e\u003e id(c) 4383457680 \u003e\u003e\u003e id(d) 4382391344 \u003e\u003e\u003e id(c[0]) 4383618320 \u003e\u003e\u003e id(d[0]) 4383618320 d = c让d这个变量指向c指向的空间，d = copy.copy是赋值所有c指向的数据到一个新的空间，但是不会递归copy \u003e\u003e\u003e e = copy.deepcopy(c) \u003e\u003e\u003e c [([1, 2, 3, 4],)] \u003e\u003e\u003e e [([1, 2, 3, 4],)] \u003e\u003e\u003e id(c) 4383457680 \u003e\u003e\u003e id(e) 4383582240 \u003e\u003e\u003e id(c[0]) 4383618320 \u003e\u003e\u003e id(e[0]) 4384001616 \u003e\u003e\u003e a.append(5) \u003e\u003e\u003e c [([1, 2, 3, 4, 5],)] \u003e\u003e\u003e d [([1, 2, 3, 4, 5],)] \u003e\u003e\u003e e [([1, 2, 3, 4],)] 当使用copy.deepcopy后会将c指向的空间进行递归copy，相当于进行了深层次的拷贝，所以改变a不会影响到e ","date":"2020-04-25","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/:4:1","tags":["Python学习之路"],"title":"Python学习之路-深拷贝与浅拷贝","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/"},{"categories":["Python"],"content":"简介 Python的内存管理机制可以总结为：引用计数、垃圾回收、内存池。 ","date":"2020-04-18","objectID":"/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/:1:0","tags":["Python学习之路"],"title":"Python学习之路-内存管理","uri":"/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"},{"categories":["Python"],"content":"引用计数 引用计数是一种非常高效的内存管理手段， 当一个 Python 对象被引用时其引用计数增加 1， 当其不再被一个变量引用时则计数减 1. 当引用计数等于 0 时对象被删除。 ","date":"2020-04-18","objectID":"/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/:2:0","tags":["Python学习之路"],"title":"Python学习之路-内存管理","uri":"/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"},{"categories":["Python"],"content":"垃圾回收 ","date":"2020-04-18","objectID":"/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/:3:0","tags":["Python学习之路"],"title":"Python学习之路-内存管理","uri":"/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"},{"categories":["Python"],"content":"引用计数 引用计数也是一种垃圾收集机制，而且也是一种最直观，最简单的垃圾收集技术。当 Python 的某 个对象的引用计数降为 0 时，说明没有任何引用指向该对象，该对象就成为要被回收的垃圾了。比如 某个新建对象，它被分配给某个引用，对象的引用计数变为 1。如果引用被删除，对象的引用计数为 0， 那么该对象就可以被垃圾回收。不过如果出现循环引用的话，引用计数机制就不再起有效的作用了 ","date":"2020-04-18","objectID":"/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/:3:1","tags":["Python学习之路"],"title":"Python学习之路-内存管理","uri":"/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"},{"categories":["Python"],"content":"标记清除 如果两个对象的引用计数都为 1，但是仅仅存在他们之间的循环引用，那么这两个对象都是需要被 回收的，也就是说，它们的引用计数虽然表现为非 0，但实际上有效的引用计数为 0。所以先将循环引 用摘掉，就会得出这两个对象的有效计数。 ","date":"2020-04-18","objectID":"/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/:3:2","tags":["Python学习之路"],"title":"Python学习之路-内存管理","uri":"/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"},{"categories":["Python"],"content":"分代回收 从前面“标记-清除”这样的垃圾收集机制来看，这种垃圾收集机制所带来的额外操作实际上与系统 中总的内存块的数量是相关的，当需要回收的内存块越多时，垃圾检测带来的额外操作就越多，而垃圾 回收带来的额外操作就越少；反之，当需回收的内存块越少时，垃圾检测就将比垃圾回收带来更少的额 外操作。 ","date":"2020-04-18","objectID":"/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/:3:3","tags":["Python学习之路"],"title":"Python学习之路-内存管理","uri":"/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"},{"categories":["Python"],"content":"内存池 ","date":"2020-04-18","objectID":"/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/:4:0","tags":["Python学习之路"],"title":"Python学习之路-内存管理","uri":"/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"},{"categories":["Python"],"content":"简介 Python 的内存机制呈现金字塔形状，-1，-2 层主要有操作系统进行操作，第 0 层是 C 中的 malloc，free 等内存分配和释放函数进行操作，第 1 层和第 2 层是内存池，有 Python 的接口函数 PyMem_Malloc 函数实现，当对象小于256K 时有该层直接分配内存，第 3 层是最上层，也就是我们对 Python 对象的直接操作。 Python 在运行期间会大量地执行 malloc 和 free 的操作，频繁地在用户态和核心态之间进行切换，这将严重影响 Python 的执行效率。为了加速 Python 的执行效率，Python 引入了一个内存池机制，用于管理对小块内存的申请和释放。 Python 内部默认的小块内存与大块内存的分界点定在 256 个字节，当申请的内存小于 256 字节时，PyObject_Malloc 会在内存池中申请内存；当申请的内存大于 256 字节时，PyObject_Malloc 的行为将蜕化为 malloc 的行为。当然，通过修改 Python 源代码，我们可以改变这个默认值，从而改 变 Python 的默认内存管理行为。 ","date":"2020-04-18","objectID":"/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/:4:1","tags":["Python学习之路"],"title":"Python学习之路-内存管理","uri":"/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"},{"categories":["Python"],"content":"调优手段 手动垃圾回 调高垃圾回收阈值 避免循环引用（手动解循环引用和使用弱引用） ","date":"2020-04-18","objectID":"/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/:4:2","tags":["Python学习之路"],"title":"Python学习之路-内存管理","uri":"/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"},{"categories":["Python"],"content":"内存泄露 是什么？ 指由于疏忽或错误造成程序未能释放已经不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。导致程序运行速度减慢甚至系统崩溃等严重后果。 有 del() 函数的对象间的循环引用是导致内存泄漏的主凶。 如何避免？ 不使用一个对象时使用:del object 来删除一个对象的引用计数就可以有效防止内存泄漏问题。 通过 Python 扩展模块 gc 来查看不能回收的对象的详细信息。 可以通过 sys.getrefcount(obj) 来获取对象的引用计数，并根据返回值是否为 0 来判断是否内存 泄漏。 ","date":"2020-04-18","objectID":"/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/:4:3","tags":["Python学习之路"],"title":"Python学习之路-内存管理","uri":"/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"},{"categories":["Redis"],"content":"主从 ","date":"2020-04-11","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E8%BF%9B%E9%98%B6/:1:0","tags":["Python学习之路"],"title":"Python学习之路-Redis进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E8%BF%9B%E9%98%B6/"},{"categories":["Redis"],"content":"概念 ⼀个master可以拥有多个slave，⼀个slave⼜可以拥有多个slave，如此下去，形成了强⼤的多级服务器集群架构。master用来写数据，slave用来读数据，经统计：网站的读写比率是10:1，通过主从配置可以实现读写分离。master和slave都是一个redis实例(redis服务) ","date":"2020-04-11","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E8%BF%9B%E9%98%B6/:1:1","tags":["Python学习之路"],"title":"Python学习之路-Redis进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E8%BF%9B%E9%98%B6/"},{"categories":["Redis"],"content":"配置 主服务器 修改etc/redis/redis.conf文件 sudo vi redis.conf bind 192.168.1.1 重启redis服务 sudo service redis stop redis-server redis.conf 从服务器 复制etc/redis/redis.conf文件 sudo cp redis.conf ./slave.conf 修改redis/slave.conf文件 sudo vi slave.conf 编辑内容 bind 192.168.1.1 slaveof 192.168.1.1 6379 port 6378 配置redis服务 sudo redis-server slave.conf 查看主从关系 redis-cli -h 192.168.26.128 info Replication ","date":"2020-04-11","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E8%BF%9B%E9%98%B6/:1:2","tags":["Python学习之路"],"title":"Python学习之路-Redis进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E8%BF%9B%E9%98%B6/"},{"categories":["Redis"],"content":"数据操作 在master和slave分别执⾏info命令，查看输出信息 进入主客户端 redis-cli -h 192.168.1.1 -p 6379 进入从的客户端 redis-cli -h 192.168.26.128 -p 6378 在master上写数据 在slave上读数据 ","date":"2020-04-11","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E8%BF%9B%E9%98%B6/:1:3","tags":["Python学习之路"],"title":"Python学习之路-Redis进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E8%BF%9B%E9%98%B6/"},{"categories":["Redis"],"content":"集群 ","date":"2020-04-11","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E8%BF%9B%E9%98%B6/:2:0","tags":["Python学习之路"],"title":"Python学习之路-Redis进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E8%BF%9B%E9%98%B6/"},{"categories":["Redis"],"content":"为什么要有 之前我们已经讲了主从的概念，一主可以多从，如果同时的访问量过大(1000w),主服务肯定就会挂掉，数据服务就挂掉了或者发生自然灾难。大公司都会有很多的服务器(华东地区、华南地区、华中地区、华北地区、西北地区、西南地区、东北地区、台港澳地区机房) ","date":"2020-04-11","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E8%BF%9B%E9%98%B6/:2:1","tags":["Python学习之路"],"title":"Python学习之路-Redis进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E8%BF%9B%E9%98%B6/"},{"categories":["Redis"],"content":"概念 集群是一组相互独立的、通过高速网络互联的计算机，它们构成了一个组，并以单一系统的模式加以管理。一个客户与集群相互作用时，集群像是一个独立的服务器。集群配置是用于提高可用性和可缩放性。当请求到来首先由负载均衡服务器处理，把请求转发到另外的一台服务器上。 ","date":"2020-04-11","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E8%BF%9B%E9%98%B6/:2:2","tags":["Python学习之路"],"title":"Python学习之路-Redis进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E8%BF%9B%E9%98%B6/"},{"categories":["Redis"],"content":"分类 软件层面：只有一台电脑，在这一台电脑上启动了多个redis服务。 硬件层面：存在多台实体的电脑，每台电脑上都启动了一个redis或者多个redis服务。 ","date":"2020-04-11","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E8%BF%9B%E9%98%B6/:2:3","tags":["Python学习之路"],"title":"Python学习之路-Redis进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E8%BF%9B%E9%98%B6/"},{"categories":["Redis"],"content":"搭建 配置机器1 在conf⽬录下创建⽂件7000.conf，编辑内容如下 port 7000 bind 192.168.1.1 daemonize yes pidfile 7000.pid cluster-enabled yes cluster-config-file 7000_node.conf cluster-node-timeout 15000 appendonly yes 在conf⽬录下创建⽂件7001.conf，编辑内容如下 port 7001 bind 192.168.1.1 daemonize yes pidfile 7001.pid cluster-enabled yes cluster-config-file 7001_node.conf cluster-node-timeout 15000 appendonly yes 在conf⽬录下创建⽂件7002.conf，编辑内容如下 port 7002 bind 192.168.1.1 daemonize yes pidfile 7002.pid cluster-enabled yes cluster-config-file 7002_node.conf cluster-node-timeout 15000 三个⽂件的配置区别在port、pidfile、cluster-config-file三项 使⽤配置⽂件启动redis服务 redis-server 7000.conf redis-server 7001.conf redis-server 7002.conf 配置机器2 在conf⽬录下创建⽂件7003.conf，编辑内容如下 port 7003 bind 192.168.1.2 daemonize yes pidfile 7003.pid cluster-enabled yes cluster-config-file 7003_node.conf cluster-node-timeout 15000 appendonly yes 在conf⽬录下创建⽂件7004.conf，编辑内容如下 port 7004 bind 192.168.1.2 daemonize yes pidfile 7004.pid cluster-enabled yes cluster-config-file 7004_node.conf cluster-node-timeout 15000 appendonly yes 在conf⽬录下创建⽂件7005.conf，编辑内容如下 port 7005 bind 192.168.1.2 daemonize yes pidfile 7005.pid cluster-enabled yes cluster-config-file 7005_node.conf cluster-node-timeout 15000 appendonly yes 三个⽂件的配置区别在port、pidfile、cluster-config-file三项 使⽤配置⽂件启动redis服务 redis-server 7003.conf redis-server 7004.conf redis-server 7005.conf 创建集群 redis的安装包中包含了redis-trib.rb，⽤于创建集群，接下来的操作在191.168.1.1机器上进⾏将命令复制，这样可以在任何⽬录下调⽤此命令： sudo cp /usr/share/doc/redis-tools/examples/redis-trib.rb /usr/local/bin/ 安装ruby环境，因为redis-trib.rb是⽤ruby开发的 sudo apt-get install ruby 在提示信息处输⼊y，然后回⻋继续安装 运⾏如下命令创建集群 redis-trib.rb create --replicas 1 191.168.1.1:7000 192.168.1.1:7001 192.168.1.1:7002 192.168.1.2:7003 192.168.1.2:7004 192.168.1.2:7000 执⾏上⾯这个指令在某些机器上可能会报错，主要原因是由于安装的ruby不是最新版本！天朝的防⽕墙导致⽆法下载最新版本，所以需要设置 gem 的源解决办法如下： -- 先查看⾃⼰的 gem 源是什么地址 gem source -l -- 如果是https://rubygems.org/ 就需要更换 -- 更换指令为 gem sources --add https://gems.ruby-china.org/ --remove https://rubygems.org/ -- 通过 gem 安装 redis 的相关依赖 sudo gem install redis -- 然后重新执⾏指令 提示完成，集群搭建成功 数据验证 当前搭建的主服务器为7000、7001、7003，对应的从服务器是7004、7005、7002，在192.168.1.2机器上连接7002，加参数-c表示连接到集群 redis-cli -h 172.16.179.131 -c -p 7002 写⼊数据，⾃动跳到了7003服务器，并写⼊数据成功，在7003可以获取数据，如果写入数据又重定向到7000(负载均衡) ","date":"2020-04-11","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E8%BF%9B%E9%98%B6/:2:4","tags":["Python学习之路"],"title":"Python学习之路-Redis进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E8%BF%9B%E9%98%B6/"},{"categories":["Redis"],"content":"在哪个服务器上写数据：CRC16 redis cluster在设计的时候，就考虑到了去中⼼化，去中间件，也就是说，集群中 的每个节点都是平等的关系，都是对等的，每个节点都保存各⾃的数据和整个集 群的状态。每个节点都和其他所有节点连接，⽽且这些连接保持活跃，这样就保 证了我们只需要连接集群中的任意⼀个节点，就可以获取到其他节点的数据 Redis集群没有并使⽤传统的⼀致性哈希来分配数据，⽽是采⽤另外⼀种叫做哈希 槽 (hash slot)的⽅式来分配的。redis cluster 默认分配了 16384 个slot，当我们 set⼀个key 时，会⽤CRC16算法来取模得到所属的slot，然后将这个key 分到哈 希槽区间的节点上，具体算法就是：CRC16(key) % 16384。所以我们在测试的 时候看到set 和 get 的时候，直接跳转到了7000端⼝的节点 Redis 集群会把数据存在⼀个 master 节点，然后在这个 master 和其对应的salve 之间进⾏数据同步。当读取数据时，也根据⼀致性哈希算法到对应的 master 节 点获取数据。只有当⼀个master 挂掉之后，才会启动⼀个对应的 salve 节点，充 当 master 需要注意的是：必须要3个或以上的主节点，否则在创建集群时会失败，并且当存 活的主节点数⼩于总节点数的⼀半时，整个集群就⽆法提供服务了 ","date":"2020-04-11","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E8%BF%9B%E9%98%B6/:2:5","tags":["Python学习之路"],"title":"Python学习之路-Redis进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E8%BF%9B%E9%98%B6/"},{"categories":["Redis"],"content":"Python交互 安装包：pip install redis-py-cluster，redis-py-cluster源码地址https://github.com/Grokzen/redis-py-cluster 创建⽂件redis_cluster.py，示例码如下： from rediscluster import * if __name__ == '__main__': try: # 构建所有的节点，Redis会使⽤CRC16算法，将键和值写到某个节点上 startup_nodes = [ {'host': '192.168.26.128', 'port': '7000'}, {'host': '192.168.26.130', 'port': '7003'}, {'host': '192.168.26.128', 'port': '7001'}, ] # 构建StrictRedisCluster对象 src=StrictRedisCluster(startup_nodes=startup_nodes,decode_responses=True) # 设置键为name、值为itheima的数据 result=src.set('name','itheima') print(result) # 获取键为name name = src.get('name') print(name) except Exception as e: print(e) ","date":"2020-04-11","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E8%BF%9B%E9%98%B6/:2:6","tags":["Python学习之路"],"title":"Python学习之路-Redis进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"前言 在Python中操作Redis可以直接用redis模块 ","date":"2020-03-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-python%E6%93%8D%E4%BD%9Credis/:1:0","tags":["Python学习之路"],"title":"Python学习之路-Python操作redis","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-python%E6%93%8D%E4%BD%9Credis/"},{"categories":["Python"],"content":"安装 安装Redis的有3种方式https://github.com/andymccurdy/redis-py 第一种：进⼊虚拟环境py_django，联⽹安装包redis pip install redis 第二种：进⼊虚拟环境py_django，联⽹安装包redis easy_install redis 第三种：到中⽂官⽹-客户端下载redis包的源码，使⽤源码安装： 下载：执行 wget https://github.com/andymccurdy/redis-py/archive/master.zip 解压：unzip master.zip 安装：先进入文件夹cd redis-py-master通过setup.py安装sudo python setup.py install ","date":"2020-03-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-python%E6%93%8D%E4%BD%9Credis/:2:0","tags":["Python学习之路"],"title":"Python学习之路-Python操作redis","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-python%E6%93%8D%E4%BD%9Credis/"},{"categories":["Python"],"content":"使用 ","date":"2020-03-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-python%E6%93%8D%E4%BD%9Credis/:3:0","tags":["Python学习之路"],"title":"Python学习之路-Python操作redis","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-python%E6%93%8D%E4%BD%9Credis/"},{"categories":["Python"],"content":"引入 引⼊模块：from redis import * 注意 这个模块中提供了StrictRedis对象(Strict严格)，⽤于连接redis服务器，并按照不同类型提供 了不同⽅法，进⾏交互操作 ","date":"2020-03-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-python%E6%93%8D%E4%BD%9Credis/:3:1","tags":["Python学习之路"],"title":"Python学习之路-Python操作redis","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-python%E6%93%8D%E4%BD%9Credis/"},{"categories":["Python"],"content":"StrictRedis对象 通过创建对象，指定参数host、port与指定的服务器和端⼝连接，host默认为localhost，port默认为6379，db默认为0 sr = StrictRedis(host='localhost', port=6379, db=0) # 简写 sr=StrictRedis() 提示 根据不同的类型，拥有不同的实例⽅法可以调⽤，与前⾯学的redis命令对应，⽅法需要的参数与命令的参数⼀致 ","date":"2020-03-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-python%E6%93%8D%E4%BD%9Credis/:3:2","tags":["Python学习之路"],"title":"Python学习之路-Python操作redis","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-python%E6%93%8D%E4%BD%9Credis/"},{"categories":["Python"],"content":"指令 string set setex mset append get mget key keys exists type delete expire getrange ttl hash hset hmset hkeys hget hmget hvals hdel list lpush rpush linsert lrange lset lrem set sadd smembers srem zset zadd zrange zrangebyscore zscore zrem zremrangebyscore ","date":"2020-03-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-python%E6%93%8D%E4%BD%9Credis/:3:3","tags":["Python学习之路"],"title":"Python学习之路-Python操作redis","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-python%E6%93%8D%E4%BD%9Credis/"},{"categories":["Redis"],"content":"前言 前面学习数据库的时候学习了用的最多的关系型数据库MySQL，这次来学习用的最多的非关系型数据库Redis。 ","date":"2020-03-21","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E5%9F%BA%E7%A1%80/:1:0","tags":["Python学习之路"],"title":"Python学习之路-Redis基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E5%9F%BA%E7%A1%80/"},{"categories":["Redis"],"content":"简介 Redis是一个使用ANSI C编写的开源、支持网络、基于内存、分布式、可选持久性的键值对存储数据库。根据月度排行网站DB-Engines.com的数据，Redis是最流行的键值对存储数据库。 ","date":"2020-03-21","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E5%9F%BA%E7%A1%80/:2:0","tags":["Python学习之路"],"title":"Python学习之路-Redis基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E5%9F%BA%E7%A1%80/"},{"categories":["Redis"],"content":"安装 ","date":"2020-03-21","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E5%9F%BA%E7%A1%80/:3:0","tags":["Python学习之路"],"title":"Python学习之路-Redis基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E5%9F%BA%E7%A1%80/"},{"categories":["Redis"],"content":"下载 使用以下命令下载，提取和编译Redis： $ wget https://download.redis.io/releases/redis-5.0.7.tar.gz $ tar xzf redis-5.0.7.tar.gz $ cd redis-5.0.7 $ make ","date":"2020-03-21","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E5%9F%BA%E7%A1%80/:3:1","tags":["Python学习之路"],"title":"Python学习之路-Redis基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E5%9F%BA%E7%A1%80/"},{"categories":["Redis"],"content":"运行 src 目录 中现在提供了已编译的二进制文件 。使用以下命令运行Redis： $ src/redis-server ","date":"2020-03-21","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E5%9F%BA%E7%A1%80/:3:2","tags":["Python学习之路"],"title":"Python学习之路-Redis基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E5%9F%BA%E7%A1%80/"},{"categories":["Redis"],"content":"测试 可以使用内置客户端与Redis进行交互： $ src/redis-cli redis\u003e set foo bar OK redis\u003e get foo \"bar\" ","date":"2020-03-21","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E5%9F%BA%E7%A1%80/:3:3","tags":["Python学习之路"],"title":"Python学习之路-Redis基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E5%9F%BA%E7%A1%80/"},{"categories":["Redis"],"content":"常用配置 Redis的配置信息在/etc/redis/redis.conf下，使用vi进行编辑配置： sudo vi /etc/redis/redis.conf ip与端口 绑定绑定⼀个真实ip。端⼝默认为6379 bind 127.0.0.1 port 6379 如果需要远程访问，可将ip⾏注释 守护进程 如果以守护进程运⾏，则不会在命令⾏阻塞，类似于服务。如果以⾮守护进程运⾏，则当前终端被阻塞。设置为yes表示守护进程，设置为no表示⾮守护进程。推荐设置为yes daemonize yes 数据⽂件 # 数据文件名 dbfilename dump.rdb # 存储路径 dir /var/lib/redis ⽇志⽂件 # 日志文件存储位置 logfile \"/var/log/redis/redis-server.log\" 数据库 数据库个数，默认有16个 database 16 主从复制 类似于双机备份 slaveof 其他配置 redis-5.0.3配置https://blog.csdn.net/suprezheng/article/details/90679790 ","date":"2020-03-21","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E5%9F%BA%E7%A1%80/:3:4","tags":["Python学习之路"],"title":"Python学习之路-Redis基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E5%9F%BA%E7%A1%80/"},{"categories":["Redis"],"content":"相关命令 ","date":"2020-03-21","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E5%9F%BA%E7%A1%80/:4:0","tags":["Python学习之路"],"title":"Python学习之路-Redis基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E5%9F%BA%E7%A1%80/"},{"categories":["Redis"],"content":"服务端 启动服务端的命令为：redis-server。 查看帮助⽂档：redis-server --help 查看redis服务器进程：ps aux | grep redis 杀死redis服务器：sudo kill -9 pid 指定加载的配置文件：sudo redis-server /etc/redis/redis.conf ","date":"2020-03-21","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E5%9F%BA%E7%A1%80/:4:1","tags":["Python学习之路"],"title":"Python学习之路-Redis基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E5%9F%BA%E7%A1%80/"},{"categories":["Redis"],"content":"客户端 进入客户端的命令为：redis-cli 查看帮助⽂档：redis-cli --help 运⾏测试命令：ping 127.0.0.1:6379\u003e ping PONG 切换数据库，数据库没有名称，默认有16个，通过0-15来标识，连接redis默认选择第一个数据库 \u003e select 2 OK 127.0.0.1:6379[2]\u003e ","date":"2020-03-21","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E5%9F%BA%E7%A1%80/:4:2","tags":["Python学习之路"],"title":"Python学习之路-Redis基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E5%9F%BA%E7%A1%80/"},{"categories":["Redis"],"content":"数据结构 redis是key-value的数据结构，每条数据都是⼀个键值对，键的类型是字符串 注意 键不能重复 值的类型分为五种： 字符串string：字符串类型是Redis中最为基础的数据存储类型，一个 key 对应一个 value。 提示 string类型在Redis中是二进制安全的。这便意味着该类型可以接受任何格式的数据，比如JPEG图像数据或JSON对象描述信息等。在Redis中字符串类型的Value最多可以容纳的数据长度是512M。 哈希hash：是一个键值(key=\u003evalue)对集合。特别适合用于存储对象。 列表list：简单的字符串列表，按照插入顺序排序。可以添加一个元素到列表的头部(左边)或者尾部(右边)。 集合set：string 类型的无序集合。通过哈希表实现的，添加，删除，查找的复杂度都是 O(1)。 有序集合zset：和 set 一样也是string类型元素的集合，且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的,但分数(score)却可以重复。 ","date":"2020-03-21","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E5%9F%BA%E7%A1%80/:5:0","tags":["Python学习之路"],"title":"Python学习之路-Redis基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E5%9F%BA%E7%A1%80/"},{"categories":["Redis"],"content":"数据操作 ","date":"2020-03-21","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E5%9F%BA%E7%A1%80/:6:0","tags":["Python学习之路"],"title":"Python学习之路-Redis基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E5%9F%BA%E7%A1%80/"},{"categories":["Redis"],"content":"string 存储 设置键值：set key value，例： 127.0.0.1:6379[2]\u003e set name xiaoliang OK 设置键值及过期时间，单位为秒：setex key seconds value，例： 127.0.0.1:6379[2]\u003e setex name 3 xiaoliang OK 设置多个键值：mset key1 value1 key2 value2 ...，例： 127.0.0.1:6379[2]\u003e mset name xiaoliang age 18 OK 追加值：append key value，例： 127.0.0.1:6379[2]\u003e set name xiaoliang OK 127.0.0.1:6379[2]\u003e append name liang (integer) 14 127.0.0.1:6379[2]\u003e get name \"xiaoliangliang\" 获取 根据键获取值，如果不存在此键则返回nil：get key，例： 127.0.0.1:6379[2]\u003e get name \"xiaoliang\" 根据多个键获取多个值：mget key1 key2 ...，例： 127.0.0.1:6379[2]\u003e mget name age 1) \"xiaoliang\" 2) \"18\" 查看所有键：keys * 查找键，参数⽀持正则表达式：keys pattern，例： 127.0.0.1:6379[2]\u003e keys n* 1) \"name\" 判断键是否存在，如果存在返回1，不存在返回0：exists key，例： 127.0.0.1:6379[2]\u003e exists name (integer) 1 127.0.0.1:6379[2]\u003e exists namee (integer) 0 查看键对应的value的类型：type key，例： 127.0.0.1:6379[2]\u003e type name string 删除 删除键及对应的值：del key1 key2 ...，例： del name age (integer) 2 mget name age (nil) (nil) 设置过期时间，以秒为单位：expire key seconds，例 127.0.0.1:6379[2]\u003e expire name 10 (integer) 1 127.0.0.1:6379[2]\u003e ttl name (integer) 4 注意 如果没有指定过期时间则⼀直存在，直到使⽤DEL移除 ","date":"2020-03-21","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E5%9F%BA%E7%A1%80/:6:1","tags":["Python学习之路"],"title":"Python学习之路-Redis基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E5%9F%BA%E7%A1%80/"},{"categories":["Redis"],"content":"hash 存储 设置单个属性：hset key field value，例： 127.0.0.1:6379[2]\u003e hset user name xiaoliang (integer) 1 提示 可能会出现错误：MISCONF Redis is configured to save RDB snapshots, but is currently not able to persist on disk. Commands that may modify the data set are disabled. Please check Redis logs for details about the error. Redis被配置为保存数据库快照，但它目前不能持久化到硬盘。用来修改集合数据的命令不能用 原因：强制关闭Redis快照导致不能持久化。 解决方案：运行config set stop-writes-on-bgsave-error no　命令后，关闭配置项stop-writes-on-bgsave-error解决该问题。 设置多个属性：hmset key field1 value1 field2 value2 ...，例： 127.0.0.1:6379[2]\u003e hset user name xiaoliang age 18 (integer) 1 获取 获取指定键所有的属性：hkeys key，例： 127.0.0.1:6379[2]\u003e hkeys user 1) \"name\" 2) \"age\" 获取⼀个属性的值：hget key field，例： 127.0.0.1:6379[2]\u003e hget user name \"xiaoliang\" 获取多个属性的值：hmget key field1 field2 ...，例： 127.0.0.1:6379[2]\u003e hmget user name age 1) \"xiaoliang\" 2) \"18\" 获取所有属性的值：hvals key，例： 127.0.0.1:6379[2]\u003e hvals user 1) \"xiaoliang\" 2) \"18\" 删除 删除整个hash键及值，使⽤del命令 删除属性，属性对应的值会被⼀起删除：hdel key field1 field2 ...，例子： 127.0.0.1:6379[2]\u003e hdel user age (integer) 1 127.0.0.1:6379[2]\u003e hkeys user 1) \"name\" ","date":"2020-03-21","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E5%9F%BA%E7%A1%80/:6:2","tags":["Python学习之路"],"title":"Python学习之路-Redis基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E5%9F%BA%E7%A1%80/"},{"categories":["Redis"],"content":"list 存储 在左侧插⼊数据：lpush key value1 value2 ...，例： 127.0.0.1:6379[2]\u003e lpush name si liang (integer) 2 127.0.0.1:6379[2]\u003e lrange name 0 2 1) \"liang\" 2) \"si\" 在右侧插⼊数据：rpush key value1 value2 ...，例： 127.0.0.1:6379[2]\u003e rpush name liang si (integer) 4 127.0.0.1:6379[2]\u003e lrange name 0 4 1) \"liang\" 2) \"si\" 3) \"liang\" 4) \"si\" 在指定元素的前或后插⼊新元素：linsert key before或after 现有元素 新元素，例： 127.0.0.1:6379[2]\u003e linsert name before si yao (integer) 5 127.0.0.1:6379[2]\u003e lrange name 0 6 1) \"liang\" 2) \"yao\" 3) \"si\" 4) \"liang\" 5) \"si\" 获取 返回列表⾥指定范围内的元素：lrange key start stop()，例： 提示 start、stop为元素的下标索引，索引从左侧开始，第⼀个元素为0，索引可以是负数，表示从尾部开始计数，如-1表示最后⼀个元素 # 获取name列表所有元素 127.0.0.1:6379[2]\u003e lrange name 0 -1 1) \"liang\" 2) \"yao\" 3) \"si\" 4) \"liang\" 5) \"si\" 设置指定索引位置的元素值：lset key index value，例： 提示 索引从左侧开始，第⼀个元素为0。索引可以是负数，表示尾部开始计数，如-1表示最后⼀个元素 127.0.0.1:6379[2]\u003e lset name 4 si OK 127.0.0.1:6379[2]\u003e lrange name 0 -1 1) \"liang\" 2) \"yao\" 3) \"si\" 4) \"liang\" 5) \"si\" 删除 删除指定元素：lrem key count value，例： 提示 将列表中前count次出现的值为value的元素移除，count \u003e 0: 从头往尾移除，count \u003c 0: 从尾往头移除，count = 0: 移除所有 127.0.0.1:6379[2]\u003e lrem name 0 liang (integer) 2 127.0.0.1:6379[2]\u003e lrange name 0 -1 1) \"yao\" 2) \"si\" 3) \"si\" ","date":"2020-03-21","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E5%9F%BA%E7%A1%80/:6:3","tags":["Python学习之路"],"title":"Python学习之路-Redis基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E5%9F%BA%E7%A1%80/"},{"categories":["Redis"],"content":"set 存储 添加元素：sadd key member1 member2 ...，例： 127.0.0.1:6379[2]\u003e sadd name liang si (integer) 2 获取 返回所有的元素：smembers key，例： 127.0.0.1:6379[2]\u003e smembers name 1) \"si\" 2) \"liang\" 删除 删除指定元素：srem key，例： 127.0.0.1:6379[2]\u003e srem name liang (integer) 1 127.0.0.1:6379[2]\u003e smembers name 1) \"si\" ","date":"2020-03-21","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E5%9F%BA%E7%A1%80/:6:4","tags":["Python学习之路"],"title":"Python学习之路-Redis基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E5%9F%BA%E7%A1%80/"},{"categories":["Redis"],"content":"zset 存储 添加：zadd key score1 member1 score2 member2 ...，例： 127.0.0.1:6379[2]\u003e zadd name 2 liang 1 si (integer) 2 获取 返回指定范围内的元素：zrange key start stop，例： 提示 start、stop为元素的下标索引，索引从左侧开始，第⼀个元素为0，索引可以是负数，表示从尾部开始计数，如-1表示最后⼀个元素 127.0.0.1:6379[2]\u003e zrange name 0 -1 1) \"si\" 2) \"liang\" 返回score值在min和max之间的成员：zrangebyscore key min max，例： 127.0.0.1:6379[2]\u003e zrangebyscore name 1 2 1) \"si\" 2) \"liang\" 返回成员member的score值：zscore key member，例： 127.0.0.1:6379[2]\u003e zscore name liang \"2\" ","date":"2020-03-21","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E5%9F%BA%E7%A1%80/:6:5","tags":["Python学习之路"],"title":"Python学习之路-Redis基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E5%9F%BA%E7%A1%80/"},{"categories":["Redis"],"content":"删除 删除指定元素：zrem key member1 member2 ...，例： 127.0.0.1:6379[2]\u003e zrem name liang (integer) 1 127.0.0.1:6379[2]\u003e zrange name 0 -1 1) \"si\" 删除权重在指定范围的元素：zremrangebyscore key min max，例： 127.0.0.1:6379[2]\u003e zremrangebyscore name 0 2 (integer) 1 127.0.0.1:6379[2]\u003e zrange name 0 -4 (empty array) ","date":"2020-03-21","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E5%9F%BA%E7%A1%80/:6:6","tags":["Python学习之路"],"title":"Python学习之路-Redis基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E5%9F%BA%E7%A1%80/"},{"categories":["Hugo"],"content":"前言 由于前一段时间学习了Golang，在家查阅相关资料的时候发现了Hugo这个用Go语言编写的静态网站生成器，根据网站的介绍它有着速度快，易用，可配置程度高等特点，而且文章依赖于Markdown生成，非常适合作为博客、文档、个人简历这类型的网站，于是我准备用Hugo搭建一个属于自己的博客，并将之前写的文章都搬运过来，最后通过GitHub Pages部署，一起开始吧！ ","date":"2020-02-07","objectID":"/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%80%9A%E8%BF%87github/:1:0","tags":["Hugo","博客"],"title":"使用Hugo搭建自己的博客并通过GitHub Pages部署","uri":"/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%80%9A%E8%BF%87github/"},{"categories":["Hugo"],"content":"使用Hugo搭建博客 ","date":"2020-02-07","objectID":"/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%80%9A%E8%BF%87github/:2:0","tags":["Hugo","博客"],"title":"使用Hugo搭建自己的博客并通过GitHub Pages部署","uri":"/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%80%9A%E8%BF%87github/"},{"categories":["Hugo"],"content":"安装 Mac和Linux可以直接用Homebrew安装 brew install hugo Windows在github上下载解压后安装， 注意 Windows安装完毕记得添加环境变量！ 此外Hugo官方还提供了多种安装方式，选择自己喜欢的即可 安装完毕后，可以通过查询Hugo版本验证是否安装成功 hugo version ","date":"2020-02-07","objectID":"/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%80%9A%E8%BF%87github/:2:1","tags":["Hugo","博客"],"title":"使用Hugo搭建自己的博客并通过GitHub Pages部署","uri":"/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%80%9A%E8%BF%87github/"},{"categories":["Hugo"],"content":"创建新站点 hugo new site SilenceBlog 创建成功图片 ","date":"2020-02-07","objectID":"/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%80%9A%E8%BF%87github/:2:2","tags":["Hugo","博客"],"title":"使用Hugo搭建自己的博客并通过GitHub Pages部署","uri":"/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%80%9A%E8%BF%87github/"},{"categories":["Hugo"],"content":"添加并配置主题 Hugo收录的主题非常多，可以在主题库中寻找自己喜欢的 从GitHub下载主题到站点存放主题的目录中： git clone https://github.com/dillonzq/LoveIt.git SilenceBlog/themes/LoveIt 将主题添加到站点的配置文件中： echo theme = \\\"LoveIt\\\" \u003e\u003e config.toml 查看主题官方文档，并根据自己的情况进行配置 信息 LoveIt主题说明、主题文档相关配置介绍 ","date":"2020-02-07","objectID":"/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%80%9A%E8%BF%87github/:2:3","tags":["Hugo","博客"],"title":"使用Hugo搭建自己的博客并通过GitHub Pages部署","uri":"/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%80%9A%E8%BF%87github/"},{"categories":["Hugo"],"content":"添加一篇文章并在本地查看效果 可以在content/posts/下手动创建一个Markdown文件，但是需要我们手动输入所有内容。也可以直接通过new命令来创建文章，创建好的文章已经存在相应的模板内容 hugo new posts/firstpost.md 输入完后会提是我们创建成功和文章所在的位置 接下来可以打开这个文件进行编辑，当我们编辑完毕保存退出后，可以启动Hugo服务器查看效果 hugo server -D 启动后我们可以看到，本次启动的一些信息 在浏览器中打开http://localhost:1313/即可查看效果，并且效果是实时更新的，会随着对站点博客的操作自动更新相应的效果 最后当我们完成博客内容想对博客部署的时候可以通过hugo命令进行建立静态页面 hugo -d 文件路径 提示 默认情况下会保存在./public/目录中 信息 更详细的内容可以查看Hugo官方文档 ","date":"2020-02-07","objectID":"/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%80%9A%E8%BF%87github/:2:4","tags":["Hugo","博客"],"title":"使用Hugo搭建自己的博客并通过GitHub Pages部署","uri":"/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%80%9A%E8%BF%87github/"},{"categories":["Hugo"],"content":"通过GitHub Pages部署 ","date":"2020-02-07","objectID":"/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%80%9A%E8%BF%87github/:3:0","tags":["Hugo","博客"],"title":"使用Hugo搭建自己的博客并通过GitHub Pages部署","uri":"/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%80%9A%E8%BF%87github/"},{"categories":["Hugo"],"content":"什么是GitHub Pages GitHub Pages 是一种静态网站托管服务，它可以直接从 GitHub 上的仓库中获取 HTML、CSS 和 JavaScript 文件，并通过构建过程选择性地运行这些文件，然后发布一个网站。 上面我们通过hugo -D命令正是将站点生成一个静态网站，可以完美配合GitHub Pages进行部署 ","date":"2020-02-07","objectID":"/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%80%9A%E8%BF%87github/:3:1","tags":["Hugo","博客"],"title":"使用Hugo搭建自己的博客并通过GitHub Pages部署","uri":"/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%80%9A%E8%BF%87github/"},{"categories":["Hugo"],"content":"部署方式 1.首先我们要创建一个Github 仓库，仓库名必须是\u003cuser\u003e.github.io的形式，如果是组织则为\u003corganization\u003e.github.io。仓库的可见性必须是Public。 提示 用户名的大小写不会影响GitHub Pages的部署。例如我的仓库为：Silencehuliang/silencehuliang.github.io 2.接下来进入仓库的设置页对GitHub Pages进行配置，找到GitHub Pages所在的位置，按下图配置好分支和站点存放路径即可 3.配置完毕后，把仓库克隆下来，使用hugo -D 路径将站点生成的静态文件存放在配置文件中选择的路径下即可。最后将文件提交上去就可以打开对应域名进行查看了。 ","date":"2020-02-07","objectID":"/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%80%9A%E8%BF%87github/:3:2","tags":["Hugo","博客"],"title":"使用Hugo搭建自己的博客并通过GitHub Pages部署","uri":"/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%80%9A%E8%BF%87github/"},{"categories":["Hugo"],"content":"出现问题的解决方案 当我们将文件提交上去之后打开对应域名发现并没有我们想要的内容时可以通过查看提交记录查看错误原因，点击Deatils可以找到具体位置的具体错误 还可以在GitHub Pages的设置出找到错误原因 信息 更详细的内容可以查看Hugo官方部署文档或GitHub Pages入门教程文档 ","date":"2020-02-07","objectID":"/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%80%9A%E8%BF%87github/:3:3","tags":["Hugo","博客"],"title":"使用Hugo搭建自己的博客并通过GitHub Pages部署","uri":"/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%80%9A%E8%BF%87github/"},{"categories":["MySQL"],"content":"视图 ","date":"2020-02-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/:1:0","tags":["Python学习之路"],"title":"Python学习之路-MySQL进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/"},{"categories":["MySQL"],"content":"前言 对于复杂的查询，往往是有多个数据表进行关联查询而得到，如果数据库因为需求等原因发生了改变，为了保证查询出来的数据与之前相同，则需要在多个地方进行修改，维护起来非常麻烦。可以通过定义视图来解决 ","date":"2020-02-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/:1:1","tags":["Python学习之路"],"title":"Python学习之路-MySQL进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/"},{"categories":["MySQL"],"content":"简介 通俗的讲，视图就是一条SELECT语句执行后返回的结果集。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。视图是对若干张基本表的引用，一张虚表，查询语句执行的结果，不存储具体的数据（基本表数据发生了改变，视图也会跟着改变）；方便操作，特别是查询操作，减少复杂的SQL语句，增强可读性； ","date":"2020-02-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/:1:2","tags":["Python学习之路"],"title":"Python学习之路-MySQL进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/"},{"categories":["MySQL"],"content":"定义 建议以v_开头 create view 视图名称 as select语句; ","date":"2020-02-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/:1:3","tags":["Python学习之路"],"title":"Python学习之路-MySQL进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/"},{"categories":["MySQL"],"content":"查看 查看表会将所有的视图也列出来 show tables; ","date":"2020-02-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/:1:4","tags":["Python学习之路"],"title":"Python学习之路-MySQL进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/"},{"categories":["MySQL"],"content":"使用 视图的用途就是查询 select * from v_stu_score; ","date":"2020-02-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/:1:5","tags":["Python学习之路"],"title":"Python学习之路-MySQL进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/"},{"categories":["MySQL"],"content":"删除 drop view 视图名称; 例： drop view v_stu_sco; ","date":"2020-02-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/:1:6","tags":["Python学习之路"],"title":"Python学习之路-MySQL进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/"},{"categories":["MySQL"],"content":"作用 提高了重用性，就像一个函数 对数据库重构，却不影响程序的运行 提高了安全性能，可以对不同的用户 让数据更加清晰 ","date":"2020-02-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/:1:7","tags":["Python学习之路"],"title":"Python学习之路-MySQL进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/"},{"categories":["MySQL"],"content":"事务 ","date":"2020-02-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/:2:0","tags":["Python学习之路"],"title":"Python学习之路-MySQL进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/"},{"categories":["MySQL"],"content":"前言 事务广泛的运用于订单系统、银行系统等多种场景。 ","date":"2020-02-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/:2:1","tags":["Python学习之路"],"title":"Python学习之路-MySQL进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/"},{"categories":["MySQL"],"content":"简介 所谓事务,它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。 ","date":"2020-02-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/:2:2","tags":["Python学习之路"],"title":"Python学习之路-MySQL进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/"},{"categories":["MySQL"],"content":"四大特性(ACID) 原子性(Atomicity)：一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性 一致性(Consistency)：数据库总是从一个一致性的状态转换到另一个一致性的状态。（在前面的例子中，一致性确保了，即使在执行第三、四条语句之间时系统崩溃，支票账户中也不会损失200美元，因为事务最终没有提交，所以事务中所做的修改也不会保存到数据库中。） 隔离性(Isolation)：通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的。（在前面的例子中，当执行完第三条语句、第四条语句还未开始时，此时有另外的一个账户汇总程序开始运行，则其看到支票帐户的余额并没有被减去200美元。） 持久性(Durability)：一旦事务提交，则其所做的修改会永久保存到数据库。（此时即使系统崩溃，修改的数据也不会丢失。） ","date":"2020-02-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/:2:3","tags":["Python学习之路"],"title":"Python学习之路-MySQL进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/"},{"categories":["MySQL"],"content":"命令 表的引擎类型必须是innodb类型才可以使用事务，这是mysql表的默认引擎，查看表的创建语句，可以看到engine=innodb -- 选择数据库 use jing_dong; -- 查看goods表 show create table goods; 开启事务 开启事务后执行修改命令，变更会维护到本地缓存中，而不维护到物理表中，命令如下： begin; 或者 start transaction; 提交事务 将缓存中的数据变更维护到物理表中，命令如下 commit; 回滚事务 放弃缓存中变更的数据，命令如下： rollback; 注意 修改数据的命令会自动的触发事务，包括insert、update、delete 而在SQL语句中有手动开启事务的原因是：可以进行多次数据的修改，如果成功一起成功，否则一起会滚到之前的数据 ","date":"2020-02-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/:2:4","tags":["Python学习之路"],"title":"Python学习之路-MySQL进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/"},{"categories":["MySQL"],"content":"索引 ","date":"2020-02-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/:3:0","tags":["Python学习之路"],"title":"Python学习之路-MySQL进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/"},{"categories":["MySQL"],"content":"前言 一般的应用系统对比数据库的读写比例在10:1左右(即有10次查询操作时有1次写的操作)，而且插入操作和更新操作很少出现性能问题，遇到最多、最容易出问题还是一些复杂的查询操作，所以查询语句的优化显然是重中之重。当数据库中数据量很大时，查找数据会变得很慢，可以通过创建索引的方式进行优化。 ","date":"2020-02-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/:3:1","tags":["Python学习之路"],"title":"Python学习之路-MySQL进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/"},{"categories":["MySQL"],"content":"简介 索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。更通俗的说，数据库索引好比是一本书前面的目录，能加快数据库的查询速度。 ","date":"2020-02-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/:3:2","tags":["Python学习之路"],"title":"Python学习之路-MySQL进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/"},{"categories":["MySQL"],"content":"目的 索引的目的在于提高查询效率，可以类比字典，如果要查“mysql”这个单词，我们肯定需要定位到m字母，然后从下往下找到y字母，再找到剩下的sql。如果没有索引，那么你可能需要把所有单词看一遍才能找到你想要的，如果我想找到m开头的单词呢？或者ze开头的单词呢？是不是觉得如果没有索引，这个事情根本无法完成？ ","date":"2020-02-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/:3:3","tags":["Python学习之路"],"title":"Python学习之路-MySQL进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/"},{"categories":["MySQL"],"content":"原理 除了词典，生活中随处可见索引的例子，如火车站的车次表、图书的目录等。它们的原理都是一样的，通过不断的缩小想要获得数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，也就是我们总是通过同一种查找方式来锁定数据。数据库也是一样，但显然要复杂许多，因为不仅面临着等值查询，还有范围查询(\u003e、\u003c、between、in)、模糊查询(like)、并集查询(or)等等。数据库应该选择怎么样的方式来应对所有的问题呢？我们回想字典的例子，能不能把数据分成段，然后分段查询呢？最简单的如果1000条数据，1到100分成第一段，101到200分成第二段，201到300分成第三段……这样查第250条数据，只要找第三段就可以了，一下子去除了90%的无效数据。 ","date":"2020-02-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/:3:4","tags":["Python学习之路"],"title":"Python学习之路-MySQL进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/"},{"categories":["MySQL"],"content":"使用 查看索引 show index from 表名; 创建索引 如果指定字段是字符串，需要指定长度，建议长度与定义字段时的长度一致，字段类型如果不是字符串，可以不填写长度部分 create index 索引名称 on 表名(字段名称(长度)) 删除索引 drop index 索引名称 on 表名; ","date":"2020-02-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/:3:5","tags":["Python学习之路"],"title":"Python学习之路-MySQL进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/"},{"categories":["MySQL"],"content":"注意： 要注意的是，建立太多的索引将会影响更新和插入的速度，因为它需要同样更新每个索引文件。对于一个经常需要更新和插入的表格，就没有必要为一个很少使用的where字句单独建立索引了，对于比较小的表，排序的开销不会很大，也没有必要建立另外的索引。建立索引会占用磁盘空间。 ","date":"2020-02-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/:3:6","tags":["Python学习之路"],"title":"Python学习之路-MySQL进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/"},{"categories":["MySQL"],"content":"账户管理 在生产环境下操作数据库时，绝对不可以使用root账户连接，而是创建特定的账户，授予这个账户特定的操作权限，然后连接进行操作，主要的操作就是数据的crud。MySQL账户体系：根据账户所具有的权限的不同，MySQL的账户可以分为以下几种： 服务实例级账号：，启动了一个mysqld，即为一个数据库实例；如果某用户如root,拥有服务实例级分配的权限，那么该账号就可以删除所有的数据库、连同这些库中的表 数据库级别账号：对特定数据库执行增删改查的所有操作 数据表级别账号：对特定表执行增删改查等所有操作 字段级别的权限：对某些表的特定字段进行操作 存储程序级别的账号：对存储程序进行增删改查的操作 账户的操作主要包括创建账户、删除账户、修改密码、授权权限等 注意： 进行账户操作时，需要使用root账户登录，这个账户拥有最高的实例级权限 通常都使用数据库级操作权限 ","date":"2020-02-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/:4:0","tags":["Python学习之路"],"title":"Python学习之路-MySQL进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/"},{"categories":["MySQL"],"content":"授予权限 需要使用实例级账户登录后操作，以root为例 主要操作包括： 查看所有用户 修改密码 删除用户 查看所有用户 所有用户及权限信息存储在mysql数据库的user表中 查看user表的结构 desc user; 主要字段说明： Host表示允许访问的主机 User表示用户名 authentication_string表示密码，为加密后的值 查看所有用户 select host,user,authentication_string from user; 创建账户、授权 需要使用实例级账户登录后操作，以root为例 常用权限主要包括：create、alter、drop、insert、update、delete、select 如果分配所有权限，可以使用all privileges grant 权限列表 on 数据库 to '用户名'@'访问主机' identified by '密码'; 修改权限 grant 权限名称 on 数据库 to 账户@主机 with grant option; 修改密码 使用root登录，修改mysql数据库的user表，使用password()函数进行密码加密 update user set authentication_string=password('新密码') where user='用户名'; 注意修改完成后需要刷新权限 刷新权限：flush privileges 远程登录（危险慎用） 如果向在一个Ubuntu中使用msyql命令远程连接另外一台mysql服务器的话，通过以下方式即可完成，但是此方法仅仅了解就好了，不要在实际生产环境中使用，修改 /etc/mysql/mysql.conf.d/mysqld.cnf 文件把bind-address = 127.0.0.1注释掉，然后重启msyql service mysql restart 如果依然连不上，可能原因： 1)网络不通：通过 ping xxx.xxx.xx.xxx可以发现网络是否正常 2)查看数据库是否配置了bind_address参数：本地登录数据库查看my.cnf文件和数据库当前参数show variables like ‘bind_address’；如果设置了bind_address=127.0.0.1 那么只能本地登录 3)查看数据库是否设置了skip_networking参数：如果设置了该参数，那么只能本地登录mysql数据库 4)端口指定是否正确 删除账户 使用root登录 drop user '用户名'@'主机'; 使用root登录，删除mysql数据库的user表中数据 delete from user where user='用户名'; 推荐使用第一种删除用户, 如果使用第一种删除失败，采用第二种方式 ","date":"2020-02-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/:4:1","tags":["Python学习之路"],"title":"Python学习之路-MySQL进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/"},{"categories":["MySQL"],"content":"主从同步 ","date":"2020-02-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/:5:0","tags":["Python学习之路"],"title":"Python学习之路-MySQL进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/"},{"categories":["MySQL"],"content":"简介 主从同步使得数据可以从一个数据库服务器复制到其他服务器上，在复制数据时，一个服务器充当主服务器（master），其余的服务器充当从服务器（slave）。因为复制是异步进行的，所以从服务器不需要一直连接着主服务器，从服务器甚至可以通过拨号断断续续地连接主服务器。通过配置文件，可以指定复制所有的数据库，某个数据库，甚至是某个数据库上的某个表。 ","date":"2020-02-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/:5:1","tags":["Python学习之路"],"title":"Python学习之路-MySQL进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/"},{"categories":["MySQL"],"content":"好处 通过增加从服务器来提高数据库的性能，在主服务器上执行写入和更新，在从服务器上向外提供读功能，可以动态地调整从服务器的数量，从而调整整个数据库的性能。 提高数据安全，因为数据已复制到从服务器，从服务器可以终止复制进程，所以，可以在从服务器上备份而不破坏主服务器相应数据 在主服务器上生成实时数据，而在从服务器上分析这些数据，从而提高主服务器的性能 ","date":"2020-02-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/:5:2","tags":["Python学习之路"],"title":"Python学习之路-MySQL进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/"},{"categories":["MySQL"],"content":"机制 Mysql服务器之间的主从同步是基于二进制日志机制，主服务器使用二进制日志来记录数据库的变动情况，从服务器通过读取和执行该日志文件来保持和主服务器的数据一致。 在使用二进制日志时，主服务器的所有操作都会被记录下来，然后从服务器会接收到该日志的一个副本。从服务器可以指定执行该日志中的哪一类事件（譬如只插入数据或者只更新数据），默认会执行日志中的所有语句。 每一个从服务器会记录关于二进制日志的信息：文件名和已经处理过的语句，这样意味着不同的从服务器可以分别执行同一个二进制日志的不同部分，并且从服务器可以随时连接或者中断和服务器的连接。 主服务器和每一个从服务器都必须配置一个唯一的ID号（在my.cnf文件的[mysqld]模块下有一个server-id配置项），另外，每一个从服务器还需要通过CHANGE MASTER TO语句来配置它要连接的主服务器的ip地址，日志文件名称和该日志里面的位置（这些信息存储在主服务器的数据库里） ","date":"2020-02-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/:5:3","tags":["Python学习之路"],"title":"Python学习之路-MySQL进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/"},{"categories":["MySQL"],"content":"基本步骤 有很多种配置主从同步的方法，可以总结为如下的步骤： 在主服务器上，必须开启二进制日志机制和配置一个独立的ID 在每一个从服务器上，配置一个唯一的ID，创建一个用来专门复制主服务器数据的账号 在开始复制进程前，在主服务器上记录二进制文件的位置信息 如果在开始复制之前，数据库中已经有数据，就必须先创建一个数据快照（可以使用mysqldump导出数据库，或者直接复制数据文件） 配置从服务器要连接的主服务器的IP地址和登陆授权，二进制日志文件名和位置 ","date":"2020-02-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/:5:4","tags":["Python学习之路"],"title":"Python学习之路-MySQL进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/"},{"categories":["MySQL"],"content":"详细配置 主和从的身份可以自己指定，我们将虚拟机Ubuntu中MySQL作为主服务器，将Windows中的MySQL作为从服务器。 在主从设置前，要保证Ubuntu与Windows间的网络连通。 备份主服务器原有数据到从服务器 如果在设置主从同步前，主服务器上已有大量数据，可以使用mysqldump进行数据备份并还原到从服务器以实现数据的复制。 在主服务器Ubuntu上进行备份，执行命令： mysqldump -uroot -pmysql --all-databases --lock-all-tables \u003e ~/master_db.sql 说明： -u ：用户名 -p ：示密码 –all-databases ：导出所有数据库 –lock-all-tables ：执行操作时锁住所有表，防止操作时有数据修改 ~/master_db.sql :导出的备份数据（sql文件）位置，可自己指定 数据还原 在从服务器命令行中执行还原操作: mysql –uroot –pmysql \u003c master_db.sql 配置主服务器master 编辑设置mysqld的配置文件，设置log_bin和server-id sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf 重启mysql服务 sudo service mysql restart 登入主服务器Ubuntu中的mysql，创建用于从服务器同步数据使用的帐号 mysql –uroot –pmysql GRANT REPLICATION SLAVE ON *.* TO 'slave'@'%' identified by 'slave'; FLUSH PRIVILEGES; 获取主服务器的二进制日志信息 SHOW MASTER STATUS; File为使用的日志文件名字，Position为使用的文件位置，这两个参数须记下，配置从服务器时会用到 配置从服务器slave 编辑从服务器配置文件将server-id修改为2，并保存退出 重启MySQL服务 service mysql restart 设置连接到master主服务器 change master to master_host='10.211.55.5', master_user='slave', master_password='slave',master_log_file='mysql-bin.000006', master_log_pos=590; 注： master_host：主服务器Ubuntu的ip地址 master_log_file: 前面查询到的主服务器日志文件名 master_log_pos: 前面查询到的主服务器日志文件位置 开启同步，查看同步状态 start slave; show slave status ; 测试主从同步 在主服务器创建一个数据库，在从服务器中查看新建的数据库是否存在 ","date":"2020-02-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/:5:5","tags":["Python学习之路"],"title":"Python学习之路-MySQL进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"简介 ","date":"2020-02-02","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-python%E6%93%8D%E4%BD%9Cmysql/:1:0","tags":["Python学习之路"],"title":"Python学习之路-Python操作MySQL","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-python%E6%93%8D%E4%BD%9Cmysql/"},{"categories":["Python"],"content":"PyMySQL PyMySQL是在 Python3.x 版本中用于连接MySQL服务器的一个库，PyMySQL遵循Python数据库 API v2.0 规范，并包含了 pure-Python MySQL 客户端库。 ","date":"2020-02-02","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-python%E6%93%8D%E4%BD%9Cmysql/:2:0","tags":["Python学习之路"],"title":"Python学习之路-Python操作MySQL","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-python%E6%93%8D%E4%BD%9Cmysql/"},{"categories":["Python"],"content":"安装 pip install pymsql ","date":"2020-02-02","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-python%E6%93%8D%E4%BD%9Cmysql/:2:1","tags":["Python学习之路"],"title":"Python学习之路-Python操作MySQL","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-python%E6%93%8D%E4%BD%9Cmysql/"},{"categories":["Python"],"content":"连接 通过Connection对象与数据库建立连接 from pymysql import connect conn=connect(参数列表) 参数host：连接的MySQL主机，如果本机是localhost 参数port：连接的MySQL主机的端口，默认是3306 参数database：数据库的名称 参数user：连接的用户名 参数password：连接的密码 参数charset：通信采用的编码方式，推荐使用utf8 对象的方法 close()：关闭连接 commit()：提交 cursor()：返回Cursor对象，用于执行SQL语句并获得结果 ","date":"2020-02-02","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-python%E6%93%8D%E4%BD%9Cmysql/:2:2","tags":["Python学习之路"],"title":"Python学习之路-Python操作MySQL","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-python%E6%93%8D%E4%BD%9Cmysql/"},{"categories":["Python"],"content":"执行sql语句 通过Cursor对象的execute()方法执行sql语句，调用Connection对象的cursor()方法获取Cursor对象 cs=conn.cursor() cs.execute(\"SQL语句\") 对象的方法 close()：关闭 execute(operation [, parameters ])：执行语句，返回受影响的行数，主要用于执行insert、update、delete语句，也可以执行create、alter、drop等语句 fetchone()：执行查询语句时，获取查询结果集的第一个行数据，返回一个元组 fetchall()：执行查询时，获取结果集的所有行，一行构成一个元组，再将这些元组装入一个元组返回 对象的属性 rowcount只读属性，表示最近一次execute()执行后受影响的行数 connection获得当前连接对象 ","date":"2020-02-02","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-python%E6%93%8D%E4%BD%9Cmysql/:2:3","tags":["Python学习之路"],"title":"Python学习之路-Python操作MySQL","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-python%E6%93%8D%E4%BD%9Cmysql/"},{"categories":["Python"],"content":"SQL注入 sql语句的参数化，可以有效防止sql注入 ","date":"2020-02-02","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-python%E6%93%8D%E4%BD%9Cmysql/:2:4","tags":["Python学习之路"],"title":"Python学习之路-Python操作MySQL","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-python%E6%93%8D%E4%BD%9Cmysql/"},{"categories":["MySQL"],"content":"简介 数据库就是一种特殊的文件，其中存储着需要的数据。 ","date":"2020-01-31","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/:1:0","tags":["Python学习之路"],"title":"Python学习之路-数据库入门","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/"},{"categories":["MySQL"],"content":"类型 当前主要使用两种类型的数据库：关系型数据库、非关系型数据库，本篇主要讨论关系型数据库，对于非关系型数据库会在后面学习。所谓的关系型数据库RDBMS，是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。 关系型数据库的主要产品： oracle：在以前的大型项目中使用,银行,电信等项目 mysql：web时代使用最广泛的关系型数据库 ms sql server：在微软的项目中使用 sqlite：轻量级数据库，主要应用在移动平台 ","date":"2020-01-31","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/:2:0","tags":["Python学习之路"],"title":"Python学习之路-数据库入门","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/"},{"categories":["MySQL"],"content":"RDBMS和数据库的关系 图片取材于布布扣，更详细的内容可以参考其博客 ","date":"2020-01-31","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/:3:0","tags":["Python学习之路"],"title":"Python学习之路-数据库入门","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/"},{"categories":["MySQL"],"content":"SQL SQL(Structured Query Language)是结构化查询语言，是一种用来操作RDBMS的数据库语言，当前关系型数据库都支持使用SQL语言进行操作，也就是说可以通过 SQL 操作oracle，sql，server，mysql，sqlite 等等所有的关系型的数据库。 SQL语句主要分为： DQL：数据查询语言，用于对数据进行查询，如select DML：数据操作语言，对数据进行增加、修改、删除，如insert、udpate、delete TPL：事务处理语言，对事务进行处理，包括begin transaction、commit、rollback DCL：数据控制语言，进行授权与权限回收，如grant、revoke DDL：数据定义语言，进行数据库、表的管理等，如create、drop CCL：指针控制语言，通过控制指针完成表的操作，如declare cursor 提示 SQL 是一门特殊的语言,专门用来操作关系数据库。不区分大小写 ","date":"2020-01-31","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/:4:0","tags":["Python学习之路"],"title":"Python学习之路-数据库入门","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/"},{"categories":["MySQL"],"content":"MySQL ","date":"2020-01-31","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/:5:0","tags":["Python学习之路"],"title":"Python学习之路-数据库入门","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/"},{"categories":["MySQL"],"content":"简介 MySQL是一个关系型数据库管理系统，由瑞典MySQL AB公司开发，后来被Sun公司收购，Sun公司后来又被Oracle公司收购，目前属于Oracle旗下产品。MySQL官方网站 ","date":"2020-01-31","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/:5:1","tags":["Python学习之路"],"title":"Python学习之路-数据库入门","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/"},{"categories":["MySQL"],"content":"特点 使用C和C++编写，并使用了多种编译器进行测试，保证源代码的可移植性 支持多种操作系统，如Linux、Windows、AIX、FreeBSD、HP-UX、MacOS、NovellNetware、OpenBSD、OS/2 Wrap、Solaris等 为多种编程语言提供了API，如C、C++、Python、Java、Perl、PHP、Eiffel、Ruby等 支持多线程，充分利用CPU资源 优化的SQL查询算法，有效地提高查询速度 提供多语言支持，常见的编码如GB2312、BIG5、UTF8 提供TCP/IP、ODBC和JDBC等多种数据库连接途径 提供用于管理、检查、优化数据库操作的管理工具 大型的数据库。可以处理拥有上千万条记录的大型数据库 支持多种存储引擎 MySQL 软件采用了双授权政策，它分为社区版和商业版，由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，一般中小型网站的开发都选择MySQL作为网站数据库 MySQL使用标准的SQL数据语言形式 Mysql是可以定制的，采用了GPL协议，你可以修改源码来开发自己的Mysql系统 在线DDL更改功能 复制全局事务标识 复制无崩溃从机 复制多线程从机 提示 开源、免费、不要钱、使用范围广，跨平台支持性好，提供了多种语言调用的API，是学习数据库开发的首选 ","date":"2020-01-31","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/:5:2","tags":["Python学习之路"],"title":"Python学习之路-数据库入门","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/"},{"categories":["MySQL"],"content":"安装与配置 安装服务器端 在终端中输入如下命令，回车后，然后按照提示输入 sudo apt-get install mysql-server 启动服务 sudo service mysql start 查看进程中是否存在mysql服务 ps ajx|grep mysql 停止服务 sudo service mysql stop 重启服务 sudo service mysql restart 配置 配置文件目录为/etc/mysql/mysql.cnf 主要配置项如下： bind-address表示服务器绑定的ip，默认为127.0.0.1 port表示端口，默认为3306 datadir表示数据库目录，默认为/var/lib/mysql general_log_file表示普通日志，默认为/var/log/mysql/mysql.log log_error表示错误日志，默认为/var/log/mysql/error.log 安装客户端 在终端运行如下命令，按提示填写信息 sudo apt-get install mysql-client 详细连接的命令可以查看帮助文档 mysql --help ","date":"2020-01-31","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/:5:3","tags":["Python学习之路"],"title":"Python学习之路-数据库入门","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/"},{"categories":["MySQL"],"content":"数据完整性 一个数据库就是一个完整的业务单元，可以包含多张表，数据被存储在表中。在表中为了更加准确的存储数据，保证数据的正确有效，可以在创建表的时候，为表添加一些强制性的验证，包括数据字段的类型、约束 数据类型 可以通过查看帮助文档查阅所有支持的数据类型 使用数据类型的原则是：够用就行，尽量使用取值范围小的，而不用大的，这样可以更多的节省存储空间 常用数据类型如下： 整数：int，bit 小数：decimal 字符串：varchar,char 日期时间: date, time, datetime 枚举类型(enum) 特别说明的类型如下： decimal表示浮点数，如decimal(5,2)表示共存5位数，小数占2位 char表示固定长度的字符串，如char(3)，如果填充’ab’时会补一个空格为'ab ' varchar表示可变长度的字符串，如varchar(3)，填充’ab’时就会存储’ab’ 字符串text表示存储大文本，当字符大于4000时推荐使用 对于图片、音频、视频等文件，不存储在数据库中，而是上传到某个服务器上，然后在表中存储这个文件的保存路径 更全的数据类型可以参考http://blog.csdn.net/anxpp/article/details/51284106 约束 主键primary key：物理上存储的顺序 非空not null：此字段不允许填写空值 惟一unique：此字段的值不允许重复 默认default：当不填写此值时会使用默认值，如果填写时以填写为准 外键foreign key：对关系字段进行约束，当为关系字段填写值时，会到关联的表中查询此值是否存在，如果存在则填写成功，如果不存在则填写失败并抛出异常 说明：虽然外键约束可以保证数据的有效性，但是在进行数据的crud（增加、修改、删除、查询）时，都会降低数据库的性能，所以不推荐使用，那么数据的有效性怎么保证呢？答：可以在逻辑层进行控制 数值类型(常用) 类型 字节大小 有符号范围(Signed) 无符号范围(Unsigned) TINYINT 1 -128 ~ 127 0 ~ 255 SMALLINT 2 -32768 ~ 32767 0 ~ 65535 MEDIUMINT 3 -8388608 ~ 8388607 0 ~ 16777215 INT/INTEGER 4 -2147483648 ~2147483647 0 ~ 4294967295 BIGINT 8 -9223372036854775808 ~ 9223372036854775807 0 ~ 18446744073709551615 字符串 类型 字节大小 示例 CHAR 0-255 类型:char(3) 输入 ‘ab’, 实际存储为’ab ‘, 输入’abcd’ 实际存储为 ‘abc’ VARCHAR 0-255 类型:varchar(3) 输 ‘ab’,实际存储为’ab’, 输入’abcd’,实际存储为’abc’ TEXT 0-65535 大文本 日期时间类型 类型 字节大小 示例 DATE 4 ‘2020-01-01’ TIME 3 ‘12:29:59’ DATETIME 8 ‘2020-01-01 12:29:59’ YEAR 1 ‘2017’ TIMESTAMP 4 ‘1970-01-01 00:00:01’ UTC ~ ‘2038-01-01 00:00:01’ UTC ","date":"2020-01-31","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/:5:4","tags":["Python学习之路"],"title":"Python学习之路-数据库入门","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/"},{"categories":["MySQL"],"content":"命令行脚本 登陆与退出 最基本的连接命令如下，输入后回车 mysql -u root -p # 回车后输入密码 退出 quit 或者 exit 或 ctrl+d 登录成功后，输入如下命令查看效果 查看版本：select version(); 显示当前时间：select now(); 数据库相关操作 查看所有数据库 show databases; 使用数据库 use 数据库名; 查看当前使用的数据库 select database(); 创建数据库 create database 数据库名 charset=utf8; 删除数据库 drop database 数据库名; 数据表相关操作 查看当前数据库中所有表 show tables; 查看表结构 desc 表名; 创建表 提示 auto_increment表示自动增长 CREATE TABLE table_name( column1 datatype contrai, column2 datatype, column3 datatype, ..... columnN datatype, PRIMARY KEY(one or more columns) ); 提示 auto_increment表示自动增长 修改表-添加字段 alter table 表名 add 列名 类型; 修改表-修改字段：重命名版 alter table 表名 change 原名 新名 类型及约束; 修改表-修改字段：不重命名版 alter table 表名 modify 列名 类型及约束; 修改表-删除字段 alter table 表名 drop 列名; 删除表 drop table 表名; 查看表的创建语句 show create table 表名; 增删改查 查询 查询所有列 select * from 表名; 查询指定列 select 列1,列2,... from 表名; 提示 可以使用as为列或表指定别名 条件查询 使用where子句对表中的数据筛选，结果为true的行会出现在结果集中，语法如下： select * from 表名 where 条件; where后面支持多种运算符，进行条件的处理：比较运算符、逻辑运算符、模糊查询、范围查询、空判断 模糊查询 like %表示任意多个任意字符 _表示一个任意字符 select * from 表名 where 条件 like '模糊查询字符%'; 范围查询 select * from 表名 where 条件 in('范围查询'); 提示 in表示在一个非连续的范围内 空判断 select * from 表名 where 条件 is null; 提示 null与'‘是不同的，判空is null 优先级 优先级由高到低的顺序为：小括号，not，比较运算符，逻辑运算符，and比or先运算，如果同时出现并希望先算or，需要结合()使用。 增加 全列插入：值的顺序与表中字段的顺序对应 insert into 表名 values(...) 提示 说明：主键列是自动增长，但是在全列插入时需要占位，通常使用0或者 default 或者 null 来占位，插入成功后以实际数据为准 部分列插入：值的顺序与给出的列顺序对应 insert into 表名(列1,...) values(值1,...) 全列多行插入：值的顺序与给出的列顺序对应 insert into 表名 values(...),(...)...; 或 insert into 表名(列1,...) values(值1,...),(值1,...)...; 提示 上面的语句一次可以向表中插入一行数据，还可以一次性插入多行数据，这样可以减少与数据库的通信 修改 update 表名 set 列1=值1,列2=值2... where 条件 删除 delete from 表名 where 条件 逻辑删除，本质就是修改操作 update 表名 set isdelete=1 where 条件; 排序 为了方便查看数据，可以对数据进行排序，语法如下： select * from 表名 order by 列1 asc|desc [,列2 asc|desc,...] 行数据按照列1进行排序，如果某些行列1的值相同时，则按照列2排序，以此类推。默认按照列值从小到大排列。asc从小到大排列，即升序。desc从大到小排序，即降序。 聚合函数 为了快速得到统计数据，经常会用到如下5个聚合函数 总数 count(*)表示计算总行数，括号中写星与列名，结果是相同的 select count(*) from 表名; 最大值 max(列)表示求此列的最大值 select max(列) from 表名 where 条件; 最小值 min(列)表示求此列的最小值 select min(列) from 表名 where 条件; 求和 sum(列)表示求此列的和 select sum(列) from 表名 where 条件; 平均值 avg(列)表示求此列的平均值 select avg(列) from 表名 where 条件; 分组 group by，将查询结果按照1个或多个字段进行分组，字段值相同的为一组。可用于单个字段分组，也可用于多个字段分组 group by + group_concat() group_concat(字段名)可以作为一个输出字段来使用，表示分组之后，根据分组结果，使用group_concat()来放置每一组的某字段的值的集合 group by + 集合函数 通过group_concat()的启发，我们既然可以统计出每个分组的某字段的值的集合，那么我们也可以通过集合函数来对这个值的集合做一些操作 group by + having having 条件表达式：用来分组查询后指定一些条件来输出查询结果。having作用和where一样，但having只能用于group by group by + with rollup with rollup的作用是：在最后新增一行，来记录当前列里所有记录的总和 分页 当数据量过大时，在一页中查看数据是一件非常麻烦的事情，可以通过分行来解决，语法如下： select * from 表名 limit start,count 从start开始，获取count条数据 连接查询 当查询结果的列来源于多张表时，需要将多张表连接成一个大的数据集，再选择合适的列返回，mysql支持三种类型的连接查询，分别为： 内连接查询：查询的结果为两个表匹配到的数据 右连接查询：查询的结果为两个表匹配到的数据，右表特有的数据，对于左表中不存在的数据使用null填充 左连接查询：查询的结果为两个表匹配到的数据，左表特有的数据，对于右表中不存在的数据使用null填充 语法如下： select * from 表1 inner或left或right join 表2 on 表1.列 = 表2.列 子查询 在一个 select 语句中,嵌入了另外一个 select 语句, 那么被嵌入的 select 语句称之为子查询语句 主查询和子查询的关系 子查询是嵌入到主查询中；子查询是辅助主查询的,要么充当条件,要么充当数据源；子查询是可以独立存在的语句,是一条完整的 select 语句 子查询分类 标量子查询: 子查询返回的结果是一个数据(一行一列) 列子查询: 返回的结果是一列(一列多行) 行子查询: 返回的结果是一行(一行多列) 子查询中特定关键字使用 in 范围 格式: 主查询 where 条件 in (列子查询) 备份 运行mysqldump命令 mysqldump –uroot –p 数据库名 \u003e python.sql; # 按提示输入mysql的密码 恢复 连接mysql，创建新的数据库，退出连接，执行如下命令 mysql -uroot –p 新数据库名 \u003c python.sql # 根据提示输入mysql密码 ","date":"2020-01-31","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/:5:5","tags":["Python学习之路"],"title":"Python学习之路-数据库入门","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/"},{"categories":["MySQL"],"content":"数据库设计 关系型数据库建议在E-R模型的基础上，需要根据产品经理的设计策划，抽取出来模型与关系，制定出表结构，这是项目开始的第一步。在开发中有很多设计数据库的软件，常用的如power designer，db desinger等，这些软件可以直观的看到实体及实体间的关系。设计数据库，可能是由专门的数据库设计人员完成，也可能是由开发组成员完成，一般是项目经理带领组员来完成。 三范式 经过研究和对使用中问题的总结，对于设计数据库提出了一些规范，这些规范被称为范式(Normal Form)。目前有迹可寻的共有8种范式，一般需要遵守3范式即可： 第一范式（1NF）：强调的是列的原子性，即列不能够再分成其他几列。 第二范式（2NF）：首先是 1NF，另外包含两部分内容，一是表必须有一个主键；二是没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分。 第三范式（3NF）：首先是 2NF，另外非主键列必须直接依赖于主键，不能存在传递依赖。即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。 E-R模型 E表示entry，实体，设计实体就像定义一个类一样，指定从哪些方面描述对象，一个实体转换为数据库中的一个表 R表示relationship，关系，关系描述两个实体之间的对应规则，关系的类型包括包括一对一、一对多、多对多 关系也是一种数据，需要通过一个字段存储在表中 实体A对实体B为1对1，则在表A或表B中创建一个字段，存储另一个表的主键值 实体A对实体B为1对多：在表B中创建一个字段，存储表A的主键值 实体A对实体B为多对多：新建一张表C，这个表只有两个字段，一个用于存储A的主键值，一个用于存储B的主键值 逻辑删除 对于重要数据，并不希望物理删除，一旦删除，数据无法找回 删除方案：设置isDelete的列，类型为bit，表示逻辑删除，默认值为0 对于非重要数据，可以进行物理删除 数据的重要性，要根据实际开发决定 ","date":"2020-01-31","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/:5:6","tags":["Python学习之路"],"title":"Python学习之路-数据库入门","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/"},{"categories":["Python"],"content":"简介 正则表达式是计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些匹配某个模式的文本。 ","date":"2020-01-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:1:0","tags":["Python学习之路"],"title":"Python学习之路-正则表达式","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["Python"],"content":"RE模块 在Python中需要通过正则表达式对字符串进行匹配的时候，可以使用一个模块：re ","date":"2020-01-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:2:0","tags":["Python学习之路"],"title":"Python学习之路-正则表达式","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["Python"],"content":"语法 # 导入re模块 import re # 使用match方法进行匹配操作 result = re.match(\"正则表达式要匹配的字符串\") # 如果上一步匹配到数据的话，可以使用group方法来提取数据 result.group() re.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。 ","date":"2020-01-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:2:1","tags":["Python学习之路"],"title":"Python学习之路-正则表达式","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["Python"],"content":"正则表达式 单字符匹配 字符 功能 . 匹配任意1个字符（除了\\n） [ ] 匹配[ ]中列举的字符 \\d 匹配数字，即0-9 \\D 匹配非数字，即不是数字 \\s 匹配空白，即 空格，tab键 \\S 匹配非空白 \\w 匹配单词字符，即a-z、A-Z、0-9、_ \\W 匹配非单词字符 多个字符匹配 字符 功能 * 匹配前一个字符出现0次或者无限次，即可有可无 + 匹配前一个字符出现1次或者无限次，即至少有1次 ? 匹配前一个字符出现1次或者0次，即要么有1次，要么没有 {m} 匹配前一个字符出现m次 {m,n} 匹配前一个字符出现从m到n次 开头结尾匹配 字符 功能 ^ 匹配字符串开头 $ 匹配字符串结尾 分组匹配 字符 功能 | 匹配左右任意一个表达式 (ab) 将括号中字符作为一个分组 \\num 引用分组num匹配到的字符串 (?P\u003cname\u003e) 分组起别名 (?P=name) 引用别名为name分组匹配到的字符串 ","date":"2020-01-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:2:2","tags":["Python学习之路"],"title":"Python学习之路-正则表达式","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["Python"],"content":"高级用法 search re.search 扫描整个字符串并返回第一个成功的匹配。 语法 import re ret = re.search(r\"正则表达式\", \"正则表达式要匹配的字符串\") ret.group() match与search的区别 re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配。 findall 在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果没有找到匹配的，则返回空列表。 注意 match 和 search 是匹配一次 findall 匹配所有。 语法 import re ret = re.findall(r\"正则表达式\", \"正则表达式要匹配的字符串\") print(ret) sub 用于替换字符串中的匹配项。 语法 import re ret = re.sub(r\"正则表达式\", '替换的字符串', \"正则表达式要匹配的字符串\") print(ret) split 按照能够匹配的子串将字符串分割后返回列表 语法 import re ret = re.split(r\"正则表达式\",\"正则表达式要匹配的字符串\") print(ret) ","date":"2020-01-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:2:3","tags":["Python学习之路"],"title":"Python学习之路-正则表达式","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["Python"],"content":"贪婪和非贪婪 Python里数量词默认是贪婪的（在少数语言里也可能是默认非贪婪），总是尝试匹配尽可能多的字符；非贪婪则相反，总是尝试匹配尽可能少的字符。在”*”,”?”,“+”,\"{m,n}“后面加上？，使贪婪变成非贪婪。 正则表达式模式中使用到通配字，那它在从左到右的顺序求值时，会尽量“抓取”满足匹配最长字符串，在我们上面的例子里面，“.+”会从字符串的启始处抓取满足模式的最长字符，其中包括我们想得到的第一个整型字段的中的大部分，“\\d+”只需一位字符就可以匹配，所以它匹配了数字“4”，而“.+”则匹配了从字符串起始到这个第一位数字4之前的所有字符。 解决方式：非贪婪操作符“？”，这个操作符可以用在”*”,“+”,”?“的后面，要求正则匹配的越少越好。 ","date":"2020-01-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:2:4","tags":["Python学习之路"],"title":"Python学习之路-正则表达式","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["Python"],"content":"r的作用 Python中字符串前面加上 r 表示原生字符串，与大多数编程语言相同，正则表达式里使用\\作为转义字符，这就可能造成反斜杠困扰。假如你需要匹配文本中的字符\\，那么使用编程语言表示的正则表达式里将需要4个反斜杠\\：前两个和后两个分别用于在编程语言里转义成反斜杠，转换成两个反斜杠后再在正则表达式里转义成一个反斜杠。Python里的原生字符串很好地解决了这个问题，有了原生字符串，你再也不用担心是不是漏写了反斜杠，写出来的表达式也更直观。 ","date":"2020-01-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:2:5","tags":["Python学习之路"],"title":"Python学习之路-正则表达式","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["生活"],"content":"前言 没想到这次新冠这么严重，年都不能好好过了，还好家里备了很多吃的，应该还够坚持一周的吧，节约点吃吧。。。 ","date":"2020-01-25","objectID":"/%E6%96%B0%E5%86%A0%E6%84%9F%E6%83%B3/:1:0","tags":["新冠"],"title":"新冠感想","uri":"/%E6%96%B0%E5%86%A0%E6%84%9F%E6%83%B3/"},{"categories":["生活"],"content":"感想 这次新冠最大的感触生命真的很珍贵，一个亲戚在武汉的某个医院上班，见过很多生离死别，她发过来的视频真的很震撼，第一次离我这么近。武汉那边水深火热，人心惶惶的，但看到那么多为新冠付出的人，我相信一切都会好起来的，这次对我们中华民族的打击可能会让我们停下前进的脚步，但绝不会击垮我们。我们有那么多可爱的人，上海第一时间就派出了援汉的医疗队，他们不惧死亡，只为拯救更多的中华儿女。有时候我也会向往米国的自由，但是假如他们受到这般打击，他们绝对会一塌糊涂，他们没有我们的凝聚力，国家不会放弃任何一个人。这几年来，我越来越感受到祖国的强大，各行各业也都有了起色，我相信我们这股凝聚力能让疫情早点恢复，可能还需要些时间，但都会好起来的，全国人民都跟我们一起共度难关。就想国庆看的电影我和我的祖国里那样，不管是大人物还是小人物，我们都在自己的岗位上努力，让祖国变得更好，我们有人民的军队和人民的医生，他们敢于在祖国人民身处危难的时候挺身而出，有他们的无私奉献，中国才能这么强大。 最后，希望大家都在坚持一下，在居家隔离一段时间，为医护人员减少点负担，一起加油💪 ","date":"2020-01-25","objectID":"/%E6%96%B0%E5%86%A0%E6%84%9F%E6%83%B3/:2:0","tags":["新冠"],"title":"新冠感想","uri":"/%E6%96%B0%E5%86%A0%E6%84%9F%E6%83%B3/"},{"categories":["生活"],"content":"前言 不知道该说我是幸运呢还是不幸，22号坐火车从上海回到武汉，转火车回黄石的时候差点没赶上火车，最后5分钟进的站，上车不到一分钟就开车了，晚上刚刚到家就听到武汉要封城的消息，结果第二天一醒来就听到真的封城的消息，要是没有赶上火车，可能我就回不来了。。。 ","date":"2020-01-22","objectID":"/%E6%AD%A6%E6%B1%89%E5%B0%81%E5%9F%8E%E4%BA%86/:1:0","tags":["武汉"],"title":"武汉封城了","uri":"/%E6%AD%A6%E6%B1%89%E5%B0%81%E5%9F%8E%E4%BA%86/"},{"categories":["生活"],"content":"感慨 现在还不清楚具体情况，不过听说黄石马上也要封城了，应该是比较严重了吧，未来还不知道会发生什么情况，希望这场风波能早点过去吧。武汉目前情况比较严重了，感染人数每天也在指数增长，希望能早点好起来吧。马上过年了，大家出门记得做好防护呀！一定要劝父母长辈们一起做好防护，他们都不当回事，现在武汉都封城了，说明问题的严重性了，一定一定要劝住他们，一起做好防护，保护好自己，保护你们的家人，咱们一起共度难关！干巴爹！ ","date":"2020-01-22","objectID":"/%E6%AD%A6%E6%B1%89%E5%B0%81%E5%9F%8E%E4%BA%86/:2:0","tags":["武汉"],"title":"武汉封城了","uri":"/%E6%AD%A6%E6%B1%89%E5%B0%81%E5%9F%8E%E4%BA%86/"},{"categories":["Python"],"content":"简介 协程，又称微线程，纤程。英文名Coroutine。协程是python个中另外一种实现多任务的方式，只不过比线程更小占用更小执行单元（理解为需要的资源）。 为啥说它是一个执行单元，因为它自带CPU上下文。这样只要在合适的时机， 我们可以把一个协程 切换到另一个协程。 只要这个过程中保存或恢复 CPU上下文那么程序还是可以运行的。 通俗的理解：在一个线程中的某个函数，可以在任何地方保存当前函数的一些临时变量等信息，然后切换到另外一个函数中执行，注意不是通过调用函数的方式做到的，并且切换的次数以及什么时候再切换到原来的函数都由开发者自己确定 ","date":"2020-01-18","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/:1:0","tags":["Python学习之路"],"title":"Python学习之路-多任务:协程","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/"},{"categories":["Python"],"content":"协程和线程差异 在实现多任务时, 线程切换从系统层面远不止保存和恢复 CPU上下文这么简单。 操作系统为了程序运行的高效性每个线程都有自己缓存Cache等等数据，操作系统还会帮你做这些数据的恢复操作。 所以线程的切换非常耗性能。但是协程的切换只是单纯的操作CPU的上下文，所以一秒钟切换个上百万次系统都抗的住。 ","date":"2020-01-18","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/:2:0","tags":["Python学习之路"],"title":"Python学习之路-多任务:协程","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/"},{"categories":["Python"],"content":"迭代 迭代是访问集合元素的一种方式。使用for…in…的循环语法从其中依次拿到数据进行使用，我们把这样的过程称为遍历，也叫迭代。 ","date":"2020-01-18","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/:3:0","tags":["Python学习之路"],"title":"Python学习之路-多任务:协程","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/"},{"categories":["Python"],"content":"迭代器 迭代器是一个可以记住遍历的位置的对象。迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。 ","date":"2020-01-18","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/:4:0","tags":["Python学习之路"],"title":"Python学习之路-多任务:协程","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/"},{"categories":["Python"],"content":"可迭代对象 把可以通过for…in…这类语句迭代读取一条数据供我们使用的对象称之为可迭代对象（Iterable）。可以使用 isinstance() 判断一个对象是否是可迭代对象 Iterable 对象。 ","date":"2020-01-18","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/:5:0","tags":["Python学习之路"],"title":"Python学习之路-多任务:协程","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/"},{"categories":["Python"],"content":"可迭代对象的本质 我们分析对可迭代对象进行迭代使用的过程，发现每迭代一次（即在for…in…中每循环一次）都会返回对象中的下一条数据，一直向后读取数据直到迭代了所有数据后结束。那么，在这个过程中就应该有一个“人”去记录每次访问到了第几条数据，以便每次迭代都可以返回下一条数据。我们把这个能帮助我们进行数据迭代的“人”称为迭代器(Iterator)。 可迭代对象的本质就是可以向我们提供一个这样的中间“人”即迭代器帮助我们对其进行迭代遍历使用。 可迭代对象通过__iter__方法向我们提供一个迭代器，我们在迭代一个可迭代对象的时候，实际上就是先获取该对象提供的一个迭代器，然后通过这个迭代器来依次获取对象中的每一个数据. 那么也就是说，一个具备了__iter__方法的对象，就是一个可迭代对象。 注意 可以通过iter()函数获取这些可迭代对象的迭代器(iter()函数实际上就是调用了可迭代对象的__iter__方法)，然后我们可以对获取到的迭代器不断使用next()函数来获取下一条数据(使用next()函数的时候，调用的就是迭代器对象的__next__方法)。当我们已经迭代完最后一个数据之后，再次调用next()函数会抛出StopIteration的异常，来告诉我们所有数据都已迭代完成，不用再执行next()函数了。 ","date":"2020-01-18","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/:5:1","tags":["Python学习之路"],"title":"Python学习之路-多任务:协程","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/"},{"categories":["Python"],"content":"for…in…循环的本质 for item in Iterable 循环的本质就是先通过iter()函数获取可迭代对象Iterable的迭代器，然后对获取到的迭代器不断调用next()方法来获取下一个值并将其赋值给item，当遇到StopIteration的异常后循环结束。 ","date":"2020-01-18","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/:5:2","tags":["Python学习之路"],"title":"Python学习之路-多任务:协程","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/"},{"categories":["Python"],"content":"生成器 ","date":"2020-01-18","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/:6:0","tags":["Python学习之路"],"title":"Python学习之路-多任务:协程","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/"},{"categories":["Python"],"content":"简介 生成器是一类特殊的迭代器。利用迭代器，我们可以在每次迭代获取数据（通过next()方法）时按照特定的规律进行生成。但是我们在实现一个迭代器时，关于当前迭代到的状态需要我们自己记录，进而才能根据当前状态生成下一个数据。为了达到记录当前状态，并配合next()函数进行迭代使用，我们可以采用更简便的语法，即生成器(generator) ","date":"2020-01-18","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/:6:1","tags":["Python学习之路"],"title":"Python学习之路-多任务:协程","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/"},{"categories":["Python"],"content":"创建生成器方法 只要把一个列表生成式的 改成 ( )，如下 In [1]: A = [ x*2 for x in range(5)] In [2]: A Out[2]: [0, 2, 4, 6, 8] In [3]: B = ( x*2 for x in range(5)) In [4]: B Out[4]: \u003cgenerator object \u003cgenexpr\u003e at 0x7f626c132db0\u003e 创建 L 和 G 的区别仅在于最外层的 [ ] 和 ( ) ， L 是一个列表，而 G 是一个生成器。我们可以直接打印出列表L的每一个元素，而对于生成器G，我们可以按照迭代器的使用方法来使用，即可以通过next()函数、for循环、list()等方法使用。 In [5]: next(G) Out[5]: 0 In [6]: next(G) Out[6]: 2 In [7]: next(G) Out[7]: 4 In [8]: next(G) Out[8]: 6 In [9]: next(G) Out[9]: 8 In [10]: next(G) --------------------------------------------------------------------------- StopIteration Traceback (most recent call last) \u003cipython-input-24-380e167d6934\u003e in \u003cmodule\u003e() ----\u003e 1 next(G) StopIteration: In [11]: In [12]: G = ( x*2 for x in range(5)) In [13]: for x in G: ....: print(x) ....: 0 2 4 6 8 In [14]: 将原本在迭代器__next__方法中实现的基本逻辑放到一个函数中来实现，但是将每次迭代返回数值的return换成了yield，此时新定义的函数便不再是函数，而是一个生成器了。简单来说：只要在def中有yield关键字的 就称为 生成器。用生成器实现斐波那契数列 In [15]: def fib(n): ....: current = 0 ....: num1, num2 = 0, 1 ....: while current \u003c n: ....: num = num1 ....: num1, num2 = num2, num1+num2 ....: current += 1 ....: yield num ....: return 'done' ....: In [16]: F = fib(5) In [17]: next(F) Out[17]: 1 In [18]: next(F) Out[18]: 1 In [19]: next(F) Out[19]: 2 In [20]: next(F) Out[20]: 3 In [21]: next(F) Out[21]: 5 In [22]: next(F) --------------------------------------------------------------------------- StopIteration Traceback (most recent call last) \u003cipython-input-22-8c2b02b4361a\u003e in \u003cmodule\u003e() ----\u003e 1 next(F) StopIteration: done 此时按照调用函数的方式( 案例中为F = fib(5) )使用生成器就不再是执行函数体了，而是会返回一个生成器对象（ 案例中为F ），然后就可以按照使用迭代器的方式来使用生成器了。 In [23]: for n in fib(5): ....: print(n) ....: 1 1 2 3 5 但是用for循环调用generator时，发现拿不到generator的return语句的返回值。如果想要拿到返回值，必须捕获StopIteration错误，返回值包含在StopIteration的value中： In [25]: g = fib(5) In [26]: while True: ....: try: ....: x = next(g) ....: print(\"value:%d\"%x) ....: except StopIteration as e: ....: print(\"生成器返回值:%s\"%e.value) ....: break ....: value:1 value:1 value:2 value:3 value:5 生成器返回值:done ","date":"2020-01-18","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/:6:2","tags":["Python学习之路"],"title":"Python学习之路-多任务:协程","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/"},{"categories":["Python"],"content":"使用send唤醒 我们除了可以使用next()函数来唤醒生成器继续执行外，还可以使用send()函数来唤醒执行。使用send()函数的一个好处是可以在唤醒的同时向断点处传入一个附加数据。 例子：执行到yield时，gen函数作用暂时保存，返回i的值; temp接收下次c.send(“python”)，send发送过来的值，c.next()等价c.send(None) In [27]: def gen(): ....: i = 0 ....: while i\u003c5: ....: temp = yield i ....: print(temp) ....: i+=1 ....: 使用send In [28]: f = gen() In [29]: next(f) Out[29]: 0 In [30]: f.send('haha') haha Out[30]: 1 In [31]: next(f) None Out[31]: 2 In [32]: f.send('haha') haha Out[32]: 3 使用next函数 In [33]: f = gen() In [34]: next(f) Out[34]: 0 In [35]: next(f) None Out[35]: 1 In [36]: next(f) None Out[36]: 2 In [37]: next(f) None Out[37]: 3 In [38]: next(f) None Out[38]: 4 In [39]: next(f) None --------------------------------------------------------------------------- StopIteration Traceback (most recent call last) \u003cipython-input-17-468f0afdf1b9\u003e in \u003cmodule\u003e() ----\u003e 1 next(f) StopIteration: 使用__next__()方法（不常使用） In [40]: f = gen() In [41]: f.__next__() Out[41]: 0 In [42]: f.__next__() None Out[42]: 1 In [43]: f.__next__() None Out[43]: 2 In [44]: f.__next__() None Out[44]: 3 In [45]: f.__next__() None Out[45]: 4 In [46]: f.__next__() None --------------------------------------------------------------------------- StopIteration Traceback (most recent call last) \u003cipython-input-24-39ec527346a9\u003e in \u003cmodule\u003e() ----\u003e 1 f.__next__() StopIteration: ","date":"2020-01-18","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/:6:3","tags":["Python学习之路"],"title":"Python学习之路-多任务:协程","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/"},{"categories":["Python"],"content":"简单实现协程 import time def work1(): while True: print(\"----work1---\") yield time.sleep(0.5) def work2(): while True: print(\"----work2---\") yield time.sleep(0.5) def main(): w1 = work1() w2 = work2() while True: next(w1) next(w2) if __name__ == \"__main__\": main() 运行结果： ----work1--- ----work2--- ----work1--- ----work2--- ----work1--- ----work2--- ----work1--- ----work2--- ----work1--- ----work2--- ----work1--- ----work2--- ...省略... ","date":"2020-01-18","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/:7:0","tags":["Python学习之路"],"title":"Python学习之路-多任务:协程","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/"},{"categories":["Python"],"content":"greenlet 为了更好使用协程来完成多任务，python中的greenlet模块对其封装，从而使得切换任务变的更加简单 ","date":"2020-01-18","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/:8:0","tags":["Python学习之路"],"title":"Python学习之路-多任务:协程","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/"},{"categories":["Python"],"content":"安装 使用如下命令安装greenlet模块: sudo pip3 install greenlet ","date":"2020-01-18","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/:8:1","tags":["Python学习之路"],"title":"Python学习之路-多任务:协程","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/"},{"categories":["Python"],"content":"简单实现 from greenlet import greenlet import time def test1(): while True: print \"---A--\" gr2.switch() time.sleep(0.5) def test2(): while True: print \"---B--\" gr1.switch() time.sleep(0.5) gr1 = greenlet(test1) gr2 = greenlet(test2) #切换到gr1中运行 gr1.switch() 运行效果： ---A-- ---B-- ---A-- ---B-- ---A-- ---B-- ---A-- ---B-- ...省略... ","date":"2020-01-18","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/:8:2","tags":["Python学习之路"],"title":"Python学习之路-多任务:协程","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/"},{"categories":["Python"],"content":"gevent greenlet已经实现了协程，但是这个还的人工切换，是不是觉得太麻烦了，不要捉急，python还有一个比greenlet更强大的并且能够自动切换任务的模块gevent 其原理是当一个greenlet遇到IO(指的是input output 输入输出，比如网络、文件操作等)操作时，比如访问网络，就自动切换到其他的greenlet，等到IO操作完成，再在适当的时候切换回来继续执行。 由于IO操作非常耗时，经常使程序处于等待状态，有了gevent为我们自动切换协程，就保证总有greenlet在运行，而不是等待IO ","date":"2020-01-18","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/:9:0","tags":["Python学习之路"],"title":"Python学习之路-多任务:协程","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/"},{"categories":["Python"],"content":"安装 使用如下命令安装gevent模块: pip3 install gevent ","date":"2020-01-18","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/:9:1","tags":["Python学习之路"],"title":"Python学习之路-多任务:协程","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/"},{"categories":["Python"],"content":"简单实现 import gevent def f(n): for i in range(n): print(gevent.getcurrent(), i) g1 = gevent.spawn(f, 5) g2 = gevent.spawn(f, 5) g3 = gevent.spawn(f, 5) g1.join() g2.join() g3.join() 运行结果 \u003cGreenlet at 0x10e49f550: f(5)\u003e 0 \u003cGreenlet at 0x10e49f550: f(5)\u003e 1 \u003cGreenlet at 0x10e49f550: f(5)\u003e 2 \u003cGreenlet at 0x10e49f550: f(5)\u003e 3 \u003cGreenlet at 0x10e49f550: f(5)\u003e 4 \u003cGreenlet at 0x10e49f910: f(5)\u003e 0 \u003cGreenlet at 0x10e49f910: f(5)\u003e 1 \u003cGreenlet at 0x10e49f910: f(5)\u003e 2 \u003cGreenlet at 0x10e49f910: f(5)\u003e 3 \u003cGreenlet at 0x10e49f910: f(5)\u003e 4 \u003cGreenlet at 0x10e49f4b0: f(5)\u003e 0 \u003cGreenlet at 0x10e49f4b0: f(5)\u003e 1 \u003cGreenlet at 0x10e49f4b0: f(5)\u003e 2 \u003cGreenlet at 0x10e49f4b0: f(5)\u003e 3 \u003cGreenlet at 0x10e49f4b0: f(5)\u003e 4 可以看到，3个greenlet是依次运行而不是交替运行 ","date":"2020-01-18","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/:9:2","tags":["Python学习之路"],"title":"Python学习之路-多任务:协程","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/"},{"categories":["Python"],"content":"切换执行 import gevent def f(n): for i in range(n): print(gevent.getcurrent(), i) #用来模拟一个耗时操作，注意不是time模块中的sleep gevent.sleep(1) g1 = gevent.spawn(f, 5) g2 = gevent.spawn(f, 5) g3 = gevent.spawn(f, 5) g1.join() g2.join() g3.join() 运行结果 \u003cGreenlet at 0x7fa70ffa1c30: f(5)\u003e 0 \u003cGreenlet at 0x7fa70ffa1870: f(5)\u003e 0 \u003cGreenlet at 0x7fa70ffa1eb0: f(5)\u003e 0 \u003cGreenlet at 0x7fa70ffa1c30: f(5)\u003e 1 \u003cGreenlet at 0x7fa70ffa1870: f(5)\u003e 1 \u003cGreenlet at 0x7fa70ffa1eb0: f(5)\u003e 1 \u003cGreenlet at 0x7fa70ffa1c30: f(5)\u003e 2 \u003cGreenlet at 0x7fa70ffa1870: f(5)\u003e 2 \u003cGreenlet at 0x7fa70ffa1eb0: f(5)\u003e 2 \u003cGreenlet at 0x7fa70ffa1c30: f(5)\u003e 3 \u003cGreenlet at 0x7fa70ffa1870: f(5)\u003e 3 \u003cGreenlet at 0x7fa70ffa1eb0: f(5)\u003e 3 \u003cGreenlet at 0x7fa70ffa1c30: f(5)\u003e 4 \u003cGreenlet at 0x7fa70ffa1870: f(5)\u003e 4 \u003cGreenlet at 0x7fa70ffa1eb0: f(5)\u003e 4 ","date":"2020-01-18","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/:9:3","tags":["Python学习之路"],"title":"Python学习之路-多任务:协程","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/"},{"categories":["Python"],"content":"给程序打补丁 from gevent import monkey import gevent import random import time def coroutine_work(coroutine_name): for i in range(10): print(coroutine_name, i) time.sleep(random.random()) gevent.joinall([ gevent.spawn(coroutine_work, \"work1\"), gevent.spawn(coroutine_work, \"work2\") ]) 运行结果 work1 0 work1 1 work1 2 work1 3 work1 4 work1 5 work1 6 work1 7 work1 8 work1 9 work2 0 work2 1 work2 2 work2 3 work2 4 work2 5 work2 6 work2 7 work2 8 work2 9 ","date":"2020-01-18","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/:9:4","tags":["Python学习之路"],"title":"Python学习之路-多任务:协程","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/"},{"categories":["Python"],"content":"monkey from gevent import monkey import gevent import random import time # 有耗时操作时需要 monkey.patch_all() # 将程序中用到的耗时操作的代码，换为gevent中自己实现的模块 def coroutine_work(coroutine_name): for i in range(10): print(coroutine_name, i) time.sleep(random.random()) gevent.joinall([ gevent.spawn(coroutine_work, \"work1\"), gevent.spawn(coroutine_work, \"work2\") ]) 运行结果 work1 0 work2 0 work1 1 work1 2 work1 3 work2 1 work1 4 work2 2 work1 5 work2 3 work1 6 work1 7 work1 8 work2 4 work2 5 work1 9 work2 6 work2 7 work2 8 work2 9 ","date":"2020-01-18","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/:9:5","tags":["Python学习之路"],"title":"Python学习之路-多任务:协程","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/"},{"categories":["Python"],"content":"进程、线程、协程对比 进程是资源分配的单位 线程是操作系统调度的单位 进程切换需要的资源很最大，效率很低 线程切换需要的资源一般，效率一般（当然了在不考虑GIL的情况下） 协程切换任务资源很小，效率高 多进程、多线程根据cpu核数不一样可能是并行的，但是协程是在一个线程中 所以是并发 ","date":"2020-01-18","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/:10:0","tags":["Python学习之路"],"title":"Python学习之路-多任务:协程","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/"},{"categories":["Python"],"content":"简介 一个程序运行起来后，代码+用到的资源 称之为进程，它是操作系统分配资源的基本单元。不仅可以通过线程完成多任务，进程也是可以的。 ","date":"2020-01-11","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%BF%9B%E7%A8%8B/:1:0","tags":["Python学习之路"],"title":"Python学习之路-多任务:进程","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%BF%9B%E7%A8%8B/"},{"categories":["Python"],"content":"状态 工作中，任务数往往大于cpu的核数，即一定有一些任务正在执行，而另外一些任务在等待cpu进行执行，因此导致了有了不同的状态 就绪态：运行的条件都已经慢去，正在等在cpu执行 执行态：cpu正在执行其功能 等待态：等待某些条件满足，例如一个程序sleep了，此时就处于等待态 ","date":"2020-01-11","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%BF%9B%E7%A8%8B/:2:0","tags":["Python学习之路"],"title":"Python学习之路-多任务:进程","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%BF%9B%E7%A8%8B/"},{"categories":["Python"],"content":"multiprocessing模块 ","date":"2020-01-11","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%BF%9B%E7%A8%8B/:3:0","tags":["Python学习之路"],"title":"Python学习之路-多任务:进程","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%BF%9B%E7%A8%8B/"},{"categories":["Python"],"content":"简介 multiprocessing模块是跨平台版本的多进程模块，提供了一个Process类来代表一个进程对象，这个对象可以理解为是一个独立的进程，可以执行另外的事情 ","date":"2020-01-11","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%BF%9B%E7%A8%8B/:3:1","tags":["Python学习之路"],"title":"Python学习之路-多任务:进程","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%BF%9B%E7%A8%8B/"},{"categories":["Python"],"content":"语法 from multiprocessing import Process p = Process(target=\"函数名\") p.start() Process([group [, target [, name [, args [, kwargs]]]]]) target：如果传递了函数的引用，可以任务这个子进程就执行这里的代码 args：给target指定的函数传递的参数，以元组的方式传递 kwargs：给target指定的函数传递命名参数 name：给进程设定一个名字，可以不设定 group：指定进程组，大多数情况下用不到 Process创建的实例对象的常用方法： start()：启动子进程实例（创建子进程） is_alive()：判断进程子进程是否还在活着 join([timeout])：是否等待子进程执行结束，或等待多少秒 terminate()：不管任务是否完成，立即终止子进程 Process创建的实例对象的常用属性： name：当前进程的别名，默认为Process-N，N为从1开始递增的整数 pid：当前进程的pid（进程号） 注意 可以通过os.getpid()来获取进程号。进程间不同享全局变量。 ","date":"2020-01-11","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%BF%9B%E7%A8%8B/:3:2","tags":["Python学习之路"],"title":"Python学习之路-多任务:进程","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%BF%9B%E7%A8%8B/"},{"categories":["Python"],"content":"进程间通信 ","date":"2020-01-11","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%BF%9B%E7%A8%8B/:4:0","tags":["Python学习之路"],"title":"Python学习之路-多任务:进程","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%BF%9B%E7%A8%8B/"},{"categories":["Python"],"content":"简介 Process之间有时需要通信，操作系统提供了很多机制来实现进程间的通信。 ","date":"2020-01-11","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%BF%9B%E7%A8%8B/:4:1","tags":["Python学习之路"],"title":"Python学习之路-多任务:进程","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%BF%9B%E7%A8%8B/"},{"categories":["Python"],"content":"Queue 可以使用multiprocessing模块的Queue实现多进程之间的数据传递，Queue本身是一个消息列队程序。 初始化Queue()对象时（例如：q=Queue()），若括号中没有指定最大可接收的消息数量，或数量为负值，那么就代表可接受的消息数量没有上限（直到内存的尽头）； Queue.qsize()：返回当前队列包含的消息数量； Queue.empty()：如果队列为空，返回True，反之False ； Queue.full()：如果队列满了，返回True,反之False； Queue.get([block[, timeout]])：获取队列中的一条消息，然后将其从列队中移除，block默认值为True； 1）如果block使用默认值，且没有设置timeout（单位秒），消息列队如果为空，此时程序将被阻塞（停在读取状态），直到从消息列队读到消息为止，如果设置了timeout，则会等待timeout秒，若还没读取到任何消息，则抛出\"Queue.Empty\"异常； 2）如果block值为False，消息列队如果为空，则会立刻抛出\"Queue.Empty\"异常； Queue.get_nowait()：相当Queue.get(False)； Queue.put(item,[block[, timeout]])：将item消息写入队列，block默认值为True； 1）如果block使用默认值，且没有设置timeout（单位秒），消息列队如果已经没有空间可写入，此时程序将被阻塞（停在写入状态），直到从消息列队腾出空间为止，如果设置了timeout，则会等待timeout秒，若还没空间，则抛出\"Queue.Full\"异常； 2）如果block值为False，消息列队如果没有空间可写入，则会立刻抛出\"Queue.Full\"异常； Queue.put_nowait(item)：相当Queue.put(item, False)； ","date":"2020-01-11","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%BF%9B%E7%A8%8B/:4:2","tags":["Python学习之路"],"title":"Python学习之路-多任务:进程","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%BF%9B%E7%A8%8B/"},{"categories":["Python"],"content":"进程池 当需要创建的子进程数量不多时，可以直接利用multiprocessing中的Process动态成生多个进程，但如果是上百甚至上千个目标，手动的去创建进程的工作量巨大，此时就可以用到multiprocessing模块提供的Pool方法。 初始化Pool时，可以指定一个最大进程数，当有新的请求提交到Pool中时，如果池还没有满，那么就会创建一个新的进程用来执行该请求；但如果池中的进程数已经达到指定的最大值，那么该请求就会等待，直到池中有进程结束，才会用之前的进程来执行新的任务。 multiprocessing.Pool常用函数解析： apply_async(func[, args[, kwds]]) ：使用非阻塞方式调用func（并行执行，堵塞方式必须等待上一个进程退出才能执行下一个进程），args为传递给func的参数列表，kwds为传递给func的关键字参数列表； close()：关闭Pool，使其不再接受新的任务； terminate()：不管任务是否完成，立即终止； join()：主进程阻塞，等待子进程的退出， 必须在close或terminate之后使用； 如果要使用Pool创建进程，就需要使用multiprocessing.Manager()中的Queue()，而不是multiprocessing.Queue()，否则会得到一条如下的错误信息： RuntimeError: Queue objects should only be shared between processes through inheritance. ","date":"2020-01-11","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%BF%9B%E7%A8%8B/:4:3","tags":["Python学习之路"],"title":"Python学习之路-多任务:进程","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%BF%9B%E7%A8%8B/"},{"categories":["Python"],"content":"简介 什么叫“多任务”呢？简单地说，就是操作系统可以同时运行多个任务。操作系统轮流让各个任务交替执行，表面上看，每个任务都是交替执行的，但是，由于CPU的执行速度实在是太快了，我们感觉就像所有任务都在同时执行一样。真正的并行执行多任务只能在多核CPU上实现，但是，由于任务数量远远多于CPU的核心数量，所以，操作系统也会自动把很多任务轮流调度到每个核心上执行。 拓展 并发：指的是任务数多余cpu核数，通过操作系统的各种任务调度算法，实现用多个任务“一起”执行（实际上总有一些任务不在执行，因为切换任务的速度相当快，看上去一起执行而已）。 并行：指的是任务数小于等于cpu核数，即任务真的是一起执行的。 ","date":"2020-01-04","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%BA%BF%E7%A8%8B/:1:0","tags":["Python学习之路"],"title":"Python学习之路-多任务:线程","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%BA%BF%E7%A8%8B/"},{"categories":["Python"],"content":"线程 ","date":"2020-01-04","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%BA%BF%E7%A8%8B/:2:0","tags":["Python学习之路"],"title":"Python学习之路-多任务:线程","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%BA%BF%E7%A8%8B/"},{"categories":["Python"],"content":"简介 线程是程序的最小执行流单元，是程序中一个单一的顺序控制流程 ","date":"2020-01-04","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%BA%BF%E7%A8%8B/:2:1","tags":["Python学习之路"],"title":"Python学习之路-多任务:线程","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%BA%BF%E7%A8%8B/"},{"categories":["Python"],"content":"threading模块 python的thread模块是比较底层的模块，python的threading模块是对thread做了一些包装的，可以更加方便的被使用 语法 import threading t = threading.Thread(target=\"函数名\") t.start() 当调用start()时，才会真正的创建线程，并且开始执行。主线程会等待所有的子线程结束后才结束 查看线程数量 可以通过len(threading.enumerate())查看当前线程数量 注意点 线程执行代码的封装 通过使用threading模块能完成多任务的程序开发，为了让每个线程的封装性更完美，所以使用threading模块时，往往会定义一个新的子类class，只要继承threading.Thread就可以了，然后重写run方法。 拓展 python的threading.Thread类有一个run方法，用于定义线程的功能函数，可以在自己的线程类中覆盖该方法。而创建自己的线程实例后，通过Thread类的start方法，可以启动该线程，交给python虚拟机进行调度，当该线程获得执行的机会时，就会调用run方法执行线程。 线程的执行顺序 多线程程序的执行顺序是不确定的。当执行到sleep语句时，线程将被阻塞（Blocked），到sleep结束后，线程进入就绪（Runnable）状态，等待调度。而线程调度将自行选择一个线程执行。上面的代码中只能保证每个线程都运行完整个run函数，但是线程的启动顺序、run函数中每次循环的执行顺序都不能确定。 拓展 每个线程默认有一个名字，尽管上面的例子中没有指定线程对象的name，但是python会自动为线程指定一个名字。 当线程的run()方法结束时该线程完成。 无法控制线程调度程序，但可以通过别的方式来影响线程调度的方式。 共享全局变量 在一个进程内的所有线程共享全局变量，很方便在多个线程间共享数据，缺点就是线程是对全局变量随意遂改可能造成多线程之间对全局变量的混乱（即线程非安全）。 多线程开发可能遇到的问题 假设两个线程t1和t2都要对全局变量g_num(默认是0)进行加1运算，t1和t2都各对g_num加10次，g_num的最终的结果应该为20。 但是由于是多线程同时操作，有可能出现下面情况： 在g_num=0时，t1取得g_num=0。此时系统把t1调度为”sleeping”状态，把t2转换为”running”状态，t2也获得g_num=0 然后t2对得到的值进行加1并赋给g_num，使得g_num=1 然后系统又把t2调度为”sleeping”，把t1转为”running”。线程t1又把它之前得到的0加1后赋值给g_num。 这样导致虽然t1和t2都对g_num加1，但结果仍然是g_num=1 如果多个线程同时对同一个全局变量操作，会出现资源竞争问题，从而数据结果会不正确 互斥锁 简介 当多个线程几乎同时修改某一个共享数据的时候，需要进行同步控制，线程同步能够保证多个线程安全访问竞争资源，最简单的同步机制是引入互斥锁。 互斥锁为资源引入一个状态：锁定/非锁定 某个线程要更改共享数据时，先将其锁定，此时资源的状态为“锁定”，其他线程不能更改；直到该线程释放资源，将资源的状态变成“非锁定”，其他的线程才能再次锁定该资源。互斥锁保证了每次只有一个线程进行写入操作，从而保证了多线程情况下数据的正确性。 threading模块中定义了Lock类，可以方便的处理锁定： # 创建锁 mutex = threading.Lock() # 锁定 mutex.acquire() # 释放 mutex.release() 注意 如果这个锁之前是没有上锁的，那么acquire不会堵塞 如果在调用acquire对这个锁上锁之前 它已经被 其他线程上了锁，那么此时acquire会堵塞，直到这个锁被解锁为止 上锁解锁过程 当一个线程调用锁的acquire()方法获得锁时，锁就进入“locked”状态。 每次只有一个线程可以获得锁。如果此时另一个线程试图获得这个锁，该线程就会变为“blocked”状态，称为“阻塞”，直到拥有锁的线程调用锁的release()方法释放锁之后，锁进入“unlocked”状态。 线程调度程序从处于同步阻塞状态的线程中选择一个来获得锁，并使得该线程进入运行（running）状态。 优缺点 优点：确保了某段关键代码只能由一个线程从头到尾完整地执行 缺点：阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了；由于可以存在多个锁，不同的线程持有不同的锁，并试图获取对方持有的锁时，可能会造成死锁 死锁 在线程间共享多个资源的时候，如果两个线程分别占有一部分资源并且同时等待对方的资源，就会造成死锁。尽管死锁很少发生，但一旦发生就会造成应用的停止响应。 如何避免死锁 程序设计时要尽量避免 添加超时时间等 ","date":"2020-01-04","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%BA%BF%E7%A8%8B/:2:2","tags":["Python学习之路"],"title":"Python学习之路-多任务:线程","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%BA%BF%E7%A8%8B/"},{"categories":["Python"],"content":"GIL GIL为全局解释器锁。每个线程在执行的过程都需要先获取GIL，保证同一时刻只有一个线程可以执行代码。 Python语言和GIL没有半毛钱关系。仅仅是由于历史原因在Cpython虚拟机(解释器)，难以移除GIL。在IO操作等可能会引起阻塞的system call之前,可以暂时释放GIL,但在执行完毕后,必须重新获取GIL Python 3.x使用计时器（执行时间达到阈值后，当前线程释放GIL）或Python 2.x，tickets计数达到100。Python使用多进程是可以利用多核的CPU资源的。多线程爬取比单线程性能有提升，因为遇到IO阻塞会自动释放GIL锁 ","date":"2020-01-04","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%BA%BF%E7%A8%8B/:3:0","tags":["Python学习之路"],"title":"Python学习之路-多任务:线程","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%BA%BF%E7%A8%8B/"},{"categories":["年终总结"],"content":"前言 一晃眼今年又过去了，这一年发生了不少事，很值得回顾一下，反思一下。 ","date":"2019-12-30","objectID":"/2019%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/:1:0","tags":["生活"],"title":"2019年终总结","uri":"/2019%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"},{"categories":["年终总结"],"content":"爱情 今年最让我兴奋的事就是跟你的感情越来越深了，原来爱情真的这么美妙，虽然我们之前也有吵架，但是总能相互理解，解决隔阂。虽然我们依然异地，但是心越来越近。自从有了你，生活真的变得多彩起来，会时不时想起你，这种异地的感觉也很奇妙，距离反而将我们拉得更近，格外珍惜在一起的时光。前几天忍不住回去看你，那种感觉真的太棒了。异地也有一些不好的地方，在你需要我的时候我不能很快出现在你身边，就想你租房、搬家，我几乎都帮不上忙。希望未来能改善吧。幸福ing~~~ ","date":"2019-12-30","objectID":"/2019%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/:2:0","tags":["生活"],"title":"2019年终总结","uri":"/2019%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"},{"categories":["年终总结"],"content":"经济 自从去年买房之后，身上的压力也大了起来，虽然每个月的房贷有父母帮忙还一部分，但是我知道我需要努力赚钱，尽快把房贷这块早点补上。目前每个月房租加上房贷有我工资的一半多了。今年又给爸妈交了医疗保险和养老保险，大概接近2万吧，所以也没存到啥钱。在搬家的时候发现我真的太能买了，都不是自己的房子就买那么多东西，买了一箱洗衣液，也不知道用多久才能用的完，这次搬家的时候还有3/4，明年一定要控制这些不必要的支出！除了缩减开支，感觉还需要理财，今年看了四本理财方面的书，感觉还是很不错的，很适合入门，分别是穷爸爸和富爸爸，工作前5年决定你一生的财富，小狗钱钱和给业余投资者的10条军规。读完这些最大的感受是，不要小瞧了不经意间花掉的那几块钱，任何钱都可以用来理财，我们可能不能赚很多，但是至少能让我们的财富有正向增长，理财的过程同样是我们对财富积累的过程。对了读书的app推荐用微信读书，现在可以免费领读书卡，免费看书。理财任何时间开始都不算晚，我们可能不会通过理财成为不了大富豪，但是能让我们过上更好的生活！ ","date":"2019-12-30","objectID":"/2019%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/:3:0","tags":["生活"],"title":"2019年终总结","uri":"/2019%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"},{"categories":["年终总结"],"content":"上海 在上海这一年听魔幻的，年初的时候还跟学长学姐一起逛了城隍庙、博物馆和外滩，毕业之后再跟学长学姐们相处感觉还是那么亲切，跟大学时没两样，希望都能在自己的领域发展的更好吧，想跟学姐约羽毛球的，无奈她在浦东我在浦西。。。这一年我的心态也发生了很多变化，之前玩的很好地室友也因为工作经常加班到很晚才能回家，能说上话的机会也变少了，我还记得上一次跟他交流是元宵节我煮了汤圆他吃，然后就是我搬家的时候了。。。现在住在上海的偏西边，这边的生活气息更浓，晚上也会有外面摆摊的，我也逐渐适应了这个较为偏僻的地方，一个人住也挺好。巧合的事，与另一个同事住的很近，还一起出去玩了几次，讨论了一下工作方面的事，东北人果然都很豪爽。。。 ","date":"2019-12-30","objectID":"/2019%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/:4:0","tags":["生活"],"title":"2019年终总结","uri":"/2019%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"},{"categories":["年终总结"],"content":"FPX夺冠 今年再欧洲图书馆有见证了LPL夺冠，G2得气死吧，哈哈，两年决赛，两个3:0，还都是被LPL的战队。网上有些键盘侠说不是全华班，不是全华班咋了，是咱LPL的胜利咋了，国人也帮欧洲人拿了TI的冠军呢，况且今年的FMVP是tian，又一个国产打野拿了FMVP，tian和ning都是瞎子王啊，去年的ning也是好几脚踢到关键人，今年tian更牛逼，这几脚真的是，比国足牛逼多了，什么时候国足能够硬气一回。不过LPL好久没出国产上单了，什么时候有牛逼的国产上单啊，希望明年有牛逼的国产上单能出现在总决赛!LPL加油啊，明年在中国举行了，把奖杯留在上海！ ","date":"2019-12-30","objectID":"/2019%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/:5:0","tags":["生活"],"title":"2019年终总结","uri":"/2019%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"},{"categories":["年终总结"],"content":"蔚来 今年去试驾了蔚来的ES6，国产车现在做的可以啊，行驶品质非常棒，自动驾驶也做的可以，nomi很有意思，可惜就是价格有点贵，偏出我的预期了。而且在我看来汽车这种消耗品，提升不了太多生活品质，或者说10万的车跟50万的车，对我来说区别不大。不过国产车可以做到50万这个级别还是很让人惊喜的，今年蔚来还差点退市了，希望他能越做越好吧，把高端车的市场抓在我们中国人的手里。 ","date":"2019-12-30","objectID":"/2019%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/:6:0","tags":["生活"],"title":"2019年终总结","uri":"/2019%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"},{"categories":["年终总结"],"content":"展望 2019年就这么过去了，去年的小目标实现了部分，攒够5万的小目标还没有实现，这个小目标继续延续下去吧，再给明年定几个小目标吧： 跟女朋友一起出去玩一次 赚更多的钱，增加还房贷的金额，减轻爸妈的负担，负责他们的各类保险 开始投资理财，争取攒够5万块 学会Golang 希望明年年终总结的时候小目标都能实现！ ","date":"2019-12-30","objectID":"/2019%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/:7:0","tags":["生活"],"title":"2019年终总结","uri":"/2019%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"},{"categories":["Python"],"content":"基本操作 在 Python 中要操作文件需要记住 1 个函数和 3 个方法 函数/方法 说明 open 打开文件，并且返回文件操作对象 read 将文件内容读取到内存 write 将指定内容写入文件 close 关闭文件 open 函数负责打开文件，并且返回文件对象 read/write/close 三个方法都需要通过文件对象来调用 ","date":"2019-12-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%96%87%E4%BB%B6/:1:0","tags":["Python学习之路"],"title":"Python学习之路-文件","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%96%87%E4%BB%B6/"},{"categories":["Python"],"content":"打开文件 open 函数默认以只读方式打开文件，并且返回文件对象。语法如下： f = open(\"文件名\", \"访问方式\") open函数的第一个参数是要打开的文件名(文件名区分大小写)，如果文件存在返回文件操作对象，如果文件不存在，会抛出异常。 访问方式 说明 r 以只读方式打开文件。文件的指针将会放在文件的开头，这是默认模式。如果文件不存在，抛出异常 w 以只写方式打开文件。如果文件存在会被覆盖。如果文件不存在，创建新文件 a 以追加方式打开文件。如果该文件已存在，文件指针将会放在文件的结尾。如果文件不存在，创建新文件进行写入 r+ 以读写方式打开文件。文件的指针将会放在文件的开头。如果文件不存在，抛出异常 w+ 以读写方式打开文件。如果文件存在会被覆盖。如果文件不存在，创建新文件 a+ 以读写方式打开文件。如果该文件已存在，文件指针将会放在文件的结尾。如果文件不存在，创建新文件进行写入 提示 文件指针标记从哪个位置开始读取数据。第一次打开文件时，通常文件指针会指向文件的开始位置。 ","date":"2019-12-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%96%87%E4%BB%B6/:1:1","tags":["Python学习之路"],"title":"Python学习之路-文件","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%96%87%E4%BB%B6/"},{"categories":["Python"],"content":"关闭文件 close方法负责关闭文件。如果忘记关闭文件，会造成系统资源消耗，而且会影响到后续对文件的访问。语法如下： file_name.close() 提示 在开发中，通常会先编写打开和关闭的代码，再编写中间针对文件的读/写操作！ ","date":"2019-12-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%96%87%E4%BB%B6/:1:2","tags":["Python学习之路"],"title":"Python学习之路-文件","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%96%87%E4%BB%B6/"},{"categories":["Python"],"content":"读取文件 read 方法可以一次性读入并返回文件的所有内容。当执行了read方法后，文件指针会移动到读取内容的末尾。 提示 如果执行了一次 read 方法，读取了所有内容，那么再次调用 read 方法不会读取到任何的内容 补充 read 方法默认会把文件的所有内容一次性读取到内存，如果文件太大，对内存的占用会非常严重。使用readline 方法可以一次读取一行内容，方法执行后，会把文件指针移动到下一行，准备再次读取。 ","date":"2019-12-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%96%87%E4%BB%B6/:1:3","tags":["Python学习之路"],"title":"Python学习之路-文件","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%96%87%E4%BB%B6/"},{"categories":["Python"],"content":"写入文件 write方法负责写入文件。语法如下： # 打开文件 f = open(\"file_name\", \"w\") f.write(\"hello python！\\n\") 提示 频繁的移动文件指针，会影响文件的读写效率，开发中更多的时候会以只读、只写的方式来操作文件。 ","date":"2019-12-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%96%87%E4%BB%B6/:1:4","tags":["Python学习之路"],"title":"Python学习之路-文件","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%96%87%E4%BB%B6/"},{"categories":["Python"],"content":"管理操作 在终端与文件浏览器中可以执行常规的文件/目录的管理操作，例如：创建、重命名、删除、改变路径、查看目录内容等等，在 Python 中，如果希望通过程序实现上述功能，需要导入 os 模块 ","date":"2019-12-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%96%87%E4%BB%B6/:2:0","tags":["Python学习之路"],"title":"Python学习之路-文件","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%96%87%E4%BB%B6/"},{"categories":["Python"],"content":"文件操作 序号 方法名 说明 示例 01 rename 重命名文件 os.rename(源文件名, 目标文件名) 02 remove 删除文件 os.remove(文件名) ","date":"2019-12-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%96%87%E4%BB%B6/:2:1","tags":["Python学习之路"],"title":"Python学习之路-文件","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%96%87%E4%BB%B6/"},{"categories":["Python"],"content":"目录操作 序号 方法名 说明 示例 01 listdir 目录列表 os.listdir(目录名) 02 mkdir 创建目录 os.mkdir(目录名) 03 rmdir 删除目录 os.rmdir(目录名) 04 getcwd 获取当前目录 os.getcwd() 05 chdir 修改工作目录 os.chdir(目标目录) 06 path.isdir 判断是否是文件 os.path.isdir(文件路径) 提示 文件或者目录操作都支持 相对路径和绝对路径 ","date":"2019-12-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%96%87%E4%BB%B6/:2:2","tags":["Python学习之路"],"title":"Python学习之路-文件","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%96%87%E4%BB%B6/"},{"categories":["Python"],"content":"编码格式 文本文件存储的内容是基于字符编码的文件，常见的编码有 ASCII 编码，UNICODE 编码等。Python 2.x 默认使用 ASCII 编码格式，Python 3.x 默认使用 UTF-8 编码格式。 提示 UTF-8 编码格式：UTF-8 是 UNICODE 编码的一种编码格式。计算机中使用1~6 个字节来表示一个 UTF-8 字符，涵盖了地球上几乎所有地区的文字。大多数汉字会使用3个字节表示。 ","date":"2019-12-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%96%87%E4%BB%B6/:3:0","tags":["Python学习之路"],"title":"Python学习之路-文件","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%96%87%E4%BB%B6/"},{"categories":["Python"],"content":"模块 ","date":"2019-12-21","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85/:1:0","tags":["Python学习之路"],"title":"Python学习之路-模块和包","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85/"},{"categories":["Python"],"content":"简介 模块是 Python 程序架构的一个核心概念。每一个以扩展名 py 结尾的 Python 源代码文件都是一个模块，模块名同样也是一个标识符，需要符合标识符的命名规则。在模块中定义的全局变量、函数、类都是提供给外界直接使用的工具。模块就好比是工具包，要想使用这个工具包中的工具，就需要先导入这个模块。 ","date":"2019-12-21","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85/:1:1","tags":["Python学习之路"],"title":"Python学习之路-模块和包","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85/"},{"categories":["Python"],"content":"导入方式 import导入：是一次性把模块中 所有工具全部导入 import 模块名 在导入模块时，每个导入应该独占一行 通过 模块名. 使用模块提供的工具 提示 开发时 import 代码应该统一写在代码的顶部，更容易及时发现冲突。一旦发现冲突，可以使用 as关键字给其中一个工具起一个别名：import 模块名 as 模块别名 from...import导入：如果希望从某一个模块中，导入部分工具，就可以使用 from ... import 的方式。import 模块名 # 从 模块 导入 某一个工具 from 模块名1 import 工具名 导入之后不需要通过 模块名.可以直接使用模块提供的工具。 注意 如果两个模块，存在同名的函数，那么后导入模块的函数，会覆盖掉先导入的函数 from…import *（不推荐） # 从 模块 导入 所有工具 from 模块名1 import * 注意 这种方式不推荐使用，因为函数重名并没有任何的提示，出现问题不好排查 ","date":"2019-12-21","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85/:1:2","tags":["Python学习之路"],"title":"Python学习之路-模块和包","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85/"},{"categories":["Python"],"content":"模块的搜索顺序 Python 的解释器在导入模块时，会先搜索当前目录指定模块名的文件，如果有就直接导入，如果没有，再搜索系统目录。 补充 可以通过sys.path给出的列表查看目录里依次查找要导入的模块文件，列表中的路径的先后顺序代表了python解释器在搜索模块时的先后顺序。 可以通过sys.path.append('xxx')的方式添加路径，通过sys.path.insert(0, 'xxx')可以确保先搜索这个路径 想重新导入模块可以reload导入,语法如下 from imp import reload reload(模块名) 注意 在开发时，给文件起名，不要和系统的模块文件重名。 提示 Python 中每一个模块都有一个内置属性 __file__ 可以查看模块的完整路径。 ","date":"2019-12-21","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85/:1:3","tags":["Python学习之路"],"title":"Python学习之路-模块和包","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85/"},{"categories":["Python"],"content":"__name__ 属性 __name__ 是 Python 的一个内置属性，记录着一个字符串。如果是被其他文件导入的，__name__就是模块名。如果 是当前执行的程序__name__是__main__。__name__属性可以做到，测试模块的代码只在测试情况下被运行，而在被导入时不会被执行！ 补充 在导入时，模块中所有没有任何缩进的代码都会被执行一遍！在实际开发中通常会在模块下方增加一些测试代码仅在模块内使用，被导入到其他文件中不需要执行。可以在if __name__ == \"__main__\":下方缩进中编写测试代码，从而不会被执行 ","date":"2019-12-21","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85/:1:4","tags":["Python学习之路"],"title":"Python学习之路-模块和包","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85/"},{"categories":["Python"],"content":"包 包是一个包含多个模块的特殊目录，目录下有一个特殊的文件：__init__.py。包名的命名方式和变量名一致。使用 import 包名 可以一次性导入包中所有的模块 ","date":"2019-12-21","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85/:2:0","tags":["Python学习之路"],"title":"Python学习之路-模块和包","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85/"},{"categories":["Python"],"content":"发布模块 如果希望自己开发的模块，分享给其他人，可以按照以下步骤操作： 创建 setup.py from distutils.core import setup setup(name=\"hm_message\", # 包名 version=\"1.0\", # 版本 description=\"itheima's 发送和接收消息模块\", # 描述信息 long_description=\"完整的发送和接收消息模块\", # 完整描述信息 author=\"itheima\", # 作者 author_email=\"itheima@itheima.com\", # 作者邮箱 url=\"www.itheima.com\", # 主页 py_modules=[\"hm_message.send_message\", \"hm_message.receive_message\"]) 补充 有关字典参数的详细信息，可以参阅官方网站 构建模块 $ python3 setup.py build 生成发布压缩包 $ python3 setup.py sdist 注意 要制作哪个版本的模块，就使用哪个版本的解释器执行！ 安装模块 $ tar -zxvf hm_message-1.0.tar.gz $ sudo python3 setup.py install 补充 卸载模块 直接从安装目录下，把安装模块的 目录 删除就可以 $ cd /usr/local/lib/python3.5/dist-packages/ $ sudo rm -r hm_message* ","date":"2019-12-21","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85/:3:0","tags":["Python学习之路"],"title":"Python学习之路-模块和包","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85/"},{"categories":["Python"],"content":"安装第三方模块 第三方模块通常是指由知名的第三方团队开发的并且被程序员广泛使用的Python包 / 模块。例如 request 就是一套非常成熟的HTTP 服务模块。pip 是一个现代的，通用的 Python 包管理工具，提供了对 Python 包的查找、下载、安装、卸载等功能。 安装和卸载命令如下： $ sudo pip3 install requests $ sudo pip3 uninstall requests ","date":"2019-12-21","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85/:4:0","tags":["Python学习之路"],"title":"Python学习之路-模块和包","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85/"},{"categories":["Python"],"content":"简介 程序在运行时，如果 Python 解释器 遇到到一个错误，会停止程序的执行，并且提示一些错误信息，这就是异常。程序停止执行并且提示错误信息这个动作，我们通常称之为：抛出(raise)异常。 程序开发时，很难将所有的特殊情况都处理的面面俱到，通过异常捕获可以针对突发事件做集中的处理，从而保证程序的稳定性和健壮性。 ","date":"2019-12-14","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%BC%82%E5%B8%B8/:1:0","tags":["Python学习之路"],"title":"Python学习之路-异常","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%BC%82%E5%B8%B8/"},{"categories":["Python"],"content":"捕获异常 在程序开发中，如果对某些代码的执行不能确定是否正确，可以增加 try(尝试) 来捕获异常。 捕获异常最简单的语法格式： try: 尝试执行的代码 except: 出现错误的处理 try尝试，下方编写要尝试代码，不确定是否能够正常执行的代码 except如果不是，下方编写尝试失败的代码 ","date":"2019-12-14","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%BC%82%E5%B8%B8/:2:0","tags":["Python学习之路"],"title":"Python学习之路-异常","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%BC%82%E5%B8%B8/"},{"categories":["Python"],"content":"错误类型捕获 在程序执行时，可能会遇到不同类型的异常，并且需要针对不同类型的异常，做出不同的响应，这个时候，就需要捕获错误类型了 语法如下： try: # 尝试执行的代码 pass except 错误类型1: # 针对错误类型1，对应的代码处理 pass except (错误类型2, 错误类型3): # 针对错误类型2 和 3，对应的代码处理 pass except Exception as result: print(\"未知错误 %s\" % result) 当 Python 解释器抛出异常时，最后一行错误信息的第一个单词，就是错误类型。 ","date":"2019-12-14","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%BC%82%E5%B8%B8/:3:0","tags":["Python学习之路"],"title":"Python学习之路-异常","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%BC%82%E5%B8%B8/"},{"categories":["Python"],"content":"捕获未知错误 在开发时，要预判到所有可能出现的错误，还是有一定难度的，如果希望程序无论出现任何错误，都不会因为 Python 解释器抛出异常而被终止，可以再增加一个except。 语法如下： except Exception as result: print(\"未知错误 %s\" % result) ","date":"2019-12-14","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%BC%82%E5%B8%B8/:4:0","tags":["Python学习之路"],"title":"Python学习之路-异常","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%BC%82%E5%B8%B8/"},{"categories":["Python"],"content":"异常捕获完整语法 在实际开发中，为了能够处理复杂的异常情况，完整的异常语法如下： try: # 尝试执行的代码 pass except 错误类型1: # 针对错误类型1，对应的代码处理 pass except 错误类型2: # 针对错误类型2，对应的代码处理 pass except (错误类型3, 错误类型4): # 针对错误类型3 和 4，对应的代码处理 pass except Exception as result: # 打印错误信息 print(result) else: # 没有异常才会执行的代码 pass finally: # 无论是否有异常，都会执行的代码 print(\"无论是否有异常，都会执行的代码\") 补充 else：只有在没有异常时才会执行的代码。finally：无论是否有异常，都会执行的代码 ","date":"2019-12-14","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%BC%82%E5%B8%B8/:5:0","tags":["Python学习之路"],"title":"Python学习之路-异常","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%BC%82%E5%B8%B8/"},{"categories":["Python"],"content":"异常的传递 当函数/方法执行出现异常，会将异常传递给函数/方法的调用一方。如果传递到主程序，仍然没有异常处理，程序才会被终止。 提示 在开发中，可以在主函数中增加异常捕获，而在主函数中调用的其他函数，只要出现异常，都会传递到主函数的异常捕获中，这样就不需要在代码中，增加大量的异常捕获，能够保证代码的整洁。 ","date":"2019-12-14","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%BC%82%E5%B8%B8/:6:0","tags":["Python学习之路"],"title":"Python学习之路-异常","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%BC%82%E5%B8%B8/"},{"categories":["Python"],"content":"抛出 raise 异常 除了代码执行出错 Python 解释器会抛出异常之外，还可以根据应用程序特有的业务需求主动抛出异常。Python 中提供了一个 Exception异常类。在开发时，如果满足特定业务需求时希望抛出异常，可以：创建一个 Exception 的对象，使用 raise 关键字抛出 异常对象。 ","date":"2019-12-14","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%BC%82%E5%B8%B8/:7:0","tags":["Python学习之路"],"title":"Python学习之路-异常","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%BC%82%E5%B8%B8/"},{"categories":["Python"],"content":"简介 类是一个特殊的对象Python中一切皆对象：class AAA: 定义的类属于类对象，obj1 = AAA() 属于实例对象。除了封装实例的属性和方法外，类对象还可以拥有自己的属性和方法成为：类属性和类方法，通过类名.的方式可以访问类的属性或者调用类的方法。 提示 在程序运行时，类同样会被加载到内存，类对象在内存中只有一份，使用一个类可以创建出很多个对象实例 ","date":"2019-12-07","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%B1%BB%E6%96%B9%E6%B3%95/:1:0","tags":["Python学习之路"],"title":"Python学习之路-面向对象:类属性与类方法","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%B1%BB%E6%96%B9%E6%B3%95/"},{"categories":["Python"],"content":"类属性 类属性就是给类对象中定义的属性，通常用来记录与这个类相关的特征。类属性不会用于记录具体对象的特征 ","date":"2019-12-07","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%B1%BB%E6%96%B9%E6%B3%95/:2:0","tags":["Python学习之路"],"title":"Python学习之路-面向对象:类属性与类方法","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%B1%BB%E6%96%B9%E6%B3%95/"},{"categories":["Python"],"content":"属性的获取机制 在 Python 中属性的获取存在一个向上查找机制。因此，要访问类属性有两种方式：1.类名.类属性；2.对象.类属性(不推荐) 提示 向上查找机制：获取对象属性时，首先在对象内部查找对象属性，没有找到就会向上寻找类属性。 如果使用 对象.类属性 = 值 赋值语句，只会给对象添加一个属性，而不会影响到类属性的值 补充 类属性在内存中只保存一份。实例属性在每个对象中都要保存一份。通过类创建实例对象时，如果每个对象需要具有相同名字的属性，那么就使用类属性，用一份既可 ","date":"2019-12-07","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%B1%BB%E6%96%B9%E6%B3%95/:2:1","tags":["Python学习之路"],"title":"Python学习之路-面向对象:类属性与类方法","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%B1%BB%E6%96%B9%E6%B3%95/"},{"categories":["Python"],"content":"类方法 类方法就是针对类对象定义的方法，在类方法内部可以直接访问类属性或者调用其他的类方法。 ","date":"2019-12-07","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%B1%BB%E6%96%B9%E6%B3%95/:3:0","tags":["Python学习之路"],"title":"Python学习之路-面向对象:类属性与类方法","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%B1%BB%E6%96%B9%E6%B3%95/"},{"categories":["Python"],"content":"语法 @classmethod def 类方法名(cls): pass 类方法需要用修饰器 @classmethod来标识，告诉解释器这是一个类方法类方法。类方法的第一个参数应该是cls。由哪一个类调用的方法，方法内的 cls 就是哪一个类的引用。这个参数和实例方法的第一个参数是 self 类似，通过类名. 调用类方法，调用方法时，不需要传递 cls 参数。在方法内部可以通过 cls. 访问类的属性，也可以通过 cls. 调用其他的类方法。 提示 使用其他名称也可以，不过习惯使用 cls ","date":"2019-12-07","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%B1%BB%E6%96%B9%E6%B3%95/:3:1","tags":["Python学习之路"],"title":"Python学习之路-面向对象:类属性与类方法","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%B1%BB%E6%96%B9%E6%B3%95/"},{"categories":["Python"],"content":"拓展 ","date":"2019-12-07","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%B1%BB%E6%96%B9%E6%B3%95/:4:0","tags":["Python学习之路"],"title":"Python学习之路-面向对象:类属性与类方法","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%B1%BB%E6%96%B9%E6%B3%95/"},{"categories":["Python"],"content":"静态方法 当类中某个方法既不需要访问实例属性或者调用实例方法也不需要访问类属性或者调用类方法的时候可以把这个方法封装成一个静态方法。 语法 @staticmethod def 静态方法名(): pass 静态方法需要用修饰器@staticmethod来标识，告诉解释器这是一个静态方法。通过类名.调用静态方法。 补充 实例方法、静态方法和类方法，三种方法在内存中都归属于类，区别在于调用方式不同。 实例方法：由对象调用；至少一个self参数；执行实例方法时，自动将调用该方法的对象赋值给self； 类方法：由类调用； 至少一个cls参数；执行类方法时，自动将调用该方法的类赋值给cls； 静态方法：由类调用；无默认参数； 相同点：对于所有的方法而言，均属于类，所以 在内存中也只保存一份 不同点：方法调用者不同、调用方法时自动传入的参数不同。 ","date":"2019-12-07","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%B1%BB%E6%96%B9%E6%B3%95/:4:1","tags":["Python学习之路"],"title":"Python学习之路-面向对象:类属性与类方法","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%B1%BB%E6%96%B9%E6%B3%95/"},{"categories":["Python"],"content":"单例 单例设计模式 目的：让类创建的对象，在系统中只有唯一的一个实例，每一次执行 类名() 返回的对象，内存地址是相同的。 补充 设计模式是前人工作的总结和提炼，通常，被人们广泛流传的设计模式都是针对某一特定问题的成熟的解决方案。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性 __new__方法 使用类名()创建对象时，Python 的解释器首先会 调用 __new__ 方法为对象分配空间。__new__方法是一个 由object 基类提供的内置的静态方法，主要作用有两个： 在内存中为对象分配空间 返回对象的引用 补充 Python 的解释器获得对象的引用后，将引用作为第一个参数，传递给 __init__ 方法 重写 __new__ 方法一定要return super().__new__(cls)，否则 Python 的解释器得不到分配了空间的对象引用，就不会调用对象的初始化方法。 注意 __new__ 是一个静态方法，在调用时需要主动传递 cls 参数 Python 中的单例 定义一个类属性，初始值是 None，用于记录单例对象的引用 重写 __new__ 方法 如果类属性 is None，调用父类方法分配空间，并在类属性中记录结果 返回类属性中记录的对象引用。 class Singleton(object): # 定义类属性记录单例对象引用 instance = None def __new__(cls, *args, **kwargs): # 1. 判断类属性是否已经被赋值 if cls.instance is None: cls.instance = super().__new__(cls) # 2. 返回类属性的单例引用 return cls.instance 定义一个类属性 init_flag 标记是否执行过初始化动作，初始值为 False 在 __init__ 方法中，判断 init_flag，如果为 False 就执行初始化动作 然后将 init_flag 设置为 True 这样，再次自动调用 __init__ 方法时，初始化动作就不会被再次执行了 class Singleton(object): # 记录第一个被创建对象的引用 instance = None # 记录是否执行过初始化动作 init_flag = False def __new__(cls, *args, **kwargs): # 1. 判断类属性是否是空对象 if cls.instance is None: # 2. 调用父类的方法，为第一个对象分配空间 cls.instance = super().__new__(cls) # 3. 返回类属性保存的对象引用 return cls.instance def __init__(self): if not Singleton.init_flag: print(\"初始化单例\") Singleton.init_flag = True # 创建多个对象 singleton1 = Singleton() print(singleton1) singleton2 = Singleton() print(singleton2) ","date":"2019-12-07","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%B1%BB%E6%96%B9%E6%B3%95/:4:2","tags":["Python学习之路"],"title":"Python学习之路-面向对象:类属性与类方法","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%B1%BB%E6%96%B9%E6%B3%95/"},{"categories":["Python"],"content":"property属性 定义 一种用起来像是使用的实例属性一样的特殊属性。property属性内部进行一系列的逻辑计算，最终将计算结果返回。 注意事项 定义时，在实例方法的基础上添加 @property 装饰器；并且仅有一个self参数 调用时，无需括号 方法：foo_obj.func() property属性：foo_obj.prop 两种方式 装饰器，即：在方法上应用装饰器 类属性，即：在类中定义值为property对象的类属性 类属性访问方式 老式类中的属性只有一种访问方式，其对应被 @property 修饰的方法。新式类中的属性有三种访问方式，并分别对应了三个被@property、@方法名.setter、@方法名.deleter修饰的方法，我们可以根据它们几个属性的访问特点，分别将三个方法定义为对同一个属性：获取、修改、删除。 提示 当使用类属性的方式创建property属性时，经典类和新式类无区别 参数 property方法中有个四个参数 第一个参数是方法名，调用 对象.属性 时自动触发执行方法 第二个参数是方法名，调用 对象.属性 ＝ XXX 时自动触发执行方法 第三个参数是方法名，调用 del 对象.属性 时自动触发执行方法 第四个参数是字符串，调用 对象.属性.__doc__ ，此参数是该属性的描述信息 ","date":"2019-12-07","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%B1%BB%E6%96%B9%E6%B3%95/:4:3","tags":["Python学习之路"],"title":"Python学习之路-面向对象:类属性与类方法","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%B1%BB%E6%96%B9%E6%B3%95/"},{"categories":["Python"],"content":"魔法属性 __init__：初始化方法，通过类创建对象时，自动触发执行 __doc__：表示类的描述信息 __module__：表示当前操作的对象在那个模块 __class__：表示当前操作的对象的类是什么 __del__：当对象在内存中被释放时，自动触发执行 __call__：对象后面加括号，触发执行，即：对象() 或者 类()() __dict__：类或对象中的所有属性(类的实例属性属于对象；类中的类属性和方法等属于类) __str__：如果一个类中定义了__str__方法，那么在打印 对象 时，默认输出该方法的返回值 __getitem__、__setitem__、__delitem__：用于索引操作，如字典 __getslice__、__setslice__、__delslice__：用于切片操作，如列表 ","date":"2019-12-07","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%B1%BB%E6%96%B9%E6%B3%95/:4:4","tags":["Python学习之路"],"title":"Python学习之路-面向对象:类属性与类方法","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%B1%BB%E6%96%B9%E6%B3%95/"},{"categories":["Python"],"content":"元类 元类就是用来创建类的“东西”，就是类的类。使用函数type对类查看类型是type类型，这是因为函数type实际上是一个元类。type就是Python在背后用来创建所有类的元类。 补充 type函数还有一种完全不同的功能，动态的创建类。type可以接受一个类的描述作为参数，然后返回一个类。 ","date":"2019-12-07","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%B1%BB%E6%96%B9%E6%B3%95/:4:5","tags":["Python学习之路"],"title":"Python学习之路-面向对象:类属性与类方法","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%B1%BB%E6%96%B9%E6%B3%95/"},{"categories":["Python"],"content":"三个基本特征 封装：根据职责将属性和方法封装到一个抽象的类中 继承：实现代码的重用，相同的代码不需要重复的编写 多态：不同的对象调用相同的方法，产生不同的执行结果，增加代码的灵活度 ","date":"2019-11-30","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81/:1:0","tags":["Python学习之路"],"title":"Python学习之路-面向对象:三个基本特征","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81/"},{"categories":["Python"],"content":"封装 封装是面向对象编程的一大特点，面向对象编程的第一步就是将属性和方法封装到一个抽象的类中，外界使用类创建对象，然后让对象调用方法，对象方法的细节都被封装在类的内部。 提示 一个对象的属性可以是另外一个类创建的对象 ","date":"2019-11-30","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81/:2:0","tags":["Python学习之路"],"title":"Python学习之路-面向对象:三个基本特征","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81/"},{"categories":["Python"],"content":"继承 ","date":"2019-11-30","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81/:3:0","tags":["Python学习之路"],"title":"Python学习之路-面向对象:三个基本特征","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81/"},{"categories":["Python"],"content":"单继承 概念 子类拥有父类的所有方法和属性 语法 class 类名(父类名): pass 提示 子类继承自父类，可以直接享受父类中已经封装好的方法，不需要再次开发.子类中应该根据职责，封装子类特有的属性和方法 传递性 子类拥有父类以及父类的父类中封装的所有属性和方法，例：C 类从 B 类继承，B 类又从 A 类继承，那么 C 类就具有 B 类和 A 类的所有属性和方法 重写 子类拥有父类的所有方法和属性，子类继承自父类，可以直接享受父类中已经封装好的方法，不需要再次开发，当父类的方法实现不能满足子类需求时，可以对方法进行重写(override)。重写父类方法有两种情况： 覆盖父类的方法：如果在开发中，父类的方法实现和子类的方法实现完全不同，就可以使用覆盖的方式，在子类中重新编写父类的方法实现。具体的实现方式，就相当于在子类中定义了一个和父类同名的方法并且实现，重写之后在运行时，只会调用子类中重写的方法，而不再会调用父类封装的方法 对父类方法进行扩展：子类的方法实现中包含父类的方法实现父类原本封装的方法实现是子类方法的一部分就可以使用扩展的方式。在子类中重写父类的方法在需要的位置使用 super().父类方法 来调用父类方法的执行代码其他的位置针对子类的需求，编写子类特有的代码实现 提示 关于 super：在 Python中 super是一个特殊的类。super() 就是使用 super 类创建出来的对象，最常使用的场景就是在重写父类方法时，调用在父类中封装的方法实现。 提示 在开发时，父类名 和 super() 两种方式不要混用，如果使用当前子类名调用方法，会形成递归调用，出现死循环。 私有属性和私有方法 私有属性、方法是对象的隐私，不对外公开，外界以及子类都不能直接访问。私有属性、方法通常用于做一些内部的事情。 子类对象不能在自己的方法内部，直接访问 父类的私有属性或私有方法。子类对象可以通过父类的公有方法间接访问到私有属性或私有方法 ","date":"2019-11-30","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81/:3:1","tags":["Python学习之路"],"title":"Python学习之路-面向对象:三个基本特征","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81/"},{"categories":["Python"],"content":"多继承 概念 子类可以拥有多个父类，并且具有所有父类的 属性和方法。 语法 class 子类名(父类名1, 父类名2...) pass 注意事项 如果父类之间存在同名的属性或者方法，应该尽量避免使用多继承。 补充 super().__init__相对于类名.__init__，在单继承上用法基本无差 但在多继承上有区别，super方法能保证每个父类的方法只会执行一次，而使用类名的方法会导致方法被执行多次，具体看前面的输出结果 多继承时，使用super方法，对父类的传参数，应该是由于Python中super的算法导致的原因，必须把参数全部传递，否则会报错 单继承时，使用super方法，则不能全部传递，只能传父类方法所需的参数，否则会报错 多继承时，相对于使用类名.__init__方法，要把每个父类全部写一遍, 而使用super方法，只需写一句话便执行了全部父类的方法，这也是为何多继承需要全部传参的一个原因 ","date":"2019-11-30","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81/:3:2","tags":["Python学习之路"],"title":"Python学习之路-面向对象:三个基本特征","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81/"},{"categories":["Python"],"content":"了解 新式类：以 object 为基类的类，推荐使用 旧式类：不以 object 为基类的类，不推荐使用 在 Python 3.x 中定义类时，如果没有指定父类，会默认使用 object 作为该类的基类 —— Python 3.x 中定义的类都是新式类 提示 object 是 Python 为所有对象提供的基类，提供有一些内置的属性和方法，可以使用 dir 函数查看。 今后在定义类时，如果没有父类，建议统一继承自 object ","date":"2019-11-30","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81/:3:3","tags":["Python学习之路"],"title":"Python学习之路-面向对象:三个基本特征","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81/"},{"categories":["Python"],"content":"多态 多态不同的子类对象调用相同的父类方法，产生不同的执行结果。多态可以增加代码的灵活度，以继承和重写父类方法为前提，是调用方法的技巧，不会影响到类的内部设计。 提示 多态更容易编写出出通用的代码，做出通用的编程，以适应需求的不断变化！ ","date":"2019-11-30","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81/:4:0","tags":["Python学习之路"],"title":"Python学习之路-面向对象:三个基本特征","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81/"},{"categories":["Python"],"content":"简介 面向对象编程(英语：Object-oriented programming，缩写：OOP)是种具有对象概念的编程典范，同时也是一种程序开发的抽象方针。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的重用性、灵活性和扩展性，对象里的程序可以访问及经常修改对象相关连的数据。在面向对象程序编程里，计算机程序会被设计成彼此相关的对象。 我们之前学习的编程方式就是面向过程的，面相过程和面相对象，是两种不同的编程方式，对比面向过程的特点，可以更好地了解什么是面向对象。 ","date":"2019-11-23","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:1:0","tags":["Python学习之路"],"title":"Python学习之路-初识面向对象","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["Python"],"content":"特点 ","date":"2019-11-23","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:2:0","tags":["Python学习之路"],"title":"Python学习之路-初识面向对象","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["Python"],"content":"面向过程 注重步骤与过程，不注重职责分工 如果需求复杂，代码会变得很复杂 开发复杂项目，没有固定的套路，开发难度很大！ ","date":"2019-11-23","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:2:1","tags":["Python学习之路"],"title":"Python学习之路-初识面向对象","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["Python"],"content":"面向对象 注重对象和职责，不同的对象承担不同的职责 更加适合应对复杂的需求变化，是专门应对复杂项目开发，提供的固定套路 需要在面向过程基础上，再学习一些面向对象的语法 提示 相比较函数，类是更大的封装，根据职责在一个对象中封装多个方法。在完成某一个需求前，首先确定职责要做的事情(方法)，根据职责确定不同的对象，在对象内部封装不同的方法(多个)。最后完成的代码，就是顺序地让不同的对象调用不同的方法 ","date":"2019-11-23","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:2:2","tags":["Python学习之路"],"title":"Python学习之路-初识面向对象","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["Python"],"content":"类和对象 ","date":"2019-11-23","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:3:0","tags":["Python学习之路"],"title":"Python学习之路-初识面向对象","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["Python"],"content":"简介 类是对一群具有相同特征或者行为的事物的一个统称，是抽象的，不能直接使用。特征被称为属性，行为被称为方法。 对象是由类创建出来的一个具体存在，可以直接使用。由哪一个类创建出来的对象，就拥有在哪一个类中定义的属性和方法。 ","date":"2019-11-23","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:3:1","tags":["Python学习之路"],"title":"Python学习之路-初识面向对象","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["Python"],"content":"关系 类是模板，对象是根据类这个模板创建出来的，应该先有类，再有对象。类只有一个，而对象可以有很多个。不同的对象之间属性可能会各不相同。类中定义了什么属性和方法，对象中就有什么属性和方法，不可能多，也不可能少。 ","date":"2019-11-23","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:3:2","tags":["Python学习之路"],"title":"Python学习之路-初识面向对象","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["Python"],"content":"类的设计 在使用面相对象开发前，应该首先分析需求，确定一下，程序中需要包含哪些类！ 在程序开发中，要设计一个类，通常需要满足一下三个要素： 类名这类事物的名字，满足大驼峰命名法 属性这类事物具有什么样的特征 方法这类事物具有什么样的行为 提示 大驼峰命名法：每一个单词的首字母大写且单词与单词之间没有下划线，如ClassName。 类名 名词提炼法分析整个业务流程，出现的名词，通常就是找到的类 属性和方法 对对象的特征描述，通常可以定义成属性 对象具有的行为(动词)，通常可以定义成方法 提示 需求中没有涉及的属性或者方法在设计类时，不需要考虑 ","date":"2019-11-23","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:3:3","tags":["Python学习之路"],"title":"Python学习之路-初识面向对象","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["Python"],"content":"基础语法 ","date":"2019-11-23","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:4:0","tags":["Python学习之路"],"title":"Python学习之路-初识面向对象","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["Python"],"content":"定义简单的类 定义一个只包含方法的类语法格式如下： class 类名: def 方法1(self, 参数列表): pass def 方法2(self, 参数列表): pass 提示 方法的定义格式和之前学习过的函数几乎一样,区别在于第一个参数必须是self，暂时先记住，稍后介绍 self ","date":"2019-11-23","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:4:1","tags":["Python学习之路"],"title":"Python学习之路-初识面向对象","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["Python"],"content":"创建对象 当一个类定义完成之后，要使用这个类来创建对象，语法格式如下： 对象变量 = 类名() ","date":"2019-11-23","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:4:2","tags":["Python学习之路"],"title":"Python学习之路-初识面向对象","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["Python"],"content":"方法中的 self 参数 由哪一个对象调用的方法，方法内的 self 就是哪一个对象的引用 提示 在面向对象开发中，引用的概念是同样适用的。使用类创建对象之后，对象的变量中仍然记录的是对象在内存中的地址，也就是对象的变量引用了新建的类对象。使用 print 输出对象变量，默认情况下，是能够输出这个变量引用的对象是由哪一个类创建的对象，以及在内存中的地址（十六进制表示） 在类封装的方法内部，self 就表示当前调用方法的对象自己。调用方法时，程序员不需要传递self参数。 在方法内部，可以通过 self. 访问对象的属性，也可以通过 self. 调用其他的对象方法。 在类的外部，通过 变量名. 访问对象的属性和方法，在类封装的方法中，通过 self. 访问对象的属性和方法。 ","date":"2019-11-23","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:4:3","tags":["Python学习之路"],"title":"Python学习之路-初识面向对象","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["Python"],"content":"初始化方法 当使用 类名() 创建对象时，会自动执行以下操作： 为对象在内存中分配空间 —— 创建对象 为对象的属性设置初始值 —— 初始化方法(init) 提示 初始化方法就是 __init__ 方法，__init__ 是对象的内置方法，__init__ 方法是 专门用来定义一个类具有哪些属性的方法 在 __init__ 方法内部使用 self.属性名 = 属性的初始值 就可以定义属性，定义属性之后，再使用类创建的对象，都会拥有该属性。 ","date":"2019-11-23","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:4:4","tags":["Python学习之路"],"title":"Python学习之路-初识面向对象","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["Python"],"content":"内置方法和属性 __del__方法 当使用 类名() 创建对象时，为对象分配完空间后，自动调用 __init__ 方法，当一个对象被从内存中销毁前，会自动调用 __del__ 方法。 提示 __init__ 改造初始化方法，可以让创建对象更加灵活，__del__ 如果希望在对象被销毁前，再做一些事情，可以考虑一下 __del__ 方法 提示 对象的生命周期，一个对象从调用 类名() 创建，生命周期开始，一个对象的 __del__ 方法一旦被调用，生命周期结束，在对象的生命周期内，可以访问对象属性，或者让对象调用方法。 __str__方法 如果在开发中，希望使用 print 输出对象变量时，能够打印自定义的内容，就可以利用__str__这个内置方法了 提示 __str__ 方法必须返回一个字符串 ","date":"2019-11-23","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:4:5","tags":["Python学习之路"],"title":"Python学习之路-初识面向对象","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["生活"],"content":"前言 来上海已经一年多了，已经逐渐融入上海这座大都市，我的故事还在继续。。。。 ","date":"2019-11-16","objectID":"/%E5%85%A5%E8%81%8C%E4%B8%80%E5%B9%B4%E6%9C%89%E6%84%9F/:1:0","tags":["职场"],"title":"入职一年有感","uri":"/%E5%85%A5%E8%81%8C%E4%B8%80%E5%B9%B4%E6%9C%89%E6%84%9F/"},{"categories":["生活"],"content":"公司 在公司的这一年学习到挺多东西的。这一年公司人员也进进出出也变化挺大的，很庆幸能遇到一个好的leader，不仅在工作中教会了我很多，在生活中也给予我很大的帮助，他的脖子和腰不是太好，希望能早点治疗好疾病。公司整体偏年轻，一群人在一起创业，虽然可能不属于同一个部门，但是大方向都是为了公司更好的未来，感觉创业型的公司凝聚力好强啊。老板给的发挥空间也比较大，可以自己找到自己的位置做出自己的贡献。 ","date":"2019-11-16","objectID":"/%E5%85%A5%E8%81%8C%E4%B8%80%E5%B9%B4%E6%9C%89%E6%84%9F/:2:0","tags":["职场"],"title":"入职一年有感","uri":"/%E5%85%A5%E8%81%8C%E4%B8%80%E5%B9%B4%E6%9C%89%E6%84%9F/"},{"categories":["生活"],"content":"转型 目前公司准备开始了新的项目，会从全Python转向Golang，但这是我们一致开会完制定的方案，虽然有些陌生，但我相信我能很快学会Go语言，并完成新的项目。这也是来上海以来最大的一个挑战了，目前看了一下Go的语法，虽然没有Python这么简洁，但也比较简单，再加上leader作出的指导，应该能很好地适应这个变化。 ","date":"2019-11-16","objectID":"/%E5%85%A5%E8%81%8C%E4%B8%80%E5%B9%B4%E6%9C%89%E6%84%9F/:3:0","tags":["职场"],"title":"入职一年有感","uri":"/%E5%85%A5%E8%81%8C%E4%B8%80%E5%B9%B4%E6%9C%89%E6%84%9F/"},{"categories":["生活"],"content":"未来 我不清楚未来Go会发展成什么样子，虽然现在社区也远不如Python强大，但他的确可以解决我们目前的很多痛点问题，而且未来的大数据时代，我相信它应该也会有一席之地。只会Python也不会提高多少，现在学会了Go也会增加我的竞争力，而且不同语言也会带来我更多的思考，说不定未来转行Go开发了。 ","date":"2019-11-16","objectID":"/%E5%85%A5%E8%81%8C%E4%B8%80%E5%B9%B4%E6%9C%89%E6%84%9F/:4:0","tags":["职场"],"title":"入职一年有感","uri":"/%E5%85%A5%E8%81%8C%E4%B8%80%E5%B9%B4%E6%9C%89%E6%84%9F/"},{"categories":["生活"],"content":"未完待续 未来不管做Python还是Go还是其他语言，我都会努力做到最好的！我的故事还在继续。。。。 ","date":"2019-11-16","objectID":"/%E5%85%A5%E8%81%8C%E4%B8%80%E5%B9%B4%E6%9C%89%E6%84%9F/:5:0","tags":["职场"],"title":"入职一年有感","uri":"/%E5%85%A5%E8%81%8C%E4%B8%80%E5%B9%B4%E6%9C%89%E6%84%9F/"},{"categories":["Python"],"content":"目前已经学习了变量、流程控制、函数、模块，可以利用已学习的知识开发一个学生管理系统 ","date":"2019-11-09","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/:0:0","tags":["Python学习之路"],"title":"Python学习之路-综合练习:学生管理系统","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"categories":["Python"],"content":"项目需求 系统有首页介绍页面与功能菜单 系统功能由查询、显示、修改与删除功能 可以使用数字选择不同的功能 学生信息需要记录：姓名、性别、年龄、班级 ","date":"2019-11-09","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/:1:0","tags":["Python学习之路"],"title":"Python学习之路-综合练习:学生管理系统","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"categories":["Python"],"content":"项目搭建 ","date":"2019-11-09","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/:2:0","tags":["Python学习之路"],"title":"Python学习之路-综合练习:学生管理系统","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"categories":["Python"],"content":"步骤 创建文件 新建student_main.py文件，用于编写主程序功能代码，并作为程序的入口每一次启动名片管理系统都通过这个文件启动 新建student_tools.py文件，用于编写功能函数，将对系统的 新增、查询、修改、删除 等功能封装在不同的函数中 梳理业务逻辑，编写业务流程 # 通过死循环控制整个业务主体运行 # 编写系统欢迎界面，并显示功能菜单 # 提供用户输入选项 # 对输入选项进行输出 # 根据用户输入决定后续的操作 提示 在进行编码前最好进行业务逻辑的梳理，然后根据需求编写一个业务流程。编码前思考再进行编码能大大提高整体的效率。 完成主程序编码 # 通过死循环控制整个业务主体运行 while True: # 编写系统欢迎界面，并显示功能菜单 print(\"*\" * 20) print(\"欢迎使用【学生管理系统】1.0\\n\\n1. 新增学生\\n2. 显示全部学生\\n3. 查询学生\\n0. 退出系统\") print(\"*\" * 20) # 提供用户输入选项 options = input(\"请选择操作功能：\") # 对输入选项进行输出 print(\"您选择的操作是：%s\" % options) # 根据用户输入决定后续的操作 if options in [\"1\", \"2\", \"3\"]: pass # TODO 后续操作业务 elif options == \"0\": print(\"欢迎再次使用【名片管理系统】\") break else: print(\"输入错误，请重新输入\") 提示 在 # 后跟上 TODO，用于标记需要去做的工作 学生管理相关业务流程 新增学生 # 新增学生模块信息提示 # 提示用户输入学生信息 # 判断学生是否存在 # 存在则提示学生已存在 # 不存在将学生信息保存到一个字典 # 并将学生字典添加到学生列表 # 提示添加成功信息 显示所有学生 # 显示全部学生模块信息提示 # 遍历列表显示全部学生信息 查询学生 # 查询学生信息模块信息提示 # 提示用户输入搜索学生的姓名 # 遍历字典进行查询 # 找到后进行后续操作：修改/删除 # 没有找到输出提示信息 修改与删除学生信息 # 修改学生信息模块信息提示 # 提示用户输入修改学生的相关信息 # 提示修改成功信息 # 提示删除成功信息 完成相关业务流程代码 student_list = [] def new_student(): \"\"\"新建名片\"\"\" # 新增学生模块信息提示 print(\"-\" * 50) print(\"功能：新建学生\") # 提示用户输入学生信息 name = input(\"请输入姓名：\") gender = input(\"请输入性别：\") age = input(\"请输入年龄：\") team = input(\"请输入班级：\") # 将学生信息保存到一个字典 student_dict = {\"name\": name, \"gender\": gender, \"age\": age, \"team\": team} # 将学生字典添加到学生列表 student_list.append(student_dict) # 提示添加成功信息 print(\"成功添加学生：%s\" % student_dict[\"name\"]) def show_all_student(): \"\"\"显示全部学生\"\"\" # 显示全部学生模块信息提示 print(\"-\" * 50) print(\"功能：显示全部学生\") # 遍历列表显示全部学生信息 for name in [\"姓名\", \"性别\", \"年龄\", \"班级\"]: print(name, end=\"\\t\\t\") print(\"\") # 打印分隔线 print(\"=\" * 50) # 格式化输出信息 for student_dict in student_list: print(\"%s\\t\\t%s\\t\\t%s\\t\\t%s\" % (student_dict[\"name\"], student_dict[\"gender\"], student_dict[\"age\"], student_dict[\"team\"])) def search_student(): \"\"\"查询学生信息\"\"\" # 查询学生信息模块信息提示 print(\"-\" * 50) print(\"功能：搜索名片\") # 提示用户输入搜索学生的姓名 find_name = input(\"请输入要查询的学生姓名：\") # 遍历字典进行查询 for student_dict in student_list: if student_dict[\"name\"] == find_name: print(\"姓名\\t\\t\\t性别\\t\\t\\t年龄\\t\\t\\t班级\") print(\"-\" * 40) print(\"%s\\t\\t\\t%s\\t\\t\\t%s\\t\\t\\t%s\" % ( student_dict[\"name\"], student_dict[\"gender\"], student_dict[\"age\"], student_dict[\"team\"])) print(\"-\" * 40) # 找到后进行后续操作：修改/删除 # 提示用户输入修改学生的相关信息 options = input(\"请选择要执行的操作[1] 修改 [2] 删除 [0] 返回上级菜单\") if options == \"1\": student_dict[\"name\"] = input(\"请输入姓名：\") student_dict[\"gender\"] = input(\"请输入性别：\") student_dict[\"age\"] = input(\"请输入年龄：\") student_dict[\"team\"] = input(\"请输入班级：\") # 提示修改成功信息 print(\"学生：'%s'的信息修改成功\" % student_dict[\"name\"]) elif options == \"2\": student_list.remove(student_dict) # 提示删除成功信息 print(\"学生：'%s'的信息删除成功\" % student_dict[\"name\"]) break else: # 没有找到输出提示信息 print(\"没有找到 %s\" % find_name) 将相关业务流程代码导入主流程,补充主流程中TUDO部分 from student_tools import new_student,show_all_student,search_student # 通过死循环控制整个业务主体运行 while True: # 编写系统欢迎界面，并显示功能菜单 print(\"*\" * 20) print(\"欢迎使用【学生管理系统】1.0\\n\\n1. 新增学生\\n2. 显示全部学生\\n3. 查询学生\\n0. 退出系统\") print(\"*\" * 20) # 提供用户输入选项 option = input(\"请选择操作功能：\") # 对输入选项进行输出 print(\"您选择的操作是：%s\" % option) # 根据用户输入决定后续的操作 if option in [\"1\", \"2\", \"3\"]: if option == \"1\": new_student() elif option == \"2\": show_all_student() elif option == \"3\": search_student() elif option == \"0\": print(\"欢迎再次使用【名片管理系统】\") break else: print(\"输入错误，请重新输入\") 提示 在代码中大量使用/n和/t等转义字符用于优化字符串输出样式，Python中可以使用的转移字符串如下表格： 转义字符 描述 \\(在行尾时) 续行符 \\\\ 反斜杠符号 ' 单引号 \" 双引号 \\a 响铃 \\b 退格(Backspace) \\e 转义 \\000 空 \\n 换行 \\v 纵向制表符 \\t 横向制表符 \\r 回车 \\f 换页 \\oyy 八进制数，y 代表 0~7 的字符，例如：\\012 代表换行。 \\xyy 十六进制数，以 \\x 开头，yy代表的字符，例如：\\x0a代表换行 \\other 其它的字符以普通格式输出 ","date":"2019-11-09","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/:2:1","tags":["Python学习之路"],"title":"Python学习之路-综合练习:学生管理系统","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"categories":["Python"],"content":"参数和返回值的作用 函数根据有没有参数以及有没有返回值，可以相互组合，一共有4 种组合形式：无参数，无返回值；无参数，有返回值；有参数，无返回值；有参数，有返回值。 提示 定义函数时，是否接收参数，或者是否返回结果，是根据实际的功能需求来决定的！如果函数内部处理的数据不确定，就可以将外界的数据以参数传递到函数内部。如果希望一个函数执行完成后，向外界汇报执行结果，就可以增加函数的返回值 ","date":"2019-11-02","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/:1:0","tags":["Python学习之路"],"title":"Python学习之路-函数进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"不可变和可变的参数 无论传递的参数是可变还是不可变只要针对参数使用赋值语句，会在函数内部修改局部变量的引用**，**不会影响到 外部变量的引用。如果传递的参数是可变类型，在函数内部，使用方法修改了数据的内容，同样会影响到外部的数据 ","date":"2019-11-02","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/:2:0","tags":["Python学习之路"],"title":"Python学习之路-函数进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"缺省参数 定义函数时，可以给某个参数指定一个默认值，具有默认值的参数就叫做缺省参数调用函数时，如果没有传入缺省参数的值，则在函数内部使用定义函数时指定的参数默认值。函数的缺省参数，将常见的值设置为参数的缺省值，从而简化函数的调用 提示 缺省参数需要使用最常见的值作为默认值！如果一个参数的值不能确定，则不应该设置默认值，具体的数值在调用函数时，由外界传递！ ","date":"2019-11-02","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/:3:0","tags":["Python学习之路"],"title":"Python学习之路-函数进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"缺省参数的注意事项 缺省参数的定义位置 必须保证带有默认值的缺省参数在参数列表末尾 调用带有多个缺省参数的函数 在调用函数时，如果有多个缺省参数，需要指定参数名，这样解释器才能够知道参数的对应关系！ ","date":"2019-11-02","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/:3:1","tags":["Python学习之路"],"title":"Python学习之路-函数进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"多值参数 定义支持多值参数的函数，有时可能需要一个函数能够处理的参数个数是不确定的，这个时候就可以使用多值参数。python中有两种多值参数： 参数名前增加 一个 * 可以接收元组 参数名前增加 两个* 可以接收字典 一般在给多值参数命名时，习惯使用以下两个名字: *args —— 存放 元组 参数，前面有一个 * **kwargs —— 存放 字典 参数，前面有两个 * 提示 args是arguments的缩写，有变量的含义，kw 是 keyword 的缩写，kwargs 可以记忆键值对参数 元组和字典的拆包 在调用带有多值参数的函数时，如果希望：将一个元组变量，直接传递给 args将一个 字典变量，直接传递给 kwargs就可以使用拆包，简化参数的传递，拆包的方式是：在元组变量前，增加一个*在字典变量前，增加两个 *。 ","date":"2019-11-02","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/:4:0","tags":["Python学习之路"],"title":"Python学习之路-函数进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"递归 ","date":"2019-11-02","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/:5:0","tags":["Python学习之路"],"title":"Python学习之路-函数进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"简介 函数调用自身的编程技巧称为递归 ","date":"2019-11-02","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/:5:1","tags":["Python学习之路"],"title":"Python学习之路-函数进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"特点 一个函数内部调用自己。函数内部可以调用其他函数，当然在函数内部也可以调用自己 ","date":"2019-11-02","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/:5:2","tags":["Python学习之路"],"title":"Python学习之路-函数进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"代码特点 函数内部的代码是相同的，只是针对参数不同，处理的结果不同 当参数满足一个条件时，函数不再执行 警告 这个非常重要，通常被称为递归的出口，否则会出现死循环！ 提示 初次接触递归会感觉有些吃力！在处理不确定的循环条件时，格外的有用，例如：遍历整个文件目录的结构 ","date":"2019-11-02","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/:5:3","tags":["Python学习之路"],"title":"Python学习之路-函数进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"内置函数 Python 解释器内置了很多函数，可以在任何时候使用，在这里查看具体包含哪些与使用方法。 ","date":"2019-11-02","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/:6:0","tags":["Python学习之路"],"title":"Python学习之路-函数进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"定义 所谓函数就是把具有独立功能的代码块组织为一个小的模块，在需要的时候可以直接调用 ","date":"2019-10-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/:1:0","tags":["Python学习之路"],"title":"Python学习之路-函数基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/"},{"categories":["Python"],"content":"作用 在开发程序时，函数可以提高编写的效率以及代码的重用。 ","date":"2019-10-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/:2:0","tags":["Python学习之路"],"title":"Python学习之路-函数基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/"},{"categories":["Python"],"content":"基本使用 ","date":"2019-10-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/:3:0","tags":["Python学习之路"],"title":"Python学习之路-函数基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/"},{"categories":["Python"],"content":"步骤 使用函数有两个步骤： 定义函数：封装独立功能的代码块 def 函数名(): 函数封装的代码 …… def为英文define的缩写，即定义的意思 函数名称应该能表达函数封装代码的功能，方便后续理解调用 函数名称的命名应该符合标识符的命名规则 调用函数：使用封装好的成功 通过 函数名() 即可完成对函数的调用 ","date":"2019-10-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/:3:1","tags":["Python学习之路"],"title":"Python学习之路-函数基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/"},{"categories":["Python"],"content":"参数 ","date":"2019-10-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/:4:0","tags":["Python学习之路"],"title":"Python学习之路-函数基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/"},{"categories":["Python"],"content":"作用 函数的参数，增加函数的通用性，针对相同的数据处理逻辑，能够适应更多的数据。在函数内部，把参数当做变量使用，进行需要的数据处理。函数调用时，按照函数定义的参数顺序，把希望在函数内部处理的数据，通过参数传递 ","date":"2019-10-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/:4:1","tags":["Python学习之路"],"title":"Python学习之路-函数基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/"},{"categories":["Python"],"content":"形参和实参 形参：定义函数时，小括号中的参数，是用来接收参数用的，在函数内部作为变量使用 实参：调用函数时，小括号中的参数，是用来把数据传递到函数内部用的 ","date":"2019-10-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/:4:2","tags":["Python学习之路"],"title":"Python学习之路-函数基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/"},{"categories":["Python"],"content":"返回值 在程序开发中，有时候，会希望一个函数执行结束后，告诉调用者一个结果，以便调用者针对具体的结果做后续的处理。返回值是函数完成工作后，最后给调用者的一个结果。在函数中使用return关键字可以返回结果，调用函数一方，可以使用变量来接收函数的返回结果。 注意 return 表示返回，后续的代码都不会被执行 ","date":"2019-10-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/:5:0","tags":["Python学习之路"],"title":"Python学习之路-函数基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/"},{"categories":["Python"],"content":"嵌套调用 一个函数里面又调用了另外一个函数，这就是函数嵌套调用。如果函数中，调用了另外一个函数那么执行到调用 外层函数时，会先把被嵌套函数中的任务都执行完才会执行后续的代码 ","date":"2019-10-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/:6:0","tags":["Python学习之路"],"title":"Python学习之路-函数基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/"},{"categories":["Python"],"content":"模块中的函数 模块是 Python 程序架构的一个核心概念。模块就好比是工具包，要想使用这个工具包中的工具，就需要导入 import这个模块。每一个以扩展名 py 结尾的 Python 源代码文件都是一个模块。在模块中定义的全局变量、函数都是模块能够提供给外界直接使用的工具 注意 模块名也是一个标识符 ","date":"2019-10-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/:7:0","tags":["Python学习之路"],"title":"Python学习之路-函数基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/"},{"categories":["Python"],"content":"拓展 ","date":"2019-10-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/:8:0","tags":["Python学习之路"],"title":"Python学习之路-函数基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/"},{"categories":["Python"],"content":"Pyc 文件 简介 C 是 compiled 编译过 的意思。浏览程序目录会发现一个__pycache__的目录，目录下会有一个 xx.cpython-37.pyc 文件，cpython-37 表示 Python 解释器的版本.这个pyc文件是由 Python 解释器将模块的源码转换为字节码 提示 Python 这样保存字节码是作为一种启动速度的优化 字节码 Python 在解释源程序时是分成两个步骤的 首先处理源代码，编译生成一个二进制字节码 再对字节码进行处理，才会生成 CPU 能够识别的机器码 有了模块的字节码文件之后，下一次运行程序时，如果在上次保存字节码之后没有修改过源代码，Python 将会加载 .pyc 文件并跳过编译这个步骤。当Python重编译时，它会自动检查源文件和字节码文件的时间戳。如果你又修改了源代码，下次程序运行时，字节码将自动重新创建 ","date":"2019-10-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/:8:1","tags":["Python学习之路"],"title":"Python学习之路-函数基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/"},{"categories":["Python"],"content":"程序就是用来处理数据的，而常量和变量就是最简单用来存储数据的 ","date":"2019-10-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/:0:0","tags":["Python学习之路"],"title":"Python学习之路-常量与变量","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/"},{"categories":["Python"],"content":"常量 ","date":"2019-10-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/:1:0","tags":["Python学习之路"],"title":"Python学习之路-常量与变量","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/"},{"categories":["Python"],"content":"定义 声明在文件的顶部 ","date":"2019-10-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/:1:1","tags":["Python学习之路"],"title":"Python学习之路-常量与变量","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/"},{"categories":["Python"],"content":"命名规范 全部大写 单词间用下划线分隔 ","date":"2019-10-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/:1:2","tags":["Python学习之路"],"title":"Python学习之路-常量与变量","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/"},{"categories":["Python"],"content":"变量 ","date":"2019-10-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/:2:0","tags":["Python学习之路"],"title":"Python学习之路-常量与变量","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/"},{"categories":["Python"],"content":"定义 变量在使用前都必须要要进行赋值，只有被赋值后变量才会被创建 ","date":"2019-10-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/:2:1","tags":["Python学习之路"],"title":"Python学习之路-常量与变量","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/"},{"categories":["Python"],"content":"命名规范 一般情况 当变量名需要由二个或多个单词组成时，每个单词都使用小写字母单词与单词之间使用 _下划线连接 驼峰命名法 当变量名是由二个或多个单词组成时，还可以利用驼峰命名法来命名 小驼峰式命名法：第一个单词以小写字母开始，后续单词的首字母大写 大驼峰式命名法：每一个单词的首字母都采用大写字母 注意 变量与常量都属于标识符，需要满足标识符的命名方式。标识符区分大小写。 提示 以上命名规范都不是强制的，命名规范可以更好的满足PEP 8和PEP 20并增加代码的识别和可读性 ","date":"2019-10-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/:2:2","tags":["Python学习之路"],"title":"Python学习之路-常量与变量","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/"},{"categories":["Python"],"content":"类型 在 Python 中定义变量是 不需要指定类型（在其他很多高级语言中都需要） 数据类型可以分为数字型和非数字型 数字型 整型(int) 浮点型float) 布尔型(bool) 真 True 非 0 数 —— 非零即真 假 False 0 复数型(complex) 主要用于科学计算，例如：平面场问题、波动问题、电感电容等问题 非数字型 字符串 列表 元组 字典 ","date":"2019-10-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/:2:3","tags":["Python学习之路"],"title":"Python学习之路-常量与变量","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/"},{"categories":["Python"],"content":"交互 数字型变量之间可以直接计算，bool型True为1，False为0 字符串变量之间使用+拼接字符串 字符串变量可以和整数使用*重复拼接相同的字符串 数字型变量和字符串之间不能进行其他计算 ","date":"2019-10-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/:2:4","tags":["Python学习之路"],"title":"Python学习之路-常量与变量","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/"},{"categories":["Python"],"content":"输入 变量也可以通过键盘输入的信息获取，这时可以使用input函数从键盘等待用户的输入 提示 input函数跟之前使用过的print函数一样都是Python3内置的函数，可以理解为提前准备好的功能，可以直接使用。 语法如下： 字符串变量 = input(\"提示信息：\") 注意 用户输入的任何内容Python 都认为是一个字符串 ","date":"2019-10-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/:2:5","tags":["Python学习之路"],"title":"Python学习之路-常量与变量","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/"},{"categories":["Python"],"content":"类型转换 函数 说明 int(x) 将x转换为整数 float(x) 将x转换为浮点数 str(x) 将x转换为字符串 ","date":"2019-10-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/:2:6","tags":["Python学习之路"],"title":"Python学习之路-常量与变量","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/"},{"categories":["Python"],"content":"格式化输出 想要输出固定字符串的同时一起输出变量的值，可以使用格式化操作符%，%和不同的字符连用可以输出不同类型的数据。 格式化字符 含义 %s 字符串 %d 有符号十进制整数，%06d表示输出的整数显示位数，不足的地方使用 0 补全 %f 浮点数，%.2f 表示小数点后只显示两位 %% 输出 % 提示 包含格式化操作符的字符串称为格式化字符串 ","date":"2019-10-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/:2:7","tags":["Python学习之路"],"title":"Python学习之路-常量与变量","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/"},{"categories":["Python"],"content":"非数字型变量 所有非数字型变量都支持以下特点： 都是一个序列 通过[]取值 通过for in遍历 计算长度、最大/最小值、比较、删除 链接 + 和 重复 * 切片 字符串 定义 字符串就是一串文本字符的数据类型，在 Python 中可以使用一对双引号\"或者一对单引号'定义一个字符串。 提示 当用双引号\"做字符串时内部可以用单引号'定义字符串；当用单引号'做字符串时内部可以用双引号\"定义字符串。 常用操作 判断类型 方法 说明 isspace() 如果 string 中只包含空格，则返回 True isalnum() 如果 string 至少有一个字符并且所有字符都是字母或数字则返回 True isalpha() 如果 string 至少有一个字符并且所有字符都是字母则返回 True isdecimal() 如果 string 只包含十进制数字则返回 True 否则返回 False isdigit() 如果 string 只包含数字则返回 True 否则返回 False isnumeric() 如果 string 中只包含数字字符，则返回 True，否则返回 False istitle() 如果 string 是标题化的(每个单词的首字母大写)则返回 True islower() 如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True isupper() 如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True 查找和替换 方法 说明 startswith(str) 检查字符串是否是以 str 开头，是则返回 True endswith(str) 检查字符串是否是以 str 结束，是则返回 True find(str, start=0, end=len(string)) 检测 str 是否包含在 string 中，如果 start 和 end 指定范围，则检查是否包含在指定范围内，如果是返回开始的索引值，否则返回 -1 rfind(str, start=0, end=len(string)) 类似于 find()，不过是从右边开始查找 index(str, start=0, end=len(string)) 跟 find() 方法类似，不过如果 str 不在 string 会报错 rindex(str, start=0, end=len(string)) 类似于 index()，不过是从右边开始 replace(old_str, new_str, num=string.count(old)) 把 string 中的 old_str 替换成 new_str，如果 num 指定，则替换不超过 num 次 大小写转换 方法 说明 capitalize() 把字符串的第一个字符大写 title() 把字符串的每个单词首字母大写 lower() 转换 string 中所有大写字符为小写 upper() 转换 string 中的小写字母为大写 swapcase() 翻转 string 中的大小写 文本对齐 方法 说明 ljust(width) 返回一个原字符串左对齐，并使用空格填充至长度 width 的新字符串 rjust(width) 返回一个原字符串右对齐，并使用空格填充至长度 width 的新字符串 center(width) 返回一个原字符串居中，并使用空格填充至长度 width 的新字符串 去除空白字符 方法 说明 lstrip() 截掉 string 左边（开始）的空白字符 rstrip() 截掉 string 右边（末尾）的空白字符 strip() 截掉 string 左右两边的空白字符 拆分和连接 方法 说明 partition(str) 把字符串 string 分成一个 3 元素的元组 (str前面, str, str后面) rpartition(str) 类似于 partition() 方法，不过是从右边开始查找 split(str=””, num) 以 str 为分隔符拆分 string，如果 num 有指定值，则仅分隔 num + 1 个子字符串，str 默认包含 ‘\\r’, ‘\\t’, ‘\\n’ 和空格 splitlines() 按照行('\\r’, ‘\\n’, ‘\\r\\n’)分隔，返回一个包含各行作为元素的列表 join(seq) 以 string 作为分隔符，将 seq 中所有的元素（的字符串表示）合并为一个新的字符串 列表 定义 list(列表)是专门用于存储一串信息的对象集合，用[]来定义，数据之间使用,分隔。列表的索引从0开始。 提示 索引就是数据在列表中的位置编号，索引又可以被称为下标。从列表中取值时，如果超出索引范围，程序会报错。 常用操作 增加 列表.insert(索引, 数据)：根据索引位置插入指定数据 列表.append(数据)：在末尾追加数据 列表.extend(list)：将另一个列表合并到当前列表中 修改 通过指定索引进行赋值操作 列表[索引] = 数据 删除 列表.remove[数据]：删除第一个出现的指定数据 列表.pop(索引)：删除指定索引数据并返回该值，不传索引则为删除末尾的数据 列表.clear：清空列表 del 列表[索引]：删除指定索引数据，不写[索引]则为删除整个列表 提示 del关键字可以删除任意变量，在对列表操作时指定索引就删除列表中指定索引的元素不指定索引则直接删除整个列表 统计 len(列表)：计算列表长度 count(数据)：统计数据在列表中出现的次数 排序 列表.sort()：升序排序，传入reverse=True则为降序排列 列表.reverse()：反转列表 元祖 定义 Tuple元祖表示多个元素组成的对象集合。用()来定义，数据之间使用,分隔。元祖的索引从0开始。与列表类似，不同之处在于元素的元素不能修改。 常规操作 统计值出现的次数 元祖.count(值) 返回索引所在的位置 元祖.index(值) 字典 定义 dict(字典)表示存储多个键值对的对象集合。用{}来定义，键与值之间用:分隔，键值对之间使用，分隔。字典的索引为键，键必须是唯一的，且只能使用字符串、数字或元祖。 常规操作 增加 通过对新的键进行赋值 dict['new_key'] = 'value' 修改 通过对存在的键进行修改 dict['key'] = 'value' 删除 dict.clear()：清空字典所有条目 del dict[‘key’]：通过对存在的键进行删除 del dict：删除整个字典 提示 字典是无序的对象集合，字符串、列表、元祖都是有序的对象集合。 字典和列表是可变对象集合，字符串、元祖为不可变对象集合。 内置方法 方法 说明 clear() 删除字典内所有元素 copy() 返回一个字典的浅拷贝 fromkeys(key, value) 创建一个新字典，以序列key中元素做字典的键，value为字典所有键对应的初始值 get(key, default=None) 返回指定键的值，如果值不在字典中返回default值 has_key(key) 如果键在字典dict里返回true，否则返回false items() 以列表返回可遍历的(键, 值) 元组数组 keys() 以列表返回一个字典所有的键 setdefault(key, default=None) 和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default update(dict2) 把字典dict2的键/值对更新到dict里 values() 以列表返回字典中的所有值 pop(key) 删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。 popitem() 返回并删除字典中的最后一对键和值。 公共方法 Python内置函数 函数 描述 备注 len(item) 计算容器中元素个数 del(item) 删除变量 del 有两种方式 max(item) 返回容器中元素最大值 如果是字典，只针对 key 比较 min(item) 返回容器中元素最小值 如果是字典，只针对 key 比较 切片 使用索引值来限定一个范围。列表和元组都是有序的集合，都能够通过索引值获取到对应的数据。字典是一个无序的集合，是使用键值对保存数据。 运算符 运算符 描述 支持的数据类型 + 合并 字符串、列表、元组 * 重复 字符串、列表、元组 in 元素是否存在 字符串、列表、元组、字典 not in 元素是否不存在 字符串、列表、元组、字典 \u003e \u003e= == \u003c \u003c= 元素比较 字符串、列表、元组 注意 in 在对字典操作时，判断的是字典的键。in和not in 被称为成员运算符 for 循环语法 可以通过for进行遍历 语法如下： for 变量 in 集合: 代码块 ","date":"2019-10-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/:2:8","tags":["Python学习之路"],"title":"Python学习之路-常量与变量","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/"},{"categories":["Python"],"content":"深入理解变量 ","date":"2019-10-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/:3:0","tags":["Python学习之路"],"title":"Python学习之路-常量与变量","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/"},{"categories":["Python"],"content":"引用 简介 变量和数据都是保存在内存中的，在Python中函数的参数传递以及返回值都是靠引用传递的 深入理解 在Python中变量和数据是分开存储的。数据保存在内存中的某个位置，变量则保存着数据在内存中的地址。变量中记录数据的地址就是引用，使用id()函数可以查看变量中保存数据所在的内存地址 注意 如果变量已经被定义，当给一个变量赋值的时候，本质上是修改了数据的引用，变量不再对之前的数据引用，变量 改为对新赋值的数据引用 提示 函数的实参/返回值都是是靠引用来传递来的 ","date":"2019-10-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/:3:1","tags":["Python学习之路"],"title":"Python学习之路-常量与变量","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/"},{"categories":["Python"],"content":"可变和不可变类型 不可变类型，内存中的数据不允许被修改：数字类型、字符串 、元组 可变类型，内存中的数据可以被修改：列表、dict 注意 字典的key只能使用不可变类型的数据。 可变类型的数据变化，是通过方法来实现的，如果给一个可变类型的变量，赋值了一个新的数据，引用会修改变量不再对之前的数据引用，改为对新赋值的数据引用 ","date":"2019-10-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/:3:2","tags":["Python学习之路"],"title":"Python学习之路-常量与变量","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/"},{"categories":["生活"],"content":"前言 房租差600上班骑车半个小时和坐地铁+公交1个小时大家会怎么选呢 ","date":"2019-10-19","objectID":"/%E7%A7%9F%E6%88%BF%E6%97%A5%E8%AE%B0/:1:0","tags":["租房"],"title":"租房日记","uri":"/%E7%A7%9F%E6%88%BF%E6%97%A5%E8%AE%B0/"},{"categories":["生活"],"content":"公司搬家 由于种种原因公司搬家了，从一个大型商业广场搬家到了一个动物园边上的别墅区。由于临近中秋和国庆，也没来得及仔细想想，还沉浸在搬家的喜悦之中。等收假回来发现，上班变得不方便了，没有直达的地铁，换乘得往回坐一站，还得站外换乘，成本高了不少；坐公交得先骑车1.5km才能到公交车站，下车后还要走1.5km上班时间从原来的20分钟内，变成四五十分钟。现在公司也不属于核心商圈了，感觉没必要租那么贵的房子，虽然房子还有一个多月才到期，但是换房子的想法涌上心头。 ","date":"2019-10-19","objectID":"/%E7%A7%9F%E6%88%BF%E6%97%A5%E8%AE%B0/:2:0","tags":["租房"],"title":"租房日记","uri":"/%E7%A7%9F%E6%88%BF%E6%97%A5%E8%AE%B0/"},{"categories":["生活"],"content":"找房子 由于第一次租房没有经验，找的中介租的房子，导致房租很贵，一年就花了3万多，虽然房子离公司很近，但是由于是老小区隔音非常差，我的睡眠质量又不是很好，这次一定要换一个隔音好的房子。我看了一下地图，由于公司位于长宁区得到边缘，与闵行、青浦相隔。考虑到虹桥机场离的很近，放弃了闵行和长宁附近。根据链家的房租地图和知乎上的租房相关的文章，青浦比长宁的房租会便宜很多，所以准备在青浦往西寻找租房的地点，于是开始在网上寻找那一块的房子。在一个机缘巧合下我发现闲鱼上有个租房信息，在一个比较偏的地方有一个60+的单间，一室一厅一厨一卫加一个4-5平的阳台，看图片第一眼就看中了，当天就约着去看房了，那天到哪里很晚，都没有公交车了，打车过去的。看完我就决定租这里了，就开始谈房租，2200一个月，押一付三，很快就签了合同。 ","date":"2019-10-19","objectID":"/%E7%A7%9F%E6%88%BF%E6%97%A5%E8%AE%B0/:3:0","tags":["租房"],"title":"租房日记","uri":"/%E7%A7%9F%E6%88%BF%E6%97%A5%E8%AE%B0/"},{"categories":["生活"],"content":"搬家 房子是周三签的合同，周四就约了一个货拉拉，然后开始收拾房间，开始了断舍离的部分，我发现我真的是买太多东西了，整整花了两个晚上才将东西打包好。周六一早就开始搬家了，由于老房子没有电梯，就让货拉拉的师傅帮忙搬，给他加了30块辛苦费。搬家整个过程还是很顺利的，从9点半出发到10点40就已经完成了，最后花了120块钱，也还算比较划算了。下午我就开始了收拾房间，整整花了3个多小时才弄完。 ","date":"2019-10-19","objectID":"/%E7%A7%9F%E6%88%BF%E6%97%A5%E8%AE%B0/:4:0","tags":["租房"],"title":"租房日记","uri":"/%E7%A7%9F%E6%88%BF%E6%97%A5%E8%AE%B0/"},{"categories":["生活"],"content":"后记 晚上躺在床上想想这次租房的经历，发现还是有很多要总结的地方。首先说租房，由于当时非常想换房子了，租房也没有看很多，发现了一个合适的，就特别想租，房东说租的很快都不让签到周末，这三天时间都浪费了，而且都没有仔细想想不方便的地方。虽然从公司坐地铁到下地铁也有半个小时，但是转公交的那趟公交最后一班是7点，而且发车间隔20分钟，要是遇到加班或者什么的很有可能赶不上车，那最后这3km就得走回去或者打车。最后是地理位置，中午的时候想点个外卖才发现外卖都没多少，不过有个不小的厨房，以后争取多自己做饭吧。 这次租的房子整体上还是比较满意的，一个人住这个大房子还是蛮舒服的，就是还是有很多细节需要优化，就当做经验吧 ","date":"2019-10-19","objectID":"/%E7%A7%9F%E6%88%BF%E6%97%A5%E8%AE%B0/:5:0","tags":["租房"],"title":"租房日记","uri":"/%E7%A7%9F%E6%88%BF%E6%97%A5%E8%AE%B0/"},{"categories":["Python"],"content":"简介 上一篇讲到Python中的语句提到很多运算符，本篇来总结一下各类运算符的作用与用法。 ","date":"2019-10-12","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%BF%90%E7%AE%97%E7%AC%A6/:1:0","tags":["Python学习之路"],"title":"Python学习之路-运算符","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["Python"],"content":"算数运算符 运算符 描述 实例 + 加 1+1=2 - 减 1-1=0 * 乘 1*1=1 ** 幂次方 2**3=8 / 除 2/1=2 // 取整 5//2=2 % 取余 5%2=1 参考 在 Python 中 * 运算符还可以用于字符串，计算结果就是字符串重复指定次数的结果 ","date":"2019-10-12","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%BF%90%E7%AE%97%E7%AC%A6/:2:0","tags":["Python学习之路"],"title":"Python学习之路-运算符","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["Python"],"content":"比较运算符 运算符 描述 == 比较两个数据的值是否 相等，如果是，则条件成立，返回 True != 比较两个数据的值是否 不相等，如果是，则条件成立，返回 True \u003e 比较左边数的值是否 大于 右边数的值，如果是，则条件成立，返回 True \u003c 比较左边数数的值是否 小于 右边数的值，如果是，则条件成立，返回 True \u003e= 比较左边数的值是否 大于或等于 右边数的值，如果是，则条件成立，返回 True \u003c= 比较左边数数的值是否 小于或等于 右边数的值，如果是，则条件成立，返回 True 参考 Python中所有数据类型都可以用==与!=比较运算符 ","date":"2019-10-12","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%BF%90%E7%AE%97%E7%AC%A6/:3:0","tags":["Python学习之路"],"title":"Python学习之路-运算符","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["Python"],"content":"逻辑运算符 运算符 逻辑表达式 描述 and a and b 只有 a 和 b 的值都为 True，才会返回 True否则只要 a 或者 b 有一个值为 False，就返回 False or a or b 只要 a 或者 b 有一个值为 True，就返回 True只有 a 和 b 的值都为 False，才会返回 False not not a 如果 a 为 True，返回 False如果 a 为 False，返回 True ","date":"2019-10-12","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%BF%90%E7%AE%97%E7%AC%A6/:4:0","tags":["Python学习之路"],"title":"Python学习之路-运算符","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["Python"],"content":"赋值运算符 运算符 描述 实例 = 赋值运算符 c = a + b 将 a + b 的运算结果赋值为 c += 加法赋值运算符 c += a 等效于 c = c + a -= 减法赋值运算符 c -= a 等效于 c = c - a *= 乘法赋值运算符 c *= a 等效于 c = c * a /= 除法赋值运算符 c /= a 等效于 c = c / a //= 取整除赋值运算符 c //= a 等效于 c = c // a %= 取余数赋值运算符 c %= a 等效于 c = c % a **= 幂赋值运算符 c **= a 等效于 c = c** a 注意 赋值运算符中间不能使用空格 ","date":"2019-10-12","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%BF%90%E7%AE%97%E7%AC%A6/:5:0","tags":["Python学习之路"],"title":"Python学习之路-运算符","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["Python"],"content":"成员运算符 运算符 描述 实例 in 如果在指定的序列中找到值返回 True，否则返回 False 3 in (1, 2, 3) 返回 True not in 如果在指定的序列中没有找到值返回 True，否则返回 False 3 not in (1, 2, 3) 返回 False 注意 在对 字典 操作时，判断的是 字典的键 ","date":"2019-10-12","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%BF%90%E7%AE%97%E7%AC%A6/:6:0","tags":["Python学习之路"],"title":"Python学习之路-运算符","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["Python"],"content":"运算符的优先级 以下表格的算数优先级由高到最低顺序排列 运算符 描述 ** 幂 (最高优先级) * / % // 乘、除、取余数、取整除 + - 加法、减法 \u003c= \u003c \u003e \u003e= 比较运算符 == != 等于运算符 = %= /= //= -= += *= **= 赋值运算符 in not in 成员运算符 not or and 逻辑运算符 ","date":"2019-10-12","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%BF%90%E7%AE%97%E7%AC%A6/:7:0","tags":["Python学习之路"],"title":"Python学习之路-运算符","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["Python"],"content":"简介 Python的设计目标之一是让代码具备高度的可阅读性。在设计时尽量使用经常使用的标点符号和英文单字，让代码看起来整洁美观。 ","date":"2019-10-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%AD%E6%B3%95/:1:0","tags":["Python学习之路"],"title":"Python学习之路-语法","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%AD%E6%B3%95/"},{"categories":["Python"],"content":"缩进 在Python中缩进表示语句块的开始和结束，作用等同于Java、Go中的大括号。增加缩进表示语句块的开始，而减少缩进则表示语句块的结束。缩进成为了语法的一部分，违反了“缩进规则”的程序不能通过解释器解释。 提示 根据PEP 8的规定，使用4个空格来表示每级缩进。使用Tab字符和其它数目的空格虽然都可以被解释器识别，但不符合编码规范，偏向使用Tab字符的程序员可以设置文本编辑器将Tab键转换为4个空格。 ","date":"2019-10-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%AD%E6%B3%95/:2:0","tags":["Python学习之路"],"title":"Python学习之路-语法","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%AD%E6%B3%95/"},{"categories":["Python"],"content":"标识符 标识符就是名字。可用于标识符的字符为：大写字母A至Z和小写字母a至z，下划线_以及数字0至9，但不能以数字开头。不能定义关键字标识符。 有关包含下划线的标识符有以下命名约定： 类型 实例 备注 单下划线开头 _abc 私有化属性或方法。通过from M import *将不能导入。 单下划线结尾 acb_ 避免与python关键字的命名冲突。 双下划线开头 __abc 避免与子类中的属性命名冲突，无法在外部直接访问(名字重整所以访问不到) 双下划线开头双下划线结尾 __abc__ 用户名字空间的魔法对象或属性。例如:__name__ , 不要使用这样的方式命名变量或函数。 ","date":"2019-10-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%AD%E6%B3%95/:3:0","tags":["Python学习之路"],"title":"Python学习之路-语法","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%AD%E6%B3%95/"},{"categories":["Python"],"content":"关键字 关键字是保留标识符，不能用作变量名、函数名或任何其他标识符。Python共有35个关键字。 逻辑运算符 and：只有两边的值都为True才会返回True，否则只要两边有一个值为False，就返回False not：如果值为True，返回False。如果值为False，返回True or：只要两边有一个值为True，就返回True。只有两边的值都为False，才会返回False 协程 async：将普通函数和生成器函数包装成异步函数和异步生成器。 await：挂起自身的协程，并等待另一个协程完成直到返回结果(只能出现在通过async修饰的函数中，否则会报SyntaxError错误) 布尔值 False：不成立则为False，等同于0 True：成立则为True，等同于1 循环 break：跳出当前循环 continue：继续循环的下一个迭代 for：创建for循环 while：创建while循环 in：for循环迭代序列或者检查序列中是否存在值 类与函数 class：定义一个类 def：定义一个函数 lambda：创建匿名函数 return：退出函数并返回值 yield：结束函数并返回生成器 条件语句 assert：测试代码中的条件是否返回True，否则程序将引发AssertionError elif：等同于else if else：在条件为False时执行else下的代码块 if：创建条件语句，并且仅当条件为True时，才允许执行代码块。 异常 except：在try ... except块中使用了关键字 except。它定义 try 块引发错误时要运行的代码块。 finally：在try ... except块中使用。它定义的代码块，在try...except...else块结束时运行，无论try块是否引发错误，都将执行 finally 块。 raise：抛出异常。 with： 作用和使用try/finally语句一样，帮助我们简化异常处理。通常用于文件相关处理。 try：用于try...except块中，它定义了代码测试块是否包含任何错误。 模块 from：从模块中仅导入指定的部分 import：导入模块 as：给模块创建别名 变量 global：声明全局变量 is：判断两个变量是否相等 nonlocal：声明非局部变量 其他 del：删除对象 None：表示null值 pass：null语句(什么都不做的语句) 提示 刚开始接触关键字不用详细了解具体含义，先记住这些关键字不要让标识符取成关键字，后面慢慢接触到这些关键字的时候边了解边使用就可以 ","date":"2019-10-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%AD%E6%B3%95/:4:0","tags":["Python学习之路"],"title":"Python学习之路-语法","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%AD%E6%B3%95/"},{"categories":["Python"],"content":"控制流和语句 ","date":"2019-10-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%AD%E6%B3%95/:5:0","tags":["Python学习之路"],"title":"Python学习之路-语法","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%AD%E6%B3%95/"},{"categories":["Python"],"content":"控制流 在程序开发中，存在三种控制流： 顺序结构：从上到下顺序执行代码 分支结构：根据条件判断决定执行代码的分支 循环结构：让特定代码重复执行 根据控制流衍生出了各类语句 ","date":"2019-10-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%AD%E6%B3%95/:5:1","tags":["Python学习之路"],"title":"Python学习之路-语法","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%AD%E6%B3%95/"},{"categories":["Python"],"content":"赋值 等号=为赋值语句，支持同时给多个变量赋值，还可以通过赋值语句改变多个变量的值。 ","date":"2019-10-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%AD%E6%B3%95/:5:2","tags":["Python学习之路"],"title":"Python学习之路-语法","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%AD%E6%B3%95/"},{"categories":["Python"],"content":"判断 简介 又称为分支语句。当条件成立时做某件时间，不成立时做另一件事或者什么都不做。 用法 Python中的判断语句格式为： if 条件1: 满足条件1的代码块 elif 条件2: 满足条件2的代码块 else: 其他情况的代码块 通过if来发起判断语句，当if条件成立时执行if下的代码块，条件不成立时执行else下的代码块。当存在多个条件时可以通过elif来分隔各个条件，执行不同条件下的代码块。 ","date":"2019-10-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%AD%E6%B3%95/:5:3","tags":["Python学习之路"],"title":"Python学习之路-语法","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%AD%E6%B3%95/"},{"categories":["Python"],"content":"循环 简介 while循环是让指定代码按照条件指定执行次数 用法 Python中的判断语句格式为： while 条件(判断计数器是否达到目标次数): 满足条件代码块 ...... 处理条件(计数器+1) 技巧 Python计数从0开始 警告 Python计数从0开始 在使用while时要注意死循环的问题，由于某些原因，忘记在循环内部修改循环的判断条件，导致循环持续执行，程序无法终止！ 结束循环 可以通过break或者continue来结束当前循环。 break：某一条件满足时退出循环 continue：某一条件满足时不执行当前循环，进行下一次循环 ","date":"2019-10-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%AD%E6%B3%95/:5:4","tags":["Python学习之路"],"title":"Python学习之路-语法","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%AD%E6%B3%95/"},{"categories":["Python"],"content":"将注释放在Python语法前面足以提现它的重要性。 ","date":"2019-09-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%B3%A8%E9%87%8A/:0:0","tags":["Python学习之路"],"title":"Python学习之路-注释","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%B3%A8%E9%87%8A/"},{"categories":["Python"],"content":"注释的作用 一个好的程序中注释是不可缺失的一环。在程序中对某些代码进行标注说明，可以增强程序的可读性。在团队协同开发中，良好的注释可以提高开发效率。 ","date":"2019-09-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%B3%A8%E9%87%8A/:1:0","tags":["Python学习之路"],"title":"Python学习之路-注释","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%B3%A8%E9%87%8A/"},{"categories":["Python"],"content":"什么时候需要使用注释？ 注释不是越多越好，对于一目了然的代码，不需要添加注释 对于 复杂的操作，应该在操作开始前写上思路的注释 对于 不是一目了然的代码，应在其行尾添加注释(为了提高可读性，注释应该至少离开代码 2 个空格) 绝不要描述代码，假设阅读代码的人比你更懂 Python，他只是不知道你的代码要做什么 提示 在一些正规的开发团队，通常会有 代码审核 的惯例一个团队中彼此阅读对方的代码 ","date":"2019-09-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%B3%A8%E9%87%8A/:2:0","tags":["Python学习之路"],"title":"Python学习之路-注释","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%B3%A8%E9%87%8A/"},{"categories":["Python"],"content":"注释类型 ","date":"2019-09-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%B3%A8%E9%87%8A/:3:0","tags":["Python学习之路"],"title":"Python学习之路-注释","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%B3%A8%E9%87%8A/"},{"categories":["Python"],"content":"单行注释 以 # 开头，# 右边的所有东西都被当做说明文字，而不是真正要执行的程序，只起到辅助说明作用 提示 *为了保证代码的可读性，*# 后面建议先添加一个空格，然后再编写相应的说明文字。需要注意的是，为了保证代码的可读性，注释和代码之间 至少要有 两个空格 ","date":"2019-09-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%B3%A8%E9%87%8A/:3:1","tags":["Python学习之路"],"title":"Python学习之路-注释","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%B3%A8%E9%87%8A/"},{"categories":["Python"],"content":"多行注释 如果要写的注释信息很多，一行无法写完，就可以使用多行注释。在Python程序中使用多行注释，可以用一对连续的三个引号(单引号和双引号都可以)。 ","date":"2019-09-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%B3%A8%E9%87%8A/:3:2","tags":["Python学习之路"],"title":"Python学习之路-注释","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%B3%A8%E9%87%8A/"},{"categories":["Python"],"content":"文档 Python有一种独一无二的的注释方式: 使用文档注释。文档注释是包、模块、 类或函数里的第一个语句。这些注释可以通过对象的__doc__成员被自动提取, 并且被pydoc所用.对文档注释的惯例是使用三重双引号”\"\"( PEP-257 )。一个文档注释应该这样组织: 首先是一行以句号，问号或惊叹号结尾的概述(或者该文档注释单纯只有一行)。接着是一个空行，接着是文档注释剩下的部分，它应该与文档注释的第一行的第一个引号对齐。 ","date":"2019-09-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%B3%A8%E9%87%8A/:3:3","tags":["Python学习之路"],"title":"Python学习之路-注释","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%B3%A8%E9%87%8A/"},{"categories":["Python"],"content":"模块 每个文件应该包含一个许可样板. 根据项目使用的许可(例如, Apache 2.0, BSD, LGPL, GPL), 选择合适的样板. ","date":"2019-09-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%B3%A8%E9%87%8A/:3:4","tags":["Python学习之路"],"title":"Python学习之路-注释","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%B3%A8%E9%87%8A/"},{"categories":["Python"],"content":"函数和方法 下文所指的函数,包括函数、方法以及生成器。一个函数必须要有文档字符串, 除非它满足以下条件: 外部不可见 非常短小 简单明了 注释应该包含函数做什么，以及输入和输出的详细描述。通常不应该描述”怎么做”，除非是一些复杂的算法.。注释应该提供足够的信息，当别人编写代码调用该函数时，他不需要看一行代码，只要看文档字符串就可以了。 对于复杂的代码, 在代码旁边加注释会比使用函数注释更有意义. 关于函数的几个方面应该在特定的小节中进行描述记录，这几个方面如下文所述.。每节应该以一个标题行开始，标题行以冒号结尾， 除标题行外。节的其他内容应被缩进2个空格。 Args：列出每个参数的名字, 并在名字后使用一个冒号和一个空格。分隔对该参数的描述，如果描述太长超过了单行80字符，使用2或者4个空格的悬挂缩进(与文件其他部分保持一致)。描述应该包括所需的类型和含义。 如果一个函数接受foo(可变长度参数列表)或者**bar (任意关键字参数), 应该详细列出foo和**bar. Returns(或者 Yields: 用于生成器)： 描述返回值的类型和语义。如果函数返回None，这一部分可以省略。 Raises：列出与接口有关的所有异常。 ","date":"2019-09-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%B3%A8%E9%87%8A/:3:5","tags":["Python学习之路"],"title":"Python学习之路-注释","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%B3%A8%E9%87%8A/"},{"categories":["Python"],"content":"类 类应该在其定义下有一个用于描述该类的文档字符串. 如果你的类有公共属性(Attributes), 那么文档中应该有一个属性(Attributes)段. 并且应该遵守和函数参数相同的格式. 参考 Python风格规范-注释 ","date":"2019-09-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%B3%A8%E9%87%8A/:3:6","tags":["Python学习之路"],"title":"Python学习之路-注释","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%B3%A8%E9%87%8A/"},{"categories":["Python"],"content":"设计哲学 Python的设计哲学是“优雅”、“明确”、“简单”。它的重要准则被称为“Python之禅”。Python之禅又名PEP 20，在Python解释器内运行import this可以获得完整的列表，下面是我的翻译与解读： 提姆·彼得斯（Tim Peters）撰写的《 Python之禅 》 优雅胜于丑陋（以编写优雅的代码为目标） 明确胜于晦涩（明确的代码增强了程序的可读性） 简单胜于复杂（简单的代码能解决复杂的问题） 复杂胜于凌乱（如果项目变得复杂，那代码间也要保持简洁） 扁平胜于嵌套（优雅的代码应该是扁平的，不能有太多嵌套） 间隔胜于紧凑（优雅的代码应当有适当的间隔，不要写一些为了缩减代码丢失了可读性） 可读性很重要（代码的可读的非常重要） 即便假借特例的实用性之名，也不可违背这些规则（这些规则是写Python程序的必备条件） 不要包容所有错误，除非你确定需要这样做（代码中不能存在错误，要善于使用捕获异常） 当存在多种可能，不要尝试去猜测 而是尽量找一种，最好是唯一一种明显的解决方案 虽然这并不容易，因为你不是 Python 之父（虽然你不是Guido，在设计程序时应该多思考，找出最好的解决方案） 做也许好过不做，但不假思索就动手还不如不做（要思考好之后再开始写代码） 如果你无法向人描述你的方案，那肯定不是一个好方案；反之亦然（好的方案是人人都能懂得方案） 命名空间是一种绝妙的理念，我们应当多加利用（要善于利用命令空间） Python开发的哲学是“用一种方法，最好是只有一种方法来做一件事”。在设计Python程序时，如果面临多种选择，一般会拒绝花俏的语法，而选择明确没有或者很少有歧义的语法。 ","date":"2019-09-21","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC/:1:0","tags":["Python学习之路"],"title":"Python学习之路-编码风格","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC/"},{"categories":["Python"],"content":"编码规范 PEP 8是由Guido van Rossum , Barry Warsaw , Nick Coghlan三位共同编写的一个Python代码风格规范。可以在这里查看具体内容，如果英文不好可以在Python风格指南中查看主要的内容 ","date":"2019-09-21","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC/:2:0","tags":["Python学习之路"],"title":"Python学习之路-编码风格","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC/"},{"categories":["Python"],"content":"检查工具 pylint是一个Python代码风格的检查工具, 它依据的标准是Guido van Rossum的PEP 8。 pylint类似于PyChecker, 但提供了更多的功能, 如检查代码行的长度, 检查变量命名是否符合编码规范, 或检查声明的接口是否被真正的实现, 完整的检查功能请参见http://www.logilab.org/card/pylintfeatures。 pylint的最大优势在于其高度的可配置化和可定制化，你可以很容易地写一个小插件添加个人功能。 ","date":"2019-09-21","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC/:2:1","tags":["Python学习之路"],"title":"Python学习之路-编码风格","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC/"},{"categories":["Python"],"content":"用法示例 pylint.bat --reports=n --include-ids=y --disable-msg=W0122,W0702 xlsconverter.py \u003e lint_result.txt 其中： –reports=n 表示不产生输出报告 –include-ids=y 表示输出的错误信息包含错误编号 –disable-msg=W0122,W0702 表示W0122和W0702这两个警告信息被过滤掉了 xlsconverter.py 是被检查的脚本 检查的结果被输出到了lint_result.txt中。 提示 任何语言的程序员，编写出符合规范的代码，是开始程序生涯的第一步。PEP 20和PEP 8陪伴我们整个学习和使用Python的过程。 ","date":"2019-09-21","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC/:2:2","tags":["Python学习之路"],"title":"Python学习之路-编码风格","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC/"},{"categories":["Python"],"content":"Python解释器 ","date":"2019-09-14","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellopython/:1:0","tags":["Python学习之路"],"title":"Python学习之路-HelloPython","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellopython/"},{"categories":["Python"],"content":"简介 前面说到Python是解释型语言，Python解释器的作用就是用于\"翻译\"Python程序。Python规定了一个Python语法规则，根据该规则可编写Python解释器。 ","date":"2019-09-14","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellopython/:1:1","tags":["Python学习之路"],"title":"Python学习之路-HelloPython","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellopython/"},{"categories":["Python"],"content":"常见的Python解释器 CPython：官方提供的解释器，由C语言实现，这是最常用的Python解释器。 PyPy：一种用Python语言实现的解释器，可用于替代CPython。PyPy采用即时编译通常运行速度比CPython快很多。多数Python代码可以很好的运行在PyPy之上，除非代码依赖于CPython扩展， Jython:一种用Java语言实现的解释器，Jython可以直接调用Java的各种函数库。 ","date":"2019-09-14","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellopython/:1:2","tags":["Python学习之路"],"title":"Python学习之路-HelloPython","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellopython/"},{"categories":["Python"],"content":"安装 Python是一门跨平台的脚本语言，不同平台的安装过程稍有区别。 注意 以下安装部分内容仅针对CPython。内容参考Python官方的安装教程，由我摘选出来各平台比较方便快捷的安装方式。如果不符合需求，可以查看官方安装教程搜索需要的内容。 ","date":"2019-09-14","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellopython/:2:0","tags":["Python学习之路"],"title":"Python学习之路-HelloPython","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellopython/"},{"categories":["Python"],"content":"Linux Python预装在大多数Linux发行版上，并作为一个包提供给所有其他用户。 也可以从源代码编译最新版本的Python。 如果Python没有预先安装并且不在发行版提供的库中，也可以轻松地为自己使用的发行版创建包。 参阅以下链接： Debian、OpenSuse、Fedora、Slackware 从源代码编译 首先要做的是获取 source 。您可以下载最新版本的源代码，也可以直接提取最新的 clone 。 构建过程由常用命令组成： ./configure make make install 提示 特定Unix平台的配置选项和注意事项通常记录在Python源代码的根目录下的 README.rst 文件中。 警告 make install 可以覆盖或伪装 python3 二进制文件。因此，建议使用 make altinstall 而不是 make install ，因为后者只安装了 *exec_prefix*/bin/python*version* 。 ","date":"2019-09-14","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellopython/:2:1","tags":["Python学习之路"],"title":"Python学习之路-HelloPython","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellopython/"},{"categories":["Python"],"content":"Windows 从Python官方获取安装包 根据需求进行安装包安装 安装完毕后将Python解释器的路径添加到系统环境变量中 提示 √上Add Python 3.x to PATH后安装程序会自动将PythonPython解释器的路径添加到系统环境变量中) ","date":"2019-09-14","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellopython/:2:2","tags":["Python学习之路"],"title":"Python学习之路-HelloPython","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellopython/"},{"categories":["Python"],"content":"Mac OS X 通过Homebrew安装 提示 使用brew install python3默认安装最新版本，可以通过安装pyenv后安装指定版本的Python。根据需求自行选择 安装pyenv brew install pyenv 将pyenv添加到shell中 echo -e 'if which pyenv \u003e /dev/null; then eval \"$(pyenv init -)\"; fi'\u003e\u003e ~/.bash_profile 使shell生效 exec \"$SHELL\" 查看可安装的Python版本 pyenv install -l 安装需求的Python版本 pyenv install 3.7.1 指定全局的Python环境 pyenv global 3.7.1 查看已安装的Python版本和正在使用的Python版本 pyenv versions ","date":"2019-09-14","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellopython/:2:3","tags":["Python学习之路"],"title":"Python学习之路-HelloPython","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellopython/"},{"categories":["Python"],"content":"检查 安装完毕之后可以通过查看Python版本号的方式来检查是否安装成功 python3 -V Python 3.7.7 或者进入Python交互式命令行中查看，在交互式命令行输入python3能进入交互式命令行并且版本对则安装成功 ","date":"2019-09-14","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellopython/:2:4","tags":["Python学习之路"],"title":"Python学习之路-HelloPython","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellopython/"},{"categories":["Python"],"content":"执行程序的方式 ","date":"2019-09-14","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellopython/:3:0","tags":["Python学习之路"],"title":"Python学习之路-HelloPython","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellopython/"},{"categories":["Python"],"content":"交互式命令行 简介 在控制台输入Python3即可进入Python3解释器集成的一个交互式命令行，可以在交互式命令行中执行程序。 python3 Python 3.7.1 (default, Oct. 20, 2018, 15:43:33) [Clang 11.0.0 (clang-1100.0.33.17)] on darwin Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. \u003e\u003e\u003e 这里我们可以看到Python的版本、当前版本发布的时间和查询相关信息的指令，例如输入help()可以查询到帮助相关的信息。 使用 在交互式命令行中写入print('Hello Python!')按回车 \u003e\u003e\u003e print(\"Hello Python!\") Hello Python! 这里使用了Python一个内置的print()方法，其作用是将传入的对象在控制台打印出来。就这么简单的完成了学习Python的第一个程序，可以看到Python的语法非常简单易懂。 提示 通过quit()方法退出Python的交互式命令行。 ","date":"2019-09-14","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellopython/:3:1","tags":["Python学习之路"],"title":"Python学习之路-HelloPython","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellopython/"},{"categories":["Python"],"content":"通过Python解释器 简介 由于在交互式命令行中编写的Python代码无法保存，当需要保存代码的时候可以用文本编辑器或集成开发环境来编写Python代码。这时候就可以用Python解释器来执行Python程序。 文本编辑器是计算机软件中的一种。主要用于用来编写和查看文本文件。有一些特殊的文本编辑器支持增加自有的格式来丰富文档的表现形式。操作系统或者集成开发环境通常会带有可以查看和编辑纯文本的编辑器，可增加格式的文本编辑器通常是个人用户或者公司在制作需要格式的文件中使用。因为程序和程序的配置文件通常是以纯文本形式储存，所以程序员也需要使用纯文本编辑器来编辑程序和配置文件。 集成开发环境（Integrated Development Environment，简称IDE）是一种辅助程序开发人员开发软件的应用软件，在开发工具内部就可以辅助编写源代码文本、并编译打包成为可用的程序，有些甚至可以设计图形接口。IDE通常包括编程语言编辑器、自动构建工具、通常还包括调试器。 在初学阶段建议用文本编辑器来进行开发，更有利于掌握Python基础相关知识。 使用 首先打开一个文本编辑器(系统自带的即可)，写入print(\"Hello Python!\") 注意 这句话一定要顶格写，Python对缩进的要求非常严格。注意print方法名的小写和中英文字符问题！ 将文本保存为Hello.py在控制台中切换到当前目录，输入python3 Hello.py来运行该程序 python3 Hello.py Hello Python! 看到Hello Python!则第一个程序执行成功。 说明 Python程序以.py结尾。控制台中输入的python3为指定的Python解释器 ","date":"2019-09-14","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellopython/:3:2","tags":["Python学习之路"],"title":"Python学习之路-HelloPython","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellopython/"},{"categories":["Python"],"content":"本篇文章由我归纳总结而来，为想要了解学习Python的朋友提供参考。大部分内容参考维基百科 ","date":"2019-09-07","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/:0:0","tags":["Python学习之路"],"title":"Python学习之路-认识Python","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/"},{"categories":["Python"],"content":"简介 Python是一种广泛使用的解释型、高级和通用的编程语言。Python支持多种编程范型，包括函数式、指令式、结构化、面向对象和反射式编程。它拥有动态类型系统和垃圾回收功能，能够自动管理内存使用，并且其本身拥有一个巨大而广泛的标准库。 Python是一种易于学习又功能强大的编程语言。它提供了高效的高级数据结构，还能简单有效地面向对象编程。Python 优雅的语法和动态类型，以及解释型语言的本质，使它成为多数平台上写脚本和快速开发应用的理想语言。 ","date":"2019-09-07","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/:1:0","tags":["Python学习之路"],"title":"Python学习之路-认识Python","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/"},{"categories":["Python"],"content":"Python的起源 ","date":"2019-09-07","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/:2:0","tags":["Python学习之路"],"title":"Python学习之路-认识Python","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/"},{"categories":["Python"],"content":"诞生 由于吉多·范罗苏姆(Guido van Rossum)参与设计的ABC语言没有成功，他在1989年的圣诞节决定开发一个新的解释型语言作为ABC语言的替代者。在他看来ABC语言的失败的原因是其非开放的，他决心在Python中避免这个错误，后来由于他的开放形成了庞大的Python社区。之所以取名为Python，是因为他非常喜欢BBC电视剧中的蒙提·派森的飞行马戏团（Monty Python’s Flying Circus）。 ","date":"2019-09-07","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/:2:1","tags":["Python学习之路"],"title":"Python学习之路-认识Python","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/"},{"categories":["Python"],"content":"发展 1991年2月第一个Python解释器(标记为版本0.9.0)诞生。这时就已经存在了带继承的类、异常处理、函数和核心数据类型list、dict、str等 1994年1月Python达到了版本1.0。这个发行版主要新特征是包括了函数式编程工具lambda、map、filter和reduce。Python 1.4增加了受Modula-3启发的关键字参数和对复数的内建支持，还包含采取名字修饰的一种基本形式[数据隐藏。 2000年10月16日Python 2.0发布。增加了列表推导式，这是从函数式编程语言SETL和Haskell中引入的。它还向垃圾收集系统增加了环检测算法，并且支持Unicode。Python 2.1支持了嵌套作用域，就像其他静态作用域语言一样。Python 2.2的重大革新是将Python的类型(用C写成)和类(用Python写成)统一入一个层级，使得Python的对象模型成为纯粹和一致的面向对象的模型；还增加了迭代器，受CLU和Icon启发的生成器，和描述器协议。Python 2.4加入了集合数据类型，和函数修饰器。Python 2.5加入了with语句。 Python 3.0于2008年12月3日发布，它对语言做了较大修订而不能完全后向兼容。Python 3发行包括了2to3实用工具，它（至少部分的）自动将Python 2代码转换成Python 3代码。Python 3的很多新特性后来也被移植到旧的Python 2.6/2.7版本中。 Python 2.7的产品寿命结束日期最初设定为2015年，出于对大量的现存代码不能前向移植到Python 3的关切而延期至2020年。随着Python 2的产品寿命结束，只有Python 3.8和后续版本仍被完全支持。 在2020年12月，活跃的Python核心开发者选举Barry Warsaw、Brett Cannon、Carol Willing、Pablo Galindo Salgado和Thomas Wouters为2021年度“掌控委员会”的五位成员来领导这个项目。 ","date":"2019-09-07","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/:2:2","tags":["Python学习之路"],"title":"Python学习之路-认识Python","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/"},{"categories":["Python"],"content":"解释型语言与编译型语言 ","date":"2019-09-07","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/:3:0","tags":["Python学习之路"],"title":"Python学习之路-认识Python","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/"},{"categories":["Python"],"content":"区别 高级语言设计的程序必须经过“翻译”成机器语言以后才能被机器执行。“翻译”的方法有两种，一种是解释，一种是编译。两种方式的区别在于“翻译”时间点不同，解释型语言编写的程序不需要编译，程序在运行时才翻译成机器语言，每执 行一次都要翻译一次。编译型语言编写的程序在执行之前需要进行的编译，把程序编译成机器语言的文件，运行时不需要重新“翻译”，直接使用编译的结果就行了。 ","date":"2019-09-07","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/:3:1","tags":["Python学习之路"],"title":"Python学习之路-认识Python","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/"},{"categories":["Python"],"content":"对比 速度：编译型语言比解释型语言执行速度快 跨平台性：解释型语言比编译型语言跨平台性好 ","date":"2019-09-07","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/:3:2","tags":["Python学习之路"],"title":"Python学习之路-认识Python","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/"},{"categories":["Python"],"content":"特点 ","date":"2019-09-07","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/:4:0","tags":["Python学习之路"],"title":"Python学习之路-认识Python","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/"},{"categories":["Python"],"content":"完全面向对象的语言 在 Python 中一切皆对象 完全支持继承、重载、多重继承 支持重载运算符，也支持泛型设计 ","date":"2019-09-07","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/:4:1","tags":["Python学习之路"],"title":"Python学习之路-认识Python","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/"},{"categories":["Python"],"content":"拥有一个强大的标准库 ​ Python 语言的核心只包含 数字、字符串、列表、字典、文件 等常见类型和函数，而由 Python 标准库提供了 系统管理、网络通信、文本处理、数据库接口、图形系统、XML 处理 等额外的功能 ","date":"2019-09-07","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/:4:2","tags":["Python学习之路"],"title":"Python学习之路-认识Python","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/"},{"categories":["Python"],"content":"Python 社区 ​ 社区提供了数量庞大的第三方模块，使用方式与标准库类似。它们的功能覆盖 科学计算、人工智能、机器学习、Web 开发、数据库接口、图形系统 等多个领域 ","date":"2019-09-07","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/:4:3","tags":["Python学习之路"],"title":"Python学习之路-认识Python","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/"},{"categories":["Python"],"content":"为什么选择Python Life is short, you need Python。 ","date":"2019-09-07","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/:5:0","tags":["Python学习之路"],"title":"Python学习之路-认识Python","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/"},{"categories":["Python"],"content":"参考 提示 以下顺序不分先后 Python维基百科 解释型语言 编译型语言 ","date":"2019-09-07","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/:6:0","tags":["Python学习之路"],"title":"Python学习之路-认识Python","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/"},{"categories":["Python"],"content":"Python学习之路 Python 是一种易于学习又功能强大的编程语言。目前网上有许多Python相关文档，质量参差不齐，更新时间也都非常久远。也没有看到有相关系统全面的文档，所以我想通过我的努力打造一个全面且及时更新的Python教程，在复习的同时也为其他Python爱好者做出贡献。 由于本人能力有限，所以本文档仅适用于想系统的学习Python的朋友。本文档所有文章皆采用 知识共享署名-非商业性使用 4.0 国际许可协议 进行许可，如果发现文档中存在错误，请联系我修正；如果发现文档中存在侵权情况，请联系我删除相关内容。文档欢迎转载，转载请注明出处，感谢您对Python社区的贡献。 通过本文档你能了解到从Python基础到Python标准库、Web开发、爬虫、数据分析、机器学习等方面的内容。由于Python2.7已于2020年1月1日起停止维护，本文档中的内容全部针对Python3.X版本。 Life is short, you need Python。接下来就让我们开始遨游在Python的世界中吧！ ","date":"2019-09-01","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%96%87%E6%A1%A3%E8%AF%B4%E6%98%8E/:1:0","tags":["Python学习之路"],"title":"Python学习之路-文档说明","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%96%87%E6%A1%A3%E8%AF%B4%E6%98%8E/"},{"categories":["Golang"],"content":"前言 最近对Go语言非常感兴趣，准备花一段时间来学习，此系列文章用于学习笔记整理与学习记录。 ","date":"2019-08-03","objectID":"/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/:1:0","tags":["Go"],"title":"Go语言学习之旅-开篇","uri":"/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/"},{"categories":["Golang"],"content":"简介 Go（又称 Golang）是 Google的 Robert Griesemer，Rob Pike 及 Ken Thompson 开发的一种静态强类型、编译型语言。Go 语言语法与 C相近，但功能上有：内存安全，GC（垃圾回收），结构形态及 CSP-style 并发计算。 ","date":"2019-08-03","objectID":"/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/:2:0","tags":["Go"],"title":"Go语言学习之旅-开篇","uri":"/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/"},{"categories":["Golang"],"content":"学习资料 Go官方提供的教程非常丰富： 官网、中文官网、Go指南 非官方推荐 书籍：Go 简易教程、Go 入门指南、Go 语言设计与实现 导航：Go网站导航 论坛：learnku 教程：Go语言学习之路 ","date":"2019-08-03","objectID":"/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/:3:0","tags":["Go"],"title":"Go语言学习之旅-开篇","uri":"/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/"},{"categories":["Golang"],"content":"安装 Go官方提供了丰富的安装方法，可以根据自己的系统与喜好进行安装 如果官方网站打开比较慢的话也可以通过Go语言中文网提供的包进行安装 警告 安装完毕记得添加环境变量！ ","date":"2019-08-03","objectID":"/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/:4:0","tags":["Go"],"title":"Go语言学习之旅-开篇","uri":"/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/"},{"categories":["Golang"],"content":"学习计划 基础：预计两周时间 ","date":"2019-08-03","objectID":"/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/:4:1","tags":["Go"],"title":"Go语言学习之旅-开篇","uri":"/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/"},{"categories":["爬虫"],"content":"Python爬虫实战之bilibili","date":"2019-07-20","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/","tags":["爬虫"],"title":"Python爬虫实战之bilibili","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/"},{"categories":["爬虫"],"content":"声明：以下内容均为我个人的理解，如果发现错误或者疑问可以联系我共同探讨 ","date":"2019-07-20","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/:0:0","tags":["爬虫"],"title":"Python爬虫实战之bilibili","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/"},{"categories":["爬虫"],"content":"爬虫介绍 ","date":"2019-07-20","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/:1:0","tags":["爬虫"],"title":"Python爬虫实战之bilibili","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/"},{"categories":["爬虫"],"content":"网站介绍 本次要爬取的网站为bilibili，它是国内知名的视频弹幕网站,这里有及时的动漫新番,活跃的ACG氛围,有创意的Up主。可以在这里找到许多欢乐。 ","date":"2019-07-20","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/:1:1","tags":["爬虫"],"title":"Python爬虫实战之bilibili","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/"},{"categories":["爬虫"],"content":"编写爬虫的原因和用途 bilibili已经从原来的小破站变成了现在现象级的多元化的社区网站，本次爬取它的目的是以它作为一个典型，告诉大家遇到各类型验证码的一种思路。 其实这类网站有个最简单的办法，就是提前登陆手动获取到cookie，然后根据cookie去请求我们需要爬取的网站。个人目的的爬虫可以用这类方法，比较省编写代码的时间。但是公司中可能会遇到众多账户的爬虫需求，一个一个手动登录去获取cookie就比较麻烦了，这时候使用Selenium自动化去获取效率就高很多了。 ","date":"2019-07-20","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/:1:2","tags":["爬虫"],"title":"Python爬虫实战之bilibili","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/"},{"categories":["爬虫"],"content":"Selenium ","date":"2019-07-20","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/:2:0","tags":["爬虫"],"title":"Python爬虫实战之bilibili","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/"},{"categories":["爬虫"],"content":"简介 正如他们官方的介绍Selenium automates browsers. That's it!，他是一个自动化的浏览器，可以模拟人的操作。 ","date":"2019-07-20","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/:2:1","tags":["爬虫"],"title":"Python爬虫实战之bilibili","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/"},{"categories":["爬虫"],"content":"使用教程 推荐通过Selenium中文网学习，非常全面！ ","date":"2019-07-20","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/:2:2","tags":["爬虫"],"title":"Python爬虫实战之bilibili","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/"},{"categories":["爬虫"],"content":"验证码分析 ","date":"2019-07-20","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/:3:0","tags":["爬虫"],"title":"Python爬虫实战之bilibili","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/"},{"categories":["爬虫"],"content":"滑动验证码 哔哩哔哩从之前的验证码是滑动验证码，主要思路就是找到缺口确定缺口的坐标，然后通过Selenium操作滑动到指定位置就行。类似的还有阿里系的大部分网页，比如飞猪、淘宝、天猫等，不过阿里系的不是每次都需要验证，得根据实际情况操作。 这种就是找到最右边的位置信息，然后滑动即可 这种需要先找到整个图片的位置，然后滑动先找到内容的轮廓在进行滑动，都是同一个思路演变的 ","date":"2019-07-20","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/:3:1","tags":["爬虫"],"title":"Python爬虫实战之bilibili","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/"},{"categories":["爬虫"],"content":"看图填答案系列 包括东方财富网上交易、bigquant等等，这类比较简单。将其下载下来根据验证码的情况进行处理然后交给各大云服务商的ORC服务识别就可以，都有免费试用的额度，根据自己的需求和喜好选择，也可以多试几家进行对比。 百度、腾讯、阿里、有道智云 ","date":"2019-07-20","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/:3:2","tags":["爬虫"],"title":"Python爬虫实战之bilibili","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/"},{"categories":["爬虫"],"content":"根据图片进行操作点击系列 目前多了很多这种验证码，这种的难度在于情况变化比较多，不仅限于汉字和数字，还有可能是图片等等，这时候自己想办法也能解决，但是策略一改变就比较麻烦，可以借助各类打码的平台，对内容进行识别，然后再根据内容去进行操作 易云打码、快识别网址、斐斐打码等等 ","date":"2019-07-20","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/:3:3","tags":["爬虫"],"title":"Python爬虫实战之bilibili","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/"},{"categories":["爬虫"],"content":"bilibili登陆分析 bilibili的最新的验证码属于第三种，在点击登陆按钮就会出现一个验证码的框,我们需要将这个图片下载下来给打码平台去识别，获得坐标信息然后再用Selenium进行点击操作 ​ bilibili验证码 ","date":"2019-07-20","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/:4:0","tags":["爬虫"],"title":"Python爬虫实战之bilibili","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/"},{"categories":["爬虫"],"content":"编写代码 ","date":"2019-07-20","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/:5:0","tags":["爬虫"],"title":"Python爬虫实战之bilibili","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/"},{"categories":["爬虫"],"content":"Selenium模拟登陆 import re import time import base64 import json import requests from selenium import webdriver from selenium.webdriver import ActionChains from selenium.webdriver.chrome.options import Options class Bilibili(object): def __init__(self): chrome_options = Options() # 设置无窗口模式 # chrome_options.add_argument('--headless') self.driver = webdriver.Chrome('./chromedriver', options=chrome_options) def login(self, username, password): # 开登陆页面 self.driver.get(\"https://passport.bilibili.com/login\") # 输入用户名和密码 self.driver.find_element_by_id('login-username').send_keys(username) self.driver.find_element_by_id('login-passwd').send_keys(password) # 点击登陆按钮 self.driver.find_element_by_class_name('btn-login').click() # 等待验证码出现 # self.driver.implicitly_wait(10) time.sleep(5) # 获取图片所在属性 img_style = self.driver.find_element_by_class_name('geetest_tip_img').get_attribute('style') # 通过正则表达式获得图片url url = re.findall('url\\(\"(.*?)\"\\)', img_style)[0] # 通过requests发送请求得到图片 response = requests.get(url).content # 将图片保存在本地 with open('./captcha.png', 'wb') as f: f.write(response) # 通过打码平台进行打码识别 result = self.captcha_recognition() # 识别成功 if result != \"\": # 对识别到的坐标进行分组处理 result_list = result.split('|') for result in result_list: x = result.split(',')[0] y = result.split(',')[1] # 根据坐标执行整个动作链 ActionChains(self.driver).move_to_element_with_offset(img_style, int(x), int(y)).click().perform() # 点击确定按钮 self.driver.find_element_by_class_name('geetest_commit').click() # 获得登陆后的cookie cookie = [item[\"name\"] + \"=\" + item[\"value\"] for item in self.driver.get_cookies()] self.driver.close() return cookie def captcha_recognition(self): \"\"\"验证码识别\"\"\" username = 'username' password = 'password' with open('./captcha.png', 'rb') as f: base64_data = base64.b64encode(f.read()) b64 = base64_data.decode() data = {\"username\": username, \"password\": password, \"typeid\": 27, \"image\": b64} result = json.loads(requests.post(\"http://api.ttshitu.com/predict\", json=data).text) if result['success']: return result[\"data\"][\"result\"] else: print(result[\"message\"]) return \"\" ","date":"2019-07-20","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/:5:1","tags":["爬虫"],"title":"Python爬虫实战之bilibili","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/"},{"categories":["爬虫"],"content":"Python爬虫实战之萝卜投研","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"声明：以下内容均为我个人的理解，如果发现错误或者疑问可以联系我共同探讨 ","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:0:0","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"爬虫介绍 ","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:1:0","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"网站介绍 本次要爬取的网站为*萝卜投研*，是利用人工智能、大数据、移动应用技术,建立的股票基本面分析智能投研平台，在进行投资交易的时候可以使用期研报与各类数据进行分析。 ","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:1:1","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"编写爬虫的原因和用途 本人闲暇时间会学习投资理财相关内容，萝卜投研可以获取许多财经类的信息与很多研报，本次想通过编写爬虫完成对目标数据完成持久化存储与相关舆情完成程序提醒的目标，由于网站内容十分丰富，一次很难将其全部爬取完毕，本次想通过Scrapy获取首页的投研信息，并完成翻页的目标，后期还会持续更新，尝试将整个网站都爬下来。（仅供个人研究使用） ","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:1:2","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"Scrapy ","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:2:0","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"简介 Scrapy是一个为了爬取网站数据，提取结构性数据编写的爬虫框架，只需要很少的代码就可以完成相关数据的抓取。 Scrapy是一个使用了Twisted的异步网络框架，可以大大提高我们的下载速度。 ","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:2:1","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"使用教程 Scrapy的相关使用教程可以通过官方文档来进行初步入门，了解各模块在框架中的作用，官方文档非常强大，建议先进行系统性的学习之后再开始使用。 学习Scrapy最重要的就是理解Scrapy的工作流程，跟着官方文档的例子去详细分析每一步的操作，与之前编写爬虫的流程相关性与区别。 ","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:2:2","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"抓包工具 ","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:3:0","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"什么是抓包工具 抓包工具是拦截查看网络数据包内容的软件。通过对抓获的数据包进行分析，可以得到有用的信息。 ","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:3:1","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"为什么要用 较为复杂的网站在进行爬取数据分析的时候使用浏览器中的调试工具会比较麻烦，这时候就可以用抓包工具去分析对应的请求，从而更快发现我们需要的数据所在的URL和整个请求的过程 ","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:3:2","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"使用与抓包工具的推荐 抓包工具的使用推荐学习朱安邦的博客中的教程，他讲了三个：Charles、Fiddler、wireshark，这些抓包工具功能各异，但基本原理相同，找一个顺手的学习基本上已经足够了。 ","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:3:3","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"业务逻辑分析 ","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:4:0","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"寻找加载数据的URL 通过对整个首页加载的流程进行抓包与分析，发现首页数据的URL为https://gw.datayes.com/rrp_mammon/web/feed/list，下一页的URL为：https://gw.datayes.com/rrp_mammon/web/feed/list?timeStamp=20210401170127\u0026feedIds=66233,66148， ","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:4:1","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"翻页参数解析 通过观察URL发现timeStamp和feedIds是两个控制翻页的参数，进一步多页进行请求发现20210401170127可以理解为一个时间节点，看到20200228猜测是本次刷新的时间，猜测后6位是当前时间的秒的时间戳，组织一下可以写成''.join(str(datetime.now())[:10].split('-'))+str(time.clock( )).split('.')[1] 再进行多页的数据获取后发现feedIds参数中的前四个是第一个响应中前四个数据的id，最后一个数为响应中最后一个数据的id，并且会随着访问变多而增加，每次新增的都是最后一个数据的id，将下一页的URL拼接起来,进行访问发现请求不到下一页的数据。通过复制原来的timeStamp发现可以访问，问题就出现在前面timeStamp的参数，刚刚再进行feedIds字段拼接的时候发现有三个字段是日期形式的，分别为：\"insertTime\"、updateTime、publishTime，进一步分析发现将其后面三个0去掉就是一个时间戳，对其转换发现就是我们需要的结果 ","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:4:2","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"模拟请求测试 ","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:5:0","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"scrapy shell scrapy shell可以帮助我们模拟请求地址，并进入一个交互式终端，在交互式终端中我们可以查看请求的各类信息，并进行调试。但scrapy shell也有缺陷，不能解析response的格式，看起来比较乱等，这时候可以通过结合Postman来协同调试。 ","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:5:1","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"Postman 简介 Postman是一种网页调试与发送网页http请求的chrome插件。我们可以用来很方便的模拟各种类型的请求来调试 接口。在爬虫中可以用于验证我们的思路。 使用与汉化 Postman官方的使用教程非常详细，可以跟着官方的使用教程中学习，如果想使用中文的版本可以在Postman汉化中下载。 实际使用 通过Postman发送请求，可以得到我们想要的数据，并且可以得到格式化后的数据，看起来条理更加清晰，再配合scrapy shell调试可以很容易就获得我们需要的数据 ","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:5:2","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"编写爬虫 ","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:6:0","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"创建爬虫项目 scrapy startproject datayes ","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:6:1","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"robots协议 在settings.py中可以通过设置ROBOTSTXT_OBEY = True遵守robots.txt 的规则。 ","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:6:2","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"创建爬虫 scrapy genspider mammon gw.datayes.com ","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:6:3","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"修改start_urls 默认的start_urls不是我们要爬取的链接，修改为我们需求的链接 start_urls = ['https://gw.datayes.com/rrp_mammon/web/feed/list'] ","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:6:4","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"完成parse方法 根据之前分析的结果设计方案完成parse，这次难度主要在于如何拼接next_url，由于feedIds参数存在着累加的关系所以将其放在了parse函数外让其可以再访问的时候累加处理。 class MammonSpider(scrapy.Spider): name = 'mammon' allowed_domains = ['gw.datayes.com'] start_urls = ['https://gw.datayes.com/rrp_mammon/web/feed/list'] # 构建一个基础next_url next_url = 'https://gw.datayes.com/rrp_mammon/web/feed/list?timeStamp=' # 构建一个基础feedIds feedIds = '\u0026feedIds=' def parse(self, response): # 将获取到的数据通过json转成字典的形式 result = json.loads(response.text) # 当访问成功时进行数据获取 if result['message'] == 'success': data_list = result['data']['list'] for data in data_list: item = {} detail_id = data['id'] # id # 通过详情页id构造详情页url并访问 detail_url = 'https://gw.datayes.com/rrp_mammon/web/feed?id=' + str(detail_id) yield scrapy.Request(detail_url, callback=self.detail_parse, meta={'item': item}) item['title'] = data['title'] # 标题 item['publish_time'] = int(data['publishTime'] / 1000) # 发布时间 item['author'] = data['roboColumn']['name'] # 作者 item['Avatar'] = data['roboColumn']['logo'] # 头像 related_list = data['related'] item['related_stocks'] = [] # 相关股票列表 for stocks in related_list: item['related_stocks'].append(stocks['targetName']) # 寻找出url的第0，1，2，3位置的id，加入feedIds if response.request.url == 'https://gw.datayes.com/rrp_mammon/web/feed/list' and data_list.index(data) in [0, 1, 2, 3]: self.feedIds = self.feedIds + str(detail_id) + ',' # 构建timeStamp参数 timeStamp = time.strftime(\"%Y%m%d%H%M%S\", time.localtime(item['publish_time'])) # 拼接feedIds参数 self.feedIds = self.feedIds + str(detail_id) + ',' # 组合next_url next_url = self.next_url + timeStamp + self.feedIds # 请求下一页 yield scrapy.Request(next_url, callback=self.parse) def detail_parse(self, response): result = json.loads(response.text) if result['message'] == 'success': item = response.meta['item'] item['content'] = result['data']['longDocContent'] yield item 通过爬虫观察到两日的cookie发生了变化，只有登录之后会保持cookie，并对cookie中的参数进行检测，找到cloud-sso-token为必要参数，并将其添加在settings.py中。 ","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:6:5","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"完成数据存储 先在settings.py中配置pipeline，和数据库相关参数 # Configure item pipelines # See https://docs.scrapy.org/en/latest/topics/item-pipeline.html ITEM_PIPELINES = { 'datayes.pipelines.DatayesPipeline': 300, } # MySQL相关配置 HOST = 'HOST', # 数据库地址 PORT = 3306, # 数据库端口 DB = 'DB', # 数据库名 USER = 'USER', # 数据库用户名 PASSWORD = 'PASSWORD', # 数据库密码 在我们定义的DatayesPipeline类中添加open_spider和close_spider方法，通过spider.settings来导入数据库相关参数 import pymysql class DatayesPipeline: # 爬虫开始时执行，只执行一次 def open_spider(self, spider): # 通过pymysql链接MySQL数据库 self.connect = pymysql.connect( host=spider.settings.HOST, # 数据库地址 port=spider.settings.PORT, # 数据库端口 db=spider.settings.DB, # 数据库名 user=spider.settings.USER, # 数据库用户名 passwd=spider.settings.PASSWORD, # 数据库密码 charset='utf8', # 编码方式 use_unicode=True) # 通过cursor执行增删查改 self.cursor = self.connect.cursor() # 爬虫结束时执行，只执行一次 def close_spider(self, spider): self.connect.close() def process_item(self, item, spider): self.cursor.execute( \"\"\"insert into mammon (title, publish_time,author,avatar,related_stocks,content)value (%s, %s,%s, %s,%s, %s)\"\"\", (item['title'], item['publish_time'], item['author'], item['avatar'], item['related_stocks'], item['content'])) # 提交sql语句 self.connect.commit() return item 最后创建数据库，开启爬虫进行数据爬取。 ","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:6:6","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"Python爬虫实战之叩富网","date":"2019-06-22","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"声明：以下内容均为我个人的理解，如果发现错误或者疑问可以联系我共同探讨 ","date":"2019-06-22","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:0:0","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"爬虫介绍 爬虫是一种按照一定规则自动抓取网络上的信息数据的程序。我们身处一个大数据的时代，可以通过爬虫获取到我们所需要的数据(遵从robots协议中的规则)。 ","date":"2019-06-22","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:1:0","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"网站介绍 叩富网是江西博辰网络科技公司旗下的一个专业网站。模拟炒股网站初建于2000年，2006年被博辰网络收购，并开始规范系统的运作。目前用户100多万，日均IP数10万左右。是国内唯一一家专业致力于模拟炒股开发和运营的网站。公司旗下有有奖大赛站、免费大赛站以及和其他证券公司合作的网站。 ","date":"2019-06-22","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:1:1","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"编写爬虫的原因和用途 本人闲暇时间会学习投资理财相关内容，并通过叩富网进行模拟炒股，本次想通过编写爬虫来程序化自己的模拟交易 ","date":"2019-06-22","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:1:2","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"robots协议 ","date":"2019-06-22","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:2:0","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"什么是robots协议 robots协议以robots.txt文件形式呈现，是网站中给各类爬虫规定爬取范围的文件，robots.txt存放在网站的根目录下。我们准备爬取某个网站时，首先应该查看我们需要的数据该网站是否允许我们爬取，当我们爬取规则之外的数据时，该网站有权利起诉我们非法获取数据。 ","date":"2019-06-22","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:2:1","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"robots协议的构成 由User-agent、Allow、Disallow构成。User-agent后面的内容是具体的爬虫名，如百度爬虫为Baiduspider，则代表所有爬虫。Allow后面的内容是允许爬取的URL路径，如/.jpg$表示可以爬取该网站下的所有.jpg图片，/表示所有路径均允许爬取。Disallow后面的内容是不允许爬取的URL路径，同Allow相反。 ","date":"2019-06-22","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:2:2","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"常见的规则有哪些 允许爬虫获取所有内容： User-agent: * Disallow: # 或者 User-agent: * Allow: / 禁止爬取所有内容： User-agent: * Disallow: / 禁止访问网站中所有动态页面 User-agent: * Disallow: /*?* 禁止搜索引擎抓取网站上所有图片 User-agent: * Disallow: /*.jpg$ Disallow: /*.jpeg$ Disallow: /*.gif$ Disallow: /*.png$ Disallow: /*.bmp$ ","date":"2019-06-22","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:2:3","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"Feeling 爬虫可以使我们更加高效的获取到互联网中的各类数据，但网络不是法外之地我们也要在合规合法的基础上进行爬取，尊重每一个网站开发者，敬畏法律。 ","date":"2019-06-22","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:2:4","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"requests requests库是学习爬虫入门最适合的一个第三方库，它是将Python内置的urllib进行深度封装的库。是一个非常成熟的HTTP客户端库，当然他也并非完美，我们后期也可以在其基础上进行补充形成适合自己的一个库。 ","date":"2019-06-22","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:3:0","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"快速上手 中文文档：https://docs.python-requests.org/zh_CN/latest/index.html 官方示例：https://docs.python-requests.org/zh_CN/latest/user/quickstart.html ","date":"2019-06-22","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:3:1","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"获取robots协议，查看可爬取范围 使用get请求获取协议内容，并将其输出控制台查看发现规则允许我们爬取整站内容 ","date":"2019-06-22","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:3:2","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"登陆叩富网 在Chrome浏览器中通过开发者选项中的Network选项卡中发现，登陆的时候有一个login.html 我们可以在里面看到请求URL、请求方式和Form Data所需要的内容，根据这个编写一个请求查看一下获取到的数据 由于是字符串格式，所以出现了我们看不懂的字符，通过json转成Python中的字典格式再查看 可以看到显示登陆成功了，接下来通过获取到的cookie就可以获取到我们需要的各种信息了 接下来我们将代码优化一下变成一个方法，让登陆后的cookie可以在以后任意需要的地方使用 import requests import json from lxml import etree def login(username, password): \"\"\" 登陆叩富网 :param username: 用户名 :param password: 密码 :return: 登陆成功返回cookie，失败抛出对应异常 \"\"\" login_url = 'http://www.cofool.com/Passport/login.html' data = { 'username': username, 'password': password } try: response = requests.post(url=login_url, data=data) except Exception as e: raise Exception(\"登陆失败，原因为：{}\".format(e)) content = json.loads(response.content.decode()) if content['status'] == 0: cookie = response.cookies.get_dict() return cookie else: raise Exception(\"登陆失败，原因为：{}\".format(content['info'])) 在出现登录失败的时候抛出异常，并显示错误信息 ","date":"2019-06-22","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:3:3","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"Feeling 爬虫是我们与开发者的博弈，我们需要站在他们的角度去分析他们开发的过程，从而更好的理解并去设计我们的相关爬虫程序。通常爬虫程序都不是一次就完成的，需要通过我们不断根据请求的反馈去修改程序，最终通过多层解析得到结果。 ","date":"2019-06-22","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:3:4","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"获取账户信息 ","date":"2019-06-22","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:4:0","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"练习区信息 通过对相关请求的分析，练习区信息在http://www.cofool.com/Trade/Stock/index/gid/2.html这个URL下 对页面分析我们所需要的数据在class为top_ts的div下 ","date":"2019-06-22","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:4:1","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"XPath XPath是一门在XML文档中查找信息的语言，可以帮助我们在爬虫中对获取数据进行查找得到我们需要的内容。 推荐从大佬崔庆才的个人博客学习XPath及爬虫的相关内容 开始通过XPath获取对应数据，考虑到多个数据在相同的font标签下，可以一次性获取所有标签然后进行处理 def get_account_info(query_category): \"\"\" 根据query_category获取账户相关信息 :param query_category: 查询类别信息,账户信息:ai 持仓状态:ap 当日委托:ac 当日成交:ad 历史成交:hd 股票收益明细:sd 日资产增长明细：da 月资产增长明细：ma 荣耀榜 ho :return: \"\"\" cookie = login('用户名', '密码') if query_category not in ['ai', 'ap', 'ac', 'ad', 'hd', 'sd', 'da', 'ma', 'ho']: raise Exception('查询类别不存在') if query_category == 'ai': url = 'http://www.cofool.com/Trade/Stock/index/gid/2.html' # 抓取账户相关数据 try: response = requests.get(url=url, cookies=cookie).content.decode() except Exception as e: raise Exception(\"获取账户数据失败，原因为：{}\".format(e)) if '总盈利率' not in response: raise Exception(\"获取账户数据失败，未获取到正确信息\") # 使用xpath对抓取到的数据进行清洗得到我们需要的数据 html = etree.HTML(response) account_info = html.xpath('//div [@class=\"top_ts\"]/div//font/text()') if len(account_info) != 4: raise Exception(\"获取账户数据失败，未获取足够的账户数据\") gross_profit_rate = account_info[0] # 总收益率 initial_funding = account_info[1] # 初始资金 number_of_participants = account_info[2] # 参赛人数 average_income = account_info[3] # 平均收益率 overall_ranking = html.xpath('//div [@class=\"top_ts\"]/div//p[2]/b/text()')[0] # 总排名 try: total_assets = float(''.join(re.search('\\d,\\d*,\\d*.\\d*', html.xpath( '//*[@id=\"left2\"]/table/tbody/tr[1]/td[@class=\"btom zjsr\"]/text()')[0])[0].split(','))) available_funds = float(''.join(re.search('\\d,\\d*,\\d*.\\d*', html.xpath( '//*[@id=\"left2\"]/table/tbody/tr[1]/td[@class=\"btom zjl\"]/text()')[0])[0].split(','))) except Exception as e: raise Exception(\"获取账户数据失败，{}\".format(e)) return {'总收益率': gross_profit_rate, '初始资金': initial_funding, '参赛人数': number_of_participants, '平均收益率': average_income, '总排名': overall_ranking, '总资产': total_assets, '可用资金': available_funds} ","date":"2019-06-22","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:4:2","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"持仓、交易、业绩信息 通过对相关请求的分析，当前持仓、当日委托、当日成交、历史成交与业绩报告都用同一个URL进行请求，只是请求中FormData部分数据不同，分析各页面数据发现当前持仓、当日委托、当日成交、历史成交数据类似，将其作为同一个类型进行爬取做简单修改即可。分页相关信息需要根据页码数据进行追加处理 ... url = 'http://www.cofool.com/Trade/Stock/tradeItem.html' data = {'gid': 'gid', 'uid': 'uid', 'web_id': 'web_id} # 根据查询条件设置对应的type值 if query_category == 'ap': data['type'] = 'position' elif query_category == 'ac': data['type'] = 'entrust' elif query_category == 'ad': data['type'] = 'turnover' elif query_category == 'hd': data['type'] = 'history' elif query_category == 'sd': data['type'] = 'earnings' elif query_category == 'da': data['type'] = 'dayasset' elif query_category == 'ma': data['type'] = 'monthasset' elif query_category == 'ho': data['type'] = 'honor' # 第一次获取对应信息，当信息不存在时返回'暂无交易的数据！' try: response = requests.post(url=url, data=data).content.decode() except Exception as e: raise Exception('获取账户数据失败，原因为：{}'.format(e)) if ' 暂无交易的数据！' in response: return '暂无交易的数据！' html = etree.HTML(response) # 当有信息时获取页码数值， number_of_pages = len(html.xpath('//div [@class = \"clearfix fr\"]/a/text()')) + 1 # 获取对应表头名 col_name = html.xpath('//tr/th/text()') # 设置临时存储字典 temp_dict = {} # 根据页码信息进行第二次访问获取信息 for i in range(1, number_of_pages + 1): # 添加页码数据 data['p'] = i try: response = requests.post(url=url, data=data).content.decode() except Exception as e: raise Exception('获取账户数据失败，原因为：{}'.format(e)) # 由于爬取的数据存在大量\\n和空格，先进行一次简单的清洗 response = re.sub('\\n\\s|\\s', '', response) html = etree.HTML(response) # 分别获取各列信息 for j in range(len(col_name)): xpath_index = j + 1 xpath_values = html.xpath('//tr/td[{}]//text()|//tr/td[{}]/font/text()|//tr/td[{}]/text()'.format(xpath_index, xpath_index,xpath_index)) if i == 1: temp_dict[col_name[j]] = xpath_values # 当出现第二页及其以上时，进行数据追加处理 else: temp_dict[col_name[j]].extend(xpath_values) return pd.DataFrame(temp_dict) ","date":"2019-06-22","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:4:3","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"Feeling 爬虫中数据清洗的过程通常也非常熬人，网站开发者的水平高低与反爬的难度，会导致许多数据清洗起来非常复杂，可能会花费大量的时间还得不到你想要的结果，这时候我们需要保持一颗平常心，针对出现的问题一个一个去解决，只要坚持下去一定能解决的！ ","date":"2019-06-22","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:4:4","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"账户操作 ","date":"2019-06-22","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:5:0","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"股票信息 接下来编写账户操作方面的爬虫，要交易首先要拿到进行交易股票的相关信息，通过分析相关请求后发现其URL为http://www.cofool.com/Trade/Stock/stockQuote.html,这个比较简单很快就可以完成对应代码 def get_stock_info(stock_code): \"\"\" 根据股票代码获取相关价格 :param code:股票代码 :return: 相关价格 \"\"\" url = \"http://www.cofool.com/Trade/Stock/stockQuote.html\" data = { \"code\": stock_code, \"uid\": 'uid', } cookie = login('账户名', '密码') try: response = json.loads(requests.post(url=url, data=data, cookies=cookie).content.decode(\"utf-8-sig\")) except Exception as e: raise Exception('获取账户数据失败，原因为：{}'.format(e)) stock_info = response[\"info\"] info_dict = { \"high_limit\": stock_info[\"surgedLimit\"], # 涨停价 \"low_limit\": stock_info[\"declineLimit\"], # 跌停价 \"stock_name\": stock_info['stockName'], # 股票名称 'currentPrice': stock_info[\"currentPrice\"], # 当前价 } return info_dict ","date":"2019-06-22","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:5:1","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"股票交易 通过观察发现买入与卖出操作的URL差距非常小，并且请求参数也高度相似，可以将其放在同一个方法中 def tradeing(stock_code, tradeing_type, amount=0): \"\"\" 股票交易，并返回交易状态 :param stock_code:股票代码 :param tradeing_type:交易类型 :param amount:交易数量,默认为0防止出现没有填写的情况 :return:交易状态 \"\"\" cookie = login('账户名', '密码') # 获取股票相关信息 info_dict = get_stock_info(stock_code) price = info_dict[\"high_limit\"] # 配置相关数据 data = { \"stockName\": info_dict['stock_name'], \"code\": stock_code, \"uid\": 'uid', \"gid\": 2, \"orderPrice\": price, \"orderAmount\": amount, \"declineLimit\": info_dict['low_limit'], \"surgedLimit\": info_dict['high_limit'] } if tradeing_type == 'buy': url = \"http://www.cofool.com/Trade/Stock/buy.html\" # 买入操作，检测买入数量防止超过最大买入数量 available_funds = get_account_info('ai')['可用资金'] if amount \u003c available_funds / float(price): data[\"orderAmount\"] = amount else: raise Exception('购买数量超过最大可购买数量') elif tradeing_type == 'sell': url = \"http://www.cofool.com/Trade/Stock/sell.html\" # 卖出操作，从持仓信息中获取可卖出数量 data[\"orderAmount\"] = get_amount(stock_code) try: content = \\ requests.post(url=url, data=data, cookies=cookie).content.decode(\"utf-8-sig\") status = json.loads(content, encoding=\"unicode_escape\")[\"status\"] except Exception as e: raise Exception('获取账户数据失败，原因为：{}'.format(e)) if status == 1: print(\"买入股票：{}，股数：{}\".format(stock_code, amount)) return 0 else: raise Exception(\"买入失败，失败原因为：{}\".format(json.loads(content, encoding=\"unicode_escape\")[\"info\"])) ","date":"2019-06-22","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:5:2","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"持仓数量 在卖出交易的时候需要获取账户中持仓的数量 def get_amount(code): \"\"\"根据股票代码获取可交易数量 :param code:股票代码 :return:对应股票可用数量 \"\"\" url = \"http://www.cofool.com/Trade/Stock/sellAmount\" data = { \"code\": code, \"uid\": 'uid', \"web_id\": 'web_id' } cookie = login('账户名', '密码') try: content = json.loads(requests.post(url=url, data=data, cookies=cookie).content.decode('unicode_escape')) except Exception as e: raise Exception(\"获取股数数据失败，{}\".format(e)) status = content['status'] if status == 1: amount = content['info']['frozen_amount'] return amount else: raise Exception(content['info']) 到这里叩富网的爬虫基本完成了，最后将转化为类就可以了，完整代码可以在我的GitHub仓库查看最新的代码 ","date":"2019-06-22","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:5:3","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["一篇文章学会系列"],"content":"一篇文章学会Vim","date":"2019-06-15","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Avim/","tags":["工具","教程"],"title":"一篇文章学会Vim","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Avim/"},{"categories":["一篇文章学会系列"],"content":"声明：以下内容均为我个人的理解，如果发现错误或者疑问可以联系我共同探讨 ","date":"2019-06-15","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Avim/:0:0","tags":["工具","教程"],"title":"一篇文章学会Vim","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Avim/"},{"categories":["一篇文章学会系列"],"content":"简介 Vim是一个高度可定制的终端文本编辑器，它可以很方便的创建和修改任何类型的文本。作为vi的升级版，有许多新的特性(以下列出的特性为比较常用的，详细特性可以查看help vi_diff.)： 无限撤销：可以无限制的撤销 可移植性：Vi仅在Unix上可用，Vim还可以在Windows、Macintosh，Amiga，OS / 2，VMS，QNX和其他系统上运行。 语法高亮：当用Vim进行编程的时候，他可以根据正在编辑的文件类型，使其以内容以不同的颜色或样式突出显示。Vim捆绑了数百种语法突出显示规则集。 图形用户界面：Vim在控制台上运行良好，也可以在许多GUI中本地运行，包括Mac OS和Windows。它还可以操作剪贴板。 vi兼容模式：紧要关头，您可以强制Vim像vi一样。使Vim与vi不兼容的所有改进和错误修复都已关闭，您将获得100％与vi兼容的编辑器。 Vim作为许多程序员最喜欢的文本编辑器之一，它具有像：多级撤销、代码补全、支持数百种编程语言和文本格式、强大的搜索和替换功能等。 ","date":"2019-06-15","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Avim/:1:0","tags":["工具","教程"],"title":"一篇文章学会Vim","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Avim/"},{"categories":["一篇文章学会系列"],"content":"安装与卸载 ","date":"2019-06-15","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Avim/:2:0","tags":["工具","教程"],"title":"一篇文章学会Vim","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Avim/"},{"categories":["一篇文章学会系列"],"content":"安装 Windows 先把安装包下载下来，然后根据提示安装。 Unix 在Github上下载源文件安装 Mac 在github下载，根据文件类型安装。 详细安装教程 ","date":"2019-06-15","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Avim/:2:1","tags":["工具","教程"],"title":"一篇文章学会Vim","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Avim/"},{"categories":["一篇文章学会系列"],"content":"卸载 Unix or Mac 源代码安装 在控制台输入 make uninstall 软件包管理器安装 根据不同软件包管理器的卸载命令卸载 Windows 找到安装目录下的 “uninstall-gui” 程序进行卸载 ","date":"2019-06-15","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Avim/:2:2","tags":["工具","教程"],"title":"一篇文章学会Vim","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Avim/"},{"categories":["一篇文章学会系列"],"content":"教程 ","date":"2019-06-15","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Avim/:3:0","tags":["工具","教程"],"title":"一篇文章学会Vim","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Avim/"},{"categories":["一篇文章学会系列"],"content":"vimtutor Vim自带教程vimtutor是你从零开始学习Vim最好的老师，教程包含了日常所需要的各个命令和功能，还有实操教学。如果你的系统语言是中文，那么打开vimtutor时默认是中文版的教程，中文版教程由梁昌泰 先生进行译制。在命令行中输入vimtutor，就可以打开该教程,学习完该教程大约需要30分钟左右。 有一款游戏Vim Adventure，可以作为学习Vim的一种放松。 Vimtutor章节小结 第一讲 光标在屏幕文本中的移动既可以用箭头键，也可以使用 hjkl 字母键。 ​ h (左移) j (下行) k (上行) l (右移) 欲进入 Vim 编辑器(从命令行提示符)，请输入：vim 文件名 \u003c回车\u003e 欲退出 Vim 编辑器，请输入 :q! \u003c回车\u003e 放弃所有改动。或者输入 :wq \u003c回车\u003e 保存改动。 在正常模式下删除光标所在位置的字符，请按： x 欲插入或添加文本，请输入： ​ i 输入欲插入文本 在光标前插入文本 ​ A 输入欲添加文本 在一行后添加文本 特别提示：按下 键会带您回到正常模式或者撤消一个不想输入或部分完整的命令。 第二讲 欲从当前光标删除至下一个单词，请输入：dw 欲从当前光标删除至当前行末尾，请输入：d$ 欲删除整行，请输入：dd 欲重复一个动作，请在它前面加上一个数字：2w 在正常模式下修改命令的格式是： operator [number] motion 其中： ​ operator - 操作符，代表要做的事情，比如 d 代表删除 ​ [number] - 可以附加的数字，代表动作重复的次数 ​ motion - 动作，代表在所操作的文本上的移动，例如 w 代表单词(word)，$ 代表行末等等。 欲移动光标到行首，请按数字0键：0 欲撤消以前的操作，请输入：u (小写的u)，欲撤消在一行中所做的改动，请输入：U (大写的U)，欲撤消以前的撤消命令，恢复以前的操作结果，请输入：CTRL-R 第三讲 要重新置入已经删除的文本内容，请按小写字母 p 键。该操作可以将已删除的文本内容置于光标之后。如果最后一次删除的是一个整行，那么该行将置于当前光标所在行的下一行。 要替换光标所在位置的字符，请输入小写的 r 和要替换掉原位置字符的新字符即可。 更改类命令允许您改变从当前光标所在位置直到动作指示的位置中间的文本。比如输入 ce 可以替换当前光标到单词的末尾的内容；输入 c$ 可以替换当前光标到行末的内容。 更改类命令的格式是： c [number] motion 第四讲 CTRL-G 用于显示当前光标所在位置和文件状态信息。 G 用于将光标跳转至文件最后一行。先敲入一个行号然后输入大写 G 则是将光标移动至该行号代表的行。gg 用于将光标跳转至文件第一行。 输入 / 然后紧随一个字符串是在当前所编辑的文档中正向查找该字符串。输入 ? 然后紧随一个字符串则是在当前所编辑的文档中反向查找该字符串。完成一次查找之后按 n 键是重复上一次的命令，可在同一方向上查找下一个匹配字符串所在；或者按大写 N 向相反方向查找下一匹配字符串所在。CTRL-O 带您跳转回较旧的位置，CTRL-I 则带您到较新的位置。 如果光标当前位置是括号(、)、[、]、{、}，按 % 会将光标移动到配对的括号上。 在一行内替换头一个字符串 old 为新的字符串 new，请输入 :s/old/new 在一行内替换所有的字符串 old 为新的字符串 new，请输入 :s/old/new/g 在两行内替换所有的字符串 old 为新的字符串 new，请输入 :#,#s/old/new/g 在文件内替换所有的字符串 old 为新的字符串 new，请输入 :%s/old/new/g 进行全文替换时询问用户确认每个替换需添加 c 标志 :%s/old/new/gc 第五讲 :!command 用于执行一个外部命令 command。 请看一些实际例子： (MS-DOS) (Unix) :!dir :!ls # 用于显示当前目录的内容。 :!del FILENAME :!rm FILENAME # 用于删除名为 FILENAME 的文件。 :w FILENAME 可将当前 VIM 中正在编辑的文件保存到名为 FILENAME 的文件中。 v motion :w FILENAME 可将当前编辑文件中可视模式下选中的内容保存到文件FILENAME 中。 :r FILENAME 可提取磁盘文件 FILENAME 并将其插入到当前文件的光标位置后面。 :r !dir 可以读取 dir 命令的输出并将其放置到当前文件的光标位置后面。 第六讲 输入小写的 o 可以在光标下方打开新的一行并进入插入模式。输入大写的 O 可以在光标上方打开新的一行。 输入小写的 a 可以在光标所在位置之后插入文本。输入大写的 A 可以在光标所在行的行末之后插入文本。 e 命令可以使光标移动到单词末尾。 操作符 y 复制文本，p 粘贴先前复制的文本。 输入大写的 R 将进入替换模式，直至按 键回到正常模式。 输入 :set xxx 可以设置 xxx 选项。一些有用的选项如下： ‘ic’ ‘ignorecase’ 查找时忽略字母大小写 ‘is’ ‘incsearch’ 查找短语时显示部分匹配 ‘hls’ ‘hlsearch’ 高亮显示所有的匹配短语 选项名可以用完整版本，也可以用缩略版本。 在选项前加上 no 可以关闭选项： :set noic 第七讲 输入 :help 或者按 键或 键可以打开帮助窗口。 输入 :help cmd 可以找到关于 cmd 命令的帮助。 输入 CTRL-W CTRL-W 可以使您在窗口之间跳转。 输入 :q 以关闭帮助窗口 您可以创建一个 vimrc 启动脚本文件用来保存您偏好的设置。 当输入 : 命令时，按 CTRL-D 可以查看可能的补全结果。 按 可以使用一个补全。 ","date":"2019-06-15","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Avim/:3:1","tags":["工具","教程"],"title":"一篇文章学会Vim","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Avim/"},{"categories":["一篇文章学会系列"],"content":"帮助 在控制台中输入vim就可以查看Vim的相关信息 根据图片所示我们可以知道，当前VIM的版本为8.0.1365，想退出需要输入”:q”，查看在线帮助文档可以输入”:help”，查看版本信息可以输入”:help version8” 在英文模式下输入”:help\"回车后便可以看到 在这里有详细的Vim教程，教你玩转Vim。 ","date":"2019-06-15","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Avim/:3:2","tags":["工具","教程"],"title":"一篇文章学会Vim","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Avim/"},{"categories":["一篇文章学会系列"],"content":"一篇文章学会Linux","date":"2019-06-09","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Alinux/","tags":["操作系统","教程"],"title":"一篇文章学会Linux","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Alinux/"},{"categories":["一篇文章学会系列"],"content":"声明：以下内容均为我个人的理解，如果发现错误或者疑问可以联系我共同探讨 ","date":"2019-06-09","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Alinux/:0:0","tags":["操作系统","教程"],"title":"一篇文章学会Linux","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Alinux/"},{"categories":["一篇文章学会系列"],"content":"简介 ","date":"2019-06-09","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Alinux/:1:0","tags":["操作系统","教程"],"title":"一篇文章学会Linux","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Alinux/"},{"categories":["一篇文章学会系列"],"content":"Linux Linux是一种自由和开放源码的类UNIX操作系统。该操作系统的内核由林纳斯·托瓦兹在1991年10月5日首次发布，在加上用户空间的应用程序之后，成为Linux操作系统。只要遵循GNU 通用公共许可证（GPL），任何个人和机构都可以自由地使用Linux的所有底层源代码，也可以自由地修改和再发布。大多数Linux系统还包括像提供GUI的X Window之类的程序。除了一部分专家之外，大多数人都是直接使用Linux 发行版，而不是自己选择每一样组件或自行设置。详细介绍 ","date":"2019-06-09","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Alinux/:1:1","tags":["操作系统","教程"],"title":"一篇文章学会Linux","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Alinux/"},{"categories":["一篇文章学会系列"],"content":"linux发行版 Linux发行版指的就是通常所说的“Linux操作系统”，它一般是由一些组织、团体、公司或者个人将Linux内核作为发行版的一部分制作并发行的。通常来讲，一个Linux发行版包括Linux内核，以及将整个软件安装到电脑上的一套安装工具，还有各种GNU软件，和其他的一些自由软件，在一些Linux发行版中可能会包含一些专有软件。当前，超过三百个发行版被积极的开发，最普遍被使用的发行版有大约十二个。较为知名的有Debian、Ubuntu、Fedora和openSUSE等。 Linux发行版份额排名，也可以在Linux终端用命令查看：wget -qO - 7z.cx/o|sh，Ubuntu以39.1%的占比遥遥领先，中国武汉深之度科技有限公司开发的deepin是国产Linux发行版中排名最高的，占比12.6%在排行榜中排名第三（截止于2020-01-10 13:54:19） ","date":"2019-06-09","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Alinux/:1:2","tags":["操作系统","教程"],"title":"一篇文章学会Linux","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Alinux/"},{"categories":["一篇文章学会系列"],"content":"安装 如果是初次安装系统建议先通过在虚拟机上安装。 ","date":"2019-06-09","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Alinux/:2:0","tags":["操作系统","教程"],"title":"一篇文章学会Linux","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Alinux/"},{"categories":["一篇文章学会系列"],"content":"下载 下面提供较为知名的Linux发行版下载地址 Ubuntu、manjaro、deepin、CentOS、Arch、Debian、Mint、Fedora Linux发行版提供了Server版和Desktop版，初次使用建议直接安装Server版。 ","date":"2019-06-09","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Alinux/:2:1","tags":["操作系统","教程"],"title":"一篇文章学会Linux","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Alinux/"},{"categories":["一篇文章学会系列"],"content":"安装 以Ubuntu Server 16.10为例 将镜像写入U盘后，开机以U盘为第一启动项启动，可以看到以下界面 选择第一项安装Ubuntu Server 下一步选择语言，这里选择英语，防止乱码与文件名是中文的问题 下一步选择区域，没有中国，所以先选其他 接下来选择亚洲Asia 接着选这中国 下一步选择字符集，这里选择美国的UTF-8字符集，即en_US.UTF-8 下一步检测键盘，选择否 接着让我们设置键盘的类型与布局 下一步是设置主机名称，默认为ubuntu，可以改为你喜欢的名称 设置用户名 下一步设置登陆账号 设置密码，可以在下面选择显示密码，可以确认一次 再次输入，确认密码 是否加密home文件夹，选择否 下一步系统根据区域推断出我们的市区是上海，没有问题，所以选择是 选择分区方式，这里选择Guided - use entire disk and set up LVM 选择安装的硬盘 这里告诉我们会格式化这个盘确认选择 选择自动安装 确认分区 确认安装 选择代理，没有就跳过 选择升级方式，这里选择不自动升级No automatic updates 安装完成后会重启，选择ubuntu启动即可 进入系统后输入用户名密码就可以登录上ubuntu了，到此安装完毕 ","date":"2019-06-09","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Alinux/:2:2","tags":["操作系统","教程"],"title":"一篇文章学会Linux","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Alinux/"},{"categories":["一篇文章学会系列"],"content":"linux 根目录 ","date":"2019-06-09","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Alinux/:3:0","tags":["操作系统","教程"],"title":"一篇文章学会Linux","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Alinux/"},{"categories":["Python"],"content":"为什么要测试 程序开发过程一般包括以下几个阶段：需求分析，设计阶段，实现阶段，测试阶段。其中测试阶段通过人工或自动来运行测试某个系统的功能。目的是检验其是否满足需求，并得出特定的结果，以达到弄清楚预期结果和实际结果之间的差别的最终目的。 ","date":"2019-05-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/:1:0","tags":["Python学习之路"],"title":"Python学习之路-单元测试","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"},{"categories":["Python"],"content":"测试的分类 测试从软件开发过程可以分为： 单元测试：对单独的代码块(例如函数)分别进行测试,以保证它们的正确性 集成测试：对大量的程序单元的协同工作情况做测试 系统测试：同时对整个系统的正确性进行检查,而不是针对独立的片段 在众多的测试中，与程序开发人员最密切的就是单元测试，因为单元测试是由开发人员进行的，而其他测试都由专业的测试人员来完成。所以我们主要学习单元测试。 ","date":"2019-05-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/:2:0","tags":["Python学习之路"],"title":"Python学习之路-单元测试","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"},{"categories":["Python"],"content":"什么是单元测试 程序开发过程中，写代码是为了实现需求。当我们的代码通过了编译，只是说明它的语法正确，功能能否实现则不能保证。 因此，当我们的某些功能代码完成后，为了检验其是否满足程序的需求。可以通过编写测试代码，模拟程序运行的过程，检验功能代码是否符合预期。 单元测试就是开发者编写一小段代码，检验目标代码的功能是否符合预期。通常情况下，单元测试主要面向一些功能单一的模块进行。 举个例子：一部手机有许多零部件组成，在正式组装一部手机前，手机内部的各个零部件，CPU、内存、电池、摄像头等，都要进行测试，这就是单元测试。 在开发过程中，单元测试实际上就是一些“断言”（assert）代码。 断言就是判断一个函数或对象的一个方法所产生的结果是否符合你期望的那个结果。 Python中assert断言是声明布尔值为真的判定，如果表达式为假会发生异常。单元测试中，一般使用assert来断言结果。 ","date":"2019-05-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/:3:0","tags":["Python学习之路"],"title":"Python学习之路-单元测试","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"},{"categories":["Python"],"content":"常用的断言方法 assertEqual 如果两个值相等，则pass assertNotEqual 如果两个值不相等，则pass assertTrue 判断bool值为True，则pass assertFalse 判断bool值为False，则pass assertIsNone 不存在，则pass assertIsNotNone 存在，则pass ","date":"2019-05-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/:4:0","tags":["Python学习之路"],"title":"Python学习之路-单元测试","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"},{"categories":["Python"],"content":"基本写法 首先，定义一个类，继承自unittest.TestCase import unittest class TestClass(unitest.TestCase): pass 其次，在测试类中，定义两个测试方法 import unittest class TestClass(unittest.TestCase): #该方法会首先执行，方法名为固定写法 def setUp(self): pass #该方法会在测试代码执行完后执行，方法名为固定写法 def tearDown(self): pass 最后，在测试类中，编写测试代码 import unittest class TestClass(unittest.TestCase): #该方法会首先执行，相当于做测试前的准备工作 def setUp(self): pass #该方法会在测试代码执行完后执行，相当于做测试后的扫尾工作 def tearDown(self): pass #测试代码 def test_app_exists(self): pass ","date":"2019-05-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/:5:0","tags":["Python学习之路"],"title":"Python学习之路-单元测试","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"},{"categories":["Flask"],"content":"Flask入门教程","date":"2019-05-19","objectID":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/","tags":["Flask"],"title":"Flask入门教程","uri":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"categories":["Flask"],"content":"简介 Flask是由Armin ronacher于2010年用Python语言基于 Werkzeug 工具箱编写的轻量级Web开发框架。 ","date":"2019-05-19","objectID":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:1:0","tags":["Flask"],"title":"Flask入门教程","uri":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"categories":["Flask"],"content":"特点 Flask只提供核心功能，其他几乎所有的功能都需要用到拓展，比如可以通过Flask-SQLAlchemy拓展对数据库进行操作等等。 ","date":"2019-05-19","objectID":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:2:0","tags":["Flask"],"title":"Flask入门教程","uri":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"categories":["Flask"],"content":"核心 由Werkzeug与Jinja2组成，Werkzeug是一个全面的WSGI Web应用程序库，Jinja是一种现代且设计友好的Python模板语言。 ","date":"2019-05-19","objectID":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:3:0","tags":["Flask"],"title":"Flask入门教程","uri":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"categories":["Flask"],"content":"Flask常用扩展 Flask-SQLalchemy：操作数据库 Flask-script：插入脚本 Flask-migrate：管理迁移数据库 Flask-Session：Session存储方式指定 ","date":"2019-05-19","objectID":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:4:0","tags":["Flask"],"title":"Flask入门教程","uri":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"categories":["Flask"],"content":"相关文档 中文文档 英文文档 ","date":"2019-05-19","objectID":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:5:0","tags":["Flask"],"title":"Flask入门教程","uri":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"categories":["Flask"],"content":"Flask初体验 ","date":"2019-05-19","objectID":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:6:0","tags":["Flask"],"title":"Flask入门教程","uri":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"categories":["Flask"],"content":"安装并使用虚拟环境 virtualenv 创建和管理虚拟环境 # 安装 pip install virtualenv # 创建 virtualenv flask_env # 使用 source flask_env/bin/activate Pipenv 创建和管理虚拟环境 # 安装 pip install pipenv # 创建 pipenv install # 使用 pipenv shell ","date":"2019-05-19","objectID":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:6:1","tags":["Flask"],"title":"Flask入门教程","uri":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"categories":["Flask"],"content":"安装指定版本flask框架 sudo pip install flask==1.0.2 ","date":"2019-05-19","objectID":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:6:2","tags":["Flask"],"title":"Flask入门教程","uri":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"categories":["Flask"],"content":"创建一个文件，并带入编写第一个Flask程序 touch helloflask.py vim helloflask.py 在文件中写入以下代码 # 导入Flask类 from flask import Flask # 传递__name__参数，创建一个叫app的Flask实例，该实例将会成为我们的 WSGI 应用。 app = Flask(__name__) # 通过route装饰器来告诉Flask触发函数的URL @app.route('/') # index视图函数，在访问根路径时会调用该函数通过其返回值得到结果 def index(): return 'Hello Flask' if __name__ == '__main__': # 通过run方法启动web服务器 app.run() 退出编辑模式，运行该程序 python helloflask.py 可以看到以下结果 这样就启动了一个非常简单的内建的服务器。这个服务器用于测试应该是足够了，但是 用于生产可能是不够的。现在在浏览器中打开 http://127.0.0.1:5000/ ，应该可以看到 Hello Flask! 字样。 ","date":"2019-05-19","objectID":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:6:3","tags":["Flask"],"title":"Flask入门教程","uri":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"categories":["Flask"],"content":"相关配置参数 ","date":"2019-05-19","objectID":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:7:0","tags":["Flask"],"title":"Flask入门教程","uri":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"categories":["Flask"],"content":"初始化参数 创建Flask项目的第一步就是实例化Flask对象，以下是实例化对象需要的参数详解 import_name：Flask程序所在的包(模块)，传 __name__ 就可以， static_url_path：静态文件访问路径，可以不传，默认为：/ + static_folder static_folder：静态文件存储的文件夹，可以不传，默认为 static static_host：使用远程主机存储静态文件的地址，默认为None。当host_matching为True时，可以通过static_folder配置静态文件存储的文件夹 host_matching：设置url_map.host_matching属性，默认为False subdomain_matching：匹配路由时，请考虑与以下项相关的子域：data:`SERVER_NAME’。默认为False。 template_folder：模板文件存储的文件夹，可以不传，默认为 templates instance_path：默认情况下，应用程序的备用实例路径假定包或模块旁边的文件夹“instance”为实例路径。 instance_relative_config：如果将用于加载配置的相对文件名设置为“True”，则假定该文件名相对于实例路径而不是应用程序根。 root_path：默认情况下，Flask将自动计算应用程序根路径。在某些情况下，这无法实现（例如，如果包是Python 3命名空间包），需要手动定义。 ","date":"2019-05-19","objectID":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:7:1","tags":["Flask"],"title":"Flask入门教程","uri":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"categories":["Flask"],"content":"程序加载配置 在Flask程序运行前，我们可以给Flask设置相关配置，例如ENV(应用程序在什么环境中运行)，DEBUG(是否启用调试模式)TESTING(启用测试模式)等配置，常见的有两种方式来实现. 从配置文件中加载：app.config.from_pyfile() 创建一个配置文件 touch config.ini vim config.ini 写入配置信息 DEBUG = True 选择从配置文件加载 # 创建 Flask 类对象,指向程序所在的包的名称 app = Flask(__name__) # 从配置文件中加载配置 app.config.from_pyfile('config.ini') 从配置对象中加载：app.config.from_object() 创建一个配置类，然后将类名传入即可 # 配置类 class ConfigObject(object): DEBUG = True # 创建 Flask 类对象,指向程序所在的包的名称 app = Flask(__name__) # 从配置对象中加载配置 app.config.from_object(Config) ","date":"2019-05-19","objectID":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:7:2","tags":["Flask"],"title":"Flask入门教程","uri":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"categories":["Flask"],"content":"程序运行配置 这个demo中Flask项目程序启动的入口是app.run()。常见的配置选项有host, port,debug，分别是设置运行主机的ip地址，端口号，是否打开调试模式，当配置文件与这里都有debug时，最终会以这里的debug为准。 app.run(host=\"127.0.0.1\", port=8000) 路由 在Web开发中，路由是一种将URL转发到对应视图的程序。 ","date":"2019-05-19","objectID":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:7:3","tags":["Flask"],"title":"Flask入门教程","uri":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"categories":["一篇文章学会系列"],"content":"一篇文章学会Git","date":"2019-05-11","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/","tags":["工具","教程"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"简介 ","date":"2019-05-11","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:0","tags":["工具","教程"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"什么是Git Git是一个免费的开源分布式版本控制系统，也是目前为止世界上最先进的分布式版本控制系统。Git官方有一个视频介绍，可以点此观看 什么是版本控制系统？ 一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。简单点理解就是一个可以帮助我们记录文件修改的系统。Git官方有一个视频介绍，可以点此观看 什么是分布式版本控制系统？ 分布式版本控制系统时相对于集中式版本控制系统的。 集中式版本控制系统将仓库存放在中央服务器中集中管理，当你需要时从中央服务器中拉取最新的版本，修改完后将修改提交给中央服务器。这就会带来例如当中央服务器宕机时整个版本控制系统就会崩溃；推送或者拉取一个较大的文件时就会消耗很多时间等弊端。 分布式版本控制系统中，每个人电脑都是一个仓库，自己的文件可以在本地管理，当需要多人协同时只需要管理好本地仓库与协同仓库的版本即可 ","date":"2019-05-11","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:1","tags":["工具","教程"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"Git有什么作用 进行源代码管理 ","date":"2019-05-11","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:2","tags":["工具","教程"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"为什么要进行源代码管理 方便多人协同开发 方便代码版本控制 ","date":"2019-05-11","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:3","tags":["工具","教程"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"Git的特点 分布式版本控制系统，服务器和客户端都有版本控制能力,都能进行代码的提交、合并等操作。 在使用Git的时候会自动创建一个.git的隐藏文件夹作为本地仓库 ","date":"2019-05-11","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:4","tags":["工具","教程"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"Git操作流程 clone：第一次从Git服务器获取项目 add：将修改添加到本地仓库 commit：将修改提交到本地仓库 push：将本地仓库的修改提交到Git服务器 pull：将Git服务器中的项目获取到本地仓库 ","date":"2019-05-11","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:5","tags":["工具","教程"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"Git仓库 什么是仓库 仓库的英文名是repository，又被称为版本库。它是一个被Git管理的文件目录。 ","date":"2019-05-11","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:6","tags":["工具","教程"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"工作区，暂存区和仓库 工作区：对代码的新增，修改，删除等操作的区域。 暂存区：存储工作区的操作的区域。 仓库区：即本地仓库区域，会记录完成的操作与历史版本。 ","date":"2019-05-11","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:7","tags":["工具","教程"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"Git操作 安装 Mac 在mac上有多种方法可以安装Git，最简单的事通过Xcode命令行工具安装。 通过Xcode安装 1.下载并安装Xcode 2.在终端中运行git即可，如果尚未安装，它将提示您安装。 通过homebrew安装 1.安装homebrew $ /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" 2.安装git $ brew install git 通过安装包安装 1.点击此下载最新版本 2.下载完成后打开安装包，一直下一步安装即可 Linux 在Linux发行版上安装GIt，可以通过附带的软件包管理工具来安装 Debian/Ubuntu $ apt-get install git 其他发行版本见这个链接 Windows 下载安装包 根据操作系统位数选择，链接 安装默认选项安装即可 安装完成后通过可以通过git --version查看安装版本 ","date":"2019-05-11","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:8","tags":["工具","教程"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"配置Git 配置文件介绍 Git有一个git config的工具，可以设置和获取配置，用来控制Git外观及操作。这些变量可以存放在三个不同的位置，根据存放位置不同作用的范围也不同。 1./etc/gitconfig：包含系统上每个用户及其存储库的配置。 2.~/.gitconfig或~/.config/git/config：每个用户专属的配置 3.config.git/config：当前使用存储库的git目录，用于该存储库的配置 如果有相同配置项时，每个级别都会覆盖上一个级别中的值，即：3\u003e2\u003e1 可以使用一下命令查看所有设置以及设置的所属： $ git config --list --show-origin 常见配置 下面介绍一些常见配置 身份配置 安装完Git做的第一件事应该是设置用户名和电子邮箱。 $ git config --global user.name \"John Doe\" $ git config --global user.email johndoe@example.com 使用global后，该信息将会始终作用域Git操作上 Git编辑器配置 Git默认的编辑器是系统默认编辑器 如果要是用其他文本编辑器（例如vim），则可以执行以下操作： $ git config --global core.editor vim 查看配置 如果要查看配置，可以使用git config --list命令列出Git可以找到的所有设置 你可能会看到很多配置项，找不到你想要的，这时候你可以通过git config \u003ckey\u003e来查看特定的配置，例： $ git config user.name silencehuliang ","date":"2019-05-11","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:9","tags":["工具","教程"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"帮助 获取方式 Git获取帮助的方式有三种git help \u003cverb\u003e、git \u003cverb\u003e --help、man git-\u003cverb\u003e 例如，可以通过git help config获取config的相关帮助 如果只需要快速了解Git命令的可用选项也可以用-h来查看相关帮助 例如git add -h ","date":"2019-05-11","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:10","tags":["工具","教程"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"创建项目 1.将本地不收版本控制的目录转换为Git仓库 ①进入本地目录 $ cd ~/Desktop/project ②输入转化命令 $ git init 此时会在当前目录下创建一个.git目录，里面存放着Git仓库中所有的必须文件 $ ls -a . .. .git 2.从其他地方克隆现有的Git仓库 ①进入我们需要存放仓库的路径 $ cd ~/Desktop/ ②将现有的仓库克隆下来 $ git clone https://github.com/Silencehuliang/project ","date":"2019-05-11","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:11","tags":["工具","教程"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"查看状态 可以通过git status 查看仓库中稳健的状态 绿色表示文件在暂存区 红色表示文件在工作区 可以通过git add 将工作区文件添加到暂存区 添加项目中所有文件：git add . 添加指定文件：git add xxx.py 可以通过git commit将暂存区文件提交到仓库区 git commit -m \"修改描述\"，其中-m参数后面跟的是对本次修改的描述 git commit -am \"修改描述\",可以通过-am来实现添加和提交合并操作 ","date":"2019-05-11","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:13","tags":["工具","教程"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"查看历史版本 通过git log或者git relog可以查看历史版本 ","date":"2019-05-11","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:14","tags":["工具","教程"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"回退版本 通过版本号会退版本 git reset --hard 版本号 通过HEAD回退版本 当工作区文件发生了意外需要回退到上一个版本时可以通过 `git reset --hard HEAD` HEAD表示当前最新版本 HEAD^表示当前最新版本的前一个版本 HEAD^^表示当前最新版本的前两个版本，以此类推… HEAD~1表示当前最新版本的前一个版本 HEAD~10表示当前最新版本的前10个版本，以此类推… ","date":"2019-05-11","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:15","tags":["工具","教程"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"撤销修改 只能撤销工作区、暂存区的代码,不能撤销仓库区的代码 撤销仓库区的代码就相当于回退版本操作 撤销工作区代码 新加代码num3 = 30，不add到暂存区，保留在工作区 git checkout 文件名 撤销暂存区代码 新加代码num3 = 30，并add到暂存区 # 第一步：将暂存区代码撤销到工作区 git reset HEAD 文件名 # 第二步：撤销工作区代码 git checkout 文件名 ","date":"2019-05-11","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:16","tags":["工具","教程"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"对比版本 对比版本库与工作区 新加代码num3 = 30，不add到暂存区，保留在工作区 git diff HEAD -- xxx.py 对比版本库 新加代码num3 = 30，并add到暂存区 git diff HEAD HEAD^ -- xxx.py ","date":"2019-05-11","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:17","tags":["工具","教程"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"删除文件 删除文件分为确定删除和误删 在项目中新建test.py文件，并添加和提交到仓库 确定删除处理： # 删除文件 rm 文件名 # git确定删除文件，对比添加文件git add git rm 文件名 # 删除后记录删除操作版本 git commit -m '删除描述' 误删处理：撤销修改即可 # 删除文件 rm 文件名 # git撤销修改 git checkout -- 文件名 ","date":"2019-05-11","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:18","tags":["工具","教程"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"代码冲突 提示：多人协同开发时，避免不了会出现代码冲突的情况 原因：多人同时修改了同一个文件 危害：会影响正常的开发进度 注意：一旦出现代码冲突，必须先解决再做后续开发 解决冲突 原则：谁冲突谁解决，并且一定要协商解决 方案：保留所有代码 或者 保留某一人代码 解决完冲突代码后，依然需要add、commit、push，如果执行pull没有影响，就算真正解决了冲突代码 补充： 容易冲突的操作方式 多个人同时操作了同一个文件 一个人一直写不提交 修改之前不更新最新代码 提交之前不更新最新代码 擅自修改同事代码 减少冲突的操作方式 养成良好的操作习惯,先pull在修改,修改完立即commit和push 一定要确保自己正在修改的文件是最新版本的 各自开发各自的模块 如果要修改公共文件,一定要先确认有没有人正在修改 下班前一定要提交代码,上班第一件事拉取最新代码 一定不要擅自修改同事的代码 ","date":"2019-05-11","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:19","tags":["工具","教程"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"标签 当某一个大版本完成之后,需要打一个标签 作用： 记录大版本 备份大版本代码 在本地打标签 git tag -a 标签名 -m '标签描述' 推送标签到远程仓库 git push origin 标签名 删除本地和远程标签 # 删除本地标签 git tag -d 标签名 # 删除远程仓库标签 git push origin --delete tag 标签名 ","date":"2019-05-11","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:20","tags":["工具","教程"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"分支 作用： 区分生产环境代码以及开发环境代码 研究新的功能或者攻关难题 解决线上bug 特点： 项目开发中公用分支包括master、dev 分支master是默认分支，用于发布，当需要发布时将dev分支合并到master分支 分支dev是用于开发的分支，开发完阶段性的代码后，需要合并到master分支 查看当前分支 git branch 创建并切换到dev分支 git checkout -b dev 设置本地分支跟踪远程指定分支（将分支推送到远程） git push -u origin dev 分支合并到master分支 先切换到master分支 git checkout master 分支合并到master分支 git merge dev ","date":"2019-05-11","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:21","tags":["工具","教程"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["Django"],"content":"Django2.x搭建博客","date":"2019-04-20","objectID":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/","tags":["博客","Django"],"title":"Django2.x搭建博客","uri":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Django"],"content":"声明：以下内容均为我个人的理解，如果发现错误或者疑问可以联系我共同探讨 ","date":"2019-04-20","objectID":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:0:0","tags":["博客","Django"],"title":"Django2.x搭建博客","uri":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Django"],"content":"简介 学完Django2.x可以搭建一个个人博客练练手 ","date":"2019-04-20","objectID":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:1:0","tags":["博客","Django"],"title":"Django2.x搭建博客","uri":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Django"],"content":"教程 ","date":"2019-04-20","objectID":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:2:0","tags":["博客","Django"],"title":"Django2.x搭建博客","uri":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Django"],"content":"创建项目 通过pycharm创建博客项目与虚拟环境 ","date":"2019-04-20","objectID":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:2:1","tags":["博客","Django"],"title":"Django2.x搭建博客","uri":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Django"],"content":"修改相关设置 允许任何域名 在开发和测试的时候可以将这里填为*，后期部署上线后修改为指定域名即可 ALLOWED_HOSTS = ['*'] 注册应用 INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', # 注册应用，当使用pycharm创建时会帮我们自动创建 'post.apps.PostConfig', ] 配置模版 TEMPLATES = [ { # 选择我们的模板引擎，刚刚用pycharm创建时已选择django自带的模板引擎 'BACKEND': 'django.template.backends.django.DjangoTemplates', # 注册我们模版文件夹的位置，刚刚用pycharm创建时已将名字定为`templates` 'DIRS': [os.path.join(BASE_DIR, 'templates')] , 'APP_DIRS': True, 'OPTIONS': { 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', ], }, }, ] 注册完后，在项目根目录中（即manage.py所在的目录）创建templates文件夹，使用pycharm创建项目会自动帮我们创建 配置数据库 DATABASES = { 'default': { # 选择使用的数据库类型，这里为mysql 'ENGINE': 'django.db.backends.mysql', # 数据库名称 'NAME': 'djangoblog', # 数据库用户名 'USER': 'root', # 数据库密码 'PASSWORD': '123456', # 数据库ip，留空默认为localhost 'HOST': '', # 数据库端口，留空默认为3306 'PORT': '3306', } } 创建mysql数据库 在注册完数据库后创建mysql数据库 \u003e\u003e\u003e mysql -uroot -p mysql\u003e create database djangoblog charset=utf8; mysql\u003e show databases; +--------------------+ | Database | +--------------------+ | information_schema | | blog | | djangoblog | | mysql | | performance_schema | | sys | +--------------------+ 6 rows in set (0.01 sec) 数据库迁移 接下来进行数据库迁移，并创建django-admin管理员 按照之前的文章：Django2.0正确配置MySQL，配置好MySQL数据库 接下来再进行数据库迁移 (DjangoBlogEnv) hls-MacBook-Pro:DjangoBlog hl$ python manage.py makemigrations No changes detected (DjangoBlogEnv) hls-MacBook-Pro:DjangoBlog hl$ python manage.py migrate Operations to perform: Apply all migrations: admin, auth, contenttypes, sessions Running migrations: Applying contenttypes.0001_initial... OK Applying auth.0001_initial... OK Applying admin.0001_initial... OK Applying admin.0002_logentry_remove_auto_add... OK Applying admin.0003_logentry_add_action_flag_choices... OK Applying contenttypes.0002_remove_content_type_name... OK Applying auth.0002_alter_permission_name_max_length... OK Applying auth.0003_alter_user_email_max_length... OK Applying auth.0004_alter_user_username_opts... OK Applying auth.0005_alter_user_last_login_null... OK Applying auth.0006_require_contenttypes_0002... OK Applying auth.0007_alter_validators_add_error_messages... OK Applying auth.0008_alter_user_username_max_length... OK Applying auth.0009_alter_user_last_name_max_length... OK Applying auth.0010_alter_group_name_max_length... OK Applying auth.0011_update_proxy_permissions... OK Applying sessions.0001_initial... OK 出现Applying sessions.0001_initial… OK 代表mysql数据库已配置完成，接下来创建django-admin管理员 (DjangoBlogEnv) hls-MacBook-Pro:DjangoBlog hl$ python manage.py createsuperuser 用户名 (leave blank to use 'hl'): silencehl 电子邮件地址: silencehuliang@163.com Password: Password (again): 密码跟 用户名 太相似了。 密码长度太短。密码必须包含至少 8 个字符。 这个密码太常见了。 Bypass password validation and create user anyway? [y/N]: y Superuser created successfully. 出现Superuser created successfully.这一阶段数据库配置已完成，这里产生的数据库是Django自带的一些库 其他设置 区域语言设置，防止admin界面乱码 # 设置语言为中文 LANGUAGE_CODE = 'zh-hans' # 设置时区为上海 TIME_ZONE = 'Asia/Shanghai' 静态文件夹与多媒体文件夹设置 # 设置静态文件目录和名称 STATIC_URL = '/static/' # 设置静态文件夹目录的路径 STATICFILES_DIRS = ( os.path.join(BASE_DIR, 'static'), ) # 设置多媒体文件目录和名称 MEDIA_URL = '/media/' # 设置多媒体文件目录的路径 MEDIA_ROOT = os.path.join(BASE_DIR, 'media') 在settings.py里设置完毕后，我们在项目中也创建这两个文件在，在项目根目录中创建static与media这两个文件夹 配置pycharm运行参数 配置完成后点击pycharm中的运行按钮，在浏览器中输入127.0.0.1:8000访问，出现小火箭升空表示Django安装成功， 访问Django-admin界面， 在浏览器中输入127.0.0.1:8000/admin，看到Django管理，需要输入用户名密码，输入用户名密码后可以跳转到Django管理页面表示Django-admin设置成功 ","date":"2019-04-20","objectID":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:2:2","tags":["博客","Django"],"title":"Django2.x搭建博客","uri":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Django"],"content":"数据库表分析 文章表 字段 类型 备注 id PrimaryKey 主键 title CharField 标题 create_time DateTimeField 创建时间 views PositiveIntegerField 阅读数 summary TextField 摘要 content TextField 内容 category_id ForeignKey 外键，分类id tag_id ManyToManyField 外键，标签id 分类表 字段 类型 备注 id PrimaryKey 主键 name CharField 分类名 标签表 字段 类型 备注 id PrimaryKey 主键 name CharField 标签名 用户表 字段 类型 备注 id PrimaryKey 主键 name CharField 用户名 password CharField 密码 评论表 字段 类型 备注 id PrimaryKey 主键 user_id ManyToManyField 外键，用户名id blog_id ManyToManyField 外键，博客id create_time DateTimeField 创建时间 content TextField 评论内容 Parent_id PositiveIntegerField 父评论id ","date":"2019-04-20","objectID":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:2:3","tags":["博客","Django"],"title":"Django2.x搭建博客","uri":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Django"],"content":"编写模型类代码 根据数据库设计表格完成模型类代码 # DjangoBlog/post/models.py from django.db import models class Category(models.Model): \"\"\"分类\"\"\" name = models.CharField('分类', max_length=100) class Meta: verbose_name = '分类' verbose_name_plural = verbose_name def __str__(self): return self.name class Tags(models.Model): \"\"\"标签\"\"\" name = models.CharField('标签', max_length=100) class Meta: verbose_name = '标签' verbose_name_plural = verbose_name def __str__(self): return self.name class Article(models.Model): \"\"\"博客\"\"\" title = models.CharField('标题', max_length=100) create_time = models.DateTimeField('创建时间', auto_now_add=True) views = models.PositiveIntegerField('阅读数', default=0) summary = models.TextField('摘要') content = models.TextField('内容') category_id = models.ForeignKey(Category, on_delete=models.DO_NOTHING, verbose_name='分类') tag_id = models.ManyToManyField(Tags, verbose_name='标签') class Meta: verbose_name = '文章' verbose_name_plural = '文章' def __str__(self): return self.title class User(models.Model): \"\"\"用户\"\"\" name = models.CharField('用户名', max_length=100) password = models.CharField('密码', max_length=100) class Meta: verbose_name = '用户名' verbose_name_plural = verbose_name def __str__(self): return self.name class Comment(models.Model): \"\"\"评论\"\"\" user = models.ManyToManyField(User, verbose_name='用户') article = models.ManyToManyField(Article, verbose_name='博客') create_time = models.DateTimeField('创建时间', auto_now_add=True) content = models.TextField('内容') Parent_id = models.PositiveIntegerField('父评论id') class Meta: verbose_name = '评论' verbose_name_plural = verbose_name def __str__(self): return self.content 数据库迁移 (DjangoBlogEnv) hls-MacBook-Pro:DjangoBlog hl$ python manage.py makemigrations Migrations for 'blog': blog/migrations/0001_initial.py - Create model Article - Create model Category - Create model Tags - Create model User - Create model Comment - Add field category_id to article - Add field tag_id to article (DjangoBlogEnv) hls-MacBook-Pro:DjangoBlog hl$ python manage.py migrate Operations to perform: Apply all migrations: admin, auth, blog, contenttypes, sessions Running migrations: Applying blog.0001_initial... OK ","date":"2019-04-20","objectID":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:2:4","tags":["博客","Django"],"title":"Django2.x搭建博客","uri":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Django"],"content":"用django-admin管理 数据库迁移完成会在post应用下生成一个迁移的文件，接下来在django-admin中注册模型，便于我们用django-admin管理 /post/admin.py from django.contrib import admin from .models import Article, Category, Tags, User, Comment @admin.register(Article) class ArticleAdmin(admin.ModelAdmin): # 在后台显示的字段 list_display = ('id', 'title', 'create_time', 'category_id', 'views') # 分页的个数 list_per_page = 10 # 按时间倒序排序 ordering = ('-create_time',) # 点击修改的字段 list_display_links = ('id', 'title') @admin.register(Category) class CategoryAdmin(admin.ModelAdmin): list_display = ('id', 'name') @admin.register(Tags) class TagsAdmin(admin.ModelAdmin): list_display = ('id', 'name') @admin.register(User) class UserAdmin(admin.ModelAdmin): list_display = ('id', 'name', 'password') @admin.register(Comment) class CommentAdmin(admin.ModelAdmin): list_display = ('id', 'content', 'create_time') 登陆Django管理后台，查看模型是否可以被管理，尝试点击添加与修改，没问题就说明注册成功 ","date":"2019-04-20","objectID":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:2:5","tags":["博客","Django"],"title":"Django2.x搭建博客","uri":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Django"],"content":"集成Markdown 很多人喜欢用markdown格式写博客，我们可以通过集成Django-mdeditor 来实现这个功能 1.安装django-mdeditor pip install django-mdeditor 2.在apps中注册 INSTALLED_APPS = [ ... 'mdeditor', ] 3.在media下创建editor文件夹 cd media mkdir editor 4.集成到路由中 /blog/urls.py from django.conf.urls import url, include from django.conf.urls.static import static from django.conf import settings ... urlpatterns = [ ... url(r'mdeditor/', include('mdeditor.urls')) ] if settings.DEBUG: # static files (images, css, javascript, etc.) urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT) 5.集成到models中 from mdeditor.fields import MDTextField class Article(models.Model): ... content = MDTextField() ... 再次进入admin，选择文章修改就可以看到集成的markdown编辑器了 ","date":"2019-04-20","objectID":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:2:6","tags":["博客","Django"],"title":"Django2.x搭建博客","uri":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Django"],"content":"实现视图 首先找到一套你喜欢的模版，将模版下载下来，html部分放入templates中，其他静态文件放入static中 将重复出现的部分提取出来，这个根据自己的模版抽取，每个都不相同，静态文件加载 如果一次没有提取好，可以慢慢一点点的抽取，对于一个后端程序员来说这个是一个慢工出细活的过程.可以写一个简单的视图，然后开着Django一边抽取一遍调试 接下来实现首页试图 首先在urls.py中配置路由 DjangoBlog/u rls.py ... from blog import views urlpatterns = [ ... path('', views.index, name='index') ] 这里path里第一个参数为访问的url，匹配采用正则表达式，第二个参数为视图函数，第三个为取的名字 接下来在blog应用的views.py中编写视图函数 blog/views.py ... def index(request): return render(request, 'index.html') 这样当我们重新访问127.0.0.1:8000时，我们修改的前端代码就被加载了 接下来我们实现将分类加载,将index视图修改为一下代码 blog/views.py ... from .models import Category # 从models里导入Category类 def index(request): categorys = Category.objects.all() # 把查询出来的分类封装到上下文里 context = { 'categorys': categorys, } print(context) return render(request, 'index.html', context) 在前端代码中渲染，我们找到base.html,将ul标签中的除首页以外的代码改为一下代码 \u003cheader class=\"header-navigation\" id=\"header\"\u003e \u003cnav\u003e \u003cdiv class=\"logo\"\u003e\u003ca href=\"/\"\u003e胡亮个人博客\u003c/a\u003e\u003c/div\u003e \u003ch2 id=\"mnavh\"\u003e\u003cspan class=\"navicon\"\u003e\u003c/span\u003e\u003c/h2\u003e \u003cul id=\"starlist\"\u003e \u003cli\u003e\u003ca href=\"index.html\"\u003e首页\u003c/a\u003e\u003c/li\u003e \u003c/ul\u003e \u003c/nav\u003e \u003c/header\u003e 这样分类栏就加载出来了，如果没有数据可以通过admin添加数据 ","date":"2019-04-20","objectID":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:2:7","tags":["博客","Django"],"title":"Django2.x搭建博客","uri":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Django"],"content":"Django配置文件详解","date":"2019-04-13","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E6%A8%A1%E6%9D%BF/","tags":["Django","教程"],"title":"Django基础教程之模板","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E6%A8%A1%E6%9D%BF/"},{"categories":["Django"],"content":"声明：以下内容均为我个人的理解，如果发现错误或者疑问可以联系我共同探讨 本教程为Django基础教程系列第六篇，前面篇章在以下链接： Django基础教程之Django介绍 Django基础教程之工程搭建 Django基础教程之配置文件详解 Django基础教程之请求与响应 Django基础教程之类视图与中间件 ","date":"2019-04-13","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E6%A8%A1%E6%9D%BF/:0:0","tags":["Django","教程"],"title":"Django基础教程之模板","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E6%A8%A1%E6%9D%BF/"},{"categories":["Django"],"content":"由于发现目前网上有很多大神的教学文章都比较出色，我就不班门弄斧继续出Django相关教程，以后会继续跟大家分享在使用Django中遇到的问题与解决方案，下面推荐几个比较好的学习Django的博客，大家可以根据自己情况选择学习 菜鸟教程 追梦人物的博客 Django中文网 Django官方文档 ","date":"2019-04-13","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E6%A8%A1%E6%9D%BF/:1:0","tags":["Django","教程"],"title":"Django基础教程之模板","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E6%A8%A1%E6%9D%BF/"},{"categories":["Django"],"content":"Django基础教程之类视图与中间件","date":"2019-03-30","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/","tags":["Django","教程"],"title":"Django基础教程之类视图与中间件","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"categories":["Django"],"content":"声明：以下内容均为我个人的理解，如果发现错误或者疑问可以联系我共同探讨 本教程为Django基础教程系列第五篇，前面篇章在以下链接： Django基础教程之Django介绍 Django基础教程之工程搭建 Django基础教程之配置文件详解 Django基础教程之请求与响应 ","date":"2019-03-30","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/:0:0","tags":["Django","教程"],"title":"Django基础教程之类视图与中间件","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"categories":["Django"],"content":"类视图 以函数的方式定义的视图称为函数视图，函数视图便于理解。但是遇到一个视图对应的路径提供了多种不同HTTP请求方式的支持时，便需要在一个函数中编写不同的业务逻辑，代码可读性与复用性都不佳。 在Django中也可以使用类来定义一个视图，称为类视图。使用类视图可以将视图对应的不同请求方式以类中的不同方法来区别定义。 类视图的好处 代码可读性好 类视图相对于函数视图有更高的复用性， 如果其他地方需要用到某个类视图的某个特定逻辑，直接继承该类视图即可 类视图使用 定义类视图需要继承自Django提供的父类View，可使用from django.views.generic import View或者from django.views.generic.base import View 导入 配置路由时，使用类视图的as_view()方法来添加。 ","date":"2019-03-30","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/:1:0","tags":["Django","教程"],"title":"Django基础教程之类视图与中间件","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"categories":["Django"],"content":"类视图原理 类视图使用装饰器 类视图Mixin扩展类 ","date":"2019-03-30","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/:1:1","tags":["Django","教程"],"title":"Django基础教程之类视图与中间件","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"categories":["Django"],"content":"中间件 Django中的中间件是一个轻量级、底层的插件系统，可以介入Django的请求和响应处理过程，修改Django的输入或输出。中间件的设计为开发者提供了一种无侵入式的开发方式，增强了Django框架的健壮性。 我们可以使用中间件，在Django处理视图的不同阶段对输入或输出进行干预。 ","date":"2019-03-30","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/:2:0","tags":["Django","教程"],"title":"Django基础教程之类视图与中间件","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"categories":["Django"],"content":"中间件的定义方法 定义一个中间件工厂函数，然后返回一个可以别调用的中间件。 中间件工厂函数需要接收一个可以调用的get_response对象。 返回的中间件也是一个可以被调用的对象，并且像视图一样需要接收一个request对象参数，返回一个response对象。 定义好中间件后，需要在settings.py 文件中添加注册中间件 ","date":"2019-03-30","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/:2:1","tags":["Django","教程"],"title":"Django基础教程之类视图与中间件","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"categories":["Django"],"content":"多个中间件的执行顺序 在请求视图被处理前，中间件由上至下依次执行 在请求视图被处理后，中间件由下至上依次执行 ","date":"2019-03-30","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/:2:2","tags":["Django","教程"],"title":"Django基础教程之类视图与中间件","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"categories":["Django"],"content":"Django基础教程之Django介绍 Django基础教程之工程搭建 Django基础教程之配置文件详解 声明：以下内容均为我个人的理解，如果发现错误或者疑问可以联系我共同探讨 本教程为Django基础教程系列第四篇，前面篇章在以下链接： Django基础教程之Django介绍 Django基础教程之工程搭建 Django基础教程之配置文件详解 ","date":"2019-03-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/:0:0","tags":["Django","教程"],"title":"Django基础教程之请求与响应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/"},{"categories":["Django"],"content":"前言 在Django基础教程之工程搭建中，视图相关部分提到过Django中视图的功能是接受请求，进行业务处理，返回响应。今天就来研究一下Django中的请求与相应部分。 ","date":"2019-03-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/:1:0","tags":["Django","教程"],"title":"Django基础教程之请求与响应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/"},{"categories":["Django"],"content":"请求 利用HTTP协议向服务器传参有几种途径？ 提取URL的特定部分，可以通过服务器端路由中用正则表达式截取； 查询字符串（query string)； 请求体（body）中发送的数据，比如表单数据、json、xml； 在http报文的头（header）中。 ","date":"2019-03-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/:2:0","tags":["Django","教程"],"title":"Django基础教程之请求与响应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/"},{"categories":["Django"],"content":"URL路径参数 在定义路由URL时，可以使用正则表达式提取参数的方法从URL中获取请求参数，Django会将提取的参数直接传递到视图的传入参数中。 未命名参数按定义顺序传递， 如 url(r'^weather/([a-z]+)/(\\d{4})/$', views.weather), def weather(request, city, year): print('city=%s' % city) print('year=%s' % year) return HttpResponse('OK') 命名参数按名字传递，如 url(r'^weather/(?P\u003ccity\u003e[a-z]+)/(?P\u003cyear\u003e\\d{4})/$', views.weather), def weather(request, year, city): print('city=%s' % city) print('year=%s' % year) return HttpResponse('OK') ","date":"2019-03-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/:2:1","tags":["Django","教程"],"title":"Django基础教程之请求与响应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/"},{"categories":["Django"],"content":"QueryDict对象 与python字典不同，QueryDict类型的对象用来处理同一个键带有多个值的情况，HttpRequest对象的属性GET、POST都是QueryDict类型的对象 get方法：根据键获取值，如果一个键同时拥有多个值将获取最后一个值，如果键不存在则返回None值，可以设置默认值进行后续处理 getlist方法：根据键获取值，值以列表返回，可以获取指定键的所有值，如果键不存在则返回空列表，可以设置默认值进行后续处理 ","date":"2019-03-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/:2:2","tags":["Django","教程"],"title":"Django基础教程之请求与响应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/"},{"categories":["Django"],"content":"查询字符串Query String 获取请求路径中的查询字符串参数，可以通过request.GET属性获取，返回QueryDict对象。查询字符串不区分请求方式，即假使客户端进行POST方式的请求，依然可以通过request.GET获取请求中的查询字符串数据。 ","date":"2019-03-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/:2:3","tags":["Django","教程"],"title":"Django基础教程之请求与响应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/"},{"categories":["Django"],"content":"请求体 请求体数据格式不固定，可以是表单类型字符串，可以是JSON字符串，可以是XML字符串，应区别对待。 可以发送请求体数据的请求方式有POST、PUT、PATCH、DELETE。 Django默认开启了CSRF防护，会对上述请求方式进行CSRF防护验证，在测试时可以关闭CSRF防护机制，方法为在settings.py文件中注释掉CSRF中间件 ","date":"2019-03-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/:2:4","tags":["Django","教程"],"title":"Django基础教程之请求与响应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/"},{"categories":["Django"],"content":"表单 Form Data 前端发送的表单类型的请求体数据，可以通过request.POST属性获取，返回QueryDict对象。request.POST只能用来获取POST方式的请求体表单数据。 ","date":"2019-03-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/:2:5","tags":["Django","教程"],"title":"Django基础教程之请求与响应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/"},{"categories":["Django"],"content":"非表单类型 Non-Form Data 非表单类型的请求体数据，Django无法自动解析，可以通过request.body属性获取最原始的请求体数据，自己按照请求体格式（JSON、XML等）进行解析。request.body返回bytes类型。 ","date":"2019-03-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/:2:6","tags":["Django","教程"],"title":"Django基础教程之请求与响应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/"},{"categories":["Django"],"content":"请求头 可以通过request.META属性获取请求头headers中的数据，request.META为字典类型。 常见的请求头如： CONTENT_LENGTH – 请求体的长度。 CONTENT_TYPE – 请求体的类型。 HTTP_ACCEPT – 响应的可接受内容类型。 HTTP_ACCEPT_ENCODING – 可接受的响应码。 HTTP_ACCEPT_LANGUAGE – 响应的可接受语言。 HTTP_HOST – 客户端发送的HTTP主机报头。 HTTP_REFERER – 参考页面。 HTTP_USER_AGENT – 客户机的用户代理字符串。 QUERY_STRING – 查询字符串，作为单个(未解析的)字符串。 REMOTE_ADDR – 客户端的IP地址。 REMOTE_HOST – 客户机的主机名。 REMOTE_USER – Web服务器认证的用户。 REQUEST_METHOD – 请求方式字符串，如\"GET\"或\"POST”。 SERVER_NAME – 服务器的主机名。 SERVER_PORT – 服务器的端口。 ","date":"2019-03-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/:2:7","tags":["Django","教程"],"title":"Django基础教程之请求与响应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/"},{"categories":["Django"],"content":"其他常用HttpRequest对象属性 method：一个字符串，表示请求使用的HTTP方法，常用值包括：‘GET’、‘POST’。 user：请求的用户对象。 path：一个字符串，表示请求的页面的完整路径，不包含域名和参数部分。 encoding：一个字符串，表示提交的数据的编码方式。 如果为None则表示使用浏览器的默认设置，一般为utf-8。 这个属性是可写的，可以通过修改它来修改访问表单数据使用的编码，接下来对属性的任何访问将使用新的encoding值。 FILES：一个类似于字典的对象，包含所有的上传文件。 ","date":"2019-03-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/:2:8","tags":["Django","教程"],"title":"Django基础教程之请求与响应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/"},{"categories":["Django"],"content":"响应 视图在接收请求并处理后，必须返回HttpResponse对象或子对象。HttpRequest对象由Django创建，HttpResponse对象由开发人员创建。 ","date":"2019-03-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/:3:0","tags":["Django","教程"],"title":"Django基础教程之请求与响应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/"},{"categories":["Django"],"content":"HttpResponse 可以使用django.http.HttpResponse来构造响应对象。也可通过HttpResponse对象属性来设置响应体、状态码： content：表示返回的内容。 status_code：返回的HTTP响应状态码。 响应头可以直接将HttpResponse对象当做字典进行响应头键值对的设置 ","date":"2019-03-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/:3:1","tags":["Django","教程"],"title":"Django基础教程之请求与响应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/"},{"categories":["Django"],"content":"HttpResponse子类 Django提供了一系列HttpResponse的子类，可以快速设置状态码 HttpResponseRedirect 301 HttpResponsePermanentRedirect 302 HttpResponseNotModified 304 HttpResponseBadRequest 400 HttpResponseNotFound 404 HttpResponseForbidden 403 HttpResponseNotAllowed 405 HttpResponseGone 410 HttpResponseServerError 500 ","date":"2019-03-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/:3:2","tags":["Django","教程"],"title":"Django基础教程之请求与响应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/"},{"categories":["Django"],"content":"JsonResponse 若要返回json数据，可以使用JsonResponse来构造响应对象，作用： 帮助我们将数据转换为json字符串 设置响应头Content-Type为 application/json ","date":"2019-03-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/:3:3","tags":["Django","教程"],"title":"Django基础教程之请求与响应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/"},{"categories":["Django"],"content":"redirect重定向 ","date":"2019-03-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/:3:4","tags":["Django","教程"],"title":"Django基础教程之请求与响应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/"},{"categories":["Django"],"content":"Cookie Cookie，有时也用其复数形式Cookies，指某些网站为了辨别用户身份、进行session跟踪而储存在用户本地终端上的数据（通常经过加密）。Cookie最早是网景公司的前雇员Lou Montulli在1993年3月的发明。Cookie是由服务器端生成，发送给User-Agent（一般是浏览器），浏览器会将Cookie的key/value保存到某个目录下的文本文件内，下次请求同一网站时就发送该Cookie给服务器（前提是浏览器设置为启用cookie）。Cookie名称和值可以由服务器端开发自己定义，这样服务器可以知道该用户是否是合法用户以及是否需要重新登录等。服务器可以利用Cookies包含信息的任意性来筛选并经常性维护这些信息，以判断在HTTP传输中的状态。Cookies最典型记住用户名。 Cookie是存储在浏览器中的一段纯文本信息，建议不要存储敏感信息如密码，因为电脑上的浏览器可能被其它人使用。 ","date":"2019-03-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/:4:0","tags":["Django","教程"],"title":"Django基础教程之请求与响应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/"},{"categories":["Django"],"content":"Cookie的特点 Cookie以键值对的格式进行信息的存储。 Cookie基于域名安全，不同域名的Cookie是不能互相访问的，如访问itcast.cn时向浏览器中写了Cookie信息，使用同一浏览器访问baidu.com时，无法访问到itcast.cn写的Cookie信息。 当浏览器请求某网站时，会将浏览器存储的跟网站相关的所有Cookie信息提交给网站服务器。 ","date":"2019-03-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/:4:1","tags":["Django","教程"],"title":"Django基础教程之请求与响应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/"},{"categories":["Django"],"content":"设置Cookie 可以通过HttpResponse对象中的set_cookie方法来设置cookie。 ","date":"2019-03-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/:4:2","tags":["Django","教程"],"title":"Django基础教程之请求与响应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/"},{"categories":["Django"],"content":"读取Cookie 可以通过HttpRequest对象的COOKIES属性来读取本次请求携带的cookie值。request.COOKIES为字典类型。 ","date":"2019-03-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/:4:3","tags":["Django","教程"],"title":"Django基础教程之请求与响应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/"},{"categories":["Django"],"content":"Session **Django项目默认启用Session。**如需禁用session，将上图中的session中间件注释掉即可。 ","date":"2019-03-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/:5:0","tags":["Django","教程"],"title":"Django基础教程之请求与响应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/"},{"categories":["Django"],"content":"存储方式 在settings.py文件中，可以设置session数据的存储方式，可以保存在数据库、本地缓存等。 数据库 存储在数据库中，如下设置可以写，也可以不写，这是默认存储方式。 SESSION_ENGINE='django.contrib.sessions.backends.db' 如果存储在数据库中，需要在项INSTALLED_APPS中安装Session应用。 INSTALLED_APPS = [ ... 'django.contrib.sessions', ... ] 存储在数据库中会生成一个diango_session的表，表结构为：键、值、过期时间 本地缓存 存储在本机内存中，如果丢失则不能找回，比数据库的方式读写更快。 SESSION_ENGINE='django.contrib.sessions.backends.cache' 混合存储 优先从本机内存中存取，如果没有则从数据库中存取。 SESSION_ENGINE='django.contrib.sessions.backends.cached_db' Redis 在redis中保存session，需要引入第三方扩展，我们可以使用django-redis来解决。 1） 安装扩展 pip install django-redis 2）配置 在settings.py文件中做如下设置 CACHES = { \"default\": { \"BACKEND\": \"django_redis.cache.RedisCache\", \"LOCATION\": \"redis://127.0.0.1:6379/1\", \"OPTIONS\": { \"CLIENT_CLASS\": \"django_redis.client.DefaultClient\", } } } SESSION_ENGINE = \"django.contrib.sessions.backends.cache\" SESSION_CACHE_ALIAS = \"default\" 注意 如果redis的ip地址不是本地回环127.0.0.1，而是其他地址，访问Django时，可能出现Redis连接错误，如下： 解决方法： 修改redis的配置文件，添加特定ip地址。 Session操作 通过HttpRequest对象的session属性进行会话的读写操作。 1） 以键值对的格式写session。 request.session['键']=值 2）根据键读取值。 request.session.get('键',默认值) 3）清除所有session，在存储中删除值部分。 request.session.clear() 4）清除session数据，在存储中删除session的整条数据。 request.session.flush() 5）删除session中的指定键及值，在存储中只删除某个键及对应的值。 del request.session['键'] 6）设置session的有效期 request.session.set_expiry(value) 如果value是一个整数，session将在value秒没有活动后过期。 如果value为0，那么用户session的Cookie将在用户的浏览器关闭时过期。 如果value为None，那么session有效期将采用系统默认值，默认为两周，可以通过在settings.py中设置SESSION_COOKIE_AGE来设置全局默认值。 ","date":"2019-03-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/:5:1","tags":["Django","教程"],"title":"Django基础教程之请求与响应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/"},{"categories":["Django"],"content":"Django配置文件详解","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"声明：以下内容均为我个人的理解，如果发现错误或者疑问可以联系我共同探讨 本教程为Django基础教程系列第三篇，前面篇章在以下链接： Django基础教程之Django介绍 Django基础教程之工程搭建 ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:0:0","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"简介 学习Django可以从Django配置文件的各项开始，由简入深的了解其作用，从而一步一步学习。本篇文章主要是介绍各项的作用以及如何配置，可以根据需求按需配置。 ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:1:0","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"内容 ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:0","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"绝对路径映射 ABSOLUTE_URL_OVERRIDES 作用：将应用的模型字符串映射到采用模型对象并返回其url，基于get_absolute_url方法。无论实际模型类名称的大小写如何，此设置中使用的模型名称均应全部小写。 ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:1","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"管理员 ADMINS 作用：用于接收代码错误的人员列表，列表中的元素格式为（全名，电子邮箱） ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:2","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"Django项目根路径 BASE_DIR 作用：以项目根路径为基础衍生其他文件 BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) 从内到外一步一步剖析 __file__：返回当前文件 os.path.abspath(__file__)：返回当前文件的绝对路径 os.path.dirname(os.path.abspath(__file__))：返回当前文件的父目录 os.path.dirname(os.path.dirname(os.path.abspath(__file__)))：返回当前文件父目录的父目录 可能这样还不太清楚，将__file__换成settings.py,可以看出来BASE_DIR是manage.py所在的目录，即整个项目的根目录 ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:3","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"秘钥 SECRET_KEY 作用：校验，主要用于表单、session、csrf SECRET_KEY = \"adsasdasdsafdasfldasfklasdlfnlasdnfklnasdfklnasldfklkdasf\" ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:4","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"调试模式 DEBUG 作用：当开启时，运行出现bug会在前端直接显示，开发，测试过程可以开启 DEBUG = True ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:5","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"允许访问的主机 ALLOWED_HOSTS 作用：在开发的时候可以使用*，当项目上线后需要更换为指定的主机(域名和ip都可以) ALLOWED_HOSTS = [] ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:6","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"应用、模块注册 INSTALLED_APPS 作用：将独立的应用或模块接入Django（注意应用名称或者模块名称必须是唯一的） INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', ] 通常INSTALLED_APPS默认包含以下Django自带的应用 django.contrib.admin：管理员站点，可以通过admin管理项目（数据、用户、权限等），使用admin必须完成以下配置 他依赖django.contrib.auth、django.contrib.contenttypes、django.contrib.sessions、django.contrib.messages四个模块 MIDDLEWARE设置必须包括 django.contrib.auth.middleware.AuthenticationMiddleware并且django.contrib.messages.middleware.MessageMiddleware 在项目url配置中必须加入admin urls.py from django.contrib import admin from django.urls import path urlpatterns = [ path('admin/', admin.site.urls), ] 可以使用django-admin createsuperuser创建管理员用户 django.contrib.auth：认证授权系统。主要负责校验用户信息与用户权限，由以下部分组成 用户：用户管理 权限：以二进制的形式标识指定用户是否可以执行的特殊任务 组：管理多个用户的权限 可配置的密码哈希话系统 为登录用户或限制内容提供表单和视图工具 可插拔的后端系统 需要注意的是它不提供密码强度检查、限制登录尝试、第三方身份验证，对象级权限 django.contrib.contenttypes：内容类型框架,他可以跟踪Django驱动的项目中安装的所有模型，为模型提供高级的通用界面 django.contrib.sessions：会话框架 django.contrib.messages：消息框架 staticfiles：管理静态文件框架 除了这些常见的自带应用外，在我们使用自己注册的应用和第三方模块时，记得第一时间来这里注册，否则会用不了哦 ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:7","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"中间件 MIDDLEWARE 作用：中间件是Django请求/响应处理的钩子框架，用于改变Django的输入或输出 中间件可以放在Python路径上的任何地方，可以自己编写中间件，中间件可以是函数也可以是类。 函数形式的中间件 def simple_middleware(get_response): # 首次配置和初始化 def middleware(request): # 每个请求之前或调用视图函数之前执行的代码 response = get_response(request) # 每个响应、请求或者调用视图函数之后执行的代码 return response return middleware 类形式的中间件 def __init__(self, get_response): self.get_response = get_response # 首次配置和初始化 def __call__(self, request): # 每个请求之前或调用视图函数之前执行的代码 response = self.get_response(request) # 每个响应、请求或者调用视图函数之后执行的代码 return response 上述方法中调用get_response方法并不是实际视图中的，而是处理程序的包装方法，它负责应用视图中间件，调用具有适当的URL参数的视图，并应用模板响应和第三方中间件。 在使用类形式的中间件时，__init__方法必须接受get_response参数，还可以初始化中间件的一些局部状态。 想使用中间件就必须在settings.py文件中的MIDDLEWARE中激活。激活的方式是使用字符串表示指向中间件完整的Python路径 在Django中MIDDLEWARE可以为空，但是强烈建议至少激活CommonMiddleware 由于某些中间件也会依赖其他中间件所以中间件在MIDDLEWARE中的顺序很重要，Django会按自上而下的顺序调用中间件 ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:8","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"路由根路径 ROOT_URLCONF 作用：Django在处理请求时会最先从此处寻找url 需要注意的是，此处的路径是基于BASE_DIR的路径 ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:9","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"模板引擎配置 TEMPLATES 作用：在Django中使用模板引擎的设置列表，列表中每个元素都是一个字典，字典里配置模板引擎 常用的配置参数： BACKEND：项目使用的模板引擎，Django内置了两个 django.template.backends.django.DjangoTemplates django.template.backends.jinja2.Jinja2 DIRS：模板文件夹的位置 APP_DIRS：模板引擎是否在已安装的应用中讯在模板源文件 OPTIONS：传给后端模板的额外参数 ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:10","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"内置服务器的路径 WSGI_APPLICATION 作用：用于调式Django程序的内置服务器， ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:11","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"数据库配置 DATABASES 在mysite/mysite/settings.py中，默认的数据库为SQLite，还支持PostgreSQL、mysql、oracle等其他第三方（这些非官方后端支持的Django版本和ORM功能差异很大。有关这些非官方后端的具体功能的查询以及任何支持查询，应该针对每个第三方项目提供的支持渠道） DATABASES = { 'default': { 'ENGINE': 'django.db.backends.sqlite3', 'NAME': os.path.join(BASE_DIR, 'db.sqlite3'), } } ENGINE，数据库引擎，可选的ENGINE还有 django.db.backends.postgresql、django.db.backends.mysql、django.db.backends.oracle、第三方数据库 NAME，数据库名称，如果使用SQLite,他会在根目录生成一个数据库文件 当不使用SQLite时，还会有一下常用参数，其他参数可以查阅文档DATABASES NAME：数据库名字 USER：数据库的用户名 PASSWORD：数据库的密码 HOST：数据库的主机 PORT：数据库的端口 OPTIONS：连接到数据库时要使用的其他参数。可用参数取决于数据库后端。 TEST：测试数据库 测试数据库也具备一些设置，也是采用键值对的方式对数据库进行设置 CHARSET：创建测试数据库时使用的字符集编码 COLLATION：创建测试数据库时使用的排序规则 DEPENDENCIES：数据库的创建顺序依耐性 MIRROR：测试期间该数据库应镜像的数据库别名。 NAME：运行测试套件时要使用的数据库的名称。 SERIALIZE：一个布尔值，用于控制默认测试运行程序在运行测试之前是否将数据库序列化为内存中的JSON字符串。False如果没有任何带有测试类，可以将其设置为加快创建时间。 TEMPLATE：PostgreSQL的特定设置。从中创建测试数据库的模板（例如'template0'）的名称。 CREATE_DB：默认为True，Oracle特定的设置。如果将其设置为False，则测试表空间将不会在测试开始时自动创建，也不会在测试结束时自动删除。 CREATE_USER：默认为True，Oracle特定的设置。如果将其设置为False，则不会在测试开始时自动创建测试用户，并在测试结束时自动将其删除。 USER：默认为None，Oracle特定的设置。连接到运行测试时将使用的Oracle数据库时使用的用户名。如果未提供，则Django将使用。'test_' + USER PASSWORD：默认为None，Oracle特定的设置。连接到运行测试时将使用的Oracle数据库的密码。如果未提供，Django将生成一个随机密码。 TBLSPACE：默认为None，Oracle特定的设置。运行测试时将使用的表空间的名称。如果未提供，则Django将使用。'test_' + USER TBLSPACE_TMP：默认为None，Oracle特定的设置。运行测试时将使用的临时表空间的名称。如果未提供，则Django将使用。'test_' + USER + '_temp' DATAFILE：默认为None，这是Oracle特定的设置。用于TBLSPACE的数据文件的名称。如果未提供，则Django将使用。TBLSPACE + '.dbf' DATAFILE_TMP：默认为None，Oracle特定的设置。用于TBLSPACE_TMP的数据文件的名称。如果未提供，则Django将使用。TBLSPACE_TMP + '.dbf' DATAFILE_MAXSIZE：默认为500M，Oracle特定的设置。允许DATAFILE增大到的最大大小。 DATAFILE_TMP_MAXSIZE：默认为500M，Oracle特定的设置。DATAFILE_TMP允许增加到的最大大小。 DATAFILE_SIZE：默认为50M，Oracle特定的设置。DATAFILE的初始大小。 DATAFILE_TMP_SIZE：默认为50M，Oracle特定的设置。DATAFILE_TMP的初始大小。 DATAFILE_EXTSIZE：默认为25M，Oracle特定的设置。需要更多空间时，DATAFILE_TMP的扩展量。 其他的配置： ATOMIC_REQUESTS：默认为False，当设置为True时将每个视图包装在该数据库的事务中 AUTOCOMMIT:默认为True，当设置为False时警用Django的事务管理，可以自己编写事务管理机制 CONN_MAX_AGE：数据库连接的生存期，以秒为单位。用于0在每个请求结束时关闭数据库连接-Django的历史行为-并 None用于无限的持久连接。 TIME_ZONE：默认为None，用一个字符串表示存储在此数据库中的时区 ​ ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:12","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"数据库路由器列表 DATABASE_ROUTERS 作用：执行数据库查询时将用来确定要使用哪个数据库的路由器列表。 ​ ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:13","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"阈值检查 DATA_UPLOAD_MAX_NUMBER_FIELDS 作用：调用SuspiciousOperation检查GET或POST接受的最大值，当设为None时禁用检查 ​ ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:14","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"显示日期的默认格式 DATE_FORMAT 作用：在任何地方显示日期字段的默认格式。 ​ ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:15","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"密码强度列表 AUTH_PASSWORD_VALIDATORS 作用：用于检查用户密码强度的验证器列表 ​ ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:16","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"语言 LANGUAGE_CODE 作用：项目语言，默认为‘en-us’ ​ ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:17","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"时区 TIME_ZONE 作用：一个字符串表达的时区默认为’UTC’ ​ ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:18","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"翻译系统 USE_I18N 作用：指定是否启用Django的翻译系统，默认为True ​ ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:19","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"本地化 USE_L10N 作用：指定默认情况下是否启用数据本地化格式，默认为True ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:20","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"时区 USE_TZ 作用：指定日期时间默认情况下是否支持时区 ​ ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:21","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"静态文件夹的路径 STATIC_URL 作用：引用位于静态文件时使用的URL ​ ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:22","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"静态文件的绝对路径 STATIC_ROOT 作用：在部署时收集静态文件的绝对路径 ​ ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:23","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"Django介绍","date":"2019-03-09","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/","tags":["Django","教程"],"title":"Django基础教程之工程搭建","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/"},{"categories":["Django"],"content":"声明：以下内容均为我个人的理解，如果发现错误或者疑问可以联系我共同探讨 本教程为Django基础教程系列第二篇，前面篇章在以下链接： Django基础教程之Django介绍 ","date":"2019-03-09","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/:0:0","tags":["Django","教程"],"title":"Django基础教程之工程搭建","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/"},{"categories":["Django"],"content":"简介 每个工程项目的开始阶段往往决定了项目的大致走向，在工程搭建的过程中要为后面的项目开发做好准备。 为了不受Python环境的影响，最好建立虚拟环境，在虚拟环境中搭建项目 ","date":"2019-03-09","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/:1:0","tags":["Django","教程"],"title":"Django基础教程之工程搭建","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/"},{"categories":["Django"],"content":"教程 ","date":"2019-03-09","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/:2:0","tags":["Django","教程"],"title":"Django基础教程之工程搭建","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/"},{"categories":["Django"],"content":"安装环境 安装virtualenv virtualenv是一个用于创建Python虚拟环境的工具包，可以通过pip直接安装 pip3 install virtualenv 创建虚拟环境 virtualenv --python=/usr/bin/python3 django2.2.2_py3 django2.2.2_py3为虚拟环境的名字，这里是以Django的版本+Python版本命名，–python指定了Python的位置。 激活虚拟环境 source django2.2.2_py3/bin/activate 激活完成后会在命令行最前面显示当前的虚拟环境名 安装Django 本教程使用django2.2.2版本 pip install django==2.2.2 ","date":"2019-03-09","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/:2:1","tags":["Django","教程"],"title":"Django基础教程之工程搭建","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/"},{"categories":["Django"],"content":"项目工程 在Django中，项目的工程目录可以通过Django提供的命令来创建。 创建 创建工程的命令为： django-admin startproject 工程名称 例如你想在做面食创建一个demo的工程项目，可以执行如下命令： cd ~/Desktop/ django-admin startproject demo 执行完毕后，会在当前目录即Desktop目录下生成一个名为demo的目录，该目录存放着整个Django工程 工程目录说明 查看创建的工程目录，结构如下 (django2.2.2_py3) ~/Desktop/demo$ tree . |-- demo | |-- __init__.py | |-- settings.py | |-- urls.py | `-- wsgi.py `-- manage.py 1 directory, 5 files demo：与项目同名的目录，存放项目相关文件。 settings.py：项目的配置文件。 urls.py：项目的总URL配置文件。 wsgi.py：项目与WSGI兼容的Web服务器入口。 manage.py 项目管理文件，通过它管理项目，同时也是启动项目的入口。 运行开发服务器 在开发阶段，为了能够快速预览到开发的效果，Djnago提供了一个纯python编写的轻量级web服务器，提供开发阶段使用。 运行服务器命令如下： python manage.py runserver 默认IP是127.0.0.1，默认端口为8000，可以写指定IP与端口，格式为：ip:端口 启动后可以看到以下信息 (django2.2.2_py3) ~/Desktop/demo$ python manage.py runserver Watching for file changes with StatReloader Performing system checks... System check identified no issues (0 silenced). You have 17 unapplied migration(s). Your project may not work properly until you apply the migrations for app(s): admin, auth, contenttypes, sessions. Run 'python manage.py migrate' to apply them. February 17, 2019 - 05:29:56 Django version 2.2.2, using settings 'demo.settings' Starting development server at http://127.0.0.1:8000/ Quit the server with CONTROL-C. 在浏览器中输入网址“127.0.0.1:8000”便可看到效果。 django默认工作在调式Debug模式下，如果增加、修改、删除文件，服务器会自动重启。 按ctrl+c停止服务器。 ","date":"2019-03-09","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/:2:2","tags":["Django","教程"],"title":"Django基础教程之工程搭建","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/"},{"categories":["Django"],"content":"应用 在Web开发中通常一个大型项目是由无数个应用构成的。将开发中的工程项目拆分成不同的功能模块，可以让各功能模块之间保持相对独立，更利于我们开发与管理。 创建 Django为我们提供了创建应用的命令，创建应用的命令为： python manage.py startapp 子应用名称 需要注意的是，创建应用时必须在manage.py所在的目录下 现在创建一个用户相关的应用users，可以执行： python manage.py startapp users 执行后，可以看到工程目录中多出了一个名为users的子目录。 应用目录说明 (django2.2.2_py3) ~/Desktop/demo$ ls db.sqlite3 demo manage.py users (django2.2.2_py3) ~/Desktop/demo$ tree . |-- db.sqlite3 |-- demo | |-- __init__.py | |-- __pycache__ | | |-- __init__.cpython-36.pyc | | |-- settings.cpython-36.pyc | | |-- urls.cpython-36.pyc | | `-- wsgi.cpython-36.pyc | |-- settings.py | |-- urls.py | `-- wsgi.py |-- manage.py `-- users |-- __init__.py |-- admin.py |-- apps.py |-- migrations | `-- __init__.py |-- models.py |-- tests.py `-- views.py 4 directories, 17 files admin.py：后台管理配置信息。 apps.py：配置信息。 migrations 存放数据库迁移历史文件。 models.py：保存数据库模型类。 tests.py：用于开发测试用例，编写单元测试。 注册应用 创建完应用后Django并不能自动将项目与应用联系起来，需要我们在工程配置文件settings.py中注册才能使用。 在工程配置文件settings.py中的INSTALLED_APPS项负责注册安装好的应用，初始工程中的INSTALLED_APPS如下： 这些默认应用的作用可以看这篇文章：Django配置文件详解 注册一个应用的方法是将应用的配置信息文件apps.py中的Config类添加到INSTALLED_APPS列表中。 例如，注册刚创建的users应用，可在INSTALLED_APPS列表中添加**‘users.apps.UsersConfig’**。 创建视图 视图用于编写应用的业务逻辑，Django的视图是在应用中views.py中的 进入users应用，在views.py中编写视图代码。 from django.http import HttpResponse def index(request): \"\"\" 视图index :param request: 包含了请求信息的请求对象 :return: 响应对象 \"\"\" return HttpResponse(\"hello Django\") 说明： Django基础教程之Django介绍中提到过，Django中视图的功能是接受请求，进行业务处理，返回响应。在这里request是接受请求的对象，业务处理是生成hello Django字符串，而HttpResponse是返回响应的对象。 ","date":"2019-03-09","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/:2:3","tags":["Django","教程"],"title":"Django基础教程之工程搭建","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/"},{"categories":["Django"],"content":"路由 什么是路由 在Django中，路由是将请求的URL分发给视图的系统。 路由定义的位置 一般情况下会有两种路由定义的位置，一种是项目工程的urls.py中，一种是每个应用下的urls.py中。项目工程的urls.py是Django解析路由的入口 路由解析顺序 Django在接收到请求时会先从项目工程urls.py中的urlpatterns列表中从上至下的顺序查找对应路由规则，如果发现规则为include包含，则再进入被包含的urls中的urlpatterns列表由上至下进行查询。 路由命名 在定义路由的时候，可以为路由命名，方便查找特定视图的具体路径信息。 在定义include函数定义路由时，可以使用namespace参数定义路由的命名空间，如 url(r'^users/', include('users.urls', namespace='users')), 命名空间表示，凡是users.urls中定义的路由，均属于namespace指明的users名下。 命名空间的作用：避免不同应用中的路由使用了相同的名字发生冲突，使用命名空间区别开。 在定义普通路由时，可以使用name参数指明路由的名字，如 urlpatterns = [ url(r'^index/$', views.index, name='index'), ] 路径结尾斜线的说明 Django中定义路由时，通常以斜线结尾，其好处是用户访问不以斜线结尾的相同路径时，Django会把用户重定向到以斜线/结尾的路径上，而不会返回404不存在。如 urlpatterns = [ url(r'^index/$', views.index, name='index'), ] 用户访问 index 或者 index/ 网址，均能访问到index视图。 虽然路由结尾带斜线能带来上述好处，但是却违背了HTTP中URL表示资源位置路径的设计理念。具体是否结尾带斜线以个人风格为准。 接下来我们要通过路由将工程-\u003e应用-\u003e视图给联系起来 首先在工程的总路由中添加users应用的路由信息 from django.contrib import admin + from django.urls import path, include urlpatterns = [ path('admin/', admin.site.urls), + path('users/', include('users.urls')), ] 说明： ‘users/‘表示所有/users/开头的请求 include表示以/users/匹配到users应用中urls.py的所有路由，即只要请求的URL是/users/开头都会去users应用中的urls.py中匹配剩下的路由。 将总路由引到users应用后，需要修改users应用中urls.py的信息 from django.conf.urls import url,re_path from . import views # urlpatterns是被django自动识别的路由列表变量 urlpatterns = [ # re_path是通过正则表达式来构造路由 # re_path(路由正则表达式，视图) re_path(r'^index/$', views.index), ] 说明： 现在完整的请求url为：/users/index/ 路由修改完成后，重启Django程序，就可以在浏览器中看到返回的信息了 ","date":"2019-03-09","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/:2:4","tags":["Django","教程"],"title":"Django基础教程之工程搭建","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/"},{"categories":["Django"],"content":"Django初体验","date":"2019-03-02","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/","tags":["Django","教程"],"title":"Django基础教程之初体验","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["Django"],"content":"声明：以下内容均为我个人的理解，如果发现错误或者疑问可以联系我共同探讨 ","date":"2019-03-02","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/:0:0","tags":["Django","教程"],"title":"Django基础教程之初体验","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["Django"],"content":"简介 在Django2.0以后，Django已经不支持python2.7，所以我们需要一个python3的系统环境，这里一python3.6为例 ","date":"2019-03-02","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/:1:0","tags":["Django","教程"],"title":"Django基础教程之初体验","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["Django"],"content":"安装Django ","date":"2019-03-02","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/:2:0","tags":["Django","教程"],"title":"Django基础教程之初体验","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["Django"],"content":"三种方式安装 pip安装 一般情况下安装python后会帮你安装好pip，当你没安装时使用这个链接安装,记得更新到最新版本 安装并使用virtualenv 在创建好并激活的虚拟环境中输入一下命令 $ pip install Django 通过第三方软件包 管理系统集成的Django 安装开发版本 安装好git 输入一下命令下载Django $ git clone https://github.com/django/django.git 安装并使用virtualenv 在创建好并激活的虚拟环境中输入一下命令 $ pip install -e django/ 安装好Django后可以通过一下命令查看当前Django版本 $ python -m django --version ","date":"2019-03-02","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/:2:1","tags":["Django","教程"],"title":"Django基础教程之初体验","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["Django"],"content":"Django初体验 ","date":"2019-03-02","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/:3:0","tags":["Django","教程"],"title":"Django基础教程之初体验","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["Django"],"content":"安装并使用virtualenv 详细过程见这个链接 ","date":"2019-03-02","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/:3:1","tags":["Django","教程"],"title":"Django基础教程之初体验","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["Django"],"content":"创建Django项目 在项目存放目录打开命令行运行一下命令： $ django-admin startproject mysite 这句话执行过后会在当前目录生成一个名字为mysite的Django项目，目录结构为下 mysite/ manage.py mysite/ __init__.py settings.py urls.py wsgi.py 这些目录和文件的作用： mysite/目录：存放项目的容器，他的名字不重要可以更换为你喜欢的任何名字 manage.py：Django项目的启动文件，他可以让你通过各种方式管理Django项目。 mysite/mysite/目录：项目目录，里面存放项目相关的文件 mysite/mysite/settings.py：Django项目的配置文件 mysite/mysite/urls.py：Django项目的url声明文件,他将url对应相关的app的视图 mysite/mysite/wsgi.py：Django项目wsgi服务器的入口 当输入以下命令，并进入浏览器输入：http://127.0.0.1:8000/看到Django启动成功 $ python manage.py runserver 这里能启动成功是因为Django自带一个简易的服务器（用纯 Python 写的轻量级的 Web 服务器）。他能帮助我们快速开发。 ","date":"2019-03-02","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/:3:2","tags":["Django","教程"],"title":"Django基础教程之初体验","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["Django"],"content":"创建一个应用 将当前目录切换到manage.py所在的目录，输入下面的命令创建一个应用: $ python manage.py startapp demo 该应用的目录结构大致如下 demo/ __init__.py admin.py apps.py migrations/ __init__.py models.py tests.py views.py 这些目录和文件的作用： admin.py：管理admin后台相关数据库模型 apps.py：该应用的相关配置 migrations/文件夹及其内容：数据库迁移相关的文件夹，里面存放着迁移版本，迁移信息等 models.py：编写模型类的文件 tests.py：用于测试的文件 view.py：编写视图的文件 我们还要在项目配置文件中注册该app，打开settings.py文件，找到INSTALLED_APPS，在列表的最后添加demoapp mysite/settings.py INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', # 注册demo 'demo.apps.DemoConfig' ] ","date":"2019-03-02","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/:3:3","tags":["Django","教程"],"title":"Django基础教程之初体验","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["Django"],"content":"编写第一个视图 视图在应用的views.py中编写 demo/views.py from django.http import HttpResponse def index(request): return HttpResponse(\"Hello, world!\") 为了能看到效果我们还需要配置一下url，在demo目录下创建一个urls.py，并输入一下代码 /demo/urls.py from django.urls import path from . import views urlpatterns = [ path(\"\",views.index,name='index'), ] 更改项目url，通过修改项目urls.py文件修改路由 /mysite/urls.py from django.contrib import admin from django.urls import include, path urlpatterns = [ path('demo/', include('demo.urls')), path('admin/', admin.site.urls), ] 这里include是将demo/的路由转发到demo应用的urls.py里。每当 Django 遇到 include时，它会截断与此项匹配的 URL 的部分，并将剩余的字符串发送到 对应urls.py以供进一步处理。 path有五个参数：route、view、kwargs、name、Pattern，其中route、view是必须传入的参数 route：匹配url的准则（类似于正则表达式）。当Django响应一个请求时，他会从urlpatterns的第一项开始，按顺序依次匹配，知道找到匹配的项 view：目标视图函数。当route找到匹配的项后，会调用当前的视图函数，并传入一个HttpRequest对象作为第一个参数，route中的参数一关键字参数的形式传入 kwargs：关键字参数。任意个关键字参数可以作为一个字典传递给目标视图函数。 name：为url取的名字。他可以使Django在任意地方引用他 Pattern：匹配模式 现在可以启动Django程序来看是否正常工作 ","date":"2019-03-02","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/:3:4","tags":["Django","教程"],"title":"Django基础教程之初体验","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["Django"],"content":"数据库 创建数据库 进入mysql并创建一个test数据库，字符设置为utf8 $ mysql -uroot -p mysql\u003e create database test charset=utf8; Query OK, 1 row affected (0.00 sec) 数据库配置 首先我们需要配置mysite/setting.py中的数据库DATABASES选项，Django默认是sqlite数据库，如果个人项目不大的情况下可以使用这个，也可以使用自己熟悉的数据库，Django不仅支持sqlite，postgresql，mysql，或oracle，还支持很多有第三方插件的数据库，我使用mysql数据库 /mysite/settings.py DATABASES = { 'default': { 'ENGINE': 'django.db.backends.mysql', # 数据库名 'NAME': 'test', # 用户名 'USER': 'root', # 密码 'PASSWORD': 'mysql' # 主机,默认为localhost 'HOST': '' # 端口号，默认为3306 'PORT': '' } } 数据库迁移 因为Django自带应用已经为我们编写了一些数据模型，即时我们不编写任何模型也可以直接使用数据库迁移命令进行迁移 $ python manage.py migrate 会看到初始化了很多用户、权限相关的表 创建一个管理员账号，依次输入用户名、邮箱、密码、确认密码，建议密码设置复杂点 $ python manage.py createsuperuser 用户名 (leave blank to use '02'): admin 电子邮件地址: 1@gmail.com Password: Password (again): 密码跟 用户名 太相似了。 密码长度太短。密码必须包含至少 8 个字符。 这个密码太常见了。 Bypass password validation and create user anyway? [y/N]: y Superuser created successfully. 接下来启动项目，并在浏览器中输入http://127.0.0.1:8000/admin，进入后台管理界面 输入账号密码，点击登录即可 数据库迁移，需要三步 编写models.py文件，改变模型。 运行 python manage.py makemigrations为模型的改变生成迁移文件。 运行 python manage.py migrate 来应用数据库迁移。 创建一个图书模型 在demo应用下创建一个图书模型 /demo/models.py from django.db import models class Books(models.Model): # 书名 book_name = models.CharField(max_length=200) # 作者 author = models.CharField(max_length=50) 建立的模型有两个字段，书名和作者，使用了字符类型，增加了长度限制（注意在使用CharField时必须要添加max_length限制） 创建迁移模型并生成迁移文件 $ python manage.py makemigrations demo Migrations for 'demo': demo\\migrations\\0001_initial.py - Create model Books 会出现创建了Books这个模型，在demo应用的migrations文件夹下会多一个0001_initila.py的迁移文件，可以使用python manage.py sqlmigrate demo 0001可以查看这次数据库迁移的操作与具体的SQL语句 $ python manage.py sqlmigrate demo 0001 BEGIN; -- -- Create model Books -- CREATE TABLE `demo_books` (`id` integer AUTO_INCREMENT NOT NULL PRIMARY KEY, `book_name` varchar(200) NOT NULL, `auhtor` varchar(50) NOT NULL); COMMIT; 需要注意一下几点： 输出的内容与使用的数据库有关。 数据库的表名默认是“应用名_模型名的小写”，也可以自定义表名。 主键会默认自动创建，也可以自定义主键。 Django会为使用的数据库定制相关SQL语句，例如主键：integer AUTO_INCREMENT NOT NULL PRIMARY KEY，varchar：NOT NULL sqlmigrate命令并没有真正执行迁移命令，他只是将迁移命令执行的流程输出到屏幕上，供你查看 执行check命令对项目做检查 $ python manage.py check System check identified no issues (0 silenced). 没有问题后执行迁移命令 $ python manage.py migrate Operations to perform: Apply all migrations: admin, auth, contenttypes, demo, sessions Running migrations: Applying demo.0001_initial... OK 看到以上内容即完成了数据库迁移 通过Python命令行尝试 $ python manage.py shell \u003e\u003e\u003e from demo.models import Books \u003e\u003e\u003e ggzh = Books(book_name=\"硅谷之火\",author=\"迈克尔.斯韦因\") \u003e\u003e\u003e ggzh.save() \u003e\u003e\u003e ggzh.id 1 \u003e\u003e\u003e ggzh.book_name '硅谷之火' \u003e\u003e\u003e ggzh.author '迈克尔.斯韦因' \u003e\u003e\u003e Books.objects.all() \u003cQuerySet [\u003cBooks: Books object (1)\u003e]\u003e 这里我们看到\u003cQuerySet [\u003cBooks: Books object (1)\u003e]\u003e这个并不能让我们知道这个对象的细节，通过修改Books模型来修复这个问题 /demo/models.py class Books(models.Model): # 书名 book_name = models.CharField(max_length=200) # 作者 author = models.CharField(max_length=50) def __str__(self): return self.book_name 修改完成后重新进入交互终端，再次查询就可以显示书名了，这里可以自己定义想显示的字段或内容 $ python manage.py shell \u003e\u003e\u003e from demo.models import Books \u003e\u003e\u003e Books.objects.all() \u003cQuerySet [\u003cBooks: 硅谷之火\u003e]\u003e 再添加一本书，聚合函数 \u003e\u003e\u003e qbsz = Books(book_name=\"史蒂夫*乔布斯传\",author=\"沃尔特·艾萨克森\") \u003e\u003e\u003e qbsz.save() \u003e\u003e\u003e Books.objects.all() \u003cQuerySet [\u003cBooks: 硅谷之火\u003e, \u003cBooks: 史蒂夫*乔布斯传\u003e]\u003e \u003e\u003e\u003e Books.objects.count() 2 \u003e\u003e\u003e Books.objects.filter(book_name=\"硅谷之火\") \u003cQuerySet [\u003cBooks: 硅谷之火\u003e]\u003e 接下来我们将Books模型添加到admin管理，通过register方法，将Books交给admin管理 /demo/admin from django.contrib import admin from .models import Books admin.site.register(Books) 重新运行项目，在地址栏输入：http://127.0.0.1:8000/admin/，输入账号密码登录即可查看到这个模型 点进去可以查看该模型的数据，右上角可以添加，动作可以删除，点图书名可以看到更多细节 ","date":"2019-03-02","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/:3:5","tags":["Django","教程"],"title":"Django基础教程之初体验","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["Django"],"content":"视图与模板 在models.py中添加一个图书模型 /demo/models.py from django.db import models class Books(models.Model): # 书名 name = models.CharField('书名', max_length=200) # 作者 author = models.CharField('作者', max_length=50) publish_house = models.CharField('出版社', max_length=50) publish_date = models.CharField('出版日期', max_length=50) price = models.IntegerField('价格') synopsis = models.TextField('简介') def __str__(self): return self.name 在admin.py中注册Books 迁移数据库 在Django后台中添加图书数据 在应用的views.py中编写一个展示图书的视图 /demo/views.py from django.http import HttpResponse from .models import Books def book_list(request): book_list = Books.objects.all() books = {book.name : book.id for book in book_list} return render(request, 'index.html', context={'books': books}) 通过模板渲染 在templates目录下新建一个index.html文件 /tempaltes/index.html \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv\u003e图书管理系统：\u003c/div\u003e \u003cul\u003e \u003c/ul\u003e \u003c/body\u003e \u003c/html\u003e 在项目的urls.py文件中添加一个关于图书的路由 /mysite/urls.py from django.contrib import admin from django.urls import path from demo import views urlpatterns = [ path('admin/', admin.site.urls), path('book/', include('demo.urls')), ] 在demo目录中新建一个urls.py文件，并添加一个路由 /demo/urls.py from django.urls import path from . import views urlpatterns = [ path('', views.book_list, name='index'), ] 启动项目，访问：http://127.0.0.1:8000/book/ 图书列表页完成了，接下来编写图书详情页 在demo项目中的urls.py文件中添加一个详情页的路由 /demo/urls.py from django.urls import path from . import views urlpatterns = [ path('', views.book_list, name='index'), path('\u003cint:id\u003e/', views.detail, name='detail'), ] 在demo项目中的views.py文件中编写详情页相关视图函数 /demo/views.py def detail(request, id): book = Books.objects.filter(id=id).all()[0] content = { \"name\": book.name, \"author\": book.author, 'publish_house': book.publish_house, 'publish_date': book.publish_date, 'price': book.price, 'synopsis': book.synopsis } return render(request, 'detail.html', context=content) 在templates文件夹里新建一个detail.html文件,并写入一下代码 /templates/detail.html \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ctable\u003e \u003ctr\u003e \u003ctd\u003e书名\u003c/td\u003e \u003ctd\u003e作者\u003c/td\u003e \u003ctd\u003e出版社\u003c/td\u003e \u003ctd\u003e出版日期\u003c/td\u003e \u003ctd\u003e价格\u003c/td\u003e \u003ctd\u003e简介\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e{{ name }}\u003c/td\u003e \u003ctd\u003e{{ author }}\u003c/td\u003e \u003ctd\u003e{{ publish_house }}\u003c/td\u003e \u003ctd\u003e{{ publish_date }}\u003c/td\u003e \u003ctd\u003e{{ price }}\u003c/td\u003e \u003ctd\u003e{{ synopsis }}\u003c/td\u003e \u003c/tr\u003e \u003c/table\u003e \u003c/body\u003e \u003c/html\u003e 启动项目，访问：http://127.0.0.1:8000/book/，点击其中一个图书就可以看到详情页，或者直接选择一个id访问详情页，这时候就会出现一个问题，当访问一个不存在的id时就会出错，我们需要定制一下错误页面，修改detail视图函数。 /demo/views.py from django.http import Http404 ... def detail(request, id): books = Books.objects.filter(id=id).all() if len(books): book = books[0] content = { \"name\": book.name, \"author\": book.author, 'publish_house': book.publish_house, 'publish_date': book.publish_date, 'price': book.price, 'synopsis': book.synopsis } return render(request, 'detail.html', context=content) else: raise Http404(\"图书不存在\") 这里调用的是Django自带的404错误页面，我们需要返回错误说明 ","date":"2019-03-02","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/:3:6","tags":["Django","教程"],"title":"Django基础教程之初体验","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["Django"],"content":"Django介绍","date":"2019-02-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BB%8B%E7%BB%8D/","tags":["Django","教程"],"title":"Django基础教程之介绍","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BB%8B%E7%BB%8D/"},{"categories":["Django"],"content":"声明：以下内容均为我个人的理解，如果发现错误或者疑问可以联系我共同探讨 本教程为Django基础教程系列第一篇 ","date":"2019-02-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BB%8B%E7%BB%8D/:0:0","tags":["Django","教程"],"title":"Django基础教程之介绍","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BB%8B%E7%BB%8D/"},{"categories":["Django"],"content":"前言 为什么网上有很多Django的学习资料，我还想自己写一个Django的教程呢，一是想通过写教程发现自己的不足，二是想通过自己的总结让那些想学习Django的小伙伴们少走一些弯路，当然我写的内容有可能也是错的，欢迎大家纠正，我们可以共同探讨，共同进步。 ","date":"2019-02-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BB%8B%E7%BB%8D/:1:0","tags":["Django","教程"],"title":"Django基础教程之介绍","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BB%8B%E7%BB%8D/"},{"categories":["Django"],"content":"简介 Django是一个高级Python Web框架，可以快速开发和简洁实用的设计。Django负责处理网站开发中遇到的问题，编程人员只需要专注于应用编写，无需重新造轮子。它是免费和开源的。 ","date":"2019-02-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BB%8B%E7%BB%8D/:2:0","tags":["Django","教程"],"title":"Django基础教程之介绍","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BB%8B%E7%BB%8D/"},{"categories":["Django"],"content":"特点 ","date":"2019-02-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BB%8B%E7%BB%8D/:3:0","tags":["Django","教程"],"title":"Django基础教程之介绍","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BB%8B%E7%BB%8D/"},{"categories":["Django"],"content":"完备性 Django原生提供了众多的功能组件，对于开发人员来说Django几乎做到了开箱即用。 ","date":"2019-02-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BB%8B%E7%BB%8D/:3:1","tags":["Django","教程"],"title":"Django基础教程之介绍","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BB%8B%E7%BB%8D/"},{"categories":["Django"],"content":"安全 Django认真对待安全性，并帮助开发人员避免许多常见的安全性错误，例如SQL注入，跨站点脚本编写，跨站点请求伪造和点击劫持。其用户身份验证系统提供了一种安全的方式来管理用户帐户和密码。 ","date":"2019-02-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BB%8B%E7%BB%8D/:3:2","tags":["Django","教程"],"title":"Django基础教程之介绍","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BB%8B%E7%BB%8D/"},{"categories":["Django"],"content":"可扩展性 Django强调代码复用，多个组件可以以\"插件\"的形式服务于整个框架，Django还有许多功能强大的第三方插件，你也可以开发自己的工具包。 ","date":"2019-02-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BB%8B%E7%BB%8D/:3:3","tags":["Django","教程"],"title":"Django基础教程之介绍","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BB%8B%E7%BB%8D/"},{"categories":["Django"],"content":"MVT模式 Django采用MVT程序设计模式 M全拼为Model，主要封装对数据库层的访问，对数据库中的数据进行增、删、改、查操作。 V全拼为View，用于接收请求，进行业务处理，返回应答。 T全拼为Template，用于封装结果，负责封装构造要返回的html。 ","date":"2019-02-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BB%8B%E7%BB%8D/:4:0","tags":["Django","教程"],"title":"Django基础教程之介绍","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BB%8B%E7%BB%8D/"},{"categories":["Django"],"content":"Django学习资料 Django官网 Django项目Github Django Book 教程 Mozilla Django教程 ","date":"2019-02-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BB%8B%E7%BB%8D/:5:0","tags":["Django","教程"],"title":"Django基础教程之介绍","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BB%8B%E7%BB%8D/"},{"categories":["Django"],"content":"Django2.x配置mysql","date":"2019-02-17","objectID":"/django2.x%E9%85%8D%E7%BD%AEmysql/","tags":["msql","Django"],"title":"Django2.x配置mysql","uri":"/django2.x%E9%85%8D%E7%BD%AEmysql/"},{"categories":["Django"],"content":"声明：以下内容均为我个人的理解，如果发现错误或者疑问可以联系我共同探讨 ","date":"2019-02-17","objectID":"/django2.x%E9%85%8D%E7%BD%AEmysql/:0:0","tags":["msql","Django"],"title":"Django2.x配置mysql","uri":"/django2.x%E9%85%8D%E7%BD%AEmysql/"},{"categories":["Django"],"content":"简介 在Django中使用mysql数据库是很常见的,但是升级到Django2.0以后，已经不支持Python2.x，mysql的配置也需要随之改变 ","date":"2019-02-17","objectID":"/django2.x%E9%85%8D%E7%BD%AEmysql/:1:0","tags":["msql","Django"],"title":"Django2.x配置mysql","uri":"/django2.x%E9%85%8D%E7%BD%AEmysql/"},{"categories":["Django"],"content":"配置 ","date":"2019-02-17","objectID":"/django2.x%E9%85%8D%E7%BD%AEmysql/:2:0","tags":["msql","Django"],"title":"Django2.x配置mysql","uri":"/django2.x%E9%85%8D%E7%BD%AEmysql/"},{"categories":["Django"],"content":"配置settings.py DATABASES = { 'default': { 'ENGINE': 'django.db.backends.mysql', 'NAME': 'dbname', 'USER': 'dbuser', 'PASSWORD': 'dbpassword', 'HOST':'dbhost', 'PORT':'dbport' } } ","date":"2019-02-17","objectID":"/django2.x%E9%85%8D%E7%BD%AEmysql/:2:1","tags":["msql","Django"],"title":"Django2.x配置mysql","uri":"/django2.x%E9%85%8D%E7%BD%AEmysql/"},{"categories":["Django"],"content":"使用pymysql 由于安装mysqlclient不支持python3，所以使用pymysql包，安装pymysql并导入 pip install pymysql 配置pymysql，在settings.py所在的目录下的__init__.py文件中导入 import pymysql pymysql.install_as_MySQLdb() ","date":"2019-02-17","objectID":"/django2.x%E9%85%8D%E7%BD%AEmysql/:2:2","tags":["msql","Django"],"title":"Django2.x配置mysql","uri":"/django2.x%E9%85%8D%E7%BD%AEmysql/"},{"categories":["Django"],"content":"修改源码中的问题 由于在python3中不在使用mysqlclient，所以源码中限制mysqlclient版本这一代码就不适用于现在的环境 文件路径django\\db\\backends\\mysql\\base.py，将版本限制异常给注释掉在文件的第35-36行 # if version \u003c (1, 3, 13): # raise ImproperlyConfigured('mysqlclient 1.3.13 or newer is required; you have %s.' % Database.__version__) 由于python2的str是字节流(类似于bytes类型)需要通过decode转换成unicode类型才能使用，但在python3中str默认unicode类型不需要转换且没有decode解码所以要将这里的代码修改。在最新的Django源码中已经将这里修改了(可以通过Django官网或github查看)，在最新的源码中使用django.utils.encoding中force_str方法解决了该问题，force_str方法实际上是force_text方法，force_text方法通过判断传入参数的类型后将类型转为unicode类型的str之后返回 \\django\\utils\\encoding.py ······ def force_text(s, encoding='utf-8', strings_only=False, errors='strict'): \"\"\" Similar to smart_text, except that lazy instances are resolved to strings, rather than kept as lazy objects. If strings_only is True, don't convert (some) non-string-like objects. \"\"\" # Handle the common case first for performance reasons. if issubclass(type(s), str): return s if strings_only and is_protected_type(s): return s try: if isinstance(s, bytes): s = str(s, encoding, errors) else: s = str(s) except UnicodeDecodeError as e: raise DjangoUnicodeDecodeError(s, *e.args) return s 最后修改\\django\\db\\backends\\mysql\\operations.py文件中的last_executed_query方法（记得导入force_str） from django.utils.encoding import force_str ··· def last_executed_query(self, cursor, sql, params): # With MySQLdb, cursor objects have an (undocumented) \"_executed\" # attribute where the exact query sent to the database is saved. # See MySQLdb/cursors.py in the source distribution. # MySQLdb returns string, PyMySQL bytes. return force_str(getattr(cursor, '_executed', None), errors='replace') ","date":"2019-02-17","objectID":"/django2.x%E9%85%8D%E7%BD%AEmysql/:2:3","tags":["msql","Django"],"title":"Django2.x配置mysql","uri":"/django2.x%E9%85%8D%E7%BD%AEmysql/"},{"categories":["Python"],"content":"Python时间合集","date":"2019-01-26","objectID":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/","tags":["时间"],"title":"Python时间合集","uri":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/"},{"categories":["Python"],"content":"声明：以下内容均为我个人的理解，如果发现错误或者疑问可以联系我共同探讨 ","date":"2019-01-26","objectID":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/:0:0","tags":["时间"],"title":"Python时间合集","uri":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/"},{"categories":["Python"],"content":"python3中时间的表示形式 ","date":"2019-01-26","objectID":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/:1:0","tags":["时间"],"title":"Python时间合集","uri":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/"},{"categories":["Python"],"content":"格式化时间字符串 格式化时间字符串（string_time）,指格式化输出指定输出参数的格式与相对位置的字符串参数，与python中的format作用类似，常见的格式化时间字符串：\"%Y-%m-%d %H:%M:%S %z,%a,%A,%b,%B,%c,%I,%p” 常用的表 名 称 含 义 例 子 %Y 有世纪并用0填充的十进制数年份 0001, 0002, …, 2013, 2014, …, 9998, 9999 %m 用零填充十进制数的月份 01, 02, …, 12 %d 用零填充十进制数的月中的某一天 01, 02, …, 31 %H 24小时格式的用0填充的十进制数小时 00, 01, …, 23 %M 用0填充的十进制数分钟 00, 01, …, 59 %S 用0填充的十进制数秒 00, 01, …, 59 %z 用零填充的十进制小时分钟秒毫秒的时差 (empty), +0000, -0400, +1030, +063415, -030712.345216 %a 根据区域设置的缩写的星期名称 Sun, Mon, …, Sat (en_US) So, Mo, …, Sa (de_DE) %A 根据区域设置的完整星期名称 Sunday, Monday, …, Saturday (en_US) Sonntag, Montag, …, Samstag (de_DE) 吐槽一下官网注释秒的范围是0-59，实测0-61都可以 官方的完整表： 以下是C标准（1989版）所需的所有格式代码的列表，这些代码适用于具有标准C实现的所有平台。请注意，1999版C标准添加了其他格式代码。 名 称 含 义 例 子 %a 根据区域设置的缩写的星期名称 Sun, Mon, …, Sat (en_US)So, Mo, …, Sa (de_DE) %A 根据区域设置的完整星期名称 Sunday, Monday, …, Saturday (en_US)Sonntag, Montag, …, Samstag (de_DE) %w 将工作日变成十进制数，其中0表示星期日，6表示星期六 0, 1, …, 6 %d 用零填充十进制数的月中的某一天 01, 02, …, 31 %b 根据区域设置的缩写月份名 Jan, Feb, …, Dec (en_US);Jan, Feb, …, Dez (de_DE) %B 根据区域改变月份全称 January, February, …, December (en_US)Januar, Februar, …, Dezember (de_DE) %m 用零填充十进制数的月份 01, 02, …, 12 %y 没有世纪并用0填充的十进制数年份 00, 01, …, 99 %Y 有世纪并用0填充的十进制数年份 0001, 0002, …, 2013, 2014, …, 9998, 9999 ","date":"2019-01-26","objectID":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/:1:1","tags":["时间"],"title":"Python时间合集","uri":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/"},{"categories":["Python"],"content":"时间戳 时间戳（Timestamp）,指字符串或编码信息用于辨识记录下来的时间日期，维基百科解释的不容易懂，我的个人理解是从1970年1月1日到现在过去了多少秒。 ","date":"2019-01-26","objectID":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/:1:2","tags":["时间"],"title":"Python时间合集","uri":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/"},{"categories":["Python"],"content":"时间元祖 时间元祖(struct_time),指包含9个特殊元素的元祖，（tm_year，tm_mon，tm_mday，tm_hour，tm_min，tm_sec，tm_wday，tm_yday，tm_isdst），详情见下表格 名 称 含 义 值 tm_year 年 具体年份，例：2017 tm_mon 月 1-12 tm_mday 日 1-31 tm_hour 时 1-23 tm_min 分 0-59 tm_sec 秒 0-61 tm_wday 周 0-6（从周末开始） tm_yday 在一年中的第几天 1-666 tm_isdst 是否为夏令时 -1,0,1（能表示true和flase的值） ","date":"2019-01-26","objectID":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/:1:3","tags":["时间"],"title":"Python时间合集","uri":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/"},{"categories":["Python"],"content":"时间对象 时间对象（time_object）,指通过某些时间类生成的对象，例如datetime对象。 ","date":"2019-01-26","objectID":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/:1:4","tags":["时间"],"title":"Python时间合集","uri":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/"},{"categories":["Python"],"content":"python中两大时间库： ","date":"2019-01-26","objectID":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/:2:0","tags":["时间"],"title":"Python时间合集","uri":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/"},{"categories":["Python"],"content":"time 简介： 常用于具体时间操作 常量 Variables with simple values，值简单的变量 altzone，-32400 daylight，0 timezone，-28800 _STRUCT_TM_ITEMS，11 variables with complex values，值复杂的变量 tzname 但是如果直接调用会得到一个乱码的值，看不懂，查阅资料后发现通过重新编码解码可以看到真实值，这里很感谢这个爱思考的博主，这里编码解码参考他的博客，这条博文在这里：https://www.cnblogs.com/luo630/p/9555684.html，里面讲的很详细 \u003e\u003e\u003e time.tzname[0].encode('latin-1').decode('gbk') '中国标准时间' \u003e\u003e\u003e time.tzname[1].encode('latin-1').decode('gbk') '中国夏令时' 方法： asctime：将时间元组转换为字符串，当没有传入参数时，调用localtime()返回的当前时间，参数类型：元祖，返回类型：字符串。例如： \u003e\u003e\u003e import time \u003e\u003e\u003e time.asctime() 'Tue Jun 11 16:07:40 2017' \u003e\u003e\u003e time.asctime((2017,6,11,16,7,40,59,59,59)) # 这里必须要穿一个包含9个数字的元组，且年月日时分都必须符合时间逻辑，秒必须小于等于61，不知道为什么是61，后面三位逻辑暂时还没弄明白，但是跟前面对应的年月日有关 'Thu Jun 11 16:07:40 2017' clock：计时器函数，在进程结束后返回从开始到第一次调用该函数使用的时间，返回类型：浮点数。例如： \u003e\u003e\u003e time.clock() 5e-07 \u003e\u003e\u003e time.sleep(1) \u003e\u003e\u003e time.clock() 11.9833418 \u003e\u003e\u003e time.sleep(10) \u003e\u003e\u003e time.clock() 35.1999596 ctime：将时间戳转换为以本地时间为单位的字符串。相当于asctime(localtime(seconds))。当没有传入参数时，使用localtime()返回的当前时间。参数类型：时间戳，返回类型：字符串。例如： \u003e\u003e\u003e time.ctime(1555555550) 'Thu Apr 18 10:45:50 2017' \u003e\u003e\u003e time.ctime() 'Tue Jun 11 17:08:44 2017' get_clock_info：获取有关指定时钟的信息作为命名空间对象。支持的时钟名称和读取其值的相应函数是： ‘clock’： time.clock() ‘monotonic’： time.monotonic() ‘perf_counter’： time.perf_counter() ‘process_time’： time.process_time() ‘thread_time’： time.thread_time() ‘time’： time.time() 结果具有以下属性： adjustable：True如果时钟可以自动更改（例如通过NTP守护程序）或由系统管理员手动更改，False否则 implementation：用于获取时钟值的基础C函数的名称。有关可能的值，请参阅时钟ID常量。 单调：True如果时钟不能倒退， False否则分辨率：时钟的分辨率（秒）（float） gmtime：将时间戳转换为时间元祖，当没有传入参数时，返回当前世界标准时间的时间元祖。参数类型：时间戳，返回类型：元祖（但是查看源码只有一个pass）。例如： \u003e\u003e\u003e time.gmtime(1555555550) time.struct_time(tm_year=2017, tm_mon=4, tm_mday=18, tm_hour=2, tm_min=45, tm_sec=50, tm_wday=3, tm_yday=108, tm_isdst=0) \u003e\u003e\u003e time.gmtime() time.struct_time(tm_year=2017, tm_mon=6, tm_mday=11, tm_hour=9, tm_min=18, tm_sec=54, tm_wday=1, tm_yday=162, tm_isdst=0) localtime：与gmtime功能类似，但是返回的时间变成了当地时间。例如： \u003e\u003e\u003e time.localtime(1555555550) time.struct_time(tm_year=2017, tm_mon=4, tm_mday=18, tm_hour=10, tm_min=45, tm_sec=50, tm_wday=3, tm_yday=108, tm_isdst=0) \u003e\u003e\u003e time.localtime() time.struct_time(tm_year=2017, tm_mon=6, tm_mday=11, tm_hour=17, tm_min=28, tm_sec=34, tm_wday=1, tm_yday=162, tm_isdst=0) mktime：将时间元祖转化为时间戳，返回时间戳。参数类型：时间元祖（9个元素），返回类型：时间戳。例如： \u003e\u003e\u003e time.mktime((2017,4,18,10,45,50,3,108,0)) 1555555550.0 monotonic: 一个单调的计时器，不能倒转。不知道从什么时候开始的，返回类型：浮点型。例如： \u003e\u003e\u003e def func(): ... print(time.monotonic()) ... time.sleep(1) ... \u003e\u003e\u003e i = 0 \u003e\u003e\u003e while i\u003c5: ... func() ... i+=1 ... 461875.89 461876.89 461877.89 461878.89 461879.89 perf_counter：性能计数器用于基准测试。不服跑个分！返回类型：浮点型。例如： \u003e\u003e\u003e time.perf_counter() 3674.2299851 \u003e\u003e\u003e time.perf_counter() 3675.2086447 \u003e\u003e\u003e time.perf_counter() 3675.9990329 process_time：用于分析的进程时间:内核和用户空间CPU时间的总和。返回类型：浮点型。例如： \u003e\u003e\u003e time.process_time() 4.40625 sleep:将执行延迟数秒。参数类型：int or float ,返回类型：无，这就不演示了…浪费时间 strftime：根据格式规范将时间元组转换为字符串。有关格式化代码，请参阅库参考手册。当没有传入参数时，使用localtime()返回的当前时间。传入参数：配对字符串,时间元祖（与字符串配对），返回参数：时间字符串,例： # 根据前面的格式化字符串来生成对应时间字符串 \u003e\u003e\u003e time.strftime(\"%Y-%m-%d%H:%M:%S\", (2017, 1, 1, 1, 1, 1, 1, 13, 0)) '2017-01-01 01:01:01' \u003e\u003e\u003e time.strftime(\"%Y-%m-%d%H:%M:%S %I\", (2017, 1, 1, 1, 1, 1, 1, 13, 0)) '2017-01-01 01:01:01 01' \u003e\u003e\u003e time.strftime(\"%Y-%m-%d%H:%M:%S %z,%a,%A,%b,%B,%c,%I,%p\", (2017, 1, 1, 1, 1, 1, 1, 13, 0)) '2017-01-01 01:01:01 +0800,Tue,Tuesday,Jan,January,Tue Jan 1 01:01:01 2017,01,AM' strptime：根据格式规范将字符串解析为时间元组。有关格式化代码，请参阅库参考手册(与strftime ())。传入参数：时间字符串，配对字符串。返回参数：时间元祖 例： python \u003e\u003e\u003e time.strptime(\"2017-01-01 01:01:02\", \"%Y-%m-%d %H:%M:%S\") time.struct_time(tm_year=2017, tm_mon=1, tm_mday=1, tm_hour=1, tm_min=1, tm_sec=2, tm_wday=1, tm_yday=1, tm_isdst=-1) time：以秒为单位返回从纪元开始的当前时间。如果系统时钟提供这些信息，那么可能只存在几分之一秒。就是我们常说的时间戳。返回参数：浮点数 ","date":"2019-01-26","objectID":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/:2:1","tags":["时间"],"title":"Python时间合集","uri":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/"},{"categories":["Python"],"content":"datetime 由五个模块组成 date： 简介 表示日期的类。常用的属性有year, month, day。 常量 date.min = date(1, 1, 1)，date.max = date(9999, 12, 31)，date.resolution = timedelta(days=1)，分别规定了date对象的最小值、最大值，date对象的最小单位，为天 类方法 fromtimestamp：将时间戳转化为date对象，参数类型：float，int，返回类型：date对象 \u003e\u003e\u003e from datetime import date \u003e\u003e\u003e date.fromtimestamp(1560415206) datetime.date(2017, 6, 13) \u003e\u003e\u003e type(date.fromtimestamp(1560415206)) \u003cclass 'datetime.date'\u003e today：获得今天的日期，返回类型：date对象 \u003e\u003e\u003e date.today() datetime.date(2017, 6, 13) \u003e\u003e\u003e type(date.today()) \u003cclass 'datetime.date'\u003e fromordinal：跟fromtimestamp类似 \u003e\u003e\u003e date.fromtimestamp(1560415206) datetime.date(2017, 6, 13) \u003e\u003e\u003e type(date.fromtimestamp(1560415206)) \u003cclass 'datetime.date'\u003e 实例方法 ctime：返回将日期对象转化为标准时间日期的 00:00:00 \u003e\u003e\u003e date(2017,6,13).ctime() 'Thu Jun 13 00:00:00 2017' strftime，返回将date对象转化为指定格式的date对象 \u003e\u003e\u003e d = date(2017,1,1) \u003e\u003e\u003e d.strftime(\"%d/%m/%y\") '01/01/17' \u003e\u003e\u003e type(d) \u003cclass 'datetime.date'\u003e isoformat,返回将date对象转化为’YYYY-MM-DD’格式的date对象, \u003e\u003e\u003e d = date(2017,2,2) \u003e\u003e\u003e d.isoformat() '2017-02-02' \u003e\u003e\u003e type(d) \u003cclass 'datetime.date'\u003e timetuple,返回与time.localtime()兼容的本地时间元组 \u003e\u003e\u003e date(2017,7,7).timetuple() time.struct_time(tm_year=2017, tm_mon=7, tm_mday=7, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=4, tm_yday=188, tm_isdst=-1) toordinal,按年、月、日返回子午线格列高利教序数。返回类型：int \u003e\u003e\u003e d = date(2017,7,7).toordinal() \u003e\u003e\u003e type(d) \u003cclass 'int'\u003e replace,根据传入的年月日修改date对象的年月日,参数类型：int,返回类型:date对象 \u003e\u003e\u003e d = date(2017,7,7) \u003e\u003e\u003e d.replace(month=8,day=8) datetime.date(2017, 8, 8) weekday,根据date对象，判断该日期为星期几,返回类型：int,0-6分别对应星期一到星期天 \u003e\u003e\u003e d = date(2017,6,12) \u003e\u003e\u003e a = d.weekday() 0 \u003e\u003e\u003e type(a) \u003cclass 'int'\u003e isoweekday，根据date对象，判断该日期为星期几,返回类型：int,1-7分别对应星期一到星期天 \u003e\u003e\u003e d = date(2017,6,12) \u003e\u003e\u003e a = d.isoweekday() 1 \u003e\u003e\u003e type(a) \u003cclass 'int'\u003e isocalendar,根据date对象，判断该日期为第几周的星期几，返回类型：包含年，第几周，星期几的元祖 \u003e\u003e\u003e d = date(2017,6,12) \u003e\u003e\u003e d.isocalendar() (2017, 24, 1) \u003e\u003e\u003e d = date(2017,7,12) \u003e\u003e\u003e d.isocalendar() (2017, 28, 3) 魔法属性 year,month,day：返回年、月、日 \u003e\u003e\u003e d = date(2017,6,13) \u003e\u003e\u003e d.year 2017 \u003e\u003e\u003e d.month 6 \u003e\u003e\u003e d.day 13 time 简介 表示时间的类。常用的属性有hour, minute, second, microsecond。 参数 hour=0, minute=0, second=0, microsecond=0, tzinfo=None, fold=0， hour，minute，小时和分钟必须传入，小时为0-23，分钟为0-59 second，microsecond，秒和毫秒，默认为0，可以不传，秒为0-59，毫秒为0-999999 tzinfo，时区默认为None,可以填你想要的时区 fold，在[0,1]。用于消除重复间隔期间的墙壁时间的歧义。(当时钟在夏令时结束时回滚，或由于政治原因降低当前区域的UTC偏移量时，会出现重复间隔。)值0(1)表示具有相同壁面时间表示的两个时刻中较早(较晚)的时刻。 常量 time.min，最早可表示的时间，时间(0,0,0,0)。 time.max，最新可表示时间，时间(23,59,59,999999)。 time.resolution在不相等的时间对象之间可能存在的最小差异是时间增量(微秒=1)，不过请注意，不支持对时间对象进行算术。 魔法属性 hour、minute、second、microsecond、tzinfo、fold分别返回时、分、秒、毫秒、时区与折叠关键字 \u003e\u003e\u003e from datetime import time \u003e\u003e\u003e t = time(9,9) \u003e\u003e\u003e t.hour 9 \u003e\u003e\u003e t.minute 9 \u003e\u003e\u003e t.second 0 \u003e\u003e\u003e t.microsecond 0 \u003e\u003e\u003e t.tzinfo \u003e\u003e\u003e t.fold 0 实例方法 isoformat，返回按ISO格式格式化的时间字符串。完整的格式是’HH:MM:SS.mmmmmm+zz:zz’可选参数：timespec，指定附加的数量所包括的时间条款 \u003e\u003e\u003e t = time(8,8) \u003e\u003e\u003e a = t.isoformat() \u003e\u003e\u003e a '08:08:00' \u003e\u003e\u003e type(a) \u003cclass 'str'\u003e strftime，返回一个表示时间的字符串，由显式格式字符串控制。参数 datetime.time(9, 9) \u003e\u003e\u003e t = time(9,9) \u003e\u003e\u003e t datetime.time(9, 9) \u003e\u003e\u003e t.strftime(\"%H/%H/%S\") '09/09/00' replace,返回根据关键字替换datetime.time对象中的值,参数：hour, minute, second, microsecond, tzinfo,fold \u003e\u003e\u003e time(9,9).replace(8,8) datetime.time(8, 8) utcoffset,根据utc返回以东的时区偏移（可以理解为时差），以分钟为单位，如果没有设置tzinfo则返回none。 \u003e\u003e\u003e class UTC(tzinfo): ... def __init__(self,offset = 0): ... self._offset = offset ... def utcoffset(self,dt): ... return timedelta(hours=self._offset) ... def tzname(self,dt): ... return \"UTC +%s\" % self._offset ... def dst(self, dt): ... return timedelta(hours=self._offset) ... \u003e\u003e\u003e time(9,9).utcoffset() \u003e\u003e\u003e \u003e\u003e\u003e time(9,9,tzinfo=UTC(8)).utcoffset() datetime.timedelta(0, 28800) tzname,返回时区的名字 \u003e\u003e\u003e time(9,9,tzinfo=UTC(8)).tzname() 'UTC +8' dst,返回dst偏移信息，如果没有则返回none \u003e\u003e\u003e time(9,9,tzinfo=UTC(8)).dst() datetime.timedelta(0, 28800) \u003e\u003e\u003e time(9,9).dst() \u003e\u003e\u003e datetime 简介 表示日期+时间 参数 year, month, day, hour=0, minute=0, second=0, microsecond=0, tzinfo=None, fold=0，年，月，日参数是必需的。 tzinfo可以是None，或者是tzinfo子类的实例。其余参数可以是整数，在以下范围内： MINYEAR \u003c= year \u003c= MAXYEAR， 1 \u003c= month \u003c= 12， 1 \u003c= day \u003c= number of days in the given month and year， 0 \u003c= ho","date":"2019-01-26","objectID":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/:2:2","tags":["时间"],"title":"Python时间合集","uri":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/"},{"categories":["Python"],"content":"Python搭建虚拟环境","date":"2019-01-20","objectID":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/","tags":["虚拟环境"],"title":"Python搭建虚拟环境","uri":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"},{"categories":["Python"],"content":"声明：以下内容均为我个人的理解，如果发现错误或者疑问可以联系我共同探讨 ","date":"2019-01-20","objectID":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/:0:0","tags":["虚拟环境"],"title":"Python搭建虚拟环境","uri":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"},{"categories":["Python"],"content":"为什么要搭建虚拟环境 平时开发的过程中会遇到不同的项目，往往不同的项目之间需要的第三方包会有所差异，如果我们都在系统的python环境中会导致遇到很多问题，通过虚拟环境搭建一套独立的python运行环境，可以让项目之间互不干扰。 ","date":"2019-01-20","objectID":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/:1:0","tags":["虚拟环境"],"title":"Python搭建虚拟环境","uri":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"},{"categories":["Python"],"content":"如何搭建 一般我们搭建虚拟环境都会用上virtualenv，它是一个可以创建并管理python虚拟环境的第三方包。 ","date":"2019-01-20","objectID":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/:2:0","tags":["虚拟环境"],"title":"Python搭建虚拟环境","uri":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"},{"categories":["Python"],"content":"安装 不论是windows还是linux还是mac都可以直接通过pip 安装，需要注意的是系统中存在两个python的时候，注意pip的版本，选择对应的版本安装 pip install virtualenv ","date":"2019-01-20","objectID":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/:2:1","tags":["虚拟环境"],"title":"Python搭建虚拟环境","uri":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"},{"categories":["Python"],"content":"创建虚拟环境 我们通常会创建一个文件夹为env(当然你也可以去任何你喜欢的名字)，专门用来存放不同的虚拟环境 进入到env文件夹中通过命令创建一个虚拟环境，名为first_env virtualenv first_env 相关参数说明 -p:选择要使用的Python解释器，默认为安装virtualenv的解释器 –prompt=xx:将xx设置为虚拟环境的提示前缀 ","date":"2019-01-20","objectID":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/:2:2","tags":["虚拟环境"],"title":"Python搭建虚拟环境","uri":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"},{"categories":["Python"],"content":"使用虚拟环境 Windows 进入虚拟环境的Scripts目录 在此处打开命令行工具 输入activate，当命令提示符多了一个虚拟环境名字的前缀时即激活成功 Linux or Mac 通过source激活使用，当命令提示符多了一个虚拟环境名字的前缀时即激活成功 source first_env/bin/activate ","date":"2019-01-20","objectID":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/:2:3","tags":["虚拟环境"],"title":"Python搭建虚拟环境","uri":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"},{"categories":["Python"],"content":"退出虚拟环境 在当前虚拟环境中输入deactivate，当命令提示符虚拟环境名字的前缀消失时即退出 ","date":"2019-01-20","objectID":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/:2:4","tags":["虚拟环境"],"title":"Python搭建虚拟环境","uri":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"},{"categories":["Python"],"content":"删除虚拟环境 在我们不需要这个虚拟环境的时候只需要将该虚拟环境的整个包删除即可 ","date":"2019-01-20","objectID":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/:2:5","tags":["虚拟环境"],"title":"Python搭建虚拟环境","uri":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"},{"categories":["Python"],"content":"Pipenv ","date":"2019-01-20","objectID":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/:3:0","tags":["虚拟环境"],"title":"Python搭建虚拟环境","uri":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"},{"categories":["Python"],"content":"简介 Pipenv是Kenneth Reitz在2017年1月发布的Python依赖管理工具，现在由PyPA维护。可以把它看做是pip和virtualenv的组合。 ","date":"2019-01-20","objectID":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/:3:1","tags":["虚拟环境"],"title":"Python搭建虚拟环境","uri":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"},{"categories":["Python"],"content":"为什么使用Pipenv Pipenv会自动帮你管理虚拟环境和依赖文件，并且提供了一系列命令和选项来帮助你实现各种依赖和环境管理相关的操作。简而言之，它更方便、完善和安全。 ","date":"2019-01-20","objectID":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/:3:2","tags":["虚拟环境"],"title":"Python搭建虚拟环境","uri":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"},{"categories":["Python"],"content":"如何使用Pipenv 安装 pip install pipenv 创建 在项目根目录下执行pipenv install，Pipenv会根据项目文件夹的名称创建一个虚拟环境，并且会在项目根目录下生成 Pipfile 和 Pipfile.lock 用于管理项目依赖（以后使用 Pipenv 安装的依赖会自动写入 Pipfile 文件，无需再手动维护 requirements.txt 文件) 提示 默认情况下Pipenv会将虚拟环境创建在~/.virtualenvs 目录下，在项目根目录下执行 pipenv --venv 可以查看到项目对应的虚拟环境的具体位置 激活使用 两种方式 在项目根目录下执行pipenv shell 在项目根目录下执行pipenv run + 命令 ","date":"2019-01-20","objectID":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/:3:3","tags":["虚拟环境"],"title":"Python搭建虚拟环境","uri":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"},{"categories":["Python"],"content":"Python2与Python3的区别","date":"2019-01-13","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"声明：以下内容均为我个人的理解，如果发现错误或者疑问可以联系我共同探讨 ","date":"2019-01-13","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:0:0","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"简介 目前用Python开发的项目有两个Python版本，分别是Python2.x与Python3.x，由于Python3相对于python2有着较大的升级，所以Python3将会是现在与未来的主流版本。 ","date":"2019-01-13","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:1:0","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"Python3时间轴 Python3.0发布于2008.12.3 Python3.1发布于2009.6.27 Python3.2发布于2011.2.20 Python 3.3 发布于 2012.9.29 Python 3.4 发布于 2014.3.16 Python 3.5 发布于 2015.9.13 Python 3.6 发布于 2016.12.23 Python3.7发布于2018.6.27 Python3.8发布于2019.10.14 Python 3.9发布于 2020.10.5 为了不带入过多的累赘，在Python3.0设计的时候没有考虑向下兼容，所以早期的项目都无法在Python3.0上正常运行。为了早期的项目可以逐步迁移到Python3.0，Python官方提供了Python2.6过度版本（基于Python2的语法与库，允许使用部分Python3的语法和函数），2010年中推出Python2.7为最后一个Python2.x版本(Python2.7在2020年1月1日以后官方停止维护)。了解Python3版本的变化对我们日常开发与项目维护都十分重要 ","date":"2019-01-13","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:1:1","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"Python3.0后的变化 ","date":"2019-01-13","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:0","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"解释器名称 Python2.x的解释器为python，Python3.x的解释器为python3 其他语言实现的解释器： PyPy Python实现的Python解释器，支持 JIT 即时编译 cpython C语言基于官方版本实现的Python解释器 Jython 运行在Java上的Python解释器 IronPython 运行在.NET与Mono平台的Python解释器 ","date":"2019-01-13","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:1","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"字符串 Python2中字符串是基于ASCII编码的str字符串，当调用字符串变量时会打印其bytes值（16进制表示的字符串内存地址）。 而unicode是一个单独的类型。 Python3中字符串原生支持unicode，byte也变成了一个单独的字节类，并且Python3源码文件默认使用utf-8编码所以中文也可以做变量名。 ","date":"2019-01-13","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:2","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"import Python2中import导包采用相对路径，导致标准库导入变困难。 Python3中import导包采用绝对路径 ","date":"2019-01-13","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:3","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"print Python2中的print是一种特殊的语句，在Python3中print变成了print函数 ","date":"2019-01-13","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:4","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"range函数与xrange函数 xrange函数在Python3中被废弃，range函数的机制进行修改实现了xrange函数返回可迭代对象的效果 ","date":"2019-01-13","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:5","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"老式类与新式类 Python2中存在老式类与新式类，在Python3中统一采用新式类（新式类申明要求继承object），且必须使用新式类应用多重继承 ","date":"2019-01-13","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:6","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"除法与取余 Python2 中若两个整形进行运算，结果为整形，但若其中有一个浮点数类型，则结果为浮点数。python3为真除法，运算结果为float类型。 Python2 中取余返回小于除法运算结果的最大整数，从类型上讲，与”/“运算符返回类型逻辑一致。Python3中与python2作用相同。 ","date":"2019-01-13","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:7","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"raw_input函数与input函数 raw_input函数在Python3中被废弃，统一使用input函数 ","date":"2019-01-13","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:8","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"缩进 Python3采用更严格的缩进方式，tab和space不能共存 ","date":"2019-01-13","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:9","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"long long整型被Python3废弃，统一使用int，int具有long的特性 ","date":"2019-01-13","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:10","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"file file函数被废弃，统一使用open函数 ","date":"2019-01-13","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:11","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"不等运算符 Python3废除\u003c\u003e，只有!= ","date":"2019-01-13","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:12","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"方法返回值 Python3 中这些方法再不再返回 list 对象：dictionary 关联的 keys()、values()、items()，zip()，map()，filter()，但是可以通过 list 强行转换 ","date":"2019-01-13","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:13","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"next()函数 迭代器 iterator 的 next()函数被 Python3 废弃，统一使用 next(iterator) ","date":"2019-01-13","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:14","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"exec exec 语句被 python3 废弃，统一使用 exec 函数 ","date":"2019-01-13","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:15","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"has_key 函数 has_key 函数被 Python 废弃，统一使用 in 关键词 ","date":"2019-01-13","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:16","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"round函数 Python2中，round函数返回float类型值。Python3中，round函数返回int类型值。 ","date":"2019-01-13","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:17","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"比较操作符 Python2中任意两个对象都可以比较。Python3中只有同一类型数据的对象才可以进行比较。 ","date":"2019-01-13","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:18","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["系统优化"],"content":"Windows10在此处打开cmd","date":"2019-01-05","objectID":"/windows10%E5%9C%A8%E6%AD%A4%E5%A4%84%E6%89%93%E5%BC%80cmd/","tags":["cmd"],"title":"Windows10在此处打开cmd","uri":"/windows10%E5%9C%A8%E6%AD%A4%E5%A4%84%E6%89%93%E5%BC%80cmd/"},{"categories":["系统优化"],"content":"声明：以下内容均为我个人的理解，如果发现错误或者疑问可以联系我共同探讨 在Windows10中我们经常需要在某个文件夹下打开cmd窗口，虽然可以在地址栏输入cmd打开，但还是比较麻烦，可以修改注册表添加一个右键菜单来解决这个问题。 ","date":"2019-01-05","objectID":"/windows10%E5%9C%A8%E6%AD%A4%E5%A4%84%E6%89%93%E5%BC%80cmd/:0:0","tags":["cmd"],"title":"Windows10在此处打开cmd","uri":"/windows10%E5%9C%A8%E6%AD%A4%E5%A4%84%E6%89%93%E5%BC%80cmd/"},{"categories":["系统优化"],"content":"步骤 新建一个文本文档 将 一下内容复制粘贴到文本文档中 Windows Registry Editor Version 5.00 [-HKEY_CLASSES_ROOT\\Directory\\shell\\runas] [HKEY_CLASSES_ROOT\\Directory\\shell\\runas] @=\"Open cmd here as admin\" \"HasLUAShield\"=\"\" [HKEY_CLASSES_ROOT\\Directory\\shell\\runas\\command] @=\"cmd.exe /s /k pushd \\\"%V\\\"\" [-HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\runas] [HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\runas] @=\"Open cmd here as admin\" \"HasLUAShield\"=\"\" [HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\runas\\command] @=\"cmd.exe /s /k pushd \\\"%V\\\"\" [-HKEY_CLASSES_ROOT\\Drive\\shell\\runas] [HKEY_CLASSES_ROOT\\Drive\\shell\\runas] @=\"Open cmd here as admin\" \"HasLUAShield\"=\"\" [HKEY_CLASSES_ROOT\\Drive\\shell\\runas\\command] @=\"cmd.exe /s /k pushd \\\"%V\\\"\" 另存为xxx.reg文件 双击运行 ","date":"2019-01-05","objectID":"/windows10%E5%9C%A8%E6%AD%A4%E5%A4%84%E6%89%93%E5%BC%80cmd/:0:1","tags":["cmd"],"title":"Windows10在此处打开cmd","uri":"/windows10%E5%9C%A8%E6%AD%A4%E5%A4%84%E6%89%93%E5%BC%80cmd/"},{"categories":["年终总结"],"content":"前言 不知不觉又到年底了，2018年6月我从母校毕业，进入社会，体会到了社会的残酷。我是幸运的，成功通过校招进入了一家企业，去到了上有天堂下有苏杭的杭州。在经历过一些痛苦后我决定出去闯一闯，年末又成功在上海找到工作。不幸的是家庭中发生了一系列的变故，让我对亲情是否可靠又产生了怀疑，难道血缘关系都不能带来相互的羁绊吗，我现在回答不上来，只希望少点这种糟心的事。 ","date":"2018-12-30","objectID":"/2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/:1:0","tags":["生活"],"title":"2018年终总结","uri":"/2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"},{"categories":["年终总结"],"content":"收获爱情 没想到在我离开母校之后还能追到追了3年都没追到的女神。虽然现在我们是异地恋，但是我想这是上天在看到我Never give up的信念后给予我的礼物吧。说实话这感觉就跟做梦一样，之前经常幻想在一起后的生活是啥样的，现在感觉全都是我无法想到的情况。我们是熟悉的，从大一就开始认识，一起参加社团，参加各种活动，经常互相吐槽。我们是陌生的，在一起后才发现你是这么的柔弱，想法是那么的奇妙。不过跟你在一起越久我就越发的喜欢上你，虽然今年跟你见面的机会很少，但每一次都让我感受到了爱情的美妙。逐渐对你了解的越多发现你跟别的女孩都不一样。我会努力赚钱，给你带来更好的生活的！ ","date":"2018-12-30","objectID":"/2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/:2:0","tags":["生活"],"title":"2018年终总结","uri":"/2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"},{"categories":["年终总结"],"content":"百万负翁 在武汉买房这是我之前从来都没想过的事，不过今年竟然那么巧合的实现了。我哥是做房产中介的，他朋友要结婚了，想把手上的房置换出去我家刚拿到拆迁款不久，身上有点余钱我妈就去看了看房子，发现还挺不错，然后就叫上我一起再去看，位置在3环和4环之前，听说附近马上要搞军运会应该会涨起来。户型和面积都很不错，符合我的要求，就算不拿来住就当投资也是一个不错的选择。就这样，我爸妈替我买了人生的第一套房，我也成了百万负翁，每月房贷5500+，跟爸妈商量着先让他们帮我还，等我找到工作了我再慢慢承担房贷，他们也答应了，现在身上压力很大。。。。 ","date":"2018-12-30","objectID":"/2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/:3:0","tags":["生活"],"title":"2018年终总结","uri":"/2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"},{"categories":["年终总结"],"content":"来上海打拼 从杭州回来后就一直在考虑去哪里打工，问了很多朋友，自己也考虑了很多。想从北上深选一个。北京机会多，工资高，但是空气差，住房条件很差。深圳互联网企业很多，政府的人才引进项目也很有吸引力但是相对的竞争也很大，而且环境氛围不太好。最后选择了上海，不过这是一个完全陌生的城市，当时我也很忐忑，不过在Boss直聘上投的简历很快有了回应，有公司已经向我发出了面试邀请，一冲动买了一张晚上的高铁票就出发了。最后经历了几天面试找到了一家我觉得不错还很适合我的公司，虽然不大，但是氛围很好，我感觉我能学到很多东西。 ","date":"2018-12-30","objectID":"/2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/:4:0","tags":["生活"],"title":"2018年终总结","uri":"/2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"},{"categories":["年终总结"],"content":"IG夺冠 这是中国LOL崭新的篇章，我是LOL的内测玩家，但最开始没有玩下去，因为那时候DOTA更火DOTA2也出来了，到S4看到当时的OMG的一场50血翻盘的比赛，震惊我了，那时候中国的LOL还恐韩，那时候的OMG就专门灭韩国对，看起来真过瘾啊，后来随着OMG的落寞也对LOL关注少了，到2018年8月IG老板王思聪上场比赛，那时候又吸引了我的关注，后面开始看IG的比赛，在LPL里每次都差一步，被巅峰期的小狗给带走了。到S8全球总决赛，随着RNG被G2击败这次网上都说是最没有希望的一年，很多人都小看了IG，结果他摧枯拉朽2个3:0带走了G2和FNC，给LPL带来了第一座世界赛的奖杯，这是具有历史意义的一天！虽然IG里有两个韩援，但是Rookie在韩国接受采访时说的中文！我觉得这就是属于LPL的冠军！ ","date":"2018-12-30","objectID":"/2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/:5:0","tags":["生活"],"title":"2018年终总结","uri":"/2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"},{"categories":["年终总结"],"content":"展望 2018年已经过去，希望2019年我能更进一步在上海扎根，学更多东西，尽快承担起家里的责任。 有几个小目标： 坚持每周写一篇博文 多出去走走看看，了解上海这座大都市，认识更多的朋友 开始偿还房贷，减轻爸妈的负担 开始攒钱，争取攒够5万块 希望明年年终总结的时候小目标都能实现！ ","date":"2018-12-30","objectID":"/2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/:6:0","tags":["生活"],"title":"2018年终总结","uri":"/2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"},{"categories":["Python"],"content":"多线程 ","date":"2018-12-29","objectID":"/python%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B/:1:0","tags":["多线程"],"title":"Python中的多线程","uri":"/python%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["Python"],"content":"简介 在日常中经常使用多任务操作，多线程通常是使用最多的一种。 ","date":"2018-12-29","objectID":"/python%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B/:1:1","tags":["多线程"],"title":"Python中的多线程","uri":"/python%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["Python"],"content":"并发 指任务数多余cpu核数，通过操作系统的任务调度算法快速切换任务，从而实现多任务 ","date":"2018-12-29","objectID":"/python%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B/:1:2","tags":["多线程"],"title":"Python中的多线程","uri":"/python%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["Python"],"content":"并行 指任务数小于等于cpu核心数，操作系统可以分配不同的核心同时去实现多任务 ","date":"2018-12-29","objectID":"/python%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B/:1:3","tags":["多线程"],"title":"Python中的多线程","uri":"/python%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["Python"],"content":"线程 定义 程序的最小执行流单元，是程序中一个单一的顺序控制流程 python中实现多线程的模块 thread和threading，不过threading更高级，是封装thread得到的 简单的多线程 import threading import time def run(): print(\"我要减肥!\") time.sleep(1) if __name__ == '__main__': print(time.ctime()) for i in range(10): t = threading.Thread(target=run) t.start() print(time.ctime()) 补充：在python3中主进程会等待子进程结束后再结束 我们可以通过enumerate方法来查看当前运行的线程数量 import threading import time def run(): \"\"\"跑步\"\"\" for i in range(3): print(\"我要减肥!\") time.sleep(1) if __name__ == '__main__': t = threading.Thread(target=run) t.start() len = len(threading.enumerate()) print('当前运行的线程数为：%d' % len) 多线程间是共享全局变量的 栗子 import threading import time weight = 130 def run(): \"\"\"跑步\"\"\" global weight for i in range(3): print(\"我要减肥!\") weight -= 1 def eat(): \"\"\"吃东西\"\"\" global weight for i in range(3): print(\"我吃了一顿好吃的\") weight += 2 if __name__ == '__main__': t_run = threading.Thread(target=run) t_eat = threading.Thread(target=eat) t_run.start() t_eat.start() time.sleep(0.5) print(weight) 由于多个线程都可以修改全局变量，会出现资源竞争，导致最后得到的数据可能不是我们想要的。 import threading import time weight = 130 def run(): \"\"\"跑步\"\"\" global weight for i in range(3): # print(\"我要减肥!\") weight -= 1 print(weight) def eat(): \"\"\"吃东西\"\"\" global weight for i in range(3): # print(\"我吃了一顿好吃的\") weight += 1 print(weight) def sedentariness(): \"\"\"久坐\"\"\" global weight for i in range(3): weight += 1 print(weight) if __name__ == '__main__': t_run = threading.Thread(target=run) t_eat = threading.Thread(target=eat) t_sedentariness = threading.Thread(target=sedentariness) # t_run.start() t_eat.start() t_sedentariness.start() 这里我们可以看到eat方法和sendentariness方法都是加weight，我们想得到两个133，但是最后结果是一个133，一个136.（tips：线程只有在调用了start方法才会开启，这里没有调用run的start方法，所以没有开启run方法的线程） 这时候我们可以加上互斥锁，在一个线程使用全局变量时其他线程不能修改 ","date":"2018-12-29","objectID":"/python%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B/:1:4","tags":["多线程"],"title":"Python中的多线程","uri":"/python%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["Python"],"content":"可迭代对象(iterable) 可以返回一个迭代器的对象可以称之为可迭代对象。本质上，具备了__iter__方法的对象是可迭代对象。在python中我们可以通过isinstance()判断一个对象是否是可迭代对象，常见的可迭代对象有：list，set，dict，tuple，str。 ","date":"2018-12-22","objectID":"/%E5%85%B3%E4%BA%8E%E6%88%91%E5%AF%B9%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/:1:0","tags":["可迭代对象","迭代器","生成器"],"title":"关于我对可迭代对象，迭代器，生成器的一些理解","uri":"/%E5%85%B3%E4%BA%8E%E6%88%91%E5%AF%B9%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/"},{"categories":["Python"],"content":"实例 In [1]: from collections import Iterable In [2]: isinstance([],Iterable) Out[2]: True In [3]: isinstance(set(),Iterable) Out[3]: True In [4]: isinstance(dict(),Iterable) Out[4]: True In [5]: isinstance((1,),Iterable) Out[5]: True In [6]: isinstance('hello world',Iterable) Out[6]: True ","date":"2018-12-22","objectID":"/%E5%85%B3%E4%BA%8E%E6%88%91%E5%AF%B9%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/:1:1","tags":["可迭代对象","迭代器","生成器"],"title":"关于我对可迭代对象，迭代器，生成器的一些理解","uri":"/%E5%85%B3%E4%BA%8E%E6%88%91%E5%AF%B9%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/"},{"categories":["Python"],"content":"__iter__方法 可以返回一个迭代器 ","date":"2018-12-22","objectID":"/%E5%85%B3%E4%BA%8E%E6%88%91%E5%AF%B9%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/:1:2","tags":["可迭代对象","迭代器","生成器"],"title":"关于我对可迭代对象，迭代器，生成器的一些理解","uri":"/%E5%85%B3%E4%BA%8E%E6%88%91%E5%AF%B9%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/"},{"categories":["Python"],"content":"自定义简单的可迭代对象 In [7]: class A(object): ...: def __iter__(self): ...: \"\"\"返回一个迭代器\"\"\" ...: pass In [8]: a = A() In [9]: isinstance(a,Iterable) Out[9]: True ","date":"2018-12-22","objectID":"/%E5%85%B3%E4%BA%8E%E6%88%91%E5%AF%B9%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/:1:3","tags":["可迭代对象","迭代器","生成器"],"title":"关于我对可迭代对象，迭代器，生成器的一些理解","uri":"/%E5%85%B3%E4%BA%8E%E6%88%91%E5%AF%B9%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/"},{"categories":["Python"],"content":"迭代器(Iterator): 在调用next()方法的时候返回可迭代对象中的下一个值的对象可称为迭代器。本质上，实现 _iter__方法和__next_(python2中next())方法的对象就是迭代器(从这里可以看出迭代器本身也是可迭代对象) ","date":"2018-12-22","objectID":"/%E5%85%B3%E4%BA%8E%E6%88%91%E5%AF%B9%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/:2:0","tags":["可迭代对象","迭代器","生成器"],"title":"关于我对可迭代对象，迭代器，生成器的一些理解","uri":"/%E5%85%B3%E4%BA%8E%E6%88%91%E5%AF%B9%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/"},{"categories":["Python"],"content":"实例 In [10]: from collections import Iterator In [11]: isinstance([], Iterator) Out[11]: False In [12]: isinstance(iter([]), Iterator) Out[12]: True In [13]: isinstance(iter(\"abc\"), Iterator) Out[13]: True ","date":"2018-12-22","objectID":"/%E5%85%B3%E4%BA%8E%E6%88%91%E5%AF%B9%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/:2:1","tags":["可迭代对象","迭代器","生成器"],"title":"关于我对可迭代对象，迭代器，生成器的一些理解","uri":"/%E5%85%B3%E4%BA%8E%E6%88%91%E5%AF%B9%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/"},{"categories":["Python"],"content":"__iter__方法 可以返回迭代器本身 ","date":"2018-12-22","objectID":"/%E5%85%B3%E4%BA%8E%E6%88%91%E5%AF%B9%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/:2:2","tags":["可迭代对象","迭代器","生成器"],"title":"关于我对可迭代对象，迭代器，生成器的一些理解","uri":"/%E5%85%B3%E4%BA%8E%E6%88%91%E5%AF%B9%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/"},{"categories":["Python"],"content":"__next__方法 可以返回可迭代对象中的下一个值，如果可迭代对象中没有下一个值了，则会抛出StopIteration异常。 在python中我们可以使用isinstance()方法判断一个对象是否为迭代器对象。 ","date":"2018-12-22","objectID":"/%E5%85%B3%E4%BA%8E%E6%88%91%E5%AF%B9%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/:2:3","tags":["可迭代对象","迭代器","生成器"],"title":"关于我对可迭代对象，迭代器，生成器的一些理解","uri":"/%E5%85%B3%E4%BA%8E%E6%88%91%E5%AF%B9%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/"},{"categories":["Python"],"content":"自定义简单的迭代器 In [14]: class B(object): ...: ...: def __next__(self): ...: “”“记录当前迭代位置”“” ...: pass ...: ...: def __iter__(self): ...: “”“返回迭代器本身”“” ...: pass ...: In [15]: b = B() In [16]: from collections import Iterator In [17]: isinstance(b,Iterable) Out[17]: True ","date":"2018-12-22","objectID":"/%E5%85%B3%E4%BA%8E%E6%88%91%E5%AF%B9%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/:2:4","tags":["可迭代对象","迭代器","生成器"],"title":"关于我对可迭代对象，迭代器，生成器的一些理解","uri":"/%E5%85%B3%E4%BA%8E%E6%88%91%E5%AF%B9%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/"},{"categories":["Python"],"content":"生成器(generator) 一次生成一个值的特殊类型函数可称为生成器。简单的说就是在函数的执行过程中，yield语句会把你需要的值返回给调用生成器的地方，然后退出函数，下一次调用生成器函数的时候又从上次中断的地方开始执行，而生成器内的所有变量参数都会被保存下来供下一次使用。 当我们自己实现一个迭代器的时候，当前迭代到的状态需要自己记录，进而才能根据当前状态生成下一个数据，而生成器可以通过yield语句记录当前状态，即生成器是一类特殊的迭代器。 由于生成器是特殊的迭代器所以生成器可以通过next()函数，for循环，list()等方法使用 tips：在python3在中range()方法返回的对象是一个生成器对象，python2中则是返回遍历结果 ","date":"2018-12-22","objectID":"/%E5%85%B3%E4%BA%8E%E6%88%91%E5%AF%B9%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/:3:0","tags":["可迭代对象","迭代器","生成器"],"title":"关于我对可迭代对象，迭代器，生成器的一些理解","uri":"/%E5%85%B3%E4%BA%8E%E6%88%91%E5%AF%B9%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/"},{"categories":["Python"],"content":"使用生成器写斐波那契数列 In [18]: def fib(n): ....: current = 0 ....: num1, num2 = 0, 1 ....: while current \u003c n: ....: num = num1 ....: num1, num2 = num2, num1+num2 ....: current += 1 ....: yield num ....: return 'None' ","date":"2018-12-22","objectID":"/%E5%85%B3%E4%BA%8E%E6%88%91%E5%AF%B9%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/:3:1","tags":["可迭代对象","迭代器","生成器"],"title":"关于我对可迭代对象，迭代器，生成器的一些理解","uri":"/%E5%85%B3%E4%BA%8E%E6%88%91%E5%AF%B9%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/"},{"categories":["Python"],"content":"yield语句 python解释器执行到yield这一行时会停下，将yield后面的变量返回，再次调用激活yield(调用next()方法等)的时候，会继续执行yield后面的代码(python3中return后面可以添加返回值，python2中return只能退出生成器，后面不能添加返回值) ","date":"2018-12-22","objectID":"/%E5%85%B3%E4%BA%8E%E6%88%91%E5%AF%B9%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/:3:2","tags":["可迭代对象","迭代器","生成器"],"title":"关于我对可迭代对象，迭代器，生成器的一些理解","uri":"/%E5%85%B3%E4%BA%8E%E6%88%91%E5%AF%B9%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/"},{"categories":["Python"],"content":"总结 ***1.可迭代对象是可以进行迭代操作的对象，具有__iter__方法，调用__iter__方法可以返回一个迭代器 2.迭代器是特殊的可迭代对象，可以记录当前访问位置的对象，具有__next__方法，当通过next()调用__next__(python2中为next)方法时，会返回下一个位置的值。迭代器是一个特殊的可迭代对象，当调用__iter__方法时，会将自己返回。 3.生成器是特殊的迭代器，他自动记录当前迭代的状态，当我们调用调用next()方法的时候会帮我们从上一次停下来的地方继续执行*** ","date":"2018-12-22","objectID":"/%E5%85%B3%E4%BA%8E%E6%88%91%E5%AF%B9%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/:4:0","tags":["可迭代对象","迭代器","生成器"],"title":"关于我对可迭代对象，迭代器，生成器的一些理解","uri":"/%E5%85%B3%E4%BA%8E%E6%88%91%E5%AF%B9%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/"},{"categories":["生活"],"content":"新的开始 ","date":"2018-12-16","objectID":"/%E4%B8%8A%E6%B5%B7%E6%88%91%E6%9D%A5%E4%BA%86/:1:0","tags":["上海"],"title":"上海我来了","uri":"/%E4%B8%8A%E6%B5%B7%E6%88%91%E6%9D%A5%E4%BA%86/"},{"categories":["生活"],"content":"序 现在还记得来上海那天在高铁上还在Boss直聘上跟几个面试官约面试，那时候真的很兴奋，感觉大展拳脚的时候到了！到上海的时候已经是晚上10点多了，万幸赶上了末班地铁，发现提前定好的青旅离虹桥站还挺近的，半个小时地铁就能到。由于身上钱不多订的是一个8人间的上下铺，我入住的时候好多人都已经准备休息了，我很快洗漱完毕就躺床上了，第一天晚上超级兴奋，根本睡不着(其实还因为有人打呼噜，太吵了，我睡眠质量又不太好！！！) ","date":"2018-12-16","objectID":"/%E4%B8%8A%E6%B5%B7%E6%88%91%E6%9D%A5%E4%BA%86/:1:1","tags":["上海"],"title":"上海我来了","uri":"/%E4%B8%8A%E6%B5%B7%E6%88%91%E6%9D%A5%E4%BA%86/"},{"categories":["生活"],"content":"面试 到上海的第二天就开始准备面试和考察面试的公司。通过地图发现要面试的这几家都很近，很快制定了面试的方案。幸运的是，第三天的面试两家都很成功，成功通过了技术面，不幸的是HR面薪资没有给到我想要的，我决定再多面几家。直到第五天，面了有5，6家了，还是没找到适合自己的，我开始有点慌了,先在美团上把青旅续费了一周时间。然后准备下一家面试给出的面试题，让我按照要求写一个程序出来，如果写的可以就能参加第二面。由于之前没接触过这个包，在网上简单学习了一下入门就开始写代码了，经过一个下午的努力终于完成了代码，发给面试官，然后开始了等消息时间，庆幸的是晚上得到了面试的邀请。面试过程非常nice，问完我问题后，他开始给我介绍他的目标与构想，我感觉非常符合我的预期，很快就收到了HR面的邀请，心里暗自高兴，虽然工资跟前几家差不多，但是这个Leader跟我非常聊得来，在面试的过程中他提出问题涉及到我不熟悉的地方他会指引我的思路，让我想出更好的解决方案，让我感觉就在跟朋友探讨一样，我非常想入职该公司！很快，当天晚上就收到了入职申请，那天是星期四，HR问我明天能不能来上班，我想都没想就说：能！ ","date":"2018-12-16","objectID":"/%E4%B8%8A%E6%B5%B7%E6%88%91%E6%9D%A5%E4%BA%86/:1:2","tags":["上海"],"title":"上海我来了","uri":"/%E4%B8%8A%E6%B5%B7%E6%88%91%E6%9D%A5%E4%BA%86/"},{"categories":["生活"],"content":"租房 由于周五就入职开始上班，周末跟上海的几个朋友聚了一下，导致一直没有时间找房子。还好有一个玩的不错的小伙伴，他找到了一个合适的两居室，我看了一下，当天晚上就一起跟房东签了。从最开始来睡在8人间上下铺的青旅(如果是来上海玩还挺不错的，前台小姐姐人超好的，而且还能认识很多五湖四海的朋友)，到现在找到工作后和志同道合的小伙伴一起合租了一个60+平的两室，生活质量提高了不少，终于不用睡上铺听下铺打呼噜声了，就是房租很肉疼，租的娄山关路这块的房子，一套5800，押一付三。非常感谢爸妈对我提供的资金支持，等赚到钱了我会好好孝顺你们的。 ","date":"2018-12-16","objectID":"/%E4%B8%8A%E6%B5%B7%E6%88%91%E6%9D%A5%E4%BA%86/:1:3","tags":["上海"],"title":"上海我来了","uri":"/%E4%B8%8A%E6%B5%B7%E6%88%91%E6%9D%A5%E4%BA%86/"},{"categories":["生活"],"content":"新的公司 目前对就职的新公司非常满意，老板很开明，让我们有很大的自由发挥空间。Leader人超棒，不仅在工作上给予了我很多帮助，在生活上也教会我很多东西。同事也都超好，大家就跟朋友一样，还经常一起聚会玩狼人杀。 ","date":"2018-12-16","objectID":"/%E4%B8%8A%E6%B5%B7%E6%88%91%E6%9D%A5%E4%BA%86/:1:4","tags":["上海"],"title":"上海我来了","uri":"/%E4%B8%8A%E6%B5%B7%E6%88%91%E6%9D%A5%E4%BA%86/"},{"categories":["生活"],"content":"感想 来上海有一个半月的时间了，对这个城市的初映象还蛮好的。最开始来的时候像个乡下人，一直在惊叹，哇上海都是4车道的大马路耶，上海好多高楼耶，上海的环卫和绿植都做得好好耶。不得不说上海的基础建设非常的棒，希望小武汉也快点跟上脚步。 现在发现刚开始买高铁票来上海可能有点点冲动，但那时候我非常想去一个更大的地方发展。从实习的公司离职其实心里很忐忑，害怕自己找不到新的工作，但来到上海发现这边对学历的包容度还是很高的，只要你有足够的能力，他们愿意给你机会。 ","date":"2018-12-16","objectID":"/%E4%B8%8A%E6%B5%B7%E6%88%91%E6%9D%A5%E4%BA%86/:1:5","tags":["上海"],"title":"上海我来了","uri":"/%E4%B8%8A%E6%B5%B7%E6%88%91%E6%9D%A5%E4%BA%86/"},{"categories":null,"content":"关于 ","date":"2018-03-30","objectID":"/about/:0:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"我 本博客的博主Silence，很高兴能在这里遇见你，以后的日子里就请多多关照啦。 目前是一名Python开发工程师，技术栈丰富，平时喜欢自己捣鼓一些有意思的项目。 ","date":"2018-03-30","objectID":"/about/:1:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"博客 本博客使用 Hugo 搭建的静态博客，主题采用的是 Dillon 开发的 LoveIt主题。 本博客用于我自己的技术记载，相关分享与生活记录总结。 目前博文数量为：88，总字数为：208122 ","date":"2018-03-30","objectID":"/about/:2:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"宗旨 分享是美德，生活因分享而充实，世界因分享而美丽！ ","date":"2018-03-30","objectID":"/about/:3:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"版权 本博客所有文章皆采用 知识共享署名-非商业性使用 4.0 国际许可协议 进行许可。 本博客文章欢迎转载，转载请注明出处。 ","date":"2018-03-30","objectID":"/about/:4:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"声明 本博客所提供的信息，只供参考之用。 本博客毋须以任何方式就任何信息的传递或传送的错误、不准确负任何直接或间接的责任。 本博客图片、文字之类，如有侵犯您的版权，请及时通知我，我一定会在第一时间将其删除。 凡以任何方式直接、间接使用本博客资料者，视为自愿接受本博客声明的约束。 ","date":"2018-03-30","objectID":"/about/:5:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"技能 ","date":"2018-03-30","objectID":"/about/:6:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"熟练 语言：Python、Go 技术栈：Django、Flask、Redis、MySQL、MongoDB、Scrapy、Selenium、Linux ","date":"2018-03-30","objectID":"/about/:6:1","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"了解 语言：Java、JavaScript、 技术栈：Docker、Vue.js、Bootstrap、ECharts、TensorFlow、 ","date":"2018-03-30","objectID":"/about/:6:2","tags":null,"title":"About","uri":"/about/"},{"categories":["Tornado"],"content":"Cookie 对于RequestHandler，除了在初始Tornado中讲到的之外，还提供了操作cookie的方法。 ","date":"0001-01-01","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E5%AE%89%E5%85%A8%E5%BA%94%E7%94%A8/:1:0","tags":["Python学习之路"],"title":"Python学习之路-Tornado基础:安全应用","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E5%AE%89%E5%85%A8%E5%BA%94%E7%94%A8/"},{"categories":["Tornado"],"content":"设置 set_cookie(name, value, domain=None, expires=None, path=’/’, expires_days=None) 参数说明： 参数名 说明 name cookie名 value cookie值 domain 提交cookie时匹配的域名 path 提交cookie时匹配的路径 expires cookie的有效期，可以是时间戳整数、时间元组或者datetime类型，为UTC时间 expires_days cookie的有效期，天数，优先级低于expires import datetime class IndexHandler(RequestHandler): def get(self): self.set_cookie(\"n1\", \"v1\") self.set_cookie(\"n2\", \"v2\", path=\"/new\", expires=time.strptime(\"2016-11-11 23:59:59\",\"%Y-%m-%d%H:%M:%S\")) self.set_cookie(\"n3\", \"v3\", expires_days=20) # 利用time.mktime将本地时间转换为UTC标准时间 self.set_cookie(\"n4\", \"v4\", expires=time.mktime(time.strptime(\"2016-11-11 23:59:59\",\"%Y-%m-%d%H:%M:%S\"))) self.write(\"OK\") ","date":"0001-01-01","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E5%AE%89%E5%85%A8%E5%BA%94%E7%94%A8/:1:1","tags":["Python学习之路"],"title":"Python学习之路-Tornado基础:安全应用","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E5%AE%89%E5%85%A8%E5%BA%94%E7%94%A8/"},{"categories":["Tornado"],"content":"原理 设置cookie实际就是通过设置header的Set-Cookie来实现的。 class IndexHandler(RequestHandler): def get(self): self.set_header(\"Set-Cookie\", \"n5=v5; expires=Fri, 11 Nov 2016 15:59:59 GMT; Path=/\") self.write(\"OK\") ","date":"0001-01-01","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E5%AE%89%E5%85%A8%E5%BA%94%E7%94%A8/:1:2","tags":["Python学习之路"],"title":"Python学习之路-Tornado基础:安全应用","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E5%AE%89%E5%85%A8%E5%BA%94%E7%94%A8/"},{"categories":["Tornado"],"content":"获取 get_cookie(name, default=None) 获取名为name的cookie，可以设置默认值。 class IndexHandler(RequestHandler): def get(self): n3 = self.get_cookie(\"n3\") self.write(n3) ","date":"0001-01-01","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E5%AE%89%E5%85%A8%E5%BA%94%E7%94%A8/:1:3","tags":["Python学习之路"],"title":"Python学习之路-Tornado基础:安全应用","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E5%AE%89%E5%85%A8%E5%BA%94%E7%94%A8/"},{"categories":["Tornado"],"content":"清除 clear_cookie(name, path=’/’, domain=None) 删除名为name，并同时匹配domain和path的cookie。 clear_all_cookies(path=’/’, domain=None) 删除同时匹配domain和path的所有cookie。 class ClearOneCookieHandler(RequestHandler): def get(self): self.clear_cookie(\"n3\") self.write(\"OK\") class ClearAllCookieHandler(RequestHandler): def get(self): self.clear_all_cookies() self.write(\"OK\") 注意 执行清除cookie操作后，并不是立即删除了浏览器中的cookie，而是给cookie值置空，并改变其有效期使其失效。真正的删除cookie是由浏览器去清理的。 ","date":"0001-01-01","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E5%AE%89%E5%85%A8%E5%BA%94%E7%94%A8/:1:4","tags":["Python学习之路"],"title":"Python学习之路-Tornado基础:安全应用","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E5%AE%89%E5%85%A8%E5%BA%94%E7%94%A8/"},{"categories":["Tornado"],"content":"安全Cookie Cookie是存储在客户端浏览器中的，很容易被篡改。Tornado提供了一种对Cookie进行简易加密签名的方法来防止Cookie被恶意篡改。 使用安全Cookie需要为应用配置一个用来给Cookie进行混淆的秘钥cookie_secret，将其传递给Application的构造函数。我们可以使用如下方法来生成一个随机字符串作为cookie_secret的值。 \u003e\u003e\u003e import base64, uuid \u003e\u003e\u003e base64.b64encode(uuid.uuid4().bytes + uuid.uuid4().bytes) '2hcicVu+TqShDpfsjMWQLZ0Mkq5NPEWSk9fi0zsSt3A=' 提示 Base64是一种基于64个可打印字符来表示二进制数据的表示方法。由于2的6次方等于64，所以每6个比特为一个单元，对应某个可打印字符。三个字节有24个比特，对应于4个Base64单元，即3个字节需要用4个可打印字符来表示。 uuid, 通用唯一识别码（英语：Universally Unique Identifier，简称UUID），是由一组32个16进制数字所构成（两个16进制数是一个字节，总共16字节），因此UUID理论上的总数为16^32=2^128，约等于3.4 x 10^38。也就是说若每纳秒产生1兆个UUID，要花100亿年才会将所有UUID用完。 uuid模块的uuid4()函数可以随机产生一个uuid码，bytes属性将此uuid码作为16字节字符串。 将生成的cookie_secret传入Application构造函数： app = tornado.web.Application( [(r\"/\", IndexHandler),], cookie_secret = \"2hcicVu+TqShDpfsjMWQLZ0Mkq5NPEWSk9fi0zsSt3A=\" ) ","date":"0001-01-01","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E5%AE%89%E5%85%A8%E5%BA%94%E7%94%A8/:1:5","tags":["Python学习之路"],"title":"Python学习之路-Tornado基础:安全应用","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E5%AE%89%E5%85%A8%E5%BA%94%E7%94%A8/"},{"categories":["Tornado"],"content":"获取和设置 set_secure_cookie(name, value, expires_days=30) 设置一个带签名和时间戳的cookie，防止cookie被伪造。 get_secure_cookie(name, value=None, max_age_days=31) 如果cookie存在且验证通过，返回cookie的值，否则返回None。max_age_day不同于expires_days，expires_days是设置浏览器中cookie的有效期，而max_age_day是过滤安全cookie的时间戳。 class IndexHandler(RequestHandler): def get(self): cookie = self.get_secure_cookie(\"count\") count = int(cookie) + 1 if cookie else 1 self.set_secure_cookie(\"count\", str(count)) self.write( '\u003chtml\u003e\u003chead\u003e\u003ctitle\u003eCookie计数器\u003c/title\u003e\u003c/head\u003e' '\u003cbody\u003e\u003ch1\u003e您已访问本页%d次。\u003c/h1\u003e' % count + '\u003c/body\u003e\u003c/html\u003e' ) 我们看签名后的cookie值： \"2|1:0|10:1476412069|5:count|4:NQ==|cb5fc1d4434971de6abf87270ac33381c686e4ec8c6f7e62130a0f8cbe5b7609\" 字段说明： 安全cookie的版本，默认使用版本2，不带长度说明前缀 默认为0 时间戳 cookie名 base64编码的cookie值 签名值，不带长度说明前缀 注意 Tornado的安全cookie只是一定程度的安全，仅仅是增加了恶意修改的难度。Tornado的安全cookies仍然容易被窃听，而cookie值是签名不是加密，攻击者能够读取已存储的cookie值，并且可以传输他们的数据到任意服务器，或者通过发送没有修改的数据给应用伪造请求。因此，避免在浏览器cookie中存储敏感的用户数据是非常重要的。 ","date":"0001-01-01","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E5%AE%89%E5%85%A8%E5%BA%94%E7%94%A8/:1:6","tags":["Python学习之路"],"title":"Python学习之路-Tornado基础:安全应用","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E5%AE%89%E5%85%A8%E5%BA%94%E7%94%A8/"},{"categories":["Tornado"],"content":"XSRF ","date":"0001-01-01","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E5%AE%89%E5%85%A8%E5%BA%94%E7%94%A8/:2:0","tags":["Python学习之路"],"title":"Python学习之路-Tornado基础:安全应用","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E5%AE%89%E5%85%A8%E5%BA%94%E7%94%A8/"},{"categories":["Tornado"],"content":"跨站请求伪造 先建立一个网站127.0.0.1:8000，使用上一节中的Cookie计数器： class IndexHandler(RequestHandler): def get(self): cookie = self.get_secure_cookie(\"count\") count = int(cookie) + 1 if cookie else 1 self.set_secure_cookie(\"count\", str(count)) self.write( '\u003chtml\u003e\u003chead\u003e\u003ctitle\u003eCookie计数器\u003c/title\u003e\u003c/head\u003e' '\u003cbody\u003e\u003ch1\u003e您已访问本页%d次。\u003c/h1\u003e' % count + '\u003c/body\u003e\u003c/html\u003e' ) 再建立一个网站127.0.0.1:9000， class IndexHandler(RequestHandler): def get(self): self.write('\u003chtml\u003e\u003chead\u003e\u003ctitle\u003e被攻击的网站\u003c/title\u003e\u003c/head\u003e' '\u003cbody\u003e\u003ch1\u003e此网站的图片链接被修改了\u003c/h1\u003e' '\u003cimg alt=\"这应该是图片\" src=\"http://127.0.0.1:8000/?f=9000/\"\u003e' '\u003c/body\u003e\u003c/html\u003e' ) 在9000网站我们模拟攻击者修改了我们的图片源地址为8000网站的Cookie计数器页面网址。当我们访问9000网站的时候，在我们不知道、未授权的情况下8000网站的Cookie被使用了，以至于让8000网址认为是我们自己调用了8000网站的逻辑。这就是CSRF（Cross-site request forgery）跨站请求伪造（跨站攻击或跨域攻击的一种），通常缩写为CSRF或者XSRF。 我们刚刚使用的是GET方式模拟的攻击，为了防范这种方式的攻击，任何会产生副作用的HTTP请求，比如点击购买按钮、编辑账户设置、改变密码或删除文档，都应该使用HTTP POST方法（或PUT、DELETE）。但是，这并不足够：一个恶意站点可能会通过其他手段来模拟发送POST请求，保护POST请求需要额外的策略。 ","date":"0001-01-01","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E5%AE%89%E5%85%A8%E5%BA%94%E7%94%A8/:2:1","tags":["Python学习之路"],"title":"Python学习之路-Tornado基础:安全应用","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E5%AE%89%E5%85%A8%E5%BA%94%E7%94%A8/"},{"categories":["Tornado"],"content":"XSRF保护 提示 浏览器有一个很重要的概念——同源策略(Same-Origin Policy)。 所谓同源是指，域名，协议，端口相同。 不同源的客户端脚本(javascript、ActionScript)在没明确授权的情况下，不能读写对方的资源。 由于第三方站点没有访问cookie数据的权限（同源策略），所以我们可以要求每个请求包括一个特定的参数值作为令牌来匹配存储在cookie中的对应值，如果两者匹配，我们的应用认定请求有效。而第三方站点无法在请求中包含令牌cookie值，这就有效地防止了不可信网站发送未授权的请求。 开启XSRF保护 要开启XSRF保护，需要在Application的构造函数中添加xsrf_cookies参数： app = tornado.web.Application( [(r\"/\", IndexHandler),], cookie_secret = \"2hcicVu+TqShDpfsjMWQLZ0Mkq5NPEWSk9fi0zsSt3A=\", xsrf_cookies = True ) 当这个参数被设置时，Tornado将拒绝请求参数中不包含正确的_xsrf值的POST、PUT和DELETE请求。 class IndexHandler(RequestHandler): def post(self): self.write(\"hello itcast\") 用不带_xsrf的post请求时，报出了HTTP 403: Forbidden ('_xsrf' argument missing from POST)的错误。 ","date":"0001-01-01","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E5%AE%89%E5%85%A8%E5%BA%94%E7%94%A8/:2:2","tags":["Python学习之路"],"title":"Python学习之路-Tornado基础:安全应用","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E5%AE%89%E5%85%A8%E5%BA%94%E7%94%A8/"},{"categories":["Tornado"],"content":"模板应用 在模板中使用XSRF保护，只需在模板中添加 module xsrf_form_html() 如新建一个模板index.html \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003e测试XSRF\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cform method=\"post\"\u003e \u003cinput type=\"text\" name=\"message\"/\u003e \u003cinput type=\"submit\" value=\"Post\"/\u003e \u003c/form\u003e \u003c/body\u003e \u003c/html\u003e 后端 class IndexHandler(RequestHandler): def get(self): self.render(\"index.html\") def post(self): self.write(\"hello itcast\") 模板中添加的语句帮我们做了两件事： 为浏览器设置了_xsrf的Cookie（注意此Cookie浏览器关闭时就会失效） 为模板的表单中添加了一个隐藏的输入名为_xsrf，其值为_xsrf的Cookie值 渲染后的页面原码如下： \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003e测试XSRF\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cform method=\"post\"\u003e \u003cinput type=\"hidden\" name=\"_xsrf\" value=\"2|543c2206|a056ff9e49df23eaffde0a694cde2b02|1476443353\"/\u003e \u003cinput type=\"text\" name=\"message\"/\u003e \u003cinput type=\"submit\" value=\"Post\"/\u003e \u003c/form\u003e \u003c/body\u003e \u003c/html\u003e ","date":"0001-01-01","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E5%AE%89%E5%85%A8%E5%BA%94%E7%94%A8/:2:3","tags":["Python学习之路"],"title":"Python学习之路-Tornado基础:安全应用","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E5%AE%89%E5%85%A8%E5%BA%94%E7%94%A8/"},{"categories":["Tornado"],"content":"非模板应用 对于不使用模板的应用来说，首先要设置_xsrf的Cookie值，可以在任意的Handler中通过获取self.xsrf_token的值来生成_xsrf并设置Cookie。 下面两种方式都可以起到设置_xsrf Cookie的作用。 class XSRFTokenHandler(RequestHandler): \"\"\"专门用来设置_xsrf Cookie的接口\"\"\" def get(self): self.xsrf_token self.write(\"Ok\") class StaticFileHandler(tornado.web.StaticFileHandler): \"\"\"重写StaticFileHandler，构造时触发设置_xsrf Cookie\"\"\" def __init__(self, *args, **kwargs): super(StaticFileHandler, self).__init__(*args, **kwargs) self.xsrf_token 对于请求携带_xsrf参数，有两种方式： 若请求体是表单编码格式的，可以在请求体中添加_xsrf参数 若请求体是其他格式的（如json或xml等），可以通过设置HTTP头X-XSRFToken来传递_xsrf值 请求体携带_xsrf参数 新建一个页面xsrf.html： \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"\u003e \u003ctitle\u003e测试XSRF\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ca href=\"javascript:;\" onclick=\"xsrfPost()\"\u003e发送POST请求\u003c/a\u003e \u003cscript src=\"http://cdn.bootcss.com/jquery/3.1.1/jquery.min.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\"\u003e //获取指定Cookie的函数 function getCookie(name) { var r = document.cookie.match(\"\\\\b\" + name + \"=([^;]*)\\\\b\"); return r ? r[1] : undefined; } //AJAX发送post请求，表单格式数据 function xsrfPost() { var xsrf = getCookie(\"_xsrf\"); $.post(\"/new\", \"_xsrf=\"+xsrf+\"\u0026key1=value1\", function(data) { alert(\"OK\"); }); } \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e HTTP头X-XSRFToken 新建一个页面json.html： \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"\u003e \u003ctitle\u003e测试XSRF\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ca href=\"javascript:;\" onclick=\"xsrfPost()\"\u003e发送POST请求\u003c/a\u003e \u003cscript src=\"http://cdn.bootcss.com/jquery/3.1.1/jquery.min.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\"\u003e //获取指定Cookie的函数 function getCookie(name) { var r = document.cookie.match(\"\\\\b\" + name + \"=([^;]*)\\\\b\"); return r ? r[1] : undefined; } //AJAX发送post请求，json格式数据 function xsrfPost() { var xsrf = getCookie(\"_xsrf\"); var data = { key1:1, key1:2 }; var json_data = JSON.stringify(data); $.ajax({ url: \"/new\", method: \"POST\", headers: { \"X-XSRFToken\":xsrf, }, data:json_data, success:function(data) { alert(\"OK\"); } }) } \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ","date":"0001-01-01","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E5%AE%89%E5%85%A8%E5%BA%94%E7%94%A8/:2:4","tags":["Python学习之路"],"title":"Python学习之路-Tornado基础:安全应用","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E5%AE%89%E5%85%A8%E5%BA%94%E7%94%A8/"},{"categories":["Tornado"],"content":"用户验证 ","date":"0001-01-01","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E5%AE%89%E5%85%A8%E5%BA%94%E7%94%A8/:3:0","tags":["Python学习之路"],"title":"Python学习之路-Tornado基础:安全应用","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E5%AE%89%E5%85%A8%E5%BA%94%E7%94%A8/"},{"categories":["Tornado"],"content":"简介 用户验证是指在收到用户请求后进行处理前先判断用户的认证状态（如登陆状态），若通过验证则正常处理，否则强制用户跳转至认证页面（如登陆页面）。 ","date":"0001-01-01","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E5%AE%89%E5%85%A8%E5%BA%94%E7%94%A8/:3:1","tags":["Python学习之路"],"title":"Python学习之路-Tornado基础:安全应用","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E5%AE%89%E5%85%A8%E5%BA%94%E7%94%A8/"},{"categories":["Tornado"],"content":"authenticated装饰器 为了使用Tornado的认证功能，我们需要对登录用户标记具体的处理函数。我们可以使用@tornado.web.authenticated装饰器完成它。当我们使用这个装饰器包裹一个处理方法时，Tornado将确保这个方法的主体只有在合法的用户被发现时才会调用。 class ProfileHandler(RequestHandler): @tornado.web.authenticated def get(self): self.write(\"这是我的个人主页。\") ","date":"0001-01-01","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E5%AE%89%E5%85%A8%E5%BA%94%E7%94%A8/:3:2","tags":["Python学习之路"],"title":"Python学习之路-Tornado基础:安全应用","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E5%AE%89%E5%85%A8%E5%BA%94%E7%94%A8/"},{"categories":["Tornado"],"content":"get_current_user()方法 装饰器@tornado.web.authenticated的判断执行依赖于请求处理类中的self.current_user属性，如果current_user值为假（None、False、0、““等），任何GET或HEAD请求都将把访客重定向到应用设置中login_url指定的URL，而非法用户的POST请求将返回一个带有403（Forbidden）状态的HTTP响应。 在获取self.current_user属性的时候，tornado会调用get_current_user()方法来返回current_user的值。也就是说，我们验证用户的逻辑应写在get_current_user()方法中，若该方法返回非假值则验证通过，否则验证失败。 class ProfileHandler(RequestHandler): def get_current_user(self): \"\"\"在此完成用户的认证逻辑\"\"\" user_name = self.get_argument(\"name\", None) return user_name @tornado.web.authenticated def get(self): self.write(\"这是我的个人主页。\") ","date":"0001-01-01","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E5%AE%89%E5%85%A8%E5%BA%94%E7%94%A8/:3:3","tags":["Python学习之路"],"title":"Python学习之路-Tornado基础:安全应用","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E5%AE%89%E5%85%A8%E5%BA%94%E7%94%A8/"},{"categories":["Tornado"],"content":"login_url设置 当用户验证失败时，将用户重定向到login_url上，所以我们还需要在Application中配置login_url。 class LoginHandler(RequestHandler): def get(self): \"\"\"在此返回登陆页面\"\"\" self.write(\"登陆页面\") app = tornado.web.Application( [ (r\"/\", IndexHandler), (r\"/profile\", ProfileHandler), (r\"/login\", LoginHandler), ], \"login_url\":\"/login\" ) 在login_url后面补充的next参数就是记录的跳转至登录页面前的所在位置，所以我们可以使用next参数来完成登陆后的跳转。 修改登陆逻辑： class LoginHandler(RequestHandler): def get(self): \"\"\"登陆处理，完成登陆后跳转回前一页面\"\"\" next = self.get_argument(\"next\", \"/\") self.redirect(next+\"?name=logined\") ","date":"0001-01-01","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E5%AE%89%E5%85%A8%E5%BA%94%E7%94%A8/:3:4","tags":["Python学习之路"],"title":"Python学习之路-Tornado基础:安全应用","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-tornado%E5%9F%BA%E7%A1%80%E5%AE%89%E5%85%A8%E5%BA%94%E7%94%A8/"}]