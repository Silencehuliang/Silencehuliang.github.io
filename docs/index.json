[{"categories":null,"content":"关于 ","date":"2021-03-30","objectID":"/about/:0:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"我 胡亮，湖北武汉人，现住上海市闵行区龙柏新村。一名Python开发工程师，技术栈丰富，平时喜欢自己捣鼓一些有意思的项目。 ","date":"2021-03-30","objectID":"/about/:1:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"博客 此博客用于我自己的技术记载与相关分享 ","date":"2021-03-30","objectID":"/about/:2:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"技能 ","date":"2021-03-30","objectID":"/about/:3:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"熟练 语言：Python 技术栈：Django、Flask、Redis、MySQL、MongoDB、Scrapy、Selenium、Linux ","date":"2021-03-30","objectID":"/about/:3:1","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"了解 语言：Java、Go、JavaScript、 技术栈：Docker、Vue.js、Bootstrap、ECharts、TensorFlow、 ","date":"2021-03-30","objectID":"/about/:3:2","tags":null,"title":"About","uri":"/about/"},{"categories":["爬虫"],"content":"Python爬虫实战之bilibili","date":"2020-03-05","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/","tags":["爬虫"],"title":"Python爬虫实战之bilibili","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/"},{"categories":["爬虫"],"content":"声明：以下内容均为我个人的理解，如果发现错误或者疑问可以联系我共同探讨 ","date":"2020-03-05","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/:0:0","tags":["爬虫"],"title":"Python爬虫实战之bilibili","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/"},{"categories":["爬虫"],"content":"爬虫介绍 ","date":"2020-03-05","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/:1:0","tags":["爬虫"],"title":"Python爬虫实战之bilibili","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/"},{"categories":["爬虫"],"content":"网站介绍 本次要爬取的网站为bilibili，它是国内知名的视频弹幕网站,这里有及时的动漫新番,活跃的ACG氛围,有创意的Up主。可以在这里找到许多欢乐。 ","date":"2020-03-05","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/:1:1","tags":["爬虫"],"title":"Python爬虫实战之bilibili","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/"},{"categories":["爬虫"],"content":"编写爬虫的原因和用途 bilibili已经从原来的小破站变成了现在现象级的多元化的社区网站，本次爬取它的目的是以它作为一个典型，告诉大家遇到各类型验证码的一种思路。 其实这类网站有个最简单的办法，就是提前登陆手动获取到cookie，然后根据cookie去请求我们需要爬取的网站。个人目的的爬虫可以用这类方法，比较省编写代码的时间。但是公司中可能会遇到众多账户的爬虫需求，一个一个手动登录去获取cookie就比较麻烦了，这时候使用Selenium自动化去获取效率就高很多了。 ","date":"2020-03-05","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/:1:2","tags":["爬虫"],"title":"Python爬虫实战之bilibili","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/"},{"categories":["爬虫"],"content":"Selenium ","date":"2020-03-05","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/:2:0","tags":["爬虫"],"title":"Python爬虫实战之bilibili","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/"},{"categories":["爬虫"],"content":"简介 正如他们官方的介绍Selenium automates browsers. That's it!，他是一个自动化的浏览器，可以模拟人的操作。 ","date":"2020-03-05","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/:2:1","tags":["爬虫"],"title":"Python爬虫实战之bilibili","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/"},{"categories":["爬虫"],"content":"使用教程 推荐通过Selenium中文网学习，非常全面！ ","date":"2020-03-05","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/:2:2","tags":["爬虫"],"title":"Python爬虫实战之bilibili","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/"},{"categories":["爬虫"],"content":"验证码分析 ","date":"2020-03-05","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/:3:0","tags":["爬虫"],"title":"Python爬虫实战之bilibili","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/"},{"categories":["爬虫"],"content":"滑动验证码 哔哩哔哩从之前的验证码是滑动验证码，主要思路就是找到缺口确定缺口的坐标，然后通过Selenium操作滑动到指定位置就行。类似的还有阿里系的大部分网页，比如飞猪、淘宝、天猫等，不过阿里系的不是每次都需要验证，得根据实际情况操作。 这种就是找到最右边的位置信息，然后滑动即可 这种需要先找到整个图片的位置，然后滑动先找到内容的轮廓在进行滑动，都是同一个思路演变的 ","date":"2020-03-05","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/:3:1","tags":["爬虫"],"title":"Python爬虫实战之bilibili","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/"},{"categories":["爬虫"],"content":"看图填答案系列 包括东方财富网上交易、bigquant等等，这类比较简单。将其下载下来根据验证码的情况进行处理然后交给各大云服务商的ORC服务识别就可以，都有免费试用的额度，根据自己的需求和喜好选择，也可以多试几家进行对比。 百度、腾讯、阿里、有道智云 ","date":"2020-03-05","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/:3:2","tags":["爬虫"],"title":"Python爬虫实战之bilibili","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/"},{"categories":["爬虫"],"content":"根据图片进行操作点击系列 目前多了很多这种验证码，这种的难度在于情况变化比较多，不仅限于汉字和数字，还有可能是图片等等，这时候自己想办法也能解决，但是策略一改变就比较麻烦，可以借助各类打码的平台，对内容进行识别，然后再根据内容去进行操作 易云打码、快识别网址、斐斐打码等等 ","date":"2020-03-05","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/:3:3","tags":["爬虫"],"title":"Python爬虫实战之bilibili","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/"},{"categories":["爬虫"],"content":"bilibili登陆分析 bilibili的最新的验证码属于第三种，在点击登陆按钮就会出现一个验证码的框,我们需要将这个图片下载下来给打码平台去识别，获得坐标信息然后再用Selenium进行点击操作 ​ bilibili验证码 ","date":"2020-03-05","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/:4:0","tags":["爬虫"],"title":"Python爬虫实战之bilibili","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/"},{"categories":["爬虫"],"content":"编写代码 ","date":"2020-03-05","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/:5:0","tags":["爬虫"],"title":"Python爬虫实战之bilibili","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/"},{"categories":["爬虫"],"content":"Selenium模拟登陆 import re import time import base64 import json import requests from selenium import webdriver from selenium.webdriver import ActionChains from selenium.webdriver.chrome.options import Options class Bilibili(object): def __init__(self): chrome_options = Options() # 设置无窗口模式 # chrome_options.add_argument('--headless') self.driver = webdriver.Chrome('./chromedriver', options=chrome_options) def login(self, username, password): # 开登陆页面 self.driver.get(\"https://passport.bilibili.com/login\") # 输入用户名和密码 self.driver.find_element_by_id('login-username').send_keys(username) self.driver.find_element_by_id('login-passwd').send_keys(password) # 点击登陆按钮 self.driver.find_element_by_class_name('btn-login').click() # 等待验证码出现 # self.driver.implicitly_wait(10) time.sleep(5) # 获取图片所在属性 img_style = self.driver.find_element_by_class_name('geetest_tip_img').get_attribute('style') # 通过正则表达式获得图片url url = re.findall('url\\(\"(.*?)\"\\)', img_style)[0] # 通过requests发送请求得到图片 response = requests.get(url).content # 将图片保存在本地 with open('./captcha.png', 'wb') as f: f.write(response) # 通过打码平台进行打码识别 result = self.captcha_recognition() # 识别成功 if result != \"\": # 对识别到的坐标进行分组处理 result_list = result.split('|') for result in result_list: x = result.split(',')[0] y = result.split(',')[1] # 根据坐标执行整个动作链 ActionChains(self.driver).move_to_element_with_offset(img_style, int(x), int(y)).click().perform() # 点击确定按钮 self.driver.find_element_by_class_name('geetest_commit').click() # 获得登陆后的cookie cookie = [item[\"name\"] + \"=\" + item[\"value\"] for item in self.driver.get_cookies()] self.driver.close() return cookie def captcha_recognition(self): \"\"\"验证码识别\"\"\" username = 'username' password = 'password' with open('./captcha.png', 'rb') as f: base64_data = base64.b64encode(f.read()) b64 = base64_data.decode() data = {\"username\": username, \"password\": password, \"typeid\": 27, \"image\": b64} result = json.loads(requests.post(\"http://api.ttshitu.com/predict\", json=data).text) if result['success']: return result[\"data\"][\"result\"] else: print(result[\"message\"]) return \"\" ","date":"2020-03-05","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/:5:1","tags":["爬虫"],"title":"Python爬虫实战之bilibili","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/"},{"categories":["爬虫"],"content":"Python爬虫实战之萝卜投研","date":"2020-02-28","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"声明：以下内容均为我个人的理解，如果发现错误或者疑问可以联系我共同探讨 ","date":"2020-02-28","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:0:0","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"爬虫介绍 ","date":"2020-02-28","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:1:0","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"网站介绍 本次要爬取的网站为*萝卜投研*，是利用人工智能、大数据、移动应用技术,建立的股票基本面分析智能投研平台，在进行投资交易的时候可以使用期研报与各类数据进行分析。 ","date":"2020-02-28","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:1:1","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"编写爬虫的原因和用途 本人闲暇时间会学习投资理财相关内容，萝卜投研可以获取许多财经类的信息与很多研报，本次想通过编写爬虫完成对目标数据完成持久化存储与相关舆情完成程序提醒的目标，由于网站内容十分丰富，一次很难将其全部爬取完毕，本次想通过Scrapy获取首页的投研信息，并完成翻页的目标，后期还会持续更新，尝试将整个网站都爬下来。（仅供个人研究使用） ","date":"2020-02-28","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:1:2","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"Scrapy ","date":"2020-02-28","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:2:0","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"简介 Scrapy是一个为了爬取网站数据，提取结构性数据编写的爬虫框架，只需要很少的代码就可以完成相关数据的抓取。 Scrapy是一个使用了Twisted的异步网络框架，可以大大提高我们的下载速度。 ","date":"2020-02-28","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:2:1","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"使用教程 Scrapy的相关使用教程可以通过官方文档来进行初步入门，了解各模块在框架中的作用，官方文档非常强大，建议先进行系统性的学习之后再开始使用。 学习Scrapy最重要的就是理解Scrapy的工作流程，跟着官方文档的例子去详细分析每一步的操作，与之前编写爬虫的流程相关性与区别。 ","date":"2020-02-28","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:2:2","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"抓包工具 ","date":"2020-02-28","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:3:0","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"什么是抓包工具 抓包工具是拦截查看网络数据包内容的软件。通过对抓获的数据包进行分析，可以得到有用的信息。 ","date":"2020-02-28","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:3:1","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"为什么要用 较为复杂的网站在进行爬取数据分析的时候使用浏览器中的调试工具会比较麻烦，这时候就可以用抓包工具去分析对应的请求，从而更快发现我们需要的数据所在的URL和整个请求的过程 ","date":"2020-02-28","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:3:2","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"使用与抓包工具的推荐 抓包工具的使用推荐学习朱安邦的博客中的教程，他讲了三个：Charles、Fiddler、wireshark，这些抓包工具功能各异，但基本原理相同，找一个顺手的学习基本上已经足够了。 ","date":"2020-02-28","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:3:3","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"业务逻辑分析 ","date":"2020-02-28","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:4:0","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"寻找加载数据的URL 通过对整个首页加载的流程进行抓包与分析，发现首页数据的URL为https://gw.datayes.com/rrp_mammon/web/feed/list，下一页的URL为：https://gw.datayes.com/rrp_mammon/web/feed/list?timeStamp=20210401170127\u0026feedIds=66233,66148， ","date":"2020-02-28","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:4:1","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"翻页参数解析 通过观察URL发现timeStamp和feedIds是两个控制翻页的参数，进一步多页进行请求发现20210401170127可以理解为一个时间节点，看到20200228猜测是本次刷新的时间，猜测后6位是当前时间的秒的时间戳，组织一下可以写成''.join(str(datetime.now())[:10].split('-'))+str(time.clock( )).split('.')[1] 再进行多页的数据获取后发现feedIds参数中的前四个是第一个响应中前四个数据的id，最后一个数为响应中最后一个数据的id，并且会随着访问变多而增加，每次新增的都是最后一个数据的id，将下一页的URL拼接起来,进行访问发现请求不到下一页的数据。通过复制原来的timeStamp发现可以访问，问题就出现在前面timeStamp的参数，刚刚再进行feedIds字段拼接的时候发现有三个字段是日期形式的，分别为：\"insertTime\"、updateTime、publishTime，进一步分析发现将其后面三个0去掉就是一个时间戳，对其转换发现就是我们需要的结果 ","date":"2020-02-28","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:4:2","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"模拟请求测试 ","date":"2020-02-28","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:5:0","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"scrapy shell scrapy shell可以帮助我们模拟请求地址，并进入一个交互式终端，在交互式终端中我们可以查看请求的各类信息，并进行调试。但scrapy shell也有缺陷，不能解析response的格式，看起来比较乱等，这时候可以通过结合Postman来协同调试。 ","date":"2020-02-28","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:5:1","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"Postman 简介 Postman是一种网页调试与发送网页http请求的chrome插件。我们可以用来很方便的模拟各种类型的请求来调试 接口。在爬虫中可以用于验证我们的思路。 使用与汉化 Postman官方的使用教程非常详细，可以跟着官方的使用教程中学习，如果想使用中文的版本可以在Postman汉化中下载。 实际使用 通过Postman发送请求，可以得到我们想要的数据，并且可以得到格式化后的数据，看起来条理更加清晰，再配合scrapy shell调试可以很容易就获得我们需要的数据 ","date":"2020-02-28","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:5:2","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"编写爬虫 ","date":"2020-02-28","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:6:0","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"创建爬虫项目 scrapy startproject datayes ","date":"2020-02-28","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:6:1","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"robots协议 在settings.py中可以通过设置ROBOTSTXT_OBEY = True遵守robots.txt 的规则。 ","date":"2020-02-28","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:6:2","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"创建爬虫 scrapy genspider mammon gw.datayes.com ","date":"2020-02-28","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:6:3","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"修改start_urls 默认的start_urls不是我们要爬取的链接，修改为我们需求的链接 start_urls = ['https://gw.datayes.com/rrp_mammon/web/feed/list'] ","date":"2020-02-28","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:6:4","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"完成parse方法 根据之前分析的结果设计方案完成parse，这次难度主要在于如何拼接next_url，由于feedIds参数存在着累加的关系所以将其放在了parse函数外让其可以再访问的时候累加处理。 class MammonSpider(scrapy.Spider): name = 'mammon' allowed_domains = ['gw.datayes.com'] start_urls = ['https://gw.datayes.com/rrp_mammon/web/feed/list'] # 构建一个基础next_url next_url = 'https://gw.datayes.com/rrp_mammon/web/feed/list?timeStamp=' # 构建一个基础feedIds feedIds = '\u0026feedIds=' def parse(self, response): # 将获取到的数据通过json转成字典的形式 result = json.loads(response.text) # 当访问成功时进行数据获取 if result['message'] == 'success': data_list = result['data']['list'] for data in data_list: item = {} detail_id = data['id'] # id # 通过详情页id构造详情页url并访问 detail_url = 'https://gw.datayes.com/rrp_mammon/web/feed?id=' + str(detail_id) yield scrapy.Request(detail_url, callback=self.detail_parse, meta={'item': item}) item['title'] = data['title'] # 标题 item['publish_time'] = int(data['publishTime'] / 1000) # 发布时间 item['author'] = data['roboColumn']['name'] # 作者 item['Avatar'] = data['roboColumn']['logo'] # 头像 related_list = data['related'] item['related_stocks'] = [] # 相关股票列表 for stocks in related_list: item['related_stocks'].append(stocks['targetName']) # 寻找出url的第0，1，2，3位置的id，加入feedIds if response.request.url == 'https://gw.datayes.com/rrp_mammon/web/feed/list' and data_list.index(data) in [0, 1, 2, 3]: self.feedIds = self.feedIds + str(detail_id) + ',' # 构建timeStamp参数 timeStamp = time.strftime(\"%Y%m%d%H%M%S\", time.localtime(item['publish_time'])) # 拼接feedIds参数 self.feedIds = self.feedIds + str(detail_id) + ',' # 组合next_url next_url = self.next_url + timeStamp + self.feedIds # 请求下一页 yield scrapy.Request(next_url, callback=self.parse) def detail_parse(self, response): result = json.loads(response.text) if result['message'] == 'success': item = response.meta['item'] item['content'] = result['data']['longDocContent'] yield item 通过爬虫观察到两日的cookie发生了变化，只有登录之后会保持cookie，并对cookie中的参数进行检测，找到cloud-sso-token为必要参数，并将其添加在settings.py中。 ","date":"2020-02-28","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:6:5","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"完成数据存储 先在settings.py中配置pipeline，和数据库相关参数 # Configure item pipelines # See https://docs.scrapy.org/en/latest/topics/item-pipeline.html ITEM_PIPELINES = { 'datayes.pipelines.DatayesPipeline': 300, } # MySQL相关配置 HOST = 'HOST', # 数据库地址 PORT = 3306, # 数据库端口 DB = 'DB', # 数据库名 USER = 'USER', # 数据库用户名 PASSWORD = 'PASSWORD', # 数据库密码 在我们定义的DatayesPipeline类中添加open_spider和close_spider方法，通过spider.settings来导入数据库相关参数 import pymysql class DatayesPipeline: # 爬虫开始时执行，只执行一次 def open_spider(self, spider): # 通过pymysql链接MySQL数据库 self.connect = pymysql.connect( host=spider.settings.HOST, # 数据库地址 port=spider.settings.PORT, # 数据库端口 db=spider.settings.DB, # 数据库名 user=spider.settings.USER, # 数据库用户名 passwd=spider.settings.PASSWORD, # 数据库密码 charset='utf8', # 编码方式 use_unicode=True) # 通过cursor执行增删查改 self.cursor = self.connect.cursor() # 爬虫结束时执行，只执行一次 def close_spider(self, spider): self.connect.close() def process_item(self, item, spider): self.cursor.execute( \"\"\"insert into mammon (title, publish_time,author,avatar,related_stocks,content)value (%s, %s,%s, %s,%s, %s)\"\"\", (item['title'], item['publish_time'], item['author'], item['avatar'], item['related_stocks'], item['content'])) # 提交sql语句 self.connect.commit() return item 最后创建数据库，开启爬虫进行数据爬取。 ","date":"2020-02-28","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:6:6","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"Python爬虫实战之叩富网","date":"2020-02-02","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"声明：以下内容均为我个人的理解，如果发现错误或者疑问可以联系我共同探讨 ","date":"2020-02-02","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:0:0","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"爬虫介绍 爬虫是一种按照一定规则自动抓取网络上的信息数据的程序。我们身处一个大数据的时代，可以通过爬虫获取到我们所需要的数据(遵从robots协议中的规则)。 ","date":"2020-02-02","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:1:0","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"网站介绍 叩富网是江西博辰网络科技公司旗下的一个专业网站。模拟炒股网站初建于2000年，2006年被博辰网络收购，并开始规范系统的运作。目前用户100多万，日均IP数10万左右。是国内唯一一家专业致力于模拟炒股开发和运营的网站。公司旗下有有奖大赛站、免费大赛站以及和其他证券公司合作的网站。 ","date":"2020-02-02","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:1:1","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"编写爬虫的原因和用途 本人闲暇时间会学习投资理财相关内容，并通过叩富网进行模拟炒股，本次想通过编写爬虫来程序化自己的模拟交易 ","date":"2020-02-02","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:1:2","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"robots协议 ","date":"2020-02-02","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:2:0","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"什么是robots协议 robots协议以robots.txt文件形式呈现，是网站中给各类爬虫规定爬取范围的文件，robots.txt存放在网站的根目录下。我们准备爬取某个网站时，首先应该查看我们需要的数据该网站是否允许我们爬取，当我们爬取规则之外的数据时，该网站有权利起诉我们非法获取数据。 ","date":"2020-02-02","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:2:1","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"robots协议的构成 由User-agent、Allow、Disallow构成。User-agent后面的内容是具体的爬虫名，如百度爬虫为Baiduspider，则代表所有爬虫。Allow后面的内容是允许爬取的URL路径，如/.jpg$表示可以爬取该网站下的所有.jpg图片，/表示所有路径均允许爬取。Disallow后面的内容是不允许爬取的URL路径，同Allow相反。 ","date":"2020-02-02","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:2:2","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"常见的规则有哪些 允许爬虫获取所有内容： User-agent: * Disallow: # 或者 User-agent: * Allow: / 禁止爬取所有内容： User-agent: * Disallow: / 禁止访问网站中所有动态页面 User-agent: * Disallow: /*?* 禁止搜索引擎抓取网站上所有图片 User-agent: * Disallow: /*.jpg$ Disallow: /*.jpeg$ Disallow: /*.gif$ Disallow: /*.png$ Disallow: /*.bmp$ ","date":"2020-02-02","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:2:3","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"Feeling 爬虫可以使我们更加高效的获取到互联网中的各类数据，但网络不是法外之地我们也要在合规合法的基础上进行爬取，尊重每一个网站开发者，敬畏法律。 ","date":"2020-02-02","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:2:4","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"requests requests库是学习爬虫入门最适合的一个第三方库，它是将Python内置的urllib进行深度封装的库。是一个非常成熟的HTTP客户端库，当然他也并非完美，我们后期也可以在其基础上进行补充形成适合自己的一个库。 ","date":"2020-02-02","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:3:0","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"快速上手 中文文档：https://docs.python-requests.org/zh_CN/latest/index.html 官方示例：https://docs.python-requests.org/zh_CN/latest/user/quickstart.html ","date":"2020-02-02","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:3:1","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"获取robots协议，查看可爬取范围 使用get请求获取协议内容，并将其输出控制台查看发现规则允许我们爬取整站内容 ","date":"2020-02-02","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:3:2","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"登陆叩富网 在Chrome浏览器中通过开发者选项中的Network选项卡中发现，登陆的时候有一个login.html 我们可以在里面看到请求URL、请求方式和Form Data所需要的内容，根据这个编写一个请求查看一下获取到的数据 由于是字符串格式，所以出现了我们看不懂的字符，通过json转成Python中的字典格式再查看 可以看到显示登陆成功了，接下来通过获取到的cookie就可以获取到我们需要的各种信息了 接下来我们将代码优化一下变成一个方法，让登陆后的cookie可以在以后任意需要的地方使用 import requests import json from lxml import etree def login(username, password): \"\"\" 登陆叩富网 :param username: 用户名 :param password: 密码 :return: 登陆成功返回cookie，失败抛出对应异常 \"\"\" login_url = 'http://www.cofool.com/Passport/login.html' data = { 'username': username, 'password': password } try: response = requests.post(url=login_url, data=data) except Exception as e: raise Exception(\"登陆失败，原因为：{}\".format(e)) content = json.loads(response.content.decode()) if content['status'] == 0: cookie = response.cookies.get_dict() return cookie else: raise Exception(\"登陆失败，原因为：{}\".format(content['info'])) 在出现登录失败的时候抛出异常，并显示错误信息 ","date":"2020-02-02","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:3:3","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"Feeling 爬虫是我们与开发者的博弈，我们需要站在他们的角度去分析他们开发的过程，从而更好的理解并去设计我们的相关爬虫程序。通常爬虫程序都不是一次就完成的，需要通过我们不断根据请求的反馈去修改程序，最终通过多层解析得到结果。 ","date":"2020-02-02","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:3:4","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"获取账户信息 ","date":"2020-02-02","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:4:0","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"练习区信息 通过对相关请求的分析，练习区信息在http://www.cofool.com/Trade/Stock/index/gid/2.html这个URL下 对页面分析我们所需要的数据在class为top_ts的div下 ","date":"2020-02-02","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:4:1","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"XPath XPath是一门在XML文档中查找信息的语言，可以帮助我们在爬虫中对获取数据进行查找得到我们需要的内容。 推荐从大佬崔庆才的个人博客学习XPath及爬虫的相关内容 开始通过XPath获取对应数据，考虑到多个数据在相同的font标签下，可以一次性获取所有标签然后进行处理 def get_account_info(query_category): \"\"\" 根据query_category获取账户相关信息 :param query_category: 查询类别信息,账户信息:ai 持仓状态:ap 当日委托:ac 当日成交:ad 历史成交:hd 股票收益明细:sd 日资产增长明细：da 月资产增长明细：ma 荣耀榜 ho :return: \"\"\" cookie = login('用户名', '密码') if query_category not in ['ai', 'ap', 'ac', 'ad', 'hd', 'sd', 'da', 'ma', 'ho']: raise Exception('查询类别不存在') if query_category == 'ai': url = 'http://www.cofool.com/Trade/Stock/index/gid/2.html' # 抓取账户相关数据 try: response = requests.get(url=url, cookies=cookie).content.decode() except Exception as e: raise Exception(\"获取账户数据失败，原因为：{}\".format(e)) if '总盈利率' not in response: raise Exception(\"获取账户数据失败，未获取到正确信息\") # 使用xpath对抓取到的数据进行清洗得到我们需要的数据 html = etree.HTML(response) account_info = html.xpath('//div [@class=\"top_ts\"]/div//font/text()') if len(account_info) != 4: raise Exception(\"获取账户数据失败，未获取足够的账户数据\") gross_profit_rate = account_info[0] # 总收益率 initial_funding = account_info[1] # 初始资金 number_of_participants = account_info[2] # 参赛人数 average_income = account_info[3] # 平均收益率 overall_ranking = html.xpath('//div [@class=\"top_ts\"]/div//p[2]/b/text()')[0] # 总排名 try: total_assets = float(''.join(re.search('\\d,\\d*,\\d*.\\d*', html.xpath( '//*[@id=\"left2\"]/table/tbody/tr[1]/td[@class=\"btom zjsr\"]/text()')[0])[0].split(','))) available_funds = float(''.join(re.search('\\d,\\d*,\\d*.\\d*', html.xpath( '//*[@id=\"left2\"]/table/tbody/tr[1]/td[@class=\"btom zjl\"]/text()')[0])[0].split(','))) except Exception as e: raise Exception(\"获取账户数据失败，{}\".format(e)) return {'总收益率': gross_profit_rate, '初始资金': initial_funding, '参赛人数': number_of_participants, '平均收益率': average_income, '总排名': overall_ranking, '总资产': total_assets, '可用资金': available_funds} ","date":"2020-02-02","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:4:2","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"持仓、交易、业绩信息 通过对相关请求的分析，当前持仓、当日委托、当日成交、历史成交与业绩报告都用同一个URL进行请求，只是请求中FormData部分数据不同，分析各页面数据发现当前持仓、当日委托、当日成交、历史成交数据类似，将其作为同一个类型进行爬取做简单修改即可。分页相关信息需要根据页码数据进行追加处理 ... url = 'http://www.cofool.com/Trade/Stock/tradeItem.html' data = {'gid': 'gid', 'uid': 'uid', 'web_id': 'web_id} # 根据查询条件设置对应的type值 if query_category == 'ap': data['type'] = 'position' elif query_category == 'ac': data['type'] = 'entrust' elif query_category == 'ad': data['type'] = 'turnover' elif query_category == 'hd': data['type'] = 'history' elif query_category == 'sd': data['type'] = 'earnings' elif query_category == 'da': data['type'] = 'dayasset' elif query_category == 'ma': data['type'] = 'monthasset' elif query_category == 'ho': data['type'] = 'honor' # 第一次获取对应信息，当信息不存在时返回'暂无交易的数据！' try: response = requests.post(url=url, data=data).content.decode() except Exception as e: raise Exception('获取账户数据失败，原因为：{}'.format(e)) if ' 暂无交易的数据！' in response: return '暂无交易的数据！' html = etree.HTML(response) # 当有信息时获取页码数值， number_of_pages = len(html.xpath('//div [@class = \"clearfix fr\"]/a/text()')) + 1 # 获取对应表头名 col_name = html.xpath('//tr/th/text()') # 设置临时存储字典 temp_dict = {} # 根据页码信息进行第二次访问获取信息 for i in range(1, number_of_pages + 1): # 添加页码数据 data['p'] = i try: response = requests.post(url=url, data=data).content.decode() except Exception as e: raise Exception('获取账户数据失败，原因为：{}'.format(e)) # 由于爬取的数据存在大量\\n和空格，先进行一次简单的清洗 response = re.sub('\\n\\s|\\s', '', response) html = etree.HTML(response) # 分别获取各列信息 for j in range(len(col_name)): xpath_index = j + 1 xpath_values = html.xpath('//tr/td[{}]//text()|//tr/td[{}]/font/text()|//tr/td[{}]/text()'.format(xpath_index, xpath_index,xpath_index)) if i == 1: temp_dict[col_name[j]] = xpath_values # 当出现第二页及其以上时，进行数据追加处理 else: temp_dict[col_name[j]].extend(xpath_values) return pd.DataFrame(temp_dict) ","date":"2020-02-02","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:4:3","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"Feeling 爬虫中数据清洗的过程通常也非常熬人，网站开发者的水平高低与反爬的难度，会导致许多数据清洗起来非常复杂，可能会花费大量的时间还得不到你想要的结果，这时候我们需要保持一颗平常心，针对出现的问题一个一个去解决，只要坚持下去一定能解决的！ ","date":"2020-02-02","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:4:4","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"账户操作 ","date":"2020-02-02","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:5:0","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"股票信息 接下来编写账户操作方面的爬虫，要交易首先要拿到进行交易股票的相关信息，通过分析相关请求后发现其URL为http://www.cofool.com/Trade/Stock/stockQuote.html,这个比较简单很快就可以完成对应代码 def get_stock_info(stock_code): \"\"\" 根据股票代码获取相关价格 :param code:股票代码 :return: 相关价格 \"\"\" url = \"http://www.cofool.com/Trade/Stock/stockQuote.html\" data = { \"code\": stock_code, \"uid\": 'uid', } cookie = login('账户名', '密码') try: response = json.loads(requests.post(url=url, data=data, cookies=cookie).content.decode(\"utf-8-sig\")) except Exception as e: raise Exception('获取账户数据失败，原因为：{}'.format(e)) stock_info = response[\"info\"] info_dict = { \"high_limit\": stock_info[\"surgedLimit\"], # 涨停价 \"low_limit\": stock_info[\"declineLimit\"], # 跌停价 \"stock_name\": stock_info['stockName'], # 股票名称 'currentPrice': stock_info[\"currentPrice\"], # 当前价 } return info_dict ","date":"2020-02-02","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:5:1","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"股票交易 通过观察发现买入与卖出操作的URL差距非常小，并且请求参数也高度相似，可以将其放在同一个方法中 def tradeing(stock_code, tradeing_type, amount=0): \"\"\" 股票交易，并返回交易状态 :param stock_code:股票代码 :param tradeing_type:交易类型 :param amount:交易数量,默认为0防止出现没有填写的情况 :return:交易状态 \"\"\" cookie = login('账户名', '密码') # 获取股票相关信息 info_dict = get_stock_info(stock_code) price = info_dict[\"high_limit\"] # 配置相关数据 data = { \"stockName\": info_dict['stock_name'], \"code\": stock_code, \"uid\": 'uid', \"gid\": 2, \"orderPrice\": price, \"orderAmount\": amount, \"declineLimit\": info_dict['low_limit'], \"surgedLimit\": info_dict['high_limit'] } if tradeing_type == 'buy': url = \"http://www.cofool.com/Trade/Stock/buy.html\" # 买入操作，检测买入数量防止超过最大买入数量 available_funds = get_account_info('ai')['可用资金'] if amount \u003c available_funds / float(price): data[\"orderAmount\"] = amount else: raise Exception('购买数量超过最大可购买数量') elif tradeing_type == 'sell': url = \"http://www.cofool.com/Trade/Stock/sell.html\" # 卖出操作，从持仓信息中获取可卖出数量 data[\"orderAmount\"] = get_amount(stock_code) try: content = \\ requests.post(url=url, data=data, cookies=cookie).content.decode(\"utf-8-sig\") status = json.loads(content, encoding=\"unicode_escape\")[\"status\"] except Exception as e: raise Exception('获取账户数据失败，原因为：{}'.format(e)) if status == 1: print(\"买入股票：{}，股数：{}\".format(stock_code, amount)) return 0 else: raise Exception(\"买入失败，失败原因为：{}\".format(json.loads(content, encoding=\"unicode_escape\")[\"info\"])) ","date":"2020-02-02","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:5:2","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"持仓数量 在卖出交易的时候需要获取账户中持仓的数量 def get_amount(code): \"\"\"根据股票代码获取可交易数量 :param code:股票代码 :return:对应股票可用数量 \"\"\" url = \"http://www.cofool.com/Trade/Stock/sellAmount\" data = { \"code\": code, \"uid\": 'uid', \"web_id\": 'web_id' } cookie = login('账户名', '密码') try: content = json.loads(requests.post(url=url, data=data, cookies=cookie).content.decode('unicode_escape')) except Exception as e: raise Exception(\"获取股数数据失败，{}\".format(e)) status = content['status'] if status == 1: amount = content['info']['frozen_amount'] return amount else: raise Exception(content['info']) 到这里叩富网的爬虫基本完成了，最后将转化为类就可以了，完整代码可以在我的GitHub仓库查看最新的代码 ","date":"2020-02-02","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:5:3","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["Flask"],"content":"Flask搭建个人博客","date":"2020-01-26","objectID":"/flask%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","tags":["Flask"],"title":"Flask搭建个人博客","uri":"/flask%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Flask"],"content":"本教程中我们将从0开始搭建一个完整的个人博客。 开发环境说明 本教程开发环境为MacOS Mojave10.14.6，Python版本为3.6.6，flask版本为1.0.2。 为了避免不必要的麻烦，尽可能的与我的开发环境保持一致。Python版本必须为3.x以上，建议3.6.x的版本，flask版本必须为1.0.x。 ","date":"2020-01-26","objectID":"/flask%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:0:0","tags":["Flask"],"title":"Flask搭建个人博客","uri":"/flask%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Flask"],"content":"Flask入门教程","date":"2020-01-20","objectID":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/","tags":["Flask"],"title":"Flask入门教程","uri":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"categories":["Flask"],"content":"Flask 简介 Flask是由Armin ronacher于2010年用Python语言基于 Werkzeug 工具箱编写的轻量级Web开发框架。 特点 Flask只提供核心功能，其他几乎所有的功能都需要用到拓展，比如可以通过Flask-SQLAlchemy拓展对数据库进行操作等等。 核心 由Werkzeug与Jinja2组成，Werkzeug是一个全面的WSGI Web应用程序库，Jinja是一种现代且设计友好的Python模板语言。 Flask常用扩展 Flask-SQLalchemy：操作数据库 Flask-script：插入脚本 Flask-migrate：管理迁移数据库 Flask-Session：Session存储方式指定 相关文档 中文文档 英文文档 Flask初体验 1.安装并使用虚拟环境 virtualenv 创建和管理虚拟环境 # 安装 pip install virtualenv # 创建 virtualenv flask_env # 使用 source flask_env/bin/activate Pipenv 创建和管理虚拟环境 # 安装 pip install pipenv # 创建 pipenv install # 使用 pipenv shell 2.安装指定版本flask框架 sudo pip install flask==1.0.2 3.创建一个文件，并带入编写第一个Flask程序 touch helloflask.py vim helloflask.py 在文件中写入以下代码 # 导入Flask类 from flask import Flask # 传递__name__参数，创建一个叫app的Flask实例，该实例将会成为我们的 WSGI 应用。 app = Flask(__name__) # 通过route装饰器来告诉Flask触发函数的URL @app.route('/') # index视图函数，在访问根路径时会调用该函数通过其返回值得到结果 def index(): return 'Hello Flask' if __name__ == '__main__': # 通过run方法启动web服务器 app.run() 退出编辑模式，运行该程序 python helloflask.py 可以看到以下结果 这样就启动了一个非常简单的内建的服务器。这个服务器用于测试应该是足够了，但是 用于生产可能是不够的。现在在浏览器中打开 http://127.0.0.1:5000/ ，应该可以看到 Hello Flask! 字样。 相关配置参数 初始化参数 创建Flask项目的第一步就是实例化Flask对象，以下是实例化对象需要的参数详解 import_name：Flask程序所在的包(模块)，传 __name__ 就可以， static_url_path：静态文件访问路径，可以不传，默认为：/ + static_folder static_folder：静态文件存储的文件夹，可以不传，默认为 static static_host：使用远程主机存储静态文件的地址，默认为None。当host_matching为True时，可以通过static_folder配置静态文件存储的文件夹 host_matching：设置url_map.host_matching属性，默认为False subdomain_matching：匹配路由时，请考虑与以下项相关的子域：data:`SERVER_NAME’。默认为False。 template_folder：模板文件存储的文件夹，可以不传，默认为 templates instance_path：默认情况下，应用程序的备用实例路径假定包或模块旁边的文件夹“instance”为实例路径。 instance_relative_config：如果将用于加载配置的相对文件名设置为“True”，则假定该文件名相对于实例路径而不是应用程序根。 root_path：默认情况下，Flask将自动计算应用程序根路径。在某些情况下，这无法实现（例如，如果包是Python 3命名空间包），需要手动定义。 程序加载配置 在Flask程序运行前，我们可以给Flask设置相关配置，例如ENV(应用程序在什么环境中运行)，DEBUG(是否启用调试模式)TESTING(启用测试模式)等配置，常见的有两种方式来实现. 从配置文件中加载：app.config.from_pyfile() 创建一个配置文件 touch config.ini vim config.ini 写入配置信息 DEBUG = True 选择从配置文件加载 # 创建 Flask 类对象,指向程序所在的包的名称 app = Flask(__name__) # 从配置文件中加载配置 app.config.from_pyfile('config.ini') 从配置对象中加载：app.config.from_object() 创建一个配置类，然后将类名传入即可 # 配置类 class ConfigObject(object): DEBUG = True # 创建 Flask 类对象,指向程序所在的包的名称 app = Flask(__name__) # 从配置对象中加载配置 app.config.from_object(Config) 程序运行配置 这个demo中Flask项目程序启动的入口是app.run()。常见的配置选项有host, port,debug，分别是设置运行主机的ip地址，端口号，是否打开调试模式，当配置文件与这里都有debug时，最终会以这里的debug为准。 app.run(host=\"127.0.0.1\", port=8000) 路由 在Web开发中，路由是一种将URL转发到对应视图的程序。 ","date":"2020-01-20","objectID":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:0:0","tags":["Flask"],"title":"Flask入门教程","uri":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"categories":["一篇文章学会系列"],"content":"一篇文章学会Git","date":"2020-01-15","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/","tags":["工具"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"简介 ","date":"2020-01-15","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:0","tags":["工具"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"什么是Git Git是一个免费的开源分布式版本控制系统，也是目前为止世界上最先进的分布式版本控制系统。Git官方有一个视频介绍，可以点此观看 什么是版本控制系统？ 一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。简单点理解就是一个可以帮助我们记录文件修改的系统。Git官方有一个视频介绍，可以点此观看 什么是分布式版本控制系统？ 分布式版本控制系统时相对于集中式版本控制系统的。 集中式版本控制系统将仓库存放在中央服务器中集中管理，当你需要时从中央服务器中拉取最新的版本，修改完后将修改提交给中央服务器。这就会带来例如当中央服务器宕机时整个版本控制系统就会崩溃；推送或者拉取一个较大的文件时就会消耗很多时间等弊端。 分布式版本控制系统中，每个人电脑都是一个仓库，自己的文件可以在本地管理，当需要多人协同时只需要管理好本地仓库与协同仓库的版本即可 ","date":"2020-01-15","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:1","tags":["工具"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"Git有什么作用 进行源代码管理 ","date":"2020-01-15","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:2","tags":["工具"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"为什么要进行源代码管理 方便多人协同开发 方便代码版本控制 ","date":"2020-01-15","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:3","tags":["工具"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"Git的特点 分布式版本控制系统，服务器和客户端都有版本控制能力,都能进行代码的提交、合并等操作。 在使用Git的时候会自动创建一个.git的隐藏文件夹作为本地仓库 ","date":"2020-01-15","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:4","tags":["工具"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"Git操作流程 clone：第一次从Git服务器获取项目 add：将修改添加到本地仓库 commit：将修改提交到本地仓库 push：将本地仓库的修改提交到Git服务器 pull：将Git服务器中的项目获取到本地仓库 ","date":"2020-01-15","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:5","tags":["工具"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"Git仓库 什么是仓库 仓库的英文名是repository，又被称为版本库。它是一个被Git管理的文件目录。 ","date":"2020-01-15","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:6","tags":["工具"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"工作区，暂存区和仓库 工作区：对代码的新增，修改，删除等操作的区域。 暂存区：存储工作区的操作的区域。 仓库区：即本地仓库区域，会记录完成的操作与历史版本。 ","date":"2020-01-15","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:7","tags":["工具"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"Git操作 安装 Mac 在mac上有多种方法可以安装Git，最简单的事通过Xcode命令行工具安装。 通过Xcode安装 1.下载并安装Xcode 2.在终端中运行git即可，如果尚未安装，它将提示您安装。 通过homebrew安装 1.安装homebrew $ /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" 2.安装git $ brew install git 通过安装包安装 1.点击此下载最新版本 2.下载完成后打开安装包，一直下一步安装即可 Linux 在Linux发行版上安装GIt，可以通过附带的软件包管理工具来安装 Debian/Ubuntu $ apt-get install git 其他发行版本见这个链接 Windows 下载安装包 根据操作系统位数选择，链接 安装默认选项安装即可 安装完成后通过可以通过git --version查看安装版本 ","date":"2020-01-15","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:8","tags":["工具"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"配置Git 配置文件介绍 Git有一个git config的工具，可以设置和获取配置，用来控制Git外观及操作。这些变量可以存放在三个不同的位置，根据存放位置不同作用的范围也不同。 1./etc/gitconfig：包含系统上每个用户及其存储库的配置。 2.~/.gitconfig或~/.config/git/config：每个用户专属的配置 3.config.git/config：当前使用存储库的git目录，用于该存储库的配置 如果有相同配置项时，每个级别都会覆盖上一个级别中的值，即：3\u003e2\u003e1 可以使用一下命令查看所有设置以及设置的所属： $ git config --list --show-origin 常见配置 下面介绍一些常见配置 身份配置 安装完Git做的第一件事应该是设置用户名和电子邮箱。 $ git config --global user.name \"John Doe\" $ git config --global user.email johndoe@example.com 使用global后，该信息将会始终作用域Git操作上 Git编辑器配置 Git默认的编辑器是系统默认编辑器 如果要是用其他文本编辑器（例如vim），则可以执行以下操作： $ git config --global core.editor vim 查看配置 如果要查看配置，可以使用git config --list命令列出Git可以找到的所有设置 你可能会看到很多配置项，找不到你想要的，这时候你可以通过git config \u003ckey\u003e来查看特定的配置，例： $ git config user.name silencehuliang ","date":"2020-01-15","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:9","tags":["工具"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"帮助 获取方式 Git获取帮助的方式有三种git help \u003cverb\u003e、git \u003cverb\u003e --help、man git-\u003cverb\u003e 例如，可以通过git help config获取config的相关帮助 如果只需要快速了解Git命令的可用选项也可以用-h来查看相关帮助 例如git add -h ","date":"2020-01-15","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:10","tags":["工具"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"创建项目 1.将本地不收版本控制的目录转换为Git仓库 ①进入本地目录 $ cd ~/Desktop/project ②输入转化命令 $ git init 此时会在当前目录下创建一个.git目录，里面存放着Git仓库中所有的必须文件 $ ls -a . .. .git 2.从其他地方克隆现有的Git仓库 ①进入我们需要存放仓库的路径 $ cd ~/Desktop/ ②将现有的仓库克隆下来 $ git clone https://github.com/Silencehuliang/project ","date":"2020-01-15","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:11","tags":["工具"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"查看状态 可以通过git status 查看仓库中稳健的状态 绿色表示文件在暂存区 红色表示文件在工作区 可以通过git add 将工作区文件添加到暂存区 添加项目中所有文件：git add . 添加指定文件：git add xxx.py 可以通过git commit将暂存区文件提交到仓库区 git commit -m \"修改描述\"，其中-m参数后面跟的是对本次修改的描述 git commit -am \"修改描述\",可以通过-am来实现添加和提交合并操作 ","date":"2020-01-15","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:13","tags":["工具"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"查看历史版本 通过git log或者git relog可以查看历史版本 ","date":"2020-01-15","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:14","tags":["工具"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"回退版本 通过版本号会退版本 git reset --hard 版本号 通过HEAD回退版本 当工作区文件发生了意外需要回退到上一个版本时可以通过 `git reset --hard HEAD` HEAD表示当前最新版本 HEAD^表示当前最新版本的前一个版本 HEAD^^表示当前最新版本的前两个版本，以此类推… HEAD~1表示当前最新版本的前一个版本 HEAD~10表示当前最新版本的前10个版本，以此类推… ","date":"2020-01-15","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:15","tags":["工具"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"撤销修改 只能撤销工作区、暂存区的代码,不能撤销仓库区的代码 撤销仓库区的代码就相当于回退版本操作 撤销工作区代码 新加代码num3 = 30，不add到暂存区，保留在工作区 git checkout 文件名 撤销暂存区代码 新加代码num3 = 30，并add到暂存区 # 第一步：将暂存区代码撤销到工作区 git reset HEAD 文件名 # 第二步：撤销工作区代码 git checkout 文件名 ","date":"2020-01-15","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:16","tags":["工具"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"对比版本 对比版本库与工作区 新加代码num3 = 30，不add到暂存区，保留在工作区 git diff HEAD -- xxx.py 对比版本库 新加代码num3 = 30，并add到暂存区 git diff HEAD HEAD^ -- xxx.py ","date":"2020-01-15","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:17","tags":["工具"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"删除文件 删除文件分为确定删除和误删 在项目中新建test.py文件，并添加和提交到仓库 确定删除处理： # 删除文件 rm 文件名 # git确定删除文件，对比添加文件git add git rm 文件名 # 删除后记录删除操作版本 git commit -m '删除描述' 误删处理：撤销修改即可 # 删除文件 rm 文件名 # git撤销修改 git checkout -- 文件名 ","date":"2020-01-15","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:18","tags":["工具"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"代码冲突 提示：多人协同开发时，避免不了会出现代码冲突的情况 原因：多人同时修改了同一个文件 危害：会影响正常的开发进度 注意：一旦出现代码冲突，必须先解决再做后续开发 解决冲突 原则：谁冲突谁解决，并且一定要协商解决 方案：保留所有代码 或者 保留某一人代码 解决完冲突代码后，依然需要add、commit、push，如果执行pull没有影响，就算真正解决了冲突代码 补充： 容易冲突的操作方式 多个人同时操作了同一个文件 一个人一直写不提交 修改之前不更新最新代码 提交之前不更新最新代码 擅自修改同事代码 减少冲突的操作方式 养成良好的操作习惯,先pull在修改,修改完立即commit和push 一定要确保自己正在修改的文件是最新版本的 各自开发各自的模块 如果要修改公共文件,一定要先确认有没有人正在修改 下班前一定要提交代码,上班第一件事拉取最新代码 一定不要擅自修改同事的代码 ","date":"2020-01-15","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:19","tags":["工具"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"标签 当某一个大版本完成之后,需要打一个标签 作用： 记录大版本 备份大版本代码 在本地打标签 git tag -a 标签名 -m '标签描述' 推送标签到远程仓库 git push origin 标签名 删除本地和远程标签 # 删除本地标签 git tag -d 标签名 # 删除远程仓库标签 git push origin --delete tag 标签名 ","date":"2020-01-15","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:20","tags":["工具"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"分支 作用： 区分生产环境代码以及开发环境代码 研究新的功能或者攻关难题 解决线上bug 特点： 项目开发中公用分支包括master、dev 分支master是默认分支，用于发布，当需要发布时将dev分支合并到master分支 分支dev是用于开发的分支，开发完阶段性的代码后，需要合并到master分支 查看当前分支 git branch 创建并切换到dev分支 git checkout -b dev 设置本地分支跟踪远程指定分支（将分支推送到远程） git push -u origin dev 分支合并到master分支 先切换到master分支 git checkout master 分支合并到master分支 git merge dev ","date":"2020-01-15","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:21","tags":["工具"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"一篇文章学会Linux","date":"2020-01-09","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Alinux/","tags":["操作系统"],"title":"一篇文章学会Linux","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Alinux/"},{"categories":["一篇文章学会系列"],"content":"声明：以下内容均为我个人的理解，如果发现错误或者疑问可以联系我共同探讨 ","date":"2020-01-09","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Alinux/:0:0","tags":["操作系统"],"title":"一篇文章学会Linux","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Alinux/"},{"categories":["一篇文章学会系列"],"content":"简介 ","date":"2020-01-09","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Alinux/:1:0","tags":["操作系统"],"title":"一篇文章学会Linux","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Alinux/"},{"categories":["一篇文章学会系列"],"content":"Linux Linux是一种自由和开放源码的类UNIX操作系统。该操作系统的内核由林纳斯·托瓦兹在1991年10月5日首次发布，在加上用户空间的应用程序之后，成为Linux操作系统。只要遵循GNU 通用公共许可证（GPL），任何个人和机构都可以自由地使用Linux的所有底层源代码，也可以自由地修改和再发布。大多数Linux系统还包括像提供GUI的X Window之类的程序。除了一部分专家之外，大多数人都是直接使用Linux 发行版，而不是自己选择每一样组件或自行设置。详细介绍 ","date":"2020-01-09","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Alinux/:1:1","tags":["操作系统"],"title":"一篇文章学会Linux","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Alinux/"},{"categories":["一篇文章学会系列"],"content":"linux发行版 Linux发行版指的就是通常所说的“Linux操作系统”，它一般是由一些组织、团体、公司或者个人将Linux内核作为发行版的一部分制作并发行的。通常来讲，一个Linux发行版包括Linux内核，以及将整个软件安装到电脑上的一套安装工具，还有各种GNU软件，和其他的一些自由软件，在一些Linux发行版中可能会包含一些专有软件。当前，超过三百个发行版被积极的开发，最普遍被使用的发行版有大约十二个。较为知名的有Debian、Ubuntu、Fedora和openSUSE等。 Linux发行版份额排名，也可以在Linux终端用命令查看：wget -qO - 7z.cx/o|sh，Ubuntu以39.1%的占比遥遥领先，中国武汉深之度科技有限公司开发的deepin是国产Linux发行版中排名最高的，占比12.6%在排行榜中排名第三（截止于2020-01-10 13:54:19） ","date":"2020-01-09","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Alinux/:1:2","tags":["操作系统"],"title":"一篇文章学会Linux","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Alinux/"},{"categories":["一篇文章学会系列"],"content":"安装 如果是初次安装系统建议先通过在虚拟机上安装。 ","date":"2020-01-09","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Alinux/:2:0","tags":["操作系统"],"title":"一篇文章学会Linux","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Alinux/"},{"categories":["一篇文章学会系列"],"content":"下载 下面提供较为知名的Linux发行版下载地址 Ubuntu、manjaro、deepin、CentOS、Arch、Debian、Mint、Fedora Linux发行版提供了Server版和Desktop版，初次使用建议直接安装Server版。 ","date":"2020-01-09","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Alinux/:2:1","tags":["操作系统"],"title":"一篇文章学会Linux","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Alinux/"},{"categories":["一篇文章学会系列"],"content":"安装 以Ubuntu Server 16.10为例 将镜像写入U盘后，开机以U盘为第一启动项启动，可以看到以下界面 选择第一项安装Ubuntu Server 下一步选择语言，这里选择英语，防止乱码与文件名是中文的问题 下一步选择区域，没有中国，所以先选其他 接下来选择亚洲Asia 接着选这中国 下一步选择字符集，这里选择美国的UTF-8字符集，即en_US.UTF-8 下一步检测键盘，选择否 接着让我们设置键盘的类型与布局 下一步是设置主机名称，默认为ubuntu，可以改为你喜欢的名称 设置用户名 下一步设置登陆账号 设置密码，可以在下面选择显示密码，可以确认一次 再次输入，确认密码 是否加密home文件夹，选择否 下一步系统根据区域推断出我们的市区是上海，没有问题，所以选择是 选择分区方式，这里选择Guided - use entire disk and set up LVM 选择安装的硬盘 这里告诉我们会格式化这个盘确认选择 选择自动安装 确认分区 确认安装 选择代理，没有就跳过 选择升级方式，这里选择不自动升级No automatic updates 安装完成后会重启，选择ubuntu启动即可 进入系统后输入用户名密码就可以登录上ubuntu了，到此安装完毕 ","date":"2020-01-09","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Alinux/:2:2","tags":["操作系统"],"title":"一篇文章学会Linux","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Alinux/"},{"categories":["一篇文章学会系列"],"content":"linux 根目录 ","date":"2020-01-09","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Alinux/:3:0","tags":["操作系统"],"title":"一篇文章学会Linux","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Alinux/"},{"categories":["一篇文章学会系列"],"content":"一篇文章学会Vim","date":"2020-01-08","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Avim/","tags":["工具"],"title":"一篇文章学会Vim","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Avim/"},{"categories":["一篇文章学会系列"],"content":"声明：以下内容均为我个人的理解，如果发现错误或者疑问可以联系我共同探讨 ","date":"2020-01-08","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Avim/:0:0","tags":["工具"],"title":"一篇文章学会Vim","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Avim/"},{"categories":["一篇文章学会系列"],"content":"简介 Vim是一个高度可定制的终端文本编辑器，它可以很方便的创建和修改任何类型的文本。作为vi的升级版，有许多新的特性(以下列出的特性为比较常用的，详细特性可以查看help vi_diff.)： 无限撤销：可以无限制的撤销 可移植性：Vi仅在Unix上可用，Vim还可以在Windows、Macintosh，Amiga，OS / 2，VMS，QNX和其他系统上运行。 语法高亮：当用Vim进行编程的时候，他可以根据正在编辑的文件类型，使其以内容以不同的颜色或样式突出显示。Vim捆绑了数百种语法突出显示规则集。 图形用户界面：Vim在控制台上运行良好，也可以在许多GUI中本地运行，包括Mac OS和Windows。它还可以操作剪贴板。 vi兼容模式：紧要关头，您可以强制Vim像vi一样。使Vim与vi不兼容的所有改进和错误修复都已关闭，您将获得100％与vi兼容的编辑器。 Vim作为许多程序员最喜欢的文本编辑器之一，它具有像：多级撤销、代码补全、支持数百种编程语言和文本格式、强大的搜索和替换功能等。 ","date":"2020-01-08","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Avim/:1:0","tags":["工具"],"title":"一篇文章学会Vim","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Avim/"},{"categories":["一篇文章学会系列"],"content":"安装与卸载 ","date":"2020-01-08","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Avim/:2:0","tags":["工具"],"title":"一篇文章学会Vim","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Avim/"},{"categories":["一篇文章学会系列"],"content":"安装 Windows 先把安装包下载下来，然后根据提示安装。 Unix 在Github上下载源文件安装 Mac 在github下载，根据文件类型安装。 详细安装教程 ","date":"2020-01-08","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Avim/:2:1","tags":["工具"],"title":"一篇文章学会Vim","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Avim/"},{"categories":["一篇文章学会系列"],"content":"卸载 Unix or Mac 源代码安装 在控制台输入 make uninstall 软件包管理器安装 根据不同软件包管理器的卸载命令卸载 Windows 找到安装目录下的 “uninstall-gui” 程序进行卸载 ","date":"2020-01-08","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Avim/:2:2","tags":["工具"],"title":"一篇文章学会Vim","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Avim/"},{"categories":["一篇文章学会系列"],"content":"教程 ","date":"2020-01-08","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Avim/:3:0","tags":["工具"],"title":"一篇文章学会Vim","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Avim/"},{"categories":["一篇文章学会系列"],"content":"vimtutor Vim自带教程vimtutor是你从零开始学习Vim最好的老师，教程包含了日常所需要的各个命令和功能，还有实操教学。如果你的系统语言是中文，那么打开vimtutor时默认是中文版的教程，中文版教程由梁昌泰 先生进行译制。在命令行中输入vimtutor，就可以打开该教程,学习完该教程大约需要30分钟左右。 有一款游戏Vim Adventure，可以作为学习Vim的一种放松。 Vimtutor章节小结 第一讲 光标在屏幕文本中的移动既可以用箭头键，也可以使用 hjkl 字母键。 ​ h (左移) j (下行) k (上行) l (右移) 欲进入 Vim 编辑器(从命令行提示符)，请输入：vim 文件名 \u003c回车\u003e 欲退出 Vim 编辑器，请输入 :q! \u003c回车\u003e 放弃所有改动。或者输入 :wq \u003c回车\u003e 保存改动。 在正常模式下删除光标所在位置的字符，请按： x 欲插入或添加文本，请输入： ​ i 输入欲插入文本 在光标前插入文本 ​ A 输入欲添加文本 在一行后添加文本 特别提示：按下 键会带您回到正常模式或者撤消一个不想输入或部分完整的命令。 第二讲 欲从当前光标删除至下一个单词，请输入：dw 欲从当前光标删除至当前行末尾，请输入：d$ 欲删除整行，请输入：dd 欲重复一个动作，请在它前面加上一个数字：2w 在正常模式下修改命令的格式是： operator [number] motion 其中： ​ operator - 操作符，代表要做的事情，比如 d 代表删除 ​ [number] - 可以附加的数字，代表动作重复的次数 ​ motion - 动作，代表在所操作的文本上的移动，例如 w 代表单词(word)，$ 代表行末等等。 欲移动光标到行首，请按数字0键：0 欲撤消以前的操作，请输入：u (小写的u)，欲撤消在一行中所做的改动，请输入：U (大写的U)，欲撤消以前的撤消命令，恢复以前的操作结果，请输入：CTRL-R 第三讲 要重新置入已经删除的文本内容，请按小写字母 p 键。该操作可以将已删除的文本内容置于光标之后。如果最后一次删除的是一个整行，那么该行将置于当前光标所在行的下一行。 要替换光标所在位置的字符，请输入小写的 r 和要替换掉原位置字符的新字符即可。 更改类命令允许您改变从当前光标所在位置直到动作指示的位置中间的文本。比如输入 ce 可以替换当前光标到单词的末尾的内容；输入 c$ 可以替换当前光标到行末的内容。 更改类命令的格式是： c [number] motion 第四讲 CTRL-G 用于显示当前光标所在位置和文件状态信息。 G 用于将光标跳转至文件最后一行。先敲入一个行号然后输入大写 G 则是将光标移动至该行号代表的行。gg 用于将光标跳转至文件第一行。 输入 / 然后紧随一个字符串是在当前所编辑的文档中正向查找该字符串。输入 ? 然后紧随一个字符串则是在当前所编辑的文档中反向查找该字符串。完成一次查找之后按 n 键是重复上一次的命令，可在同一方向上查找下一个匹配字符串所在；或者按大写 N 向相反方向查找下一匹配字符串所在。CTRL-O 带您跳转回较旧的位置，CTRL-I 则带您到较新的位置。 如果光标当前位置是括号(、)、[、]、{、}，按 % 会将光标移动到配对的括号上。 在一行内替换头一个字符串 old 为新的字符串 new，请输入 :s/old/new 在一行内替换所有的字符串 old 为新的字符串 new，请输入 :s/old/new/g 在两行内替换所有的字符串 old 为新的字符串 new，请输入 :#,#s/old/new/g 在文件内替换所有的字符串 old 为新的字符串 new，请输入 :%s/old/new/g 进行全文替换时询问用户确认每个替换需添加 c 标志 :%s/old/new/gc 第五讲 :!command 用于执行一个外部命令 command。 请看一些实际例子： (MS-DOS) (Unix) :!dir :!ls # 用于显示当前目录的内容。 :!del FILENAME :!rm FILENAME # 用于删除名为 FILENAME 的文件。 :w FILENAME 可将当前 VIM 中正在编辑的文件保存到名为 FILENAME 的文件中。 v motion :w FILENAME 可将当前编辑文件中可视模式下选中的内容保存到文件FILENAME 中。 :r FILENAME 可提取磁盘文件 FILENAME 并将其插入到当前文件的光标位置后面。 :r !dir 可以读取 dir 命令的输出并将其放置到当前文件的光标位置后面。 第六讲 输入小写的 o 可以在光标下方打开新的一行并进入插入模式。输入大写的 O 可以在光标上方打开新的一行。 输入小写的 a 可以在光标所在位置之后插入文本。输入大写的 A 可以在光标所在行的行末之后插入文本。 e 命令可以使光标移动到单词末尾。 操作符 y 复制文本，p 粘贴先前复制的文本。 输入大写的 R 将进入替换模式，直至按 键回到正常模式。 输入 :set xxx 可以设置 xxx 选项。一些有用的选项如下： ‘ic’ ‘ignorecase’ 查找时忽略字母大小写 ‘is’ ‘incsearch’ 查找短语时显示部分匹配 ‘hls’ ‘hlsearch’ 高亮显示所有的匹配短语 选项名可以用完整版本，也可以用缩略版本。 在选项前加上 no 可以关闭选项： :set noic 第七讲 输入 :help 或者按 键或 键可以打开帮助窗口。 输入 :help cmd 可以找到关于 cmd 命令的帮助。 输入 CTRL-W CTRL-W 可以使您在窗口之间跳转。 输入 :q 以关闭帮助窗口 您可以创建一个 vimrc 启动脚本文件用来保存您偏好的设置。 当输入 : 命令时，按 CTRL-D 可以查看可能的补全结果。 按 可以使用一个补全。 ","date":"2020-01-08","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Avim/:3:1","tags":["工具"],"title":"一篇文章学会Vim","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Avim/"},{"categories":["一篇文章学会系列"],"content":"帮助 在控制台中输入vim就可以查看Vim的相关信息 根据图片所示我们可以知道，当前VIM的版本为8.0.1365，想退出需要输入”:q”，查看在线帮助文档可以输入”:help”，查看版本信息可以输入”:help version8” 在英文模式下输入”:help\"回车后便可以看到 在这里有详细的Vim教程，教你玩转Vim。 ","date":"2020-01-08","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Avim/:3:2","tags":["工具"],"title":"一篇文章学会Vim","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Avim/"},{"categories":["Django基础教程"],"content":"Django配置文件详解","date":"2019-03-07","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E6%A8%A1%E6%9D%BF/","tags":["Django2.x","教程"],"title":"Django基础教程之模板","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E6%A8%A1%E6%9D%BF/"},{"categories":["Django基础教程"],"content":"声明：以下内容均为我个人的理解，如果发现错误或者疑问可以联系我共同探讨 本教程为Django基础教程系列第六篇，前面篇章在以下链接： Django基础教程之Django介绍 Django基础教程之工程搭建 Django基础教程之配置文件详解 Django基础教程之请求与响应 Django基础教程之类视图与中间件 ","date":"2019-03-07","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E6%A8%A1%E6%9D%BF/:0:0","tags":["Django2.x","教程"],"title":"Django基础教程之模板","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E6%A8%A1%E6%9D%BF/"},{"categories":["Django基础教程"],"content":"由于发现目前网上有很多大神的教学文章都比较出色，我就不班门弄斧继续出Django相关教程，以后会继续跟大家分享在使用Django中遇到的问题与解决方案，下面推荐几个比较好的学习Django的博客，大家可以根据自己情况选择学习 菜鸟教程 追梦人物的博客 Django中文网 Django官方文档 ","date":"2019-03-07","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E6%A8%A1%E6%9D%BF/:1:0","tags":["Django2.x","教程"],"title":"Django基础教程之模板","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E6%A8%A1%E6%9D%BF/"},{"categories":["Django基础教程"],"content":"Django配置文件详解","date":"2019-03-03","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/","tags":["Django2.x","教程"],"title":"Django基础教程之类视图与中间件","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"categories":["Django基础教程"],"content":"声明：以下内容均为我个人的理解，如果发现错误或者疑问可以联系我共同探讨 本教程为Django基础教程系列第五篇，前面篇章在以下链接： Django基础教程之Django介绍 Django基础教程之工程搭建 Django基础教程之配置文件详解 Django基础教程之请求与响应 ","date":"2019-03-03","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/:0:0","tags":["Django2.x","教程"],"title":"Django基础教程之类视图与中间件","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"categories":["Django基础教程"],"content":"类视图 以函数的方式定义的视图称为函数视图，函数视图便于理解。但是遇到一个视图对应的路径提供了多种不同HTTP请求方式的支持时，便需要在一个函数中编写不同的业务逻辑，代码可读性与复用性都不佳。 在Django中也可以使用类来定义一个视图，称为类视图。使用类视图可以将视图对应的不同请求方式以类中的不同方法来区别定义。 类视图的好处 代码可读性好 类视图相对于函数视图有更高的复用性， 如果其他地方需要用到某个类视图的某个特定逻辑，直接继承该类视图即可 类视图使用 定义类视图需要继承自Django提供的父类View，可使用from django.views.generic import View或者from django.views.generic.base import View 导入 配置路由时，使用类视图的as_view()方法来添加。 ","date":"2019-03-03","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/:1:0","tags":["Django2.x","教程"],"title":"Django基础教程之类视图与中间件","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"categories":["Django基础教程"],"content":"类视图原理 类视图使用装饰器 类视图Mixin扩展类 ","date":"2019-03-03","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/:1:1","tags":["Django2.x","教程"],"title":"Django基础教程之类视图与中间件","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"categories":["Django基础教程"],"content":"中间件 Django中的中间件是一个轻量级、底层的插件系统，可以介入Django的请求和响应处理过程，修改Django的输入或输出。中间件的设计为开发者提供了一种无侵入式的开发方式，增强了Django框架的健壮性。 我们可以使用中间件，在Django处理视图的不同阶段对输入或输出进行干预。 ","date":"2019-03-03","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/:2:0","tags":["Django2.x","教程"],"title":"Django基础教程之类视图与中间件","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"categories":["Django基础教程"],"content":"中间件的定义方法 定义一个中间件工厂函数，然后返回一个可以别调用的中间件。 中间件工厂函数需要接收一个可以调用的get_response对象。 返回的中间件也是一个可以被调用的对象，并且像视图一样需要接收一个request对象参数，返回一个response对象。 定义好中间件后，需要在settings.py 文件中添加注册中间件 ","date":"2019-03-03","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/:2:1","tags":["Django2.x","教程"],"title":"Django基础教程之类视图与中间件","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"categories":["Django基础教程"],"content":"多个中间件的执行顺序 在请求视图被处理前，中间件由上至下依次执行 在请求视图被处理后，中间件由下至上依次执行 ","date":"2019-03-03","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/:2:2","tags":["Django2.x","教程"],"title":"Django基础教程之类视图与中间件","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"categories":["Django基础教程"],"content":"Django配置文件详解","date":"2019-02-26","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/","tags":["Django2.x","教程"],"title":"Django基础教程之请求与相应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/"},{"categories":["Django基础教程"],"content":"声明：以下内容均为我个人的理解，如果发现错误或者疑问可以联系我共同探讨 本教程为Django基础教程系列第四篇，前面篇章在以下链接： Django基础教程之Django介绍 Django基础教程之工程搭建 Django基础教程之配置文件详解 ","date":"2019-02-26","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/:0:0","tags":["Django2.x","教程"],"title":"Django基础教程之请求与相应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/"},{"categories":["Django基础教程"],"content":"前言 在Django基础教程之工程搭建中，视图相关部分提到过Django中视图的功能是接受请求，进行业务处理，返回响应。今天就来研究一下Django中的请求与相应部分。 ","date":"2019-02-26","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/:1:0","tags":["Django2.x","教程"],"title":"Django基础教程之请求与相应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/"},{"categories":["Django基础教程"],"content":"请求 利用HTTP协议向服务器传参有几种途径？ 提取URL的特定部分，可以通过服务器端路由中用正则表达式截取； 查询字符串（query string)； 请求体（body）中发送的数据，比如表单数据、json、xml； 在http报文的头（header）中。 ","date":"2019-02-26","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/:2:0","tags":["Django2.x","教程"],"title":"Django基础教程之请求与相应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/"},{"categories":["Django基础教程"],"content":"URL路径参数 在定义路由URL时，可以使用正则表达式提取参数的方法从URL中获取请求参数，Django会将提取的参数直接传递到视图的传入参数中。 未命名参数按定义顺序传递， 如 url(r'^weather/([a-z]+)/(\\d{4})/$', views.weather), def weather(request, city, year): print('city=%s' % city) print('year=%s' % year) return HttpResponse('OK') 命名参数按名字传递，如 url(r'^weather/(?P\u003ccity\u003e[a-z]+)/(?P\u003cyear\u003e\\d{4})/$', views.weather), def weather(request, year, city): print('city=%s' % city) print('year=%s' % year) return HttpResponse('OK') ","date":"2019-02-26","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/:2:1","tags":["Django2.x","教程"],"title":"Django基础教程之请求与相应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/"},{"categories":["Django基础教程"],"content":"QueryDict对象 与python字典不同，QueryDict类型的对象用来处理同一个键带有多个值的情况，HttpRequest对象的属性GET、POST都是QueryDict类型的对象 get方法：根据键获取值，如果一个键同时拥有多个值将获取最后一个值，如果键不存在则返回None值，可以设置默认值进行后续处理 getlist方法：根据键获取值，值以列表返回，可以获取指定键的所有值，如果键不存在则返回空列表，可以设置默认值进行后续处理 ","date":"2019-02-26","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/:2:2","tags":["Django2.x","教程"],"title":"Django基础教程之请求与相应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/"},{"categories":["Django基础教程"],"content":"查询字符串Query String 获取请求路径中的查询字符串参数，可以通过request.GET属性获取，返回QueryDict对象。查询字符串不区分请求方式，即假使客户端进行POST方式的请求，依然可以通过request.GET获取请求中的查询字符串数据。 ","date":"2019-02-26","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/:2:3","tags":["Django2.x","教程"],"title":"Django基础教程之请求与相应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/"},{"categories":["Django基础教程"],"content":"请求体 请求体数据格式不固定，可以是表单类型字符串，可以是JSON字符串，可以是XML字符串，应区别对待。 可以发送请求体数据的请求方式有POST、PUT、PATCH、DELETE。 Django默认开启了CSRF防护，会对上述请求方式进行CSRF防护验证，在测试时可以关闭CSRF防护机制，方法为在settings.py文件中注释掉CSRF中间件 ","date":"2019-02-26","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/:2:4","tags":["Django2.x","教程"],"title":"Django基础教程之请求与相应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/"},{"categories":["Django基础教程"],"content":"表单 Form Data 前端发送的表单类型的请求体数据，可以通过request.POST属性获取，返回QueryDict对象。request.POST只能用来获取POST方式的请求体表单数据。 ","date":"2019-02-26","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/:2:5","tags":["Django2.x","教程"],"title":"Django基础教程之请求与相应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/"},{"categories":["Django基础教程"],"content":"非表单类型 Non-Form Data 非表单类型的请求体数据，Django无法自动解析，可以通过request.body属性获取最原始的请求体数据，自己按照请求体格式（JSON、XML等）进行解析。request.body返回bytes类型。 ","date":"2019-02-26","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/:2:6","tags":["Django2.x","教程"],"title":"Django基础教程之请求与相应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/"},{"categories":["Django基础教程"],"content":"请求头 可以通过request.META属性获取请求头headers中的数据，request.META为字典类型。 常见的请求头如： CONTENT_LENGTH – 请求体的长度。 CONTENT_TYPE – 请求体的类型。 HTTP_ACCEPT – 响应的可接受内容类型。 HTTP_ACCEPT_ENCODING – 可接受的响应码。 HTTP_ACCEPT_LANGUAGE – 响应的可接受语言。 HTTP_HOST – 客户端发送的HTTP主机报头。 HTTP_REFERER – 参考页面。 HTTP_USER_AGENT – 客户机的用户代理字符串。 QUERY_STRING – 查询字符串，作为单个(未解析的)字符串。 REMOTE_ADDR – 客户端的IP地址。 REMOTE_HOST – 客户机的主机名。 REMOTE_USER – Web服务器认证的用户。 REQUEST_METHOD – 请求方式字符串，如\"GET\"或\"POST”。 SERVER_NAME – 服务器的主机名。 SERVER_PORT – 服务器的端口。 ","date":"2019-02-26","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/:2:7","tags":["Django2.x","教程"],"title":"Django基础教程之请求与相应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/"},{"categories":["Django基础教程"],"content":"其他常用HttpRequest对象属性 method：一个字符串，表示请求使用的HTTP方法，常用值包括：‘GET’、‘POST’。 user：请求的用户对象。 path：一个字符串，表示请求的页面的完整路径，不包含域名和参数部分。 encoding：一个字符串，表示提交的数据的编码方式。 如果为None则表示使用浏览器的默认设置，一般为utf-8。 这个属性是可写的，可以通过修改它来修改访问表单数据使用的编码，接下来对属性的任何访问将使用新的encoding值。 FILES：一个类似于字典的对象，包含所有的上传文件。 ","date":"2019-02-26","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/:2:8","tags":["Django2.x","教程"],"title":"Django基础教程之请求与相应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/"},{"categories":["Django基础教程"],"content":"响应 视图在接收请求并处理后，必须返回HttpResponse对象或子对象。HttpRequest对象由Django创建，HttpResponse对象由开发人员创建。 ","date":"2019-02-26","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/:3:0","tags":["Django2.x","教程"],"title":"Django基础教程之请求与相应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/"},{"categories":["Django基础教程"],"content":"HttpResponse 可以使用django.http.HttpResponse来构造响应对象。也可通过HttpResponse对象属性来设置响应体、状态码： content：表示返回的内容。 status_code：返回的HTTP响应状态码。 响应头可以直接将HttpResponse对象当做字典进行响应头键值对的设置 ","date":"2019-02-26","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/:3:1","tags":["Django2.x","教程"],"title":"Django基础教程之请求与相应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/"},{"categories":["Django基础教程"],"content":"HttpResponse子类 Django提供了一系列HttpResponse的子类，可以快速设置状态码 HttpResponseRedirect 301 HttpResponsePermanentRedirect 302 HttpResponseNotModified 304 HttpResponseBadRequest 400 HttpResponseNotFound 404 HttpResponseForbidden 403 HttpResponseNotAllowed 405 HttpResponseGone 410 HttpResponseServerError 500 ","date":"2019-02-26","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/:3:2","tags":["Django2.x","教程"],"title":"Django基础教程之请求与相应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/"},{"categories":["Django基础教程"],"content":"JsonResponse 若要返回json数据，可以使用JsonResponse来构造响应对象，作用： 帮助我们将数据转换为json字符串 设置响应头Content-Type为 application/json ","date":"2019-02-26","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/:3:3","tags":["Django2.x","教程"],"title":"Django基础教程之请求与相应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/"},{"categories":["Django基础教程"],"content":"redirect重定向 ","date":"2019-02-26","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/:3:4","tags":["Django2.x","教程"],"title":"Django基础教程之请求与相应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/"},{"categories":["Django基础教程"],"content":"Cookie Cookie，有时也用其复数形式Cookies，指某些网站为了辨别用户身份、进行session跟踪而储存在用户本地终端上的数据（通常经过加密）。Cookie最早是网景公司的前雇员Lou Montulli在1993年3月的发明。Cookie是由服务器端生成，发送给User-Agent（一般是浏览器），浏览器会将Cookie的key/value保存到某个目录下的文本文件内，下次请求同一网站时就发送该Cookie给服务器（前提是浏览器设置为启用cookie）。Cookie名称和值可以由服务器端开发自己定义，这样服务器可以知道该用户是否是合法用户以及是否需要重新登录等。服务器可以利用Cookies包含信息的任意性来筛选并经常性维护这些信息，以判断在HTTP传输中的状态。Cookies最典型记住用户名。 Cookie是存储在浏览器中的一段纯文本信息，建议不要存储敏感信息如密码，因为电脑上的浏览器可能被其它人使用。 ","date":"2019-02-26","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/:4:0","tags":["Django2.x","教程"],"title":"Django基础教程之请求与相应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/"},{"categories":["Django基础教程"],"content":"Cookie的特点 Cookie以键值对的格式进行信息的存储。 Cookie基于域名安全，不同域名的Cookie是不能互相访问的，如访问itcast.cn时向浏览器中写了Cookie信息，使用同一浏览器访问baidu.com时，无法访问到itcast.cn写的Cookie信息。 当浏览器请求某网站时，会将浏览器存储的跟网站相关的所有Cookie信息提交给网站服务器。 ","date":"2019-02-26","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/:4:1","tags":["Django2.x","教程"],"title":"Django基础教程之请求与相应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/"},{"categories":["Django基础教程"],"content":"设置Cookie 可以通过HttpResponse对象中的set_cookie方法来设置cookie。 ","date":"2019-02-26","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/:4:2","tags":["Django2.x","教程"],"title":"Django基础教程之请求与相应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/"},{"categories":["Django基础教程"],"content":"读取Cookie 可以通过HttpRequest对象的COOKIES属性来读取本次请求携带的cookie值。request.COOKIES为字典类型。 ","date":"2019-02-26","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/:4:3","tags":["Django2.x","教程"],"title":"Django基础教程之请求与相应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/"},{"categories":["Django基础教程"],"content":"Session **Django项目默认启用Session。**如需禁用session，将上图中的session中间件注释掉即可。 ","date":"2019-02-26","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/:5:0","tags":["Django2.x","教程"],"title":"Django基础教程之请求与相应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/"},{"categories":["Django基础教程"],"content":"存储方式 在settings.py文件中，可以设置session数据的存储方式，可以保存在数据库、本地缓存等。 数据库 存储在数据库中，如下设置可以写，也可以不写，这是默认存储方式。 SESSION_ENGINE='django.contrib.sessions.backends.db' 如果存储在数据库中，需要在项INSTALLED_APPS中安装Session应用。 INSTALLED_APPS = [ ... 'django.contrib.sessions', ... ] 存储在数据库中会生成一个diango_session的表，表结构为：键、值、过期时间 本地缓存 存储在本机内存中，如果丢失则不能找回，比数据库的方式读写更快。 SESSION_ENGINE='django.contrib.sessions.backends.cache' 混合存储 优先从本机内存中存取，如果没有则从数据库中存取。 SESSION_ENGINE='django.contrib.sessions.backends.cached_db' Redis 在redis中保存session，需要引入第三方扩展，我们可以使用django-redis来解决。 1） 安装扩展 pip install django-redis 2）配置 在settings.py文件中做如下设置 CACHES = { \"default\": { \"BACKEND\": \"django_redis.cache.RedisCache\", \"LOCATION\": \"redis://127.0.0.1:6379/1\", \"OPTIONS\": { \"CLIENT_CLASS\": \"django_redis.client.DefaultClient\", } } } SESSION_ENGINE = \"django.contrib.sessions.backends.cache\" SESSION_CACHE_ALIAS = \"default\" 注意 如果redis的ip地址不是本地回环127.0.0.1，而是其他地址，访问Django时，可能出现Redis连接错误，如下： 解决方法： 修改redis的配置文件，添加特定ip地址。 Session操作 通过HttpRequest对象的session属性进行会话的读写操作。 1） 以键值对的格式写session。 request.session['键']=值 2）根据键读取值。 request.session.get('键',默认值) 3）清除所有session，在存储中删除值部分。 request.session.clear() 4）清除session数据，在存储中删除session的整条数据。 request.session.flush() 5）删除session中的指定键及值，在存储中只删除某个键及对应的值。 del request.session['键'] 6）设置session的有效期 request.session.set_expiry(value) 如果value是一个整数，session将在value秒没有活动后过期。 如果value为0，那么用户session的Cookie将在用户的浏览器关闭时过期。 如果value为None，那么session有效期将采用系统默认值，默认为两周，可以通过在settings.py中设置SESSION_COOKIE_AGE来设置全局默认值。 ","date":"2019-02-26","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/:5:1","tags":["Django2.x","教程"],"title":"Django基础教程之请求与相应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/"},{"categories":["Django基础教程"],"content":"Django配置文件详解","date":"2019-02-22","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/","tags":["Django2.x","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django基础教程"],"content":"声明：以下内容均为我个人的理解，如果发现错误或者疑问可以联系我共同探讨 本教程为Django基础教程系列第三篇，前面篇章在以下链接： Django基础教程之Django介绍 Django基础教程之工程搭建 ","date":"2019-02-22","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:0:0","tags":["Django2.x","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django基础教程"],"content":"简介 学习Django可以从Django配置文件的各项开始，由简入深的了解其作用，从而一步一步学习。本篇文章主要是介绍各项的作用以及如何配置，可以根据需求按需配置。 ","date":"2019-02-22","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:1:0","tags":["Django2.x","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django基础教程"],"content":"内容 ","date":"2019-02-22","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:0","tags":["Django2.x","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django基础教程"],"content":"绝对路径映射 ABSOLUTE_URL_OVERRIDES 作用：将应用的模型字符串映射到采用模型对象并返回其url，基于get_absolute_url方法。无论实际模型类名称的大小写如何，此设置中使用的模型名称均应全部小写。 ","date":"2019-02-22","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:1","tags":["Django2.x","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django基础教程"],"content":"管理员 ADMINS 作用：用于接收代码错误的人员列表，列表中的元素格式为（全名，电子邮箱） ","date":"2019-02-22","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:2","tags":["Django2.x","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django基础教程"],"content":"Django项目根路径 BASE_DIR 作用：以项目根路径为基础衍生其他文件 BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) 从内到外一步一步剖析 __file__：返回当前文件 os.path.abspath(__file__)：返回当前文件的绝对路径 os.path.dirname(os.path.abspath(__file__))：返回当前文件的父目录 os.path.dirname(os.path.dirname(os.path.abspath(__file__)))：返回当前文件父目录的父目录 可能这样还不太清楚，将__file__换成settings.py,可以看出来BASE_DIR是manage.py所在的目录，即整个项目的根目录 ","date":"2019-02-22","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:3","tags":["Django2.x","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django基础教程"],"content":"秘钥 SECRET_KEY 作用：校验，主要用于表单、session、csrf SECRET_KEY = \"adsasdasdsafdasfldasfklasdlfnlasdnfklnasdfklnasldfklkdasf\" ","date":"2019-02-22","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:4","tags":["Django2.x","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django基础教程"],"content":"调试模式 DEBUG 作用：当开启时，运行出现bug会在前端直接显示，开发，测试过程可以开启 DEBUG = True ","date":"2019-02-22","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:5","tags":["Django2.x","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django基础教程"],"content":"允许访问的主机 ALLOWED_HOSTS 作用：在开发的时候可以使用*，当项目上线后需要更换为指定的主机(域名和ip都可以) ALLOWED_HOSTS = [] ","date":"2019-02-22","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:6","tags":["Django2.x","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django基础教程"],"content":"应用、模块注册 INSTALLED_APPS 作用：将独立的应用或模块接入Django（注意应用名称或者模块名称必须是唯一的） INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', ] 通常INSTALLED_APPS默认包含以下Django自带的应用 django.contrib.admin：管理员站点，可以通过admin管理项目（数据、用户、权限等），使用admin必须完成以下配置 他依赖django.contrib.auth、django.contrib.contenttypes、django.contrib.sessions、django.contrib.messages四个模块 MIDDLEWARE设置必须包括 django.contrib.auth.middleware.AuthenticationMiddleware并且django.contrib.messages.middleware.MessageMiddleware 在项目url配置中必须加入admin urls.py from django.contrib import admin from django.urls import path urlpatterns = [ path('admin/', admin.site.urls), ] 可以使用django-admin createsuperuser创建管理员用户 django.contrib.auth：认证授权系统。主要负责校验用户信息与用户权限，由以下部分组成 用户：用户管理 权限：以二进制的形式标识指定用户是否可以执行的特殊任务 组：管理多个用户的权限 可配置的密码哈希话系统 为登录用户或限制内容提供表单和视图工具 可插拔的后端系统 需要注意的是它不提供密码强度检查、限制登录尝试、第三方身份验证，对象级权限 django.contrib.contenttypes：内容类型框架,他可以跟踪Django驱动的项目中安装的所有模型，为模型提供高级的通用界面 django.contrib.sessions：会话框架 django.contrib.messages：消息框架 staticfiles：管理静态文件框架 除了这些常见的自带应用外，在我们使用自己注册的应用和第三方模块时，记得第一时间来这里注册，否则会用不了哦 ","date":"2019-02-22","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:7","tags":["Django2.x","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django基础教程"],"content":"中间件 MIDDLEWARE 作用：中间件是Django请求/响应处理的钩子框架，用于改变Django的输入或输出 中间件可以放在Python路径上的任何地方，可以自己编写中间件，中间件可以是函数也可以是类。 函数形式的中间件 def simple_middleware(get_response): # 首次配置和初始化 def middleware(request): # 每个请求之前或调用视图函数之前执行的代码 response = get_response(request) # 每个响应、请求或者调用视图函数之后执行的代码 return response return middleware 类形式的中间件 def __init__(self, get_response): self.get_response = get_response # 首次配置和初始化 def __call__(self, request): # 每个请求之前或调用视图函数之前执行的代码 response = self.get_response(request) # 每个响应、请求或者调用视图函数之后执行的代码 return response 上述方法中调用get_response方法并不是实际视图中的，而是处理程序的包装方法，它负责应用视图中间件，调用具有适当的URL参数的视图，并应用模板响应和第三方中间件。 在使用类形式的中间件时，__init__方法必须接受get_response参数，还可以初始化中间件的一些局部状态。 想使用中间件就必须在settings.py文件中的MIDDLEWARE中激活。激活的方式是使用字符串表示指向中间件完整的Python路径 在Django中MIDDLEWARE可以为空，但是强烈建议至少激活CommonMiddleware 由于某些中间件也会依赖其他中间件所以中间件在MIDDLEWARE中的顺序很重要，Django会按自上而下的顺序调用中间件 ","date":"2019-02-22","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:8","tags":["Django2.x","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django基础教程"],"content":"路由根路径 ROOT_URLCONF 作用：Django在处理请求时会最先从此处寻找url 需要注意的是，此处的路径是基于BASE_DIR的路径 ","date":"2019-02-22","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:9","tags":["Django2.x","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django基础教程"],"content":"模板引擎配置 TEMPLATES 作用：在Django中使用模板引擎的设置列表，列表中每个元素都是一个字典，字典里配置模板引擎 常用的配置参数： BACKEND：项目使用的模板引擎，Django内置了两个 django.template.backends.django.DjangoTemplates django.template.backends.jinja2.Jinja2 DIRS：模板文件夹的位置 APP_DIRS：模板引擎是否在已安装的应用中讯在模板源文件 OPTIONS：传给后端模板的额外参数 ","date":"2019-02-22","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:10","tags":["Django2.x","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django基础教程"],"content":"内置服务器的路径 WSGI_APPLICATION 作用：用于调式Django程序的内置服务器， ","date":"2019-02-22","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:11","tags":["Django2.x","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django基础教程"],"content":"数据库配置 DATABASES 在mysite/mysite/settings.py中，默认的数据库为SQLite，还支持PostgreSQL、mysql、oracle等其他第三方（这些非官方后端支持的Django版本和ORM功能差异很大。有关这些非官方后端的具体功能的查询以及任何支持查询，应该针对每个第三方项目提供的支持渠道） DATABASES = { 'default': { 'ENGINE': 'django.db.backends.sqlite3', 'NAME': os.path.join(BASE_DIR, 'db.sqlite3'), } } ENGINE，数据库引擎，可选的ENGINE还有 django.db.backends.postgresql、django.db.backends.mysql、django.db.backends.oracle、第三方数据库 NAME，数据库名称，如果使用SQLite,他会在根目录生成一个数据库文件 当不使用SQLite时，还会有一下常用参数，其他参数可以查阅文档DATABASES NAME：数据库名字 USER：数据库的用户名 PASSWORD：数据库的密码 HOST：数据库的主机 PORT：数据库的端口 OPTIONS：连接到数据库时要使用的其他参数。可用参数取决于数据库后端。 TEST：测试数据库 测试数据库也具备一些设置，也是采用键值对的方式对数据库进行设置 CHARSET：创建测试数据库时使用的字符集编码 COLLATION：创建测试数据库时使用的排序规则 DEPENDENCIES：数据库的创建顺序依耐性 MIRROR：测试期间该数据库应镜像的数据库别名。 NAME：运行测试套件时要使用的数据库的名称。 SERIALIZE：一个布尔值，用于控制默认测试运行程序在运行测试之前是否将数据库序列化为内存中的JSON字符串。False如果没有任何带有测试类，可以将其设置为加快创建时间。 TEMPLATE：PostgreSQL的特定设置。从中创建测试数据库的模板（例如'template0'）的名称。 CREATE_DB：默认为True，Oracle特定的设置。如果将其设置为False，则测试表空间将不会在测试开始时自动创建，也不会在测试结束时自动删除。 CREATE_USER：默认为True，Oracle特定的设置。如果将其设置为False，则不会在测试开始时自动创建测试用户，并在测试结束时自动将其删除。 USER：默认为None，Oracle特定的设置。连接到运行测试时将使用的Oracle数据库时使用的用户名。如果未提供，则Django将使用。'test_' + USER PASSWORD：默认为None，Oracle特定的设置。连接到运行测试时将使用的Oracle数据库的密码。如果未提供，Django将生成一个随机密码。 TBLSPACE：默认为None，Oracle特定的设置。运行测试时将使用的表空间的名称。如果未提供，则Django将使用。'test_' + USER TBLSPACE_TMP：默认为None，Oracle特定的设置。运行测试时将使用的临时表空间的名称。如果未提供，则Django将使用。'test_' + USER + '_temp' DATAFILE：默认为None，这是Oracle特定的设置。用于TBLSPACE的数据文件的名称。如果未提供，则Django将使用。TBLSPACE + '.dbf' DATAFILE_TMP：默认为None，Oracle特定的设置。用于TBLSPACE_TMP的数据文件的名称。如果未提供，则Django将使用。TBLSPACE_TMP + '.dbf' DATAFILE_MAXSIZE：默认为500M，Oracle特定的设置。允许DATAFILE增大到的最大大小。 DATAFILE_TMP_MAXSIZE：默认为500M，Oracle特定的设置。DATAFILE_TMP允许增加到的最大大小。 DATAFILE_SIZE：默认为50M，Oracle特定的设置。DATAFILE的初始大小。 DATAFILE_TMP_SIZE：默认为50M，Oracle特定的设置。DATAFILE_TMP的初始大小。 DATAFILE_EXTSIZE：默认为25M，Oracle特定的设置。需要更多空间时，DATAFILE_TMP的扩展量。 其他的配置： ATOMIC_REQUESTS：默认为False，当设置为True时将每个视图包装在该数据库的事务中 AUTOCOMMIT:默认为True，当设置为False时警用Django的事务管理，可以自己编写事务管理机制 CONN_MAX_AGE：数据库连接的生存期，以秒为单位。用于0在每个请求结束时关闭数据库连接-Django的历史行为-并 None用于无限的持久连接。 TIME_ZONE：默认为None，用一个字符串表示存储在此数据库中的时区 ​ ","date":"2019-02-22","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:12","tags":["Django2.x","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django基础教程"],"content":"数据库路由器列表 DATABASE_ROUTERS 作用：执行数据库查询时将用来确定要使用哪个数据库的路由器列表。 ​ ","date":"2019-02-22","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:13","tags":["Django2.x","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django基础教程"],"content":"阈值检查 DATA_UPLOAD_MAX_NUMBER_FIELDS 作用：调用SuspiciousOperation检查GET或POST接受的最大值，当设为None时禁用检查 ​ ","date":"2019-02-22","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:14","tags":["Django2.x","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django基础教程"],"content":"显示日期的默认格式 DATE_FORMAT 作用：在任何地方显示日期字段的默认格式。 ​ ","date":"2019-02-22","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:15","tags":["Django2.x","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django基础教程"],"content":"密码强度列表 AUTH_PASSWORD_VALIDATORS 作用：用于检查用户密码强度的验证器列表 ​ ","date":"2019-02-22","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:16","tags":["Django2.x","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django基础教程"],"content":"语言 LANGUAGE_CODE 作用：项目语言，默认为‘en-us’ ​ ","date":"2019-02-22","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:17","tags":["Django2.x","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django基础教程"],"content":"时区 TIME_ZONE 作用：一个字符串表达的时区默认为’UTC’ ​ ","date":"2019-02-22","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:18","tags":["Django2.x","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django基础教程"],"content":"翻译系统 USE_I18N 作用：指定是否启用Django的翻译系统，默认为True ​ ","date":"2019-02-22","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:19","tags":["Django2.x","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django基础教程"],"content":"本地化 USE_L10N 作用：指定默认情况下是否启用数据本地化格式，默认为True ","date":"2019-02-22","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:20","tags":["Django2.x","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django基础教程"],"content":"时区 USE_TZ 作用：指定日期时间默认情况下是否支持时区 ​ ","date":"2019-02-22","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:21","tags":["Django2.x","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django基础教程"],"content":"静态文件夹的路径 STATIC_URL 作用：引用位于静态文件时使用的URL ​ ","date":"2019-02-22","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:22","tags":["Django2.x","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django基础教程"],"content":"静态文件的绝对路径 STATIC_ROOT 作用：在部署时收集静态文件的绝对路径 ​ ","date":"2019-02-22","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:23","tags":["Django2.x","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django基础教程"],"content":"Django介绍","date":"2019-02-17","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/","tags":["Django2.x","教程"],"title":"Django基础教程之工程搭建","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/"},{"categories":["Django基础教程"],"content":"声明：以下内容均为我个人的理解，如果发现错误或者疑问可以联系我共同探讨 本教程为Django基础教程系列第二篇，前面篇章在以下链接： Django基础教程之Django介绍 ","date":"2019-02-17","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/:0:0","tags":["Django2.x","教程"],"title":"Django基础教程之工程搭建","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/"},{"categories":["Django基础教程"],"content":"简介 每个工程项目的开始阶段往往决定了项目的大致走向，在工程搭建的过程中要为后面的项目开发做好准备。 为了不受Python环境的影响，最好建立虚拟环境，在虚拟环境中搭建项目 ","date":"2019-02-17","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/:1:0","tags":["Django2.x","教程"],"title":"Django基础教程之工程搭建","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/"},{"categories":["Django基础教程"],"content":"教程 ","date":"2019-02-17","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/:2:0","tags":["Django2.x","教程"],"title":"Django基础教程之工程搭建","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/"},{"categories":["Django基础教程"],"content":"安装环境 安装virtualenv virtualenv是一个用于创建Python虚拟环境的工具包，可以通过pip直接安装 pip3 install virtualenv 创建虚拟环境 virtualenv --python=/usr/bin/python3 django2.2.2_py3 django2.2.2_py3为虚拟环境的名字，这里是以Django的版本+Python版本命名，–python指定了Python的位置。 激活虚拟环境 source django2.2.2_py3/bin/activate 激活完成后会在命令行最前面显示当前的虚拟环境名 安装Django 本教程使用django2.2.2版本 pip install django==2.2.2 ","date":"2019-02-17","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/:2:1","tags":["Django2.x","教程"],"title":"Django基础教程之工程搭建","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/"},{"categories":["Django基础教程"],"content":"项目工程 在Django中，项目的工程目录可以通过Django提供的命令来创建。 创建 创建工程的命令为： django-admin startproject 工程名称 例如你想在做面食创建一个demo的工程项目，可以执行如下命令： cd ~/Desktop/ django-admin startproject demo 执行完毕后，会在当前目录即Desktop目录下生成一个名为demo的目录，该目录存放着整个Django工程 工程目录说明 查看创建的工程目录，结构如下 (django2.2.2_py3) ~/Desktop/demo$ tree . |-- demo | |-- __init__.py | |-- settings.py | |-- urls.py | `-- wsgi.py `-- manage.py 1 directory, 5 files demo：与项目同名的目录，存放项目相关文件。 settings.py：项目的配置文件。 urls.py：项目的总URL配置文件。 wsgi.py：项目与WSGI兼容的Web服务器入口。 manage.py 项目管理文件，通过它管理项目，同时也是启动项目的入口。 运行开发服务器 在开发阶段，为了能够快速预览到开发的效果，Djnago提供了一个纯python编写的轻量级web服务器，提供开发阶段使用。 运行服务器命令如下： python manage.py runserver 默认IP是127.0.0.1，默认端口为8000，可以写指定IP与端口，格式为：ip:端口 启动后可以看到以下信息 (django2.2.2_py3) ~/Desktop/demo$ python manage.py runserver Watching for file changes with StatReloader Performing system checks... System check identified no issues (0 silenced). You have 17 unapplied migration(s). Your project may not work properly until you apply the migrations for app(s): admin, auth, contenttypes, sessions. Run 'python manage.py migrate' to apply them. February 17, 2019 - 05:29:56 Django version 2.2.2, using settings 'demo.settings' Starting development server at http://127.0.0.1:8000/ Quit the server with CONTROL-C. 在浏览器中输入网址“127.0.0.1:8000”便可看到效果。 django默认工作在调式Debug模式下，如果增加、修改、删除文件，服务器会自动重启。 按ctrl+c停止服务器。 ","date":"2019-02-17","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/:2:2","tags":["Django2.x","教程"],"title":"Django基础教程之工程搭建","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/"},{"categories":["Django基础教程"],"content":"应用 在Web开发中通常一个大型项目是由无数个应用构成的。将开发中的工程项目拆分成不同的功能模块，可以让各功能模块之间保持相对独立，更利于我们开发与管理。 创建 Django为我们提供了创建应用的命令，创建应用的命令为： python manage.py startapp 子应用名称 需要注意的是，创建应用时必须在manage.py所在的目录下 现在创建一个用户相关的应用users，可以执行： python manage.py startapp users 执行后，可以看到工程目录中多出了一个名为users的子目录。 应用目录说明 (django2.2.2_py3) ~/Desktop/demo$ ls db.sqlite3 demo manage.py users (django2.2.2_py3) ~/Desktop/demo$ tree . |-- db.sqlite3 |-- demo | |-- __init__.py | |-- __pycache__ | | |-- __init__.cpython-36.pyc | | |-- settings.cpython-36.pyc | | |-- urls.cpython-36.pyc | | `-- wsgi.cpython-36.pyc | |-- settings.py | |-- urls.py | `-- wsgi.py |-- manage.py `-- users |-- __init__.py |-- admin.py |-- apps.py |-- migrations | `-- __init__.py |-- models.py |-- tests.py `-- views.py 4 directories, 17 files admin.py：后台管理配置信息。 apps.py：配置信息。 migrations 存放数据库迁移历史文件。 models.py：保存数据库模型类。 tests.py：用于开发测试用例，编写单元测试。 注册应用 创建完应用后Django并不能自动将项目与应用联系起来，需要我们在工程配置文件settings.py中注册才能使用。 在工程配置文件settings.py中的INSTALLED_APPS项负责注册安装好的应用，初始工程中的INSTALLED_APPS如下： 这些默认应用的作用可以看这篇文章：Django配置文件详解 注册一个应用的方法是将应用的配置信息文件apps.py中的Config类添加到INSTALLED_APPS列表中。 例如，注册刚创建的users应用，可在INSTALLED_APPS列表中添加**‘users.apps.UsersConfig’**。 创建视图 视图用于编写应用的业务逻辑，Django的视图是在应用中views.py中的 进入users应用，在views.py中编写视图代码。 from django.http import HttpResponse def index(request): \"\"\" 视图index :param request: 包含了请求信息的请求对象 :return: 响应对象 \"\"\" return HttpResponse(\"hello Django\") 说明： Django基础教程之Django介绍中提到过，Django中视图的功能是接受请求，进行业务处理，返回响应。在这里request是接受请求的对象，业务处理是生成hello Django字符串，而HttpResponse是返回响应的对象。 ","date":"2019-02-17","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/:2:3","tags":["Django2.x","教程"],"title":"Django基础教程之工程搭建","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/"},{"categories":["Django基础教程"],"content":"路由 什么是路由 在Django中，路由是将请求的URL分发给视图的系统。 路由定义的位置 一般情况下会有两种路由定义的位置，一种是项目工程的urls.py中，一种是每个应用下的urls.py中。项目工程的urls.py是Django解析路由的入口 路由解析顺序 Django在接收到请求时会先从项目工程urls.py中的urlpatterns列表中从上至下的顺序查找对应路由规则，如果发现规则为include包含，则再进入被包含的urls中的urlpatterns列表由上至下进行查询。 路由命名 在定义路由的时候，可以为路由命名，方便查找特定视图的具体路径信息。 在定义include函数定义路由时，可以使用namespace参数定义路由的命名空间，如 url(r'^users/', include('users.urls', namespace='users')), 命名空间表示，凡是users.urls中定义的路由，均属于namespace指明的users名下。 命名空间的作用：避免不同应用中的路由使用了相同的名字发生冲突，使用命名空间区别开。 在定义普通路由时，可以使用name参数指明路由的名字，如 urlpatterns = [ url(r'^index/$', views.index, name='index'), ] 路径结尾斜线的说明 Django中定义路由时，通常以斜线结尾，其好处是用户访问不以斜线结尾的相同路径时，Django会把用户重定向到以斜线/结尾的路径上，而不会返回404不存在。如 urlpatterns = [ url(r'^index/$', views.index, name='index'), ] 用户访问 index 或者 index/ 网址，均能访问到index视图。 虽然路由结尾带斜线能带来上述好处，但是却违背了HTTP中URL表示资源位置路径的设计理念。具体是否结尾带斜线以个人风格为准。 接下来我们要通过路由将工程-\u003e应用-\u003e视图给联系起来 首先在工程的总路由中添加users应用的路由信息 from django.contrib import admin + from django.urls import path, include urlpatterns = [ path('admin/', admin.site.urls), + path('users/', include('users.urls')), ] 说明： ‘users/‘表示所有/users/开头的请求 include表示以/users/匹配到users应用中urls.py的所有路由，即只要请求的URL是/users/开头都会去users应用中的urls.py中匹配剩下的路由。 将总路由引到users应用后，需要修改users应用中urls.py的信息 from django.conf.urls import url,re_path from . import views # urlpatterns是被django自动识别的路由列表变量 urlpatterns = [ # re_path是通过正则表达式来构造路由 # re_path(路由正则表达式，视图) re_path(r'^index/$', views.index), ] 说明： 现在完整的请求url为：/users/index/ 路由修改完成后，重启Django程序，就可以在浏览器中看到返回的信息了 ","date":"2019-02-17","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/:2:4","tags":["Django2.x","教程"],"title":"Django基础教程之工程搭建","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/"},{"categories":["Django基础教程"],"content":"Django介绍","date":"2019-02-14","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8Bdjango%E4%BB%8B%E7%BB%8D/","tags":["Django2.x","教程"],"title":"Django基础教程之Django介绍","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8Bdjango%E4%BB%8B%E7%BB%8D/"},{"categories":["Django基础教程"],"content":"声明：以下内容均为我个人的理解，如果发现错误或者疑问可以联系我共同探讨 本教程为Django基础教程系列第一篇 ","date":"2019-02-14","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8Bdjango%E4%BB%8B%E7%BB%8D/:0:0","tags":["Django2.x","教程"],"title":"Django基础教程之Django介绍","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8Bdjango%E4%BB%8B%E7%BB%8D/"},{"categories":["Django基础教程"],"content":"前言 为什么网上有很多Django的学习资料，我还想自己写一个Django的教程呢，一是想通过写教程发现自己的不足，二是想通过自己的总结让那些想学习Django的小伙伴们少走一些弯路，当然我写的内容有可能也是错的，欢迎大家纠正，我们可以共同探讨，共同进步。 ","date":"2019-02-14","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8Bdjango%E4%BB%8B%E7%BB%8D/:1:0","tags":["Django2.x","教程"],"title":"Django基础教程之Django介绍","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8Bdjango%E4%BB%8B%E7%BB%8D/"},{"categories":["Django基础教程"],"content":"简介 Django是一个高级Python Web框架，可以快速开发和简洁实用的设计。Django负责处理网站开发中遇到的问题，编程人员只需要专注于应用编写，无需重新造轮子。它是免费和开源的。 ","date":"2019-02-14","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8Bdjango%E4%BB%8B%E7%BB%8D/:2:0","tags":["Django2.x","教程"],"title":"Django基础教程之Django介绍","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8Bdjango%E4%BB%8B%E7%BB%8D/"},{"categories":["Django基础教程"],"content":"特点 ","date":"2019-02-14","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8Bdjango%E4%BB%8B%E7%BB%8D/:3:0","tags":["Django2.x","教程"],"title":"Django基础教程之Django介绍","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8Bdjango%E4%BB%8B%E7%BB%8D/"},{"categories":["Django基础教程"],"content":"完备性 Django原生提供了众多的功能组件，对于开发人员来说Django几乎做到了开箱即用。 ","date":"2019-02-14","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8Bdjango%E4%BB%8B%E7%BB%8D/:3:1","tags":["Django2.x","教程"],"title":"Django基础教程之Django介绍","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8Bdjango%E4%BB%8B%E7%BB%8D/"},{"categories":["Django基础教程"],"content":"安全 Django认真对待安全性，并帮助开发人员避免许多常见的安全性错误，例如SQL注入，跨站点脚本编写，跨站点请求伪造和点击劫持。其用户身份验证系统提供了一种安全的方式来管理用户帐户和密码。 ","date":"2019-02-14","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8Bdjango%E4%BB%8B%E7%BB%8D/:3:2","tags":["Django2.x","教程"],"title":"Django基础教程之Django介绍","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8Bdjango%E4%BB%8B%E7%BB%8D/"},{"categories":["Django基础教程"],"content":"可扩展性 Django强调代码复用，多个组件可以以\"插件\"的形式服务于整个框架，Django还有许多功能强大的第三方插件，你也可以开发自己的工具包。 ","date":"2019-02-14","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8Bdjango%E4%BB%8B%E7%BB%8D/:3:3","tags":["Django2.x","教程"],"title":"Django基础教程之Django介绍","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8Bdjango%E4%BB%8B%E7%BB%8D/"},{"categories":["Django基础教程"],"content":"MVT模式 Django采用MVT程序设计模式 M全拼为Model，主要封装对数据库层的访问，对数据库中的数据进行增、删、改、查操作。 V全拼为View，用于接收请求，进行业务处理，返回应答。 T全拼为Template，用于封装结果，负责封装构造要返回的html。 ","date":"2019-02-14","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8Bdjango%E4%BB%8B%E7%BB%8D/:4:0","tags":["Django2.x","教程"],"title":"Django基础教程之Django介绍","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8Bdjango%E4%BB%8B%E7%BB%8D/"},{"categories":["Django基础教程"],"content":"Django学习资料 Django官网 Django项目Github Django Book 教程 Mozilla Django教程 ","date":"2019-02-14","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8Bdjango%E4%BB%8B%E7%BB%8D/:5:0","tags":["Django2.x","教程"],"title":"Django基础教程之Django介绍","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8Bdjango%E4%BB%8B%E7%BB%8D/"},{"categories":["Django杂项"],"content":"Django2.x搭建博客","date":"2019-02-13","objectID":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/","tags":["Django2.x"],"title":"Django2.x搭建博客","uri":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Django杂项"],"content":"声明：以下内容均为我个人的理解，如果发现错误或者疑问可以联系我共同探讨 ","date":"2019-02-13","objectID":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:0:0","tags":["Django2.x"],"title":"Django2.x搭建博客","uri":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Django杂项"],"content":"简介 学完Django2.x可以搭建一个个人博客练练手 ","date":"2019-02-13","objectID":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:1:0","tags":["Django2.x"],"title":"Django2.x搭建博客","uri":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Django杂项"],"content":"教程 ","date":"2019-02-13","objectID":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:2:0","tags":["Django2.x"],"title":"Django2.x搭建博客","uri":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Django杂项"],"content":"创建项目 通过pycharm创建博客项目与虚拟环境 ","date":"2019-02-13","objectID":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:2:1","tags":["Django2.x"],"title":"Django2.x搭建博客","uri":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Django杂项"],"content":"修改相关设置 允许任何域名 在开发和测试的时候可以将这里填为*，后期部署上线后修改为指定域名即可 ALLOWED_HOSTS = ['*'] 注册应用 INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', # 注册应用，当使用pycharm创建时会帮我们自动创建 'post.apps.PostConfig', ] 配置模版 TEMPLATES = [ { # 选择我们的模板引擎，刚刚用pycharm创建时已选择django自带的模板引擎 'BACKEND': 'django.template.backends.django.DjangoTemplates', # 注册我们模版文件夹的位置，刚刚用pycharm创建时已将名字定为`templates` 'DIRS': [os.path.join(BASE_DIR, 'templates')] , 'APP_DIRS': True, 'OPTIONS': { 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', ], }, }, ] 注册完后，在项目根目录中（即manage.py所在的目录）创建templates文件夹，使用pycharm创建项目会自动帮我们创建 配置数据库 DATABASES = { 'default': { # 选择使用的数据库类型，这里为mysql 'ENGINE': 'django.db.backends.mysql', # 数据库名称 'NAME': 'djangoblog', # 数据库用户名 'USER': 'root', # 数据库密码 'PASSWORD': '123456', # 数据库ip，留空默认为localhost 'HOST': '', # 数据库端口，留空默认为3306 'PORT': '3306', } } 创建mysql数据库 在注册完数据库后创建mysql数据库 \u003e\u003e\u003e mysql -uroot -p mysql\u003e create database djangoblog charset=utf8; mysql\u003e show databases; +--------------------+ | Database | +--------------------+ | information_schema | | blog | | djangoblog | | mysql | | performance_schema | | sys | +--------------------+ 6 rows in set (0.01 sec) 数据库迁移 接下来进行数据库迁移，并创建django-admin管理员 按照之前的文章：Django2.0正确配置MySQL，配置好MySQL数据库 接下来再进行数据库迁移 (DjangoBlogEnv) hls-MacBook-Pro:DjangoBlog hl$ python manage.py makemigrations No changes detected (DjangoBlogEnv) hls-MacBook-Pro:DjangoBlog hl$ python manage.py migrate Operations to perform: Apply all migrations: admin, auth, contenttypes, sessions Running migrations: Applying contenttypes.0001_initial... OK Applying auth.0001_initial... OK Applying admin.0001_initial... OK Applying admin.0002_logentry_remove_auto_add... OK Applying admin.0003_logentry_add_action_flag_choices... OK Applying contenttypes.0002_remove_content_type_name... OK Applying auth.0002_alter_permission_name_max_length... OK Applying auth.0003_alter_user_email_max_length... OK Applying auth.0004_alter_user_username_opts... OK Applying auth.0005_alter_user_last_login_null... OK Applying auth.0006_require_contenttypes_0002... OK Applying auth.0007_alter_validators_add_error_messages... OK Applying auth.0008_alter_user_username_max_length... OK Applying auth.0009_alter_user_last_name_max_length... OK Applying auth.0010_alter_group_name_max_length... OK Applying auth.0011_update_proxy_permissions... OK Applying sessions.0001_initial... OK 出现Applying sessions.0001_initial… OK 代表mysql数据库已配置完成，接下来创建django-admin管理员 (DjangoBlogEnv) hls-MacBook-Pro:DjangoBlog hl$ python manage.py createsuperuser 用户名 (leave blank to use 'hl'): silencehl 电子邮件地址: silencehuliang@163.com Password: Password (again): 密码跟 用户名 太相似了。 密码长度太短。密码必须包含至少 8 个字符。 这个密码太常见了。 Bypass password validation and create user anyway? [y/N]: y Superuser created successfully. 出现Superuser created successfully.这一阶段数据库配置已完成，这里产生的数据库是Django自带的一些库 其他设置 区域语言设置，防止admin界面乱码 # 设置语言为中文 LANGUAGE_CODE = 'zh-hans' # 设置时区为上海 TIME_ZONE = 'Asia/Shanghai' 静态文件夹与多媒体文件夹设置 # 设置静态文件目录和名称 STATIC_URL = '/static/' # 设置静态文件夹目录的路径 STATICFILES_DIRS = ( os.path.join(BASE_DIR, 'static'), ) # 设置多媒体文件目录和名称 MEDIA_URL = '/media/' # 设置多媒体文件目录的路径 MEDIA_ROOT = os.path.join(BASE_DIR, 'media') 在settings.py里设置完毕后，我们在项目中也创建这两个文件在，在项目根目录中创建static与media这两个文件夹 配置pycharm运行参数 配置完成后点击pycharm中的运行按钮，在浏览器中输入127.0.0.1:8000访问，出现小火箭升空表示Django安装成功， 访问Django-admin界面， 在浏览器中输入127.0.0.1:8000/admin，看到Django管理，需要输入用户名密码，输入用户名密码后可以跳转到Django管理页面表示Django-admin设置成功 ","date":"2019-02-13","objectID":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:2:2","tags":["Django2.x"],"title":"Django2.x搭建博客","uri":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Django杂项"],"content":"数据库表分析 文章表 字段 类型 备注 id PrimaryKey 主键 title CharField 标题 create_time DateTimeField 创建时间 views PositiveIntegerField 阅读数 summary TextField 摘要 content TextField 内容 category_id ForeignKey 外键，分类id tag_id ManyToManyField 外键，标签id 分类表 字段 类型 备注 id PrimaryKey 主键 name CharField 分类名 标签表 字段 类型 备注 id PrimaryKey 主键 name CharField 标签名 用户表 字段 类型 备注 id PrimaryKey 主键 name CharField 用户名 password CharField 密码 评论表 字段 类型 备注 id PrimaryKey 主键 user_id ManyToManyField 外键，用户名id blog_id ManyToManyField 外键，博客id create_time DateTimeField 创建时间 content TextField 评论内容 Parent_id PositiveIntegerField 父评论id ","date":"2019-02-13","objectID":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:2:3","tags":["Django2.x"],"title":"Django2.x搭建博客","uri":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Django杂项"],"content":"编写模型类代码 根据数据库设计表格完成模型类代码 # DjangoBlog/post/models.py from django.db import models class Category(models.Model): \"\"\"分类\"\"\" name = models.CharField('分类', max_length=100) class Meta: verbose_name = '分类' verbose_name_plural = verbose_name def __str__(self): return self.name class Tags(models.Model): \"\"\"标签\"\"\" name = models.CharField('标签', max_length=100) class Meta: verbose_name = '标签' verbose_name_plural = verbose_name def __str__(self): return self.name class Article(models.Model): \"\"\"博客\"\"\" title = models.CharField('标题', max_length=100) create_time = models.DateTimeField('创建时间', auto_now_add=True) views = models.PositiveIntegerField('阅读数', default=0) summary = models.TextField('摘要') content = models.TextField('内容') category_id = models.ForeignKey(Category, on_delete=models.DO_NOTHING, verbose_name='分类') tag_id = models.ManyToManyField(Tags, verbose_name='标签') class Meta: verbose_name = '文章' verbose_name_plural = '文章' def __str__(self): return self.title class User(models.Model): \"\"\"用户\"\"\" name = models.CharField('用户名', max_length=100) password = models.CharField('密码', max_length=100) class Meta: verbose_name = '用户名' verbose_name_plural = verbose_name def __str__(self): return self.name class Comment(models.Model): \"\"\"评论\"\"\" user = models.ManyToManyField(User, verbose_name='用户') article = models.ManyToManyField(Article, verbose_name='博客') create_time = models.DateTimeField('创建时间', auto_now_add=True) content = models.TextField('内容') Parent_id = models.PositiveIntegerField('父评论id') class Meta: verbose_name = '评论' verbose_name_plural = verbose_name def __str__(self): return self.content 数据库迁移 (DjangoBlogEnv) hls-MacBook-Pro:DjangoBlog hl$ python manage.py makemigrations Migrations for 'blog': blog/migrations/0001_initial.py - Create model Article - Create model Category - Create model Tags - Create model User - Create model Comment - Add field category_id to article - Add field tag_id to article (DjangoBlogEnv) hls-MacBook-Pro:DjangoBlog hl$ python manage.py migrate Operations to perform: Apply all migrations: admin, auth, blog, contenttypes, sessions Running migrations: Applying blog.0001_initial... OK ","date":"2019-02-13","objectID":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:2:4","tags":["Django2.x"],"title":"Django2.x搭建博客","uri":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Django杂项"],"content":"用django-admin管理 数据库迁移完成会在post应用下生成一个迁移的文件，接下来在django-admin中注册模型，便于我们用django-admin管理 /post/admin.py from django.contrib import admin from .models import Article, Category, Tags, User, Comment @admin.register(Article) class ArticleAdmin(admin.ModelAdmin): # 在后台显示的字段 list_display = ('id', 'title', 'create_time', 'category_id', 'views') # 分页的个数 list_per_page = 10 # 按时间倒序排序 ordering = ('-create_time',) # 点击修改的字段 list_display_links = ('id', 'title') @admin.register(Category) class CategoryAdmin(admin.ModelAdmin): list_display = ('id', 'name') @admin.register(Tags) class TagsAdmin(admin.ModelAdmin): list_display = ('id', 'name') @admin.register(User) class UserAdmin(admin.ModelAdmin): list_display = ('id', 'name', 'password') @admin.register(Comment) class CommentAdmin(admin.ModelAdmin): list_display = ('id', 'content', 'create_time') 登陆Django管理后台，查看模型是否可以被管理，尝试点击添加与修改，没问题就说明注册成功 ","date":"2019-02-13","objectID":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:2:5","tags":["Django2.x"],"title":"Django2.x搭建博客","uri":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Django杂项"],"content":"集成Markdown 很多人喜欢用markdown格式写博客，我们可以通过集成Django-mdeditor 来实现这个功能 1.安装django-mdeditor pip install django-mdeditor 2.在apps中注册 INSTALLED_APPS = [ ... 'mdeditor', ] 3.在media下创建editor文件夹 cd media mkdir editor 4.集成到路由中 /blog/urls.py from django.conf.urls import url, include from django.conf.urls.static import static from django.conf import settings ... urlpatterns = [ ... url(r'mdeditor/', include('mdeditor.urls')) ] if settings.DEBUG: # static files (images, css, javascript, etc.) urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT) 5.集成到models中 from mdeditor.fields import MDTextField class Article(models.Model): ... content = MDTextField() ... 再次进入admin，选择文章修改就可以看到集成的markdown编辑器了 ","date":"2019-02-13","objectID":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:2:6","tags":["Django2.x"],"title":"Django2.x搭建博客","uri":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Django杂项"],"content":"实现视图 首先找到一套你喜欢的模版，将模版下载下来，html部分放入templates中，其他静态文件放入static中 将重复出现的部分提取出来，这个根据自己的模版抽取，每个都不相同，静态文件加载 如果一次没有提取好，可以慢慢一点点的抽取，对于一个后端程序员来说这个是一个慢工出细活的过程.可以写一个简单的视图，然后开着Django一边抽取一遍调试 接下来实现首页试图 首先在urls.py中配置路由 DjangoBlog/u rls.py ... from blog import views urlpatterns = [ ... path('', views.index, name='index') ] 这里path里第一个参数为访问的url，匹配采用正则表达式，第二个参数为视图函数，第三个为取的名字 接下来在blog应用的views.py中编写视图函数 blog/views.py ... def index(request): return render(request, 'index.html') 这样当我们重新访问127.0.0.1:8000时，我们修改的前端代码就被加载了 接下来我们实现将分类加载,将index视图修改为一下代码 blog/views.py ... from .models import Category # 从models里导入Category类 def index(request): categorys = Category.objects.all() # 把查询出来的分类封装到上下文里 context = { 'categorys': categorys, } print(context) return render(request, 'index.html', context) 在前端代码中渲染，我们找到base.html,将ul标签中的除首页以外的代码改为一下代码 \u003cheader class=\"header-navigation\" id=\"header\"\u003e \u003cnav\u003e \u003cdiv class=\"logo\"\u003e\u003ca href=\"/\"\u003e胡亮个人博客\u003c/a\u003e\u003c/div\u003e \u003ch2 id=\"mnavh\"\u003e\u003cspan class=\"navicon\"\u003e\u003c/span\u003e\u003c/h2\u003e \u003cul id=\"starlist\"\u003e \u003cli\u003e\u003ca href=\"index.html\"\u003e首页\u003c/a\u003e\u003c/li\u003e {% for category in categorys %} \u003cli\u003e\u003ca href=\"{% url 'index' %}list-{{ category.id }}.html\"\u003e{{ category.name }}\u003c/a\u003e\u003c/li\u003e {% endfor %} \u003c/ul\u003e \u003c/nav\u003e \u003c/header\u003e 这样分类栏就加载出来了，如果没有数据可以通过admin添加数据 ","date":"2019-02-13","objectID":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:2:7","tags":["Django2.x"],"title":"Django2.x搭建博客","uri":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Django杂项"],"content":"Django初体验","date":"2019-01-26","objectID":"/django%E5%88%9D%E4%BD%93%E9%AA%8C/","tags":["Django2.x"],"title":"Django初体验","uri":"/django%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["Django杂项"],"content":"声明：以下内容均为我个人的理解，如果发现错误或者疑问可以联系我共同探讨 ","date":"2019-01-26","objectID":"/django%E5%88%9D%E4%BD%93%E9%AA%8C/:0:0","tags":["Django2.x"],"title":"Django初体验","uri":"/django%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["Django杂项"],"content":"简介 在Django2.0以后，Django已经不支持python2.7，所以我们需要一个python3的系统环境，这里一python3.6为例 ","date":"2019-01-26","objectID":"/django%E5%88%9D%E4%BD%93%E9%AA%8C/:1:0","tags":["Django2.x"],"title":"Django初体验","uri":"/django%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["Django杂项"],"content":"安装Django ","date":"2019-01-26","objectID":"/django%E5%88%9D%E4%BD%93%E9%AA%8C/:2:0","tags":["Django2.x"],"title":"Django初体验","uri":"/django%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["Django杂项"],"content":"三种方式安装 pip安装 一般情况下安装python后会帮你安装好pip，当你没安装时使用这个链接安装,记得更新到最新版本 安装并使用virtualenv 在创建好并激活的虚拟环境中输入一下命令 $ pip install Django 通过第三方软件包 管理系统集成的Django 安装开发版本 安装好git 输入一下命令下载Django $ git clone https://github.com/django/django.git 安装并使用virtualenv 在创建好并激活的虚拟环境中输入一下命令 $ pip install -e django/ 安装好Django后可以通过一下命令查看当前Django版本 $ python -m django --version ","date":"2019-01-26","objectID":"/django%E5%88%9D%E4%BD%93%E9%AA%8C/:2:1","tags":["Django2.x"],"title":"Django初体验","uri":"/django%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["Django杂项"],"content":"Django初体验 ","date":"2019-01-26","objectID":"/django%E5%88%9D%E4%BD%93%E9%AA%8C/:3:0","tags":["Django2.x"],"title":"Django初体验","uri":"/django%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["Django杂项"],"content":"安装并使用virtualenv 详细过程见这个链接 ","date":"2019-01-26","objectID":"/django%E5%88%9D%E4%BD%93%E9%AA%8C/:3:1","tags":["Django2.x"],"title":"Django初体验","uri":"/django%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["Django杂项"],"content":"创建Django项目 在项目存放目录打开命令行运行一下命令： $ django-admin startproject mysite 这句话执行过后会在当前目录生成一个名字为mysite的Django项目，目录结构为下 mysite/ manage.py mysite/ __init__.py settings.py urls.py wsgi.py 这些目录和文件的作用： mysite/目录：存放项目的容器，他的名字不重要可以更换为你喜欢的任何名字 manage.py：Django项目的启动文件，他可以让你通过各种方式管理Django项目。 mysite/mysite/目录：项目目录，里面存放项目相关的文件 mysite/mysite/settings.py：Django项目的配置文件 mysite/mysite/urls.py：Django项目的url声明文件,他将url对应相关的app的视图 mysite/mysite/wsgi.py：Django项目wsgi服务器的入口 当输入以下命令，并进入浏览器输入：http://127.0.0.1:8000/看到Django启动成功 $ python manage.py runserver 这里能启动成功是因为Django自带一个简易的服务器（用纯 Python 写的轻量级的 Web 服务器）。他能帮助我们快速开发。 ","date":"2019-01-26","objectID":"/django%E5%88%9D%E4%BD%93%E9%AA%8C/:3:2","tags":["Django2.x"],"title":"Django初体验","uri":"/django%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["Django杂项"],"content":"创建一个应用 将当前目录切换到manage.py所在的目录，输入下面的命令创建一个应用: $ python manage.py startapp demo 该应用的目录结构大致如下 demo/ __init__.py admin.py apps.py migrations/ __init__.py models.py tests.py views.py 这些目录和文件的作用： admin.py：管理admin后台相关数据库模型 apps.py：该应用的相关配置 migrations/文件夹及其内容：数据库迁移相关的文件夹，里面存放着迁移版本，迁移信息等 models.py：编写模型类的文件 tests.py：用于测试的文件 view.py：编写视图的文件 我们还要在项目配置文件中注册该app，打开settings.py文件，找到INSTALLED_APPS，在列表的最后添加demoapp mysite/settings.py INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', # 注册demo 'demo.apps.DemoConfig' ] ","date":"2019-01-26","objectID":"/django%E5%88%9D%E4%BD%93%E9%AA%8C/:3:3","tags":["Django2.x"],"title":"Django初体验","uri":"/django%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["Django杂项"],"content":"编写第一个视图 视图在应用的views.py中编写 demo/views.py from django.http import HttpResponse def index(request): return HttpResponse(\"Hello, world!\") 为了能看到效果我们还需要配置一下url，在demo目录下创建一个urls.py，并输入一下代码 /demo/urls.py from django.urls import path from . import views urlpatterns = [ path(\"\",views.index,name='index'), ] 更改项目url，通过修改项目urls.py文件修改路由 /mysite/urls.py from django.contrib import admin from django.urls import include, path urlpatterns = [ path('demo/', include('demo.urls')), path('admin/', admin.site.urls), ] 这里include是将demo/的路由转发到demo应用的urls.py里。每当 Django 遇到 include时，它会截断与此项匹配的 URL 的部分，并将剩余的字符串发送到 对应urls.py以供进一步处理。 path有五个参数：route、view、kwargs、name、Pattern，其中route、view是必须传入的参数 route：匹配url的准则（类似于正则表达式）。当Django响应一个请求时，他会从urlpatterns的第一项开始，按顺序依次匹配，知道找到匹配的项 view：目标视图函数。当route找到匹配的项后，会调用当前的视图函数，并传入一个HttpRequest对象作为第一个参数，route中的参数一关键字参数的形式传入 kwargs：关键字参数。任意个关键字参数可以作为一个字典传递给目标视图函数。 name：为url取的名字。他可以使Django在任意地方引用他 Pattern：匹配模式 现在可以启动Django程序来看是否正常工作 ","date":"2019-01-26","objectID":"/django%E5%88%9D%E4%BD%93%E9%AA%8C/:3:4","tags":["Django2.x"],"title":"Django初体验","uri":"/django%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["Django杂项"],"content":"数据库 创建数据库 进入mysql并创建一个test数据库，字符设置为utf8 $ mysql -uroot -p mysql\u003e create database test charset=utf8; Query OK, 1 row affected (0.00 sec) 数据库配置 首先我们需要配置mysite/setting.py中的数据库DATABASES选项，Django默认是sqlite数据库，如果个人项目不大的情况下可以使用这个，也可以使用自己熟悉的数据库，Django不仅支持sqlite，postgresql，mysql，或oracle，还支持很多有第三方插件的数据库，我使用mysql数据库 /mysite/settings.py DATABASES = { 'default': { 'ENGINE': 'django.db.backends.mysql', # 数据库名 'NAME': 'test', # 用户名 'USER': 'root', # 密码 'PASSWORD': 'mysql' # 主机,默认为localhost 'HOST': '' # 端口号，默认为3306 'PORT': '' } } 数据库迁移 因为Django自带应用已经为我们编写了一些数据模型，即时我们不编写任何模型也可以直接使用数据库迁移命令进行迁移 $ python manage.py migrate 会看到初始化了很多用户、权限相关的表 创建一个管理员账号，依次输入用户名、邮箱、密码、确认密码，建议密码设置复杂点 $ python manage.py createsuperuser 用户名 (leave blank to use '02'): admin 电子邮件地址: 1@gmail.com Password: Password (again): 密码跟 用户名 太相似了。 密码长度太短。密码必须包含至少 8 个字符。 这个密码太常见了。 Bypass password validation and create user anyway? [y/N]: y Superuser created successfully. 接下来启动项目，并在浏览器中输入http://127.0.0.1:8000/admin，进入后台管理界面 输入账号密码，点击登录即可 数据库迁移，需要三步 编写models.py文件，改变模型。 运行 python manage.py makemigrations为模型的改变生成迁移文件。 运行 python manage.py migrate 来应用数据库迁移。 创建一个图书模型 在demo应用下创建一个图书模型 /demo/models.py from django.db import models class Books(models.Model): # 书名 book_name = models.CharField(max_length=200) # 作者 author = models.CharField(max_length=50) 建立的模型有两个字段，书名和作者，使用了字符类型，增加了长度限制（注意在使用CharField时必须要添加max_length限制） 创建迁移模型并生成迁移文件 $ python manage.py makemigrations demo Migrations for 'demo': demo\\migrations\\0001_initial.py - Create model Books 会出现创建了Books这个模型，在demo应用的migrations文件夹下会多一个0001_initila.py的迁移文件，可以使用python manage.py sqlmigrate demo 0001可以查看这次数据库迁移的操作与具体的SQL语句 $ python manage.py sqlmigrate demo 0001 BEGIN; -- -- Create model Books -- CREATE TABLE `demo_books` (`id` integer AUTO_INCREMENT NOT NULL PRIMARY KEY, `book_name` varchar(200) NOT NULL, `auhtor` varchar(50) NOT NULL); COMMIT; 需要注意一下几点： 输出的内容与使用的数据库有关。 数据库的表名默认是“应用名_模型名的小写”，也可以自定义表名。 主键会默认自动创建，也可以自定义主键。 Django会为使用的数据库定制相关SQL语句，例如主键：integer AUTO_INCREMENT NOT NULL PRIMARY KEY，varchar：NOT NULL sqlmigrate命令并没有真正执行迁移命令，他只是将迁移命令执行的流程输出到屏幕上，供你查看 执行check命令对项目做检查 $ python manage.py check System check identified no issues (0 silenced). 没有问题后执行迁移命令 $ python manage.py migrate Operations to perform: Apply all migrations: admin, auth, contenttypes, demo, sessions Running migrations: Applying demo.0001_initial... OK 看到以上内容即完成了数据库迁移 通过Python命令行尝试 $ python manage.py shell \u003e\u003e\u003e from demo.models import Books \u003e\u003e\u003e ggzh = Books(book_name=\"硅谷之火\",author=\"迈克尔.斯韦因\") \u003e\u003e\u003e ggzh.save() \u003e\u003e\u003e ggzh.id 1 \u003e\u003e\u003e ggzh.book_name '硅谷之火' \u003e\u003e\u003e ggzh.author '迈克尔.斯韦因' \u003e\u003e\u003e Books.objects.all() \u003cQuerySet [\u003cBooks: Books object (1)\u003e]\u003e 这里我们看到\u003cQuerySet [\u003cBooks: Books object (1)\u003e]\u003e这个并不能让我们知道这个对象的细节，通过修改Books模型来修复这个问题 /demo/models.py class Books(models.Model): # 书名 book_name = models.CharField(max_length=200) # 作者 author = models.CharField(max_length=50) def __str__(self): return self.book_name 修改完成后重新进入交互终端，再次查询就可以显示书名了，这里可以自己定义想显示的字段或内容 $ python manage.py shell \u003e\u003e\u003e from demo.models import Books \u003e\u003e\u003e Books.objects.all() \u003cQuerySet [\u003cBooks: 硅谷之火\u003e]\u003e 再添加一本书，聚合函数 \u003e\u003e\u003e qbsz = Books(book_name=\"史蒂夫*乔布斯传\",author=\"沃尔特·艾萨克森\") \u003e\u003e\u003e qbsz.save() \u003e\u003e\u003e Books.objects.all() \u003cQuerySet [\u003cBooks: 硅谷之火\u003e, \u003cBooks: 史蒂夫*乔布斯传\u003e]\u003e \u003e\u003e\u003e Books.objects.count() 2 \u003e\u003e\u003e Books.objects.filter(book_name=\"硅谷之火\") \u003cQuerySet [\u003cBooks: 硅谷之火\u003e]\u003e 接下来我们将Books模型添加到admin管理，通过register方法，将Books交给admin管理 /demo/admin from django.contrib import admin from .models import Books admin.site.register(Books) 重新运行项目，在地址栏输入：http://127.0.0.1:8000/admin/，输入账号密码登录即可查看到这个模型 点进去可以查看该模型的数据，右上角可以添加，动作可以删除，点图书名可以看到更多细节 ","date":"2019-01-26","objectID":"/django%E5%88%9D%E4%BD%93%E9%AA%8C/:3:5","tags":["Django2.x"],"title":"Django初体验","uri":"/django%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["Django杂项"],"content":"视图与模板 在models.py中添加一个图书模型 /demo/models.py from django.db import models class Books(models.Model): # 书名 name = models.CharField('书名', max_length=200) # 作者 author = models.CharField('作者', max_length=50) publish_house = models.CharField('出版社', max_length=50) publish_date = models.CharField('出版日期', max_length=50) price = models.IntegerField('价格') synopsis = models.TextField('简介') def __str__(self): return self.name 在admin.py中注册Books 迁移数据库 在Django后台中添加图书数据 在应用的views.py中编写一个展示图书的视图 /demo/views.py from django.http import HttpResponse from .models import Books def book_list(request): book_list = Books.objects.all() books = {book.name: book.id for book in book_list} return render(request, 'index.html', context={'books': books}) 通过模板渲染 在templates目录下新建一个index.html文件 /tempaltes/index.html \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv\u003e图书管理系统：\u003c/div\u003e \u003cul\u003e {% for key,value in books.items %} \u003cli\u003e\u003ca href=\"{% url 'detail' value %}/\"\u003e{{ key }}\u003c/a\u003e \u003c/li\u003e {% endfor %} \u003c/ul\u003e \u003c/body\u003e \u003c/html\u003e 在项目的urls.py文件中添加一个关于图书的路由 /mysite/urls.py from django.contrib import admin from django.urls import path from demo import views urlpatterns = [ path('admin/', admin.site.urls), path('book/', include('demo.urls')), ] 在demo目录中新建一个urls.py文件，并添加一个路由 /demo/urls.py from django.urls import path from . import views urlpatterns = [ path('', views.book_list, name='index'), ] 启动项目，访问：http://127.0.0.1:8000/book/ 图书列表页完成了，接下来编写图书详情页 在demo项目中的urls.py文件中添加一个详情页的路由 /demo/urls.py from django.urls import path from . import views urlpatterns = [ path('', views.book_list, name='index'), path('\u003cint:id\u003e/', views.detail, name='detail'), ] 在demo项目中的views.py文件中编写详情页相关视图函数 /demo/views.py def detail(request, id): book = Books.objects.filter(id=id).all()[0] content = { \"name\": book.name, \"author\": book.author, 'publish_house': book.publish_house, 'publish_date': book.publish_date, 'price': book.price, 'synopsis': book.synopsis } return render(request, 'detail.html', context=content) 在templates文件夹里新建一个detail.html文件,并写入一下代码 /templates/detail.html \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ctable\u003e \u003ctr\u003e \u003ctd\u003e书名\u003c/td\u003e \u003ctd\u003e作者\u003c/td\u003e \u003ctd\u003e出版社\u003c/td\u003e \u003ctd\u003e出版日期\u003c/td\u003e \u003ctd\u003e价格\u003c/td\u003e \u003ctd\u003e简介\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e{{ name }}\u003c/td\u003e \u003ctd\u003e{{ author }}\u003c/td\u003e \u003ctd\u003e{{ publish_house }}\u003c/td\u003e \u003ctd\u003e{{ publish_date }}\u003c/td\u003e \u003ctd\u003e{{ price }}\u003c/td\u003e \u003ctd\u003e{{ synopsis }}\u003c/td\u003e \u003c/tr\u003e \u003c/table\u003e \u003c/body\u003e \u003c/html\u003e 启动项目，访问：http://127.0.0.1:8000/book/，点击其中一个图书就可以看到详情页，或者直接选择一个id访问详情页，这时候就会出现一个问题，当访问一个不存在的id时就会出错，我们需要定制一下错误页面，修改detail视图函数。 /demo/views.py from django.http import Http404 ... def detail(request, id): books = Books.objects.filter(id=id).all() if len(books): book = books[0] content = { \"name\": book.name, \"author\": book.author, 'publish_house': book.publish_house, 'publish_date': book.publish_date, 'price': book.price, 'synopsis': book.synopsis } return render(request, 'detail.html', context=content) else: raise Http404(\"图书不存在\") 这里调用的是Django自带的404错误页面，我们需要返回错误说明 ","date":"2019-01-26","objectID":"/django%E5%88%9D%E4%BD%93%E9%AA%8C/:3:6","tags":["Django2.x"],"title":"Django初体验","uri":"/django%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["Django杂项"],"content":"Django2.x配置mysql","date":"2019-01-21","objectID":"/%E8%AE%B0django2.x%E9%85%8D%E7%BD%AEmysql/","tags":["pymsql","Django2.x"],"title":"Django2.x配置mysql","uri":"/%E8%AE%B0django2.x%E9%85%8D%E7%BD%AEmysql/"},{"categories":["Django杂项"],"content":"声明：以下内容均为我个人的理解，如果发现错误或者疑问可以联系我共同探讨 ","date":"2019-01-21","objectID":"/%E8%AE%B0django2.x%E9%85%8D%E7%BD%AEmysql/:0:0","tags":["pymsql","Django2.x"],"title":"Django2.x配置mysql","uri":"/%E8%AE%B0django2.x%E9%85%8D%E7%BD%AEmysql/"},{"categories":["Django杂项"],"content":"简介 在Django中使用mysql数据库是很常见的,但是升级到Django2.0以后，已经不支持Python2.x，mysql的配置也需要随之改变 ","date":"2019-01-21","objectID":"/%E8%AE%B0django2.x%E9%85%8D%E7%BD%AEmysql/:1:0","tags":["pymsql","Django2.x"],"title":"Django2.x配置mysql","uri":"/%E8%AE%B0django2.x%E9%85%8D%E7%BD%AEmysql/"},{"categories":["Django杂项"],"content":"配置 ","date":"2019-01-21","objectID":"/%E8%AE%B0django2.x%E9%85%8D%E7%BD%AEmysql/:2:0","tags":["pymsql","Django2.x"],"title":"Django2.x配置mysql","uri":"/%E8%AE%B0django2.x%E9%85%8D%E7%BD%AEmysql/"},{"categories":["Django杂项"],"content":"配置settings.py DATABASES = { 'default': { 'ENGINE': 'django.db.backends.mysql', 'NAME': 'dbname', 'USER': 'dbuser', 'PASSWORD': 'dbpassword', 'HOST':'dbhost', 'PORT':'dbport' } } ","date":"2019-01-21","objectID":"/%E8%AE%B0django2.x%E9%85%8D%E7%BD%AEmysql/:2:1","tags":["pymsql","Django2.x"],"title":"Django2.x配置mysql","uri":"/%E8%AE%B0django2.x%E9%85%8D%E7%BD%AEmysql/"},{"categories":["Django杂项"],"content":"使用pymysql 由于安装mysqlclient不支持python3，所以使用pymysql包，安装pymysql并导入 pip install pymysql 配置pymysql，在settings.py所在的目录下的__init__.py文件中导入 import pymysql pymysql.install_as_MySQLdb() ","date":"2019-01-21","objectID":"/%E8%AE%B0django2.x%E9%85%8D%E7%BD%AEmysql/:2:2","tags":["pymsql","Django2.x"],"title":"Django2.x配置mysql","uri":"/%E8%AE%B0django2.x%E9%85%8D%E7%BD%AEmysql/"},{"categories":["Django杂项"],"content":"修改源码中的问题 由于在python3中不在使用mysqlclient，所以源码中限制mysqlclient版本这一代码就不适用于现在的环境 文件路径django\\db\\backends\\mysql\\base.py，将版本限制异常给注释掉在文件的第35-36行 # if version \u003c (1, 3, 13): # raise ImproperlyConfigured('mysqlclient 1.3.13 or newer is required; you have %s.' % Database.__version__) 由于python2的str是字节流(类似于bytes类型)需要通过decode转换成unicode类型才能使用，但在python3中str默认unicode类型不需要转换且没有decode解码所以要将这里的代码修改。在最新的Django源码中已经将这里修改了(可以通过Django官网或github查看)，在最新的源码中使用django.utils.encoding中force_str方法解决了该问题，force_str方法实际上是force_text方法，force_text方法通过判断传入参数的类型后将类型转为unicode类型的str之后返回 \\django\\utils\\encoding.py ······ def force_text(s, encoding='utf-8', strings_only=False, errors='strict'): \"\"\" Similar to smart_text, except that lazy instances are resolved to strings, rather than kept as lazy objects. If strings_only is True, don't convert (some) non-string-like objects. \"\"\" # Handle the common case first for performance reasons. if issubclass(type(s), str): return s if strings_only and is_protected_type(s): return s try: if isinstance(s, bytes): s = str(s, encoding, errors) else: s = str(s) except UnicodeDecodeError as e: raise DjangoUnicodeDecodeError(s, *e.args) return s 最后修改\\django\\db\\backends\\mysql\\operations.py文件中的last_executed_query方法（记得导入force_str） from django.utils.encoding import force_str ··· def last_executed_query(self, cursor, sql, params): # With MySQLdb, cursor objects have an (undocumented) \"_executed\" # attribute where the exact query sent to the database is saved. # See MySQLdb/cursors.py in the source distribution. # MySQLdb returns string, PyMySQL bytes. return force_str(getattr(cursor, '_executed', None), errors='replace') ","date":"2019-01-21","objectID":"/%E8%AE%B0django2.x%E9%85%8D%E7%BD%AEmysql/:2:3","tags":["pymsql","Django2.x"],"title":"Django2.x配置mysql","uri":"/%E8%AE%B0django2.x%E9%85%8D%E7%BD%AEmysql/"},{"categories":["Python"],"content":"Python时间合集","date":"2019-01-17","objectID":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/","tags":["时间"],"title":"Python时间合集","uri":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/"},{"categories":["Python"],"content":"声明：以下内容均为我个人的理解，如果发现错误或者疑问可以联系我共同探讨 ","date":"2019-01-17","objectID":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/:0:0","tags":["时间"],"title":"Python时间合集","uri":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/"},{"categories":["Python"],"content":"python3中时间的表示形式 ","date":"2019-01-17","objectID":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/:1:0","tags":["时间"],"title":"Python时间合集","uri":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/"},{"categories":["Python"],"content":"格式化时间字符串 格式化时间字符串（string_time）,指格式化输出指定输出参数的格式与相对位置的字符串参数，与python中的format作用类似，常见的格式化时间字符串：\"%Y-%m-%d %H:%M:%S %z,%a,%A,%b,%B,%c,%I,%p” 常用的表 名 称 含 义 例 子 %Y 有世纪并用0填充的十进制数年份 0001, 0002, …, 2013, 2014, …, 9998, 9999 %m 用零填充十进制数的月份 01, 02, …, 12 %d 用零填充十进制数的月中的某一天 01, 02, …, 31 %H 24小时格式的用0填充的十进制数小时 00, 01, …, 23 %M 用0填充的十进制数分钟 00, 01, …, 59 %S 用0填充的十进制数秒 00, 01, …, 59 %z 用零填充的十进制小时分钟秒毫秒的时差 (empty), +0000, -0400, +1030, +063415, -030712.345216 %a 根据区域设置的缩写的星期名称 Sun, Mon, …, Sat (en_US) So, Mo, …, Sa (de_DE) %A 根据区域设置的完整星期名称 Sunday, Monday, …, Saturday (en_US) Sonntag, Montag, …, Samstag (de_DE) 吐槽一下官网注释秒的范围是0-59，实测0-61都可以 官方的完整表： 以下是C标准（1989版）所需的所有格式代码的列表，这些代码适用于具有标准C实现的所有平台。请注意，1999版C标准添加了其他格式代码。 名 称 含 义 例 子 %a 根据区域设置的缩写的星期名称 Sun, Mon, …, Sat (en_US)So, Mo, …, Sa (de_DE) %A 根据区域设置的完整星期名称 Sunday, Monday, …, Saturday (en_US)Sonntag, Montag, …, Samstag (de_DE) %w 将工作日变成十进制数，其中0表示星期日，6表示星期六 0, 1, …, 6 %d 用零填充十进制数的月中的某一天 01, 02, …, 31 %b 根据区域设置的缩写月份名 Jan, Feb, …, Dec (en_US);Jan, Feb, …, Dez (de_DE) %B 根据区域改变月份全称 January, February, …, December (en_US)Januar, Februar, …, Dezember (de_DE) %m 用零填充十进制数的月份 01, 02, …, 12 %y 没有世纪并用0填充的十进制数年份 00, 01, …, 99 %Y 有世纪并用0填充的十进制数年份 0001, 0002, …, 2013, 2014, …, 9998, 9999 ","date":"2019-01-17","objectID":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/:1:1","tags":["时间"],"title":"Python时间合集","uri":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/"},{"categories":["Python"],"content":"时间戳 时间戳（Timestamp）,指字符串或编码信息用于辨识记录下来的时间日期，维基百科解释的不容易懂，我的个人理解是从1970年1月1日到现在过去了多少秒。 ","date":"2019-01-17","objectID":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/:1:2","tags":["时间"],"title":"Python时间合集","uri":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/"},{"categories":["Python"],"content":"时间元祖 时间元祖(struct_time),指包含9个特殊元素的元祖，（tm_year，tm_mon，tm_mday，tm_hour，tm_min，tm_sec，tm_wday，tm_yday，tm_isdst），详情见下表格 名 称 含 义 值 tm_year 年 具体年份，例：2017 tm_mon 月 1-12 tm_mday 日 1-31 tm_hour 时 1-23 tm_min 分 0-59 tm_sec 秒 0-61 tm_wday 周 0-6（从周末开始） tm_yday 在一年中的第几天 1-666 tm_isdst 是否为夏令时 -1,0,1（能表示true和flase的值） ","date":"2019-01-17","objectID":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/:1:3","tags":["时间"],"title":"Python时间合集","uri":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/"},{"categories":["Python"],"content":"时间对象 时间对象（time_object）,指通过某些时间类生成的对象，例如datetime对象。 ","date":"2019-01-17","objectID":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/:1:4","tags":["时间"],"title":"Python时间合集","uri":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/"},{"categories":["Python"],"content":"python中两大时间库： ","date":"2019-01-17","objectID":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/:2:0","tags":["时间"],"title":"Python时间合集","uri":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/"},{"categories":["Python"],"content":"time 简介： 常用于具体时间操作 常量 Variables with simple values，值简单的变量 altzone，-32400 daylight，0 timezone，-28800 _STRUCT_TM_ITEMS，11 variables with complex values，值复杂的变量 tzname 但是如果直接调用会得到一个乱码的值，看不懂，查阅资料后发现通过重新编码解码可以看到真实值，这里很感谢这个爱思考的博主，这里编码解码参考他的博客，这条博文在这里：https://www.cnblogs.com/luo630/p/9555684.html，里面讲的很详细 \u003e\u003e\u003e time.tzname[0].encode('latin-1').decode('gbk') '中国标准时间' \u003e\u003e\u003e time.tzname[1].encode('latin-1').decode('gbk') '中国夏令时' 方法： asctime：将时间元组转换为字符串，当没有传入参数时，调用localtime()返回的当前时间，参数类型：元祖，返回类型：字符串。例如： \u003e\u003e\u003e import time \u003e\u003e\u003e time.asctime() 'Tue Jun 11 16:07:40 2017' \u003e\u003e\u003e time.asctime((2017,6,11,16,7,40,59,59,59)) # 这里必须要穿一个包含9个数字的元组，且年月日时分都必须符合时间逻辑，秒必须小于等于61，不知道为什么是61，后面三位逻辑暂时还没弄明白，但是跟前面对应的年月日有关 'Thu Jun 11 16:07:40 2017' clock：计时器函数，在进程结束后返回从开始到第一次调用该函数使用的时间，返回类型：浮点数。例如： \u003e\u003e\u003e time.clock() 5e-07 \u003e\u003e\u003e time.sleep(1) \u003e\u003e\u003e time.clock() 11.9833418 \u003e\u003e\u003e time.sleep(10) \u003e\u003e\u003e time.clock() 35.1999596 ctime：将时间戳转换为以本地时间为单位的字符串。相当于asctime(localtime(seconds))。当没有传入参数时，使用localtime()返回的当前时间。参数类型：时间戳，返回类型：字符串。例如： \u003e\u003e\u003e time.ctime(1555555550) 'Thu Apr 18 10:45:50 2017' \u003e\u003e\u003e time.ctime() 'Tue Jun 11 17:08:44 2017' get_clock_info：获取有关指定时钟的信息作为命名空间对象。支持的时钟名称和读取其值的相应函数是： ‘clock’： time.clock() ‘monotonic’： time.monotonic() ‘perf_counter’： time.perf_counter() ‘process_time’： time.process_time() ‘thread_time’： time.thread_time() ‘time’： time.time() 结果具有以下属性： adjustable：True如果时钟可以自动更改（例如通过NTP守护程序）或由系统管理员手动更改，False否则 implementation：用于获取时钟值的基础C函数的名称。有关可能的值，请参阅时钟ID常量。 单调：True如果时钟不能倒退， False否则分辨率：时钟的分辨率（秒）（float） gmtime：将时间戳转换为时间元祖，当没有传入参数时，返回当前世界标准时间的时间元祖。参数类型：时间戳，返回类型：元祖（但是查看源码只有一个pass）。例如： \u003e\u003e\u003e time.gmtime(1555555550) time.struct_time(tm_year=2017, tm_mon=4, tm_mday=18, tm_hour=2, tm_min=45, tm_sec=50, tm_wday=3, tm_yday=108, tm_isdst=0) \u003e\u003e\u003e time.gmtime() time.struct_time(tm_year=2017, tm_mon=6, tm_mday=11, tm_hour=9, tm_min=18, tm_sec=54, tm_wday=1, tm_yday=162, tm_isdst=0) localtime：与gmtime功能类似，但是返回的时间变成了当地时间。例如： \u003e\u003e\u003e time.localtime(1555555550) time.struct_time(tm_year=2017, tm_mon=4, tm_mday=18, tm_hour=10, tm_min=45, tm_sec=50, tm_wday=3, tm_yday=108, tm_isdst=0) \u003e\u003e\u003e time.localtime() time.struct_time(tm_year=2017, tm_mon=6, tm_mday=11, tm_hour=17, tm_min=28, tm_sec=34, tm_wday=1, tm_yday=162, tm_isdst=0) mktime：将时间元祖转化为时间戳，返回时间戳。参数类型：时间元祖（9个元素），返回类型：时间戳。例如： \u003e\u003e\u003e time.mktime((2017,4,18,10,45,50,3,108,0)) 1555555550.0 monotonic: 一个单调的计时器，不能倒转。不知道从什么时候开始的，返回类型：浮点型。例如： \u003e\u003e\u003e def func(): ... print(time.monotonic()) ... time.sleep(1) ... \u003e\u003e\u003e i = 0 \u003e\u003e\u003e while i\u003c5: ... func() ... i+=1 ... 461875.89 461876.89 461877.89 461878.89 461879.89 perf_counter：性能计数器用于基准测试。不服跑个分！返回类型：浮点型。例如： \u003e\u003e\u003e time.perf_counter() 3674.2299851 \u003e\u003e\u003e time.perf_counter() 3675.2086447 \u003e\u003e\u003e time.perf_counter() 3675.9990329 process_time：用于分析的进程时间:内核和用户空间CPU时间的总和。返回类型：浮点型。例如： \u003e\u003e\u003e time.process_time() 4.40625 sleep:将执行延迟数秒。参数类型：int or float ,返回类型：无，这就不演示了…浪费时间 strftime：根据格式规范将时间元组转换为字符串。有关格式化代码，请参阅库参考手册。当没有传入参数时，使用localtime()返回的当前时间。传入参数：配对字符串,时间元祖（与字符串配对），返回参数：时间字符串,例： # 根据前面的格式化字符串来生成对应时间字符串 \u003e\u003e\u003e time.strftime(\"%Y-%m-%d%H:%M:%S\", (2017, 1, 1, 1, 1, 1, 1, 13, 0)) '2017-01-01 01:01:01' \u003e\u003e\u003e time.strftime(\"%Y-%m-%d%H:%M:%S %I\", (2017, 1, 1, 1, 1, 1, 1, 13, 0)) '2017-01-01 01:01:01 01' \u003e\u003e\u003e time.strftime(\"%Y-%m-%d%H:%M:%S %z,%a,%A,%b,%B,%c,%I,%p\", (2017, 1, 1, 1, 1, 1, 1, 13, 0)) '2017-01-01 01:01:01 +0800,Tue,Tuesday,Jan,January,Tue Jan 1 01:01:01 2017,01,AM' strptime：根据格式规范将字符串解析为时间元组。有关格式化代码，请参阅库参考手册(与strftime ())。传入参数：时间字符串，配对字符串。返回参数：时间元祖 例： python \u003e\u003e\u003e time.strptime(\"2017-01-01 01:01:02\", \"%Y-%m-%d %H:%M:%S\") time.struct_time(tm_year=2017, tm_mon=1, tm_mday=1, tm_hour=1, tm_min=1, tm_sec=2, tm_wday=1, tm_yday=1, tm_isdst=-1) time：以秒为单位返回从纪元开始的当前时间。如果系统时钟提供这些信息，那么可能只存在几分之一秒。就是我们常说的时间戳。返回参数：浮点数 ","date":"2019-01-17","objectID":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/:2:1","tags":["时间"],"title":"Python时间合集","uri":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/"},{"categories":["Python"],"content":"datetime 由五个模块组成 date： 简介 表示日期的类。常用的属性有year, month, day。 常量 date.min = date(1, 1, 1)，date.max = date(9999, 12, 31)，date.resolution = timedelta(days=1)，分别规定了date对象的最小值、最大值，date对象的最小单位，为天 类方法 fromtimestamp：将时间戳转化为date对象，参数类型：float，int，返回类型：date对象 \u003e\u003e\u003e from datetime import date \u003e\u003e\u003e date.fromtimestamp(1560415206) datetime.date(2017, 6, 13) \u003e\u003e\u003e type(date.fromtimestamp(1560415206)) \u003cclass 'datetime.date'\u003e today：获得今天的日期，返回类型：date对象 \u003e\u003e\u003e date.today() datetime.date(2017, 6, 13) \u003e\u003e\u003e type(date.today()) \u003cclass 'datetime.date'\u003e fromordinal：跟fromtimestamp类似 \u003e\u003e\u003e date.fromtimestamp(1560415206) datetime.date(2017, 6, 13) \u003e\u003e\u003e type(date.fromtimestamp(1560415206)) \u003cclass 'datetime.date'\u003e 实例方法 ctime：返回将日期对象转化为标准时间日期的 00:00:00 \u003e\u003e\u003e date(2017,6,13).ctime() 'Thu Jun 13 00:00:00 2017' strftime，返回将date对象转化为指定格式的date对象 \u003e\u003e\u003e d = date(2017,1,1) \u003e\u003e\u003e d.strftime(\"%d/%m/%y\") '01/01/17' \u003e\u003e\u003e type(d) \u003cclass 'datetime.date'\u003e isoformat,返回将date对象转化为’YYYY-MM-DD’格式的date对象, \u003e\u003e\u003e d = date(2017,2,2) \u003e\u003e\u003e d.isoformat() '2017-02-02' \u003e\u003e\u003e type(d) \u003cclass 'datetime.date'\u003e timetuple,返回与time.localtime()兼容的本地时间元组 \u003e\u003e\u003e date(2017,7,7).timetuple() time.struct_time(tm_year=2017, tm_mon=7, tm_mday=7, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=4, tm_yday=188, tm_isdst=-1) toordinal,按年、月、日返回子午线格列高利教序数。返回类型：int \u003e\u003e\u003e d = date(2017,7,7).toordinal() \u003e\u003e\u003e type(d) \u003cclass 'int'\u003e replace,根据传入的年月日修改date对象的年月日,参数类型：int,返回类型:date对象 \u003e\u003e\u003e d = date(2017,7,7) \u003e\u003e\u003e d.replace(month=8,day=8) datetime.date(2017, 8, 8) weekday,根据date对象，判断该日期为星期几,返回类型：int,0-6分别对应星期一到星期天 \u003e\u003e\u003e d = date(2017,6,12) \u003e\u003e\u003e a = d.weekday() 0 \u003e\u003e\u003e type(a) \u003cclass 'int'\u003e isoweekday，根据date对象，判断该日期为星期几,返回类型：int,1-7分别对应星期一到星期天 \u003e\u003e\u003e d = date(2017,6,12) \u003e\u003e\u003e a = d.isoweekday() 1 \u003e\u003e\u003e type(a) \u003cclass 'int'\u003e isocalendar,根据date对象，判断该日期为第几周的星期几，返回类型：包含年，第几周，星期几的元祖 \u003e\u003e\u003e d = date(2017,6,12) \u003e\u003e\u003e d.isocalendar() (2017, 24, 1) \u003e\u003e\u003e d = date(2017,7,12) \u003e\u003e\u003e d.isocalendar() (2017, 28, 3) 魔法属性 year,month,day：返回年、月、日 \u003e\u003e\u003e d = date(2017,6,13) \u003e\u003e\u003e d.year 2017 \u003e\u003e\u003e d.month 6 \u003e\u003e\u003e d.day 13 time 简介 表示时间的类。常用的属性有hour, minute, second, microsecond。 参数 hour=0, minute=0, second=0, microsecond=0, tzinfo=None, fold=0， hour，minute，小时和分钟必须传入，小时为0-23，分钟为0-59 second，microsecond，秒和毫秒，默认为0，可以不传，秒为0-59，毫秒为0-999999 tzinfo，时区默认为None,可以填你想要的时区 fold，在[0,1]。用于消除重复间隔期间的墙壁时间的歧义。(当时钟在夏令时结束时回滚，或由于政治原因降低当前区域的UTC偏移量时，会出现重复间隔。)值0(1)表示具有相同壁面时间表示的两个时刻中较早(较晚)的时刻。 常量 time.min，最早可表示的时间，时间(0,0,0,0)。 time.max，最新可表示时间，时间(23,59,59,999999)。 time.resolution在不相等的时间对象之间可能存在的最小差异是时间增量(微秒=1)，不过请注意，不支持对时间对象进行算术。 魔法属性 hour、minute、second、microsecond、tzinfo、fold分别返回时、分、秒、毫秒、时区与折叠关键字 \u003e\u003e\u003e from datetime import time \u003e\u003e\u003e t = time(9,9) \u003e\u003e\u003e t.hour 9 \u003e\u003e\u003e t.minute 9 \u003e\u003e\u003e t.second 0 \u003e\u003e\u003e t.microsecond 0 \u003e\u003e\u003e t.tzinfo \u003e\u003e\u003e t.fold 0 实例方法 isoformat，返回按ISO格式格式化的时间字符串。完整的格式是’HH:MM:SS.mmmmmm+zz:zz’可选参数：timespec，指定附加的数量所包括的时间条款 \u003e\u003e\u003e t = time(8,8) \u003e\u003e\u003e a = t.isoformat() \u003e\u003e\u003e a '08:08:00' \u003e\u003e\u003e type(a) \u003cclass 'str'\u003e strftime，返回一个表示时间的字符串，由显式格式字符串控制。参数 datetime.time(9, 9) \u003e\u003e\u003e t = time(9,9) \u003e\u003e\u003e t datetime.time(9, 9) \u003e\u003e\u003e t.strftime(\"%H/%H/%S\") '09/09/00' replace,返回根据关键字替换datetime.time对象中的值,参数：hour, minute, second, microsecond, tzinfo,fold \u003e\u003e\u003e time(9,9).replace(8,8) datetime.time(8, 8) utcoffset,根据utc返回以东的时区偏移（可以理解为时差），以分钟为单位，如果没有设置tzinfo则返回none。 \u003e\u003e\u003e class UTC(tzinfo): ... def __init__(self,offset = 0): ... self._offset = offset ... def utcoffset(self,dt): ... return timedelta(hours=self._offset) ... def tzname(self,dt): ... return \"UTC +%s\" % self._offset ... def dst(self, dt): ... return timedelta(hours=self._offset) ... \u003e\u003e\u003e time(9,9).utcoffset() \u003e\u003e\u003e \u003e\u003e\u003e time(9,9,tzinfo=UTC(8)).utcoffset() datetime.timedelta(0, 28800) tzname,返回时区的名字 \u003e\u003e\u003e time(9,9,tzinfo=UTC(8)).tzname() 'UTC +8' dst,返回dst偏移信息，如果没有则返回none \u003e\u003e\u003e time(9,9,tzinfo=UTC(8)).dst() datetime.timedelta(0, 28800) \u003e\u003e\u003e time(9,9).dst() \u003e\u003e\u003e datetime 简介 表示日期+时间 参数 year, month, day, hour=0, minute=0, second=0, microsecond=0, tzinfo=None, fold=0，年，月，日参数是必需的。 tzinfo可以是None，或者是tzinfo子类的实例。其余参数可以是整数，在以下范围内： MINYEAR \u003c= year \u003c= MAXYEAR， 1 \u003c= month \u003c= 12， 1 \u003c= day \u003c= number of days in the given month and year， 0 \u003c= ho","date":"2019-01-17","objectID":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/:2:2","tags":["时间"],"title":"Python时间合集","uri":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/"},{"categories":["Python"],"content":"Python搭建虚拟环境","date":"2019-01-13","objectID":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/","tags":["虚拟环境"],"title":"Python搭建虚拟环境","uri":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"},{"categories":["Python"],"content":"声明：以下内容均为我个人的理解，如果发现错误或者疑问可以联系我共同探讨 ","date":"2019-01-13","objectID":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/:0:0","tags":["虚拟环境"],"title":"Python搭建虚拟环境","uri":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"},{"categories":["Python"],"content":"为什么要搭建虚拟环境。 平时开发的过程中会遇到不同的项目，往往不同的项目之间需要的第三方包会有所差异，如果我们都在系统的python环境中会导致遇到很多问题，通过虚拟环境搭建一套独立的python运行环境，可以让项目之间互不干扰。 ","date":"2019-01-13","objectID":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/:1:0","tags":["虚拟环境"],"title":"Python搭建虚拟环境","uri":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"},{"categories":["Python"],"content":"如何搭建 一般我们搭建虚拟环境都会用上virtualenv，它是一个可以创建并管理python虚拟环境的第三方包。 ","date":"2019-01-13","objectID":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/:2:0","tags":["虚拟环境"],"title":"Python搭建虚拟环境","uri":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"},{"categories":["Python"],"content":"安装 不论是windows还是linux还是mac都可以直接通过pip 安装，需要注意的是系统中存在两个python的时候，注意pip的版本，选择对应的版本安装 pip install virtualenv ","date":"2019-01-13","objectID":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/:2:1","tags":["虚拟环境"],"title":"Python搭建虚拟环境","uri":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"},{"categories":["Python"],"content":"创建虚拟环境 我们通常会创建一个文件夹为env(当然你也可以去任何你喜欢的名字)，专门用来存放不同的虚拟环境 进入到env文件夹中通过命令创建一个虚拟环境，名为first_env virtualenv first_env 相关参数说明 -p:选择要使用的Python解释器，默认为安装virtualenv的解释器 –prompt=xx:将xx设置为虚拟环境的提示前缀 ","date":"2019-01-13","objectID":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/:2:2","tags":["虚拟环境"],"title":"Python搭建虚拟环境","uri":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"},{"categories":["Python"],"content":"使用虚拟环境 Windows 进入虚拟环境的Scripts目录 在此处打开命令行工具 输入activate，当命令提示符多了一个虚拟环境名字的前缀时即激活成功 Linux or Mac 通过source激活使用，当命令提示符多了一个虚拟环境名字的前缀时即激活成功 source first_env/bin/activate ","date":"2019-01-13","objectID":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/:2:3","tags":["虚拟环境"],"title":"Python搭建虚拟环境","uri":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"},{"categories":["Python"],"content":"退出虚拟环境 在当前虚拟环境中输入deactivate，当命令提示符虚拟环境名字的前缀消失时即退出 ","date":"2019-01-13","objectID":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/:2:4","tags":["虚拟环境"],"title":"Python搭建虚拟环境","uri":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"},{"categories":["Python"],"content":"删除虚拟环境 在我们不需要这个虚拟环境的时候只需要将该虚拟环境的整个包删除即可 ","date":"2019-01-13","objectID":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/:2:5","tags":["虚拟环境"],"title":"Python搭建虚拟环境","uri":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"},{"categories":["Python"],"content":"Python2与Python3的区别","date":"2019-01-09","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"声明：以下内容均为我个人的理解，如果发现错误或者疑问可以联系我共同探讨 ","date":"2019-01-09","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:0:0","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"简介 目前用Python开发的项目有两个Python版本，分别是Python2.x与Python3.x，由于Python3相对于python2有着较大的升级，所以Python3将会是现在与未来的主流版本。 ","date":"2019-01-09","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:1:0","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"Python3时间轴 Python3.0发布于2008.12.3 Python3.1发布于2009.6.27 Python3.2发布于2011.2.20 Python 3.3 发布于 2012.9.29 Python 3.4 发布于 2014.3.16 Python 3.5 发布于 2015.9.13 Python 3.6 发布于 2016.12.23 为了不带入过多的累赘，在Python3.0设计的时候没有考虑向下兼容，所以早期的项目都无法在Python3.0上正常运行。为了早期的项目可以逐步迁移到Python3.0，Python官方提供了Python2.6过度版本（基于Python2的语法与库，允许使用部分Python3的语法和函数），2010年中推出Python2.7为最后一个Python2.x版本。了解Python3版本的变化对我们日常开发与项目维护都十分重要 ","date":"2019-01-09","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:1:1","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"Python3.0后的变化 ","date":"2019-01-09","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:0","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"解释器名称 Python2.x的解释器为python，Python3.x的解释器为python3 其他语言实现的解释器： PyPy Python实现的Python解释器，支持 JIT 即时编译 cpython C语言基于官方版本实现的Python解释器 Jython 运行在Java上的Python解释器 IronPython 运行在.NET与Mono平台的Python解释器 ","date":"2019-01-09","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:1","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"字符串 Python2中字符串是基于ASCII编码的str字符串，当调用字符串变量时会打印其bytes值（16进制表示的字符串内存地址）。 而unicode是一个单独的类型。 Python3中字符串原生支持unicode，byte也变成了一个单独的字节类，并且Python3源码文件默认使用utf-8编码所以中文也可以做变量名。 ","date":"2019-01-09","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:2","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"import Python2中import导包采用相对路径，导致标准库导入变困难。 Python3中import导包采用绝对路径 ","date":"2019-01-09","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:3","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"print Python2中的print是一种特殊的语句，在Python3中print变成了print函数 ","date":"2019-01-09","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:4","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"range函数与xrange函数 xrange函数在Python3中被废弃，range函数的机制进行修改实现了xrange函数返回可迭代对象的效果 ","date":"2019-01-09","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:5","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"老式类与新式类 Python2中存在老式类与新式类，在Python3中统一采用新式类（新式类申明要求继承object），且必须使用新式类应用多重继承 ","date":"2019-01-09","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:6","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"除法与取余 Python2 中若两个整形进行运算，结果为整形，但若其中有一个浮点数类型，则结果为浮点数。python3为真除法，运算结果为float类型。 Python2 中取余返回小于除法运算结果的最大整数，从类型上讲，与”/“运算符返回类型逻辑一致。Python3中与python2作用相同。 ","date":"2019-01-09","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:7","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"raw_input函数与input函数 raw_input函数在Python3中被废弃，统一使用input函数 ","date":"2019-01-09","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:8","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"缩进 Python3采用更严格的缩进方式，tab和space不能共存 ","date":"2019-01-09","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:9","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"long long整型被Python3废弃，统一使用int，int具有long的特性 ","date":"2019-01-09","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:10","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"file file函数被废弃，统一使用open函数 ","date":"2019-01-09","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:11","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"不等运算符 Python3废除\u003c\u003e，只有!= ","date":"2019-01-09","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:12","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"方法返回值 Python3 中这些方法再不再返回 list 对象：dictionary 关联的 keys()、values()、items()，zip()，map()，filter()，但是可以通过 list 强行转换 ","date":"2019-01-09","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:13","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"next()函数 迭代器 iterator 的 next()函数被 Python3 废弃，统一使用 next(iterator) ","date":"2019-01-09","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:14","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"exec exec 语句被 python3 废弃，统一使用 exec 函数 ","date":"2019-01-09","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:15","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"has_key 函数 has_key 函数被 Python 废弃，统一使用 in 关键词 ","date":"2019-01-09","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:16","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"round函数 Python2中，round函数返回float类型值。Python3中，round函数返回int类型值。 ","date":"2019-01-09","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:17","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"比较操作符 Python2中任意两个对象都可以比较。Python3中只有同一类型数据的对象才可以进行比较。 ","date":"2019-01-09","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:18","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["系统优化"],"content":"Windows10在此处打开cmd","date":"2019-01-05","objectID":"/windows10%E5%9C%A8%E6%AD%A4%E5%A4%84%E6%89%93%E5%BC%80cmd/","tags":["cmd"],"title":"Windows10在此处打开cmd","uri":"/windows10%E5%9C%A8%E6%AD%A4%E5%A4%84%E6%89%93%E5%BC%80cmd/"},{"categories":["系统优化"],"content":"声明：以下内容均为我个人的理解，如果发现错误或者疑问可以联系我共同探讨 在Windows10中我们经常需要在某个文件夹下打开cmd窗口，虽然可以在地址栏输入cmd打开，但还是比较麻烦，可以修改注册表添加一个右键菜单来解决这个问题。 ","date":"2019-01-05","objectID":"/windows10%E5%9C%A8%E6%AD%A4%E5%A4%84%E6%89%93%E5%BC%80cmd/:0:0","tags":["cmd"],"title":"Windows10在此处打开cmd","uri":"/windows10%E5%9C%A8%E6%AD%A4%E5%A4%84%E6%89%93%E5%BC%80cmd/"},{"categories":["系统优化"],"content":"步骤 新建一个文本文档 将 一下内容复制粘贴到文本文档中 Windows Registry Editor Version 5.00 [-HKEY_CLASSES_ROOT\\Directory\\shell\\runas] [HKEY_CLASSES_ROOT\\Directory\\shell\\runas] @=\"Open cmd here as admin\" \"HasLUAShield\"=\"\" [HKEY_CLASSES_ROOT\\Directory\\shell\\runas\\command] @=\"cmd.exe /s /k pushd \\\"%V\\\"\" [-HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\runas] [HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\runas] @=\"Open cmd here as admin\" \"HasLUAShield\"=\"\" [HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\runas\\command] @=\"cmd.exe /s /k pushd \\\"%V\\\"\" [-HKEY_CLASSES_ROOT\\Drive\\shell\\runas] [HKEY_CLASSES_ROOT\\Drive\\shell\\runas] @=\"Open cmd here as admin\" \"HasLUAShield\"=\"\" [HKEY_CLASSES_ROOT\\Drive\\shell\\runas\\command] @=\"cmd.exe /s /k pushd \\\"%V\\\"\" 另存为xxx.reg文件 双击运行 ","date":"2019-01-05","objectID":"/windows10%E5%9C%A8%E6%AD%A4%E5%A4%84%E6%89%93%E5%BC%80cmd/:0:1","tags":["cmd"],"title":"Windows10在此处打开cmd","uri":"/windows10%E5%9C%A8%E6%AD%A4%E5%A4%84%E6%89%93%E5%BC%80cmd/"}]