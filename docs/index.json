[{"categories":null,"content":"关于 ","date":"2021-03-30","objectID":"/about/:0:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"我 胡亮，湖北武汉人，现住上海市闵行区龙柏新村。一名Python开发工程师，技术栈丰富，平时喜欢自己捣鼓一些有意思的项目。 ","date":"2021-03-30","objectID":"/about/:1:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"博客 此博客用于我自己的技术记载与相关分享 ","date":"2021-03-30","objectID":"/about/:2:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"技能 ","date":"2021-03-30","objectID":"/about/:3:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"熟练 语言：Python、Go 技术栈：Django、Flask、Redis、MySQL、MongoDB、Scrapy、Selenium、Linux ","date":"2021-03-30","objectID":"/about/:3:1","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"了解 语言：Java、JavaScript、 技术栈：Docker、Vue.js、Bootstrap、ECharts、TensorFlow、 ","date":"2021-03-30","objectID":"/about/:3:2","tags":null,"title":"About","uri":"/about/"},{"categories":["Hugo"],"content":"前言 由于最近在学习Golang，在网上查阅相关资料的时候发现了Hugo这个用Go语言编写的静态网站生成器，根据网站的介绍它有着速度快，易用，可配置程度高等特点，而且文章依赖于Markdown生成，非常适合作为博客、文档、个人简历这类型的网站。 ","date":"2020-04-03","objectID":"/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%80%9A%E8%BF%87github/:1:0","tags":["Hugo","博客"],"title":"使用Hugo搭建自己的博客并通过GitHub Pages部署","uri":"/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%80%9A%E8%BF%87github/"},{"categories":["Hugo"],"content":"使用Hugo搭建博客 ","date":"2020-04-03","objectID":"/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%80%9A%E8%BF%87github/:2:0","tags":["Hugo","博客"],"title":"使用Hugo搭建自己的博客并通过GitHub Pages部署","uri":"/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%80%9A%E8%BF%87github/"},{"categories":["Hugo"],"content":"安装 Mac和Linux可以直接用Homebrew安装 brew install hugo Windows在github上下载解压后安装， 注意 Windows安装完毕记得添加环境变量！ 此外Hugo官方还提供了多种安装方式，选择自己喜欢的即可 安装完毕后，可以通过查询Hugo版本验证是否安装成功 hugo version ","date":"2020-04-03","objectID":"/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%80%9A%E8%BF%87github/:2:1","tags":["Hugo","博客"],"title":"使用Hugo搭建自己的博客并通过GitHub Pages部署","uri":"/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%80%9A%E8%BF%87github/"},{"categories":["Hugo"],"content":"创建新站点 hugo new site SilenceBlog 创建成功图片 ","date":"2020-04-03","objectID":"/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%80%9A%E8%BF%87github/:2:2","tags":["Hugo","博客"],"title":"使用Hugo搭建自己的博客并通过GitHub Pages部署","uri":"/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%80%9A%E8%BF%87github/"},{"categories":["Hugo"],"content":"添加并配置主题 Hugo收录的主题非常多，可以在主题库中寻找自己喜欢的 从GitHub下载主题到站点存放主题的目录中： git clone https://github.com/dillonzq/LoveIt.git SilenceBlog/themes/LoveIt 将主题添加到站点的配置文件中： echo theme = \\\"LoveIt\\\" \u003e\u003e config.toml 查看主题官方文档，并根据自己的情况进行配置 信息 LoveIt主题说明、主题文档相关配置介绍 ","date":"2020-04-03","objectID":"/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%80%9A%E8%BF%87github/:2:3","tags":["Hugo","博客"],"title":"使用Hugo搭建自己的博客并通过GitHub Pages部署","uri":"/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%80%9A%E8%BF%87github/"},{"categories":["Hugo"],"content":"添加一篇文章并在本地查看效果 可以在content/posts/下手动创建一个Markdown文件，但是需要我们手动输入所有内容。也可以直接通过new命令来创建文章，创建好的文章已经存在相应的模板内容 hugo new posts/firstpost.md 输入完后会提是我们创建成功和文章所在的位置 接下来可以打开这个文件进行编辑，当我们编辑完毕保存退出后，可以启动Hugo服务器查看效果 hugo server -D 启动后我们可以看到，本次启动的一些信息 在浏览器中打开http://localhost:1313/即可查看效果，并且效果是实时更新的，会随着对站点博客的操作自动更新相应的效果 最后当我们完成博客内容想对博客部署的时候可以通过hugo命令进行建立静态页面 hugo -d 文件路径 提示 默认情况下会保存在./public/目录中 信息 更详细的内容可以查看Hugo官方文档 ","date":"2020-04-03","objectID":"/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%80%9A%E8%BF%87github/:2:4","tags":["Hugo","博客"],"title":"使用Hugo搭建自己的博客并通过GitHub Pages部署","uri":"/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%80%9A%E8%BF%87github/"},{"categories":["Hugo"],"content":"通过GitHub Pages部署 ","date":"2020-04-03","objectID":"/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%80%9A%E8%BF%87github/:3:0","tags":["Hugo","博客"],"title":"使用Hugo搭建自己的博客并通过GitHub Pages部署","uri":"/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%80%9A%E8%BF%87github/"},{"categories":["Hugo"],"content":"什么是GitHub Pages GitHub Pages 是一种静态网站托管服务，它可以直接从 GitHub 上的仓库中获取 HTML、CSS 和 JavaScript 文件，并通过构建过程选择性地运行这些文件，然后发布一个网站。 上面我们通过hugo -D命令正是将站点生成一个静态网站，可以完美配合GitHub Pages进行部署 ","date":"2020-04-03","objectID":"/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%80%9A%E8%BF%87github/:3:1","tags":["Hugo","博客"],"title":"使用Hugo搭建自己的博客并通过GitHub Pages部署","uri":"/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%80%9A%E8%BF%87github/"},{"categories":["Hugo"],"content":"部署方式 1.首先我们要创建一个Github 仓库，仓库名必须是\u003cuser\u003e.github.io的形式，如果是组织则为\u003corganization\u003e.github.io。仓库的可见性必须是Public。 提示 用户名的大小写不会影响GitHub Pages的部署。例如我的仓库为：Silencehuliang/silencehuliang.github.io 2.接下来进入仓库的设置页对GitHub Pages进行配置，找到GitHub Pages所在的位置，按下图配置好分支和站点存放路径即可 3.配置完毕后，把仓库克隆下来，使用hugo -D 路径将站点生成的静态文件存放在配置文件中选择的路径下即可。最后将文件提交上去就可以打开对应域名进行查看了。 ","date":"2020-04-03","objectID":"/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%80%9A%E8%BF%87github/:3:2","tags":["Hugo","博客"],"title":"使用Hugo搭建自己的博客并通过GitHub Pages部署","uri":"/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%80%9A%E8%BF%87github/"},{"categories":["Hugo"],"content":"出现问题的解决方案 当我们将文件提交上去之后打开对应域名发现并没有我们想要的内容时可以通过查看提交记录查看错误原因，点击Deatils可以找到具体位置的具体错误 还可以在GitHub Pages的设置出找到错误原因 信息 更详细的内容可以查看Hugo官方部署文档或GitHub Pages入门教程文档 ","date":"2020-04-03","objectID":"/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%80%9A%E8%BF%87github/:3:3","tags":["Hugo","博客"],"title":"使用Hugo搭建自己的博客并通过GitHub Pages部署","uri":"/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%80%9A%E8%BF%87github/"},{"categories":["Python"],"content":"参数和返回值的作用 函数根据有没有参数以及有没有返回值，可以相互组合，一共有4 种组合形式：无参数，无返回值；无参数，有返回值；有参数，无返回值；有参数，有返回值。 提示 定义函数时，是否接收参数，或者是否返回结果，是根据实际的功能需求来决定的！如果函数内部处理的数据不确定，就可以将外界的数据以参数传递到函数内部。如果希望一个函数执行完成后，向外界汇报执行结果，就可以增加函数的返回值 ","date":"2019-11-02","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/:1:0","tags":["Python学习之路"],"title":"Python学习之路-函数进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"不可变和可变的参数 无论传递的参数是可变还是不可变只要针对参数使用赋值语句，会在函数内部修改局部变量的引用**，**不会影响到 外部变量的引用。如果传递的参数是可变类型，在函数内部，使用方法修改了数据的内容，同样会影响到外部的数据 ","date":"2019-11-02","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/:2:0","tags":["Python学习之路"],"title":"Python学习之路-函数进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"缺省参数 定义函数时，可以给某个参数指定一个默认值，具有默认值的参数就叫做缺省参数调用函数时，如果没有传入缺省参数的值，则在函数内部使用定义函数时指定的参数默认值。函数的缺省参数，将常见的值设置为参数的缺省值，从而简化函数的调用 提示 缺省参数需要使用最常见的值作为默认值！如果一个参数的值不能确定，则不应该设置默认值，具体的数值在调用函数时，由外界传递！ ","date":"2019-11-02","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/:3:0","tags":["Python学习之路"],"title":"Python学习之路-函数进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"缺省参数的注意事项 缺省参数的定义位置 必须保证带有默认值的缺省参数在参数列表末尾 调用带有多个缺省参数的函数 在调用函数时，如果有多个缺省参数，需要指定参数名，这样解释器才能够知道参数的对应关系！ ","date":"2019-11-02","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/:3:1","tags":["Python学习之路"],"title":"Python学习之路-函数进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"多值参数 定义支持多值参数的函数，有时可能需要一个函数能够处理的参数个数是不确定的，这个时候就可以使用多值参数。python中有两种多值参数： 参数名前增加 一个 * 可以接收元组 参数名前增加 两个* 可以接收字典 一般在给多值参数命名时，习惯使用以下两个名字: *args —— 存放 元组 参数，前面有一个 * **kwargs —— 存放 字典 参数，前面有两个 * 提示 args是arguments的缩写，有变量的含义，kw 是 keyword 的缩写，kwargs 可以记忆键值对参数 元组和字典的拆包 在调用带有多值参数的函数时，如果希望：将一个元组变量，直接传递给 args将一个 字典变量，直接传递给 kwargs就可以使用拆包，简化参数的传递，拆包的方式是：在元组变量前，增加一个*在字典变量前，增加两个 *。 ","date":"2019-11-02","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/:4:0","tags":["Python学习之路"],"title":"Python学习之路-函数进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"递归 ","date":"2019-11-02","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/:5:0","tags":["Python学习之路"],"title":"Python学习之路-函数进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"简介 函数调用自身的编程技巧称为递归 ","date":"2019-11-02","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/:5:1","tags":["Python学习之路"],"title":"Python学习之路-函数进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"特点 一个函数内部调用自己。函数内部可以调用其他函数，当然在函数内部也可以调用自己 ","date":"2019-11-02","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/:5:2","tags":["Python学习之路"],"title":"Python学习之路-函数进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"代码特点 函数内部的代码是相同的，只是针对参数不同，处理的结果不同 当参数满足一个条件时，函数不再执行 警告 这个非常重要，通常被称为递归的出口，否则会出现死循环！ 提示 初次接触递归会感觉有些吃力！在处理不确定的循环条件时，格外的有用，例如：遍历整个文件目录的结构 ","date":"2019-11-02","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/:5:3","tags":["Python学习之路"],"title":"Python学习之路-函数进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"定义 所谓函数就是把具有独立功能的代码块组织为一个小的模块，在需要的时候可以直接调用 ","date":"2019-10-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/:1:0","tags":["Python学习之路"],"title":"Python学习之路-函数基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/"},{"categories":["Python"],"content":"作用 在开发程序时，函数可以提高编写的效率以及代码的重用。 ","date":"2019-10-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/:2:0","tags":["Python学习之路"],"title":"Python学习之路-函数基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/"},{"categories":["Python"],"content":"基本使用 ","date":"2019-10-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/:3:0","tags":["Python学习之路"],"title":"Python学习之路-函数基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/"},{"categories":["Python"],"content":"步骤 使用函数有两个步骤： 定义函数：封装独立功能的代码块 def 函数名(): 函数封装的代码 …… def为英文define的缩写，即定义的意思 函数名称应该能表达函数封装代码的功能，方便后续理解调用 函数名称的命名应该符合标识符的命名规则 调用函数：使用封装好的成功 通过 函数名() 即可完成对函数的调用 ","date":"2019-10-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/:3:1","tags":["Python学习之路"],"title":"Python学习之路-函数基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/"},{"categories":["Python"],"content":"参数 ","date":"2019-10-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/:4:0","tags":["Python学习之路"],"title":"Python学习之路-函数基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/"},{"categories":["Python"],"content":"作用 函数的参数，增加函数的通用性，针对相同的数据处理逻辑，能够适应更多的数据。在函数内部，把参数当做变量使用，进行需要的数据处理。函数调用时，按照函数定义的参数顺序，把希望在函数内部处理的数据，通过参数传递 ","date":"2019-10-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/:4:1","tags":["Python学习之路"],"title":"Python学习之路-函数基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/"},{"categories":["Python"],"content":"形参和实参 形参：定义函数时，小括号中的参数，是用来接收参数用的，在函数内部作为变量使用 实参：调用函数时，小括号中的参数，是用来把数据传递到函数内部用的 ","date":"2019-10-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/:4:2","tags":["Python学习之路"],"title":"Python学习之路-函数基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/"},{"categories":["Python"],"content":"返回值 在程序开发中，有时候，会希望一个函数执行结束后，告诉调用者一个结果，以便调用者针对具体的结果做后续的处理。返回值是函数完成工作后，最后给调用者的一个结果。在函数中使用return关键字可以返回结果，调用函数一方，可以使用变量来接收函数的返回结果。 注意 return 表示返回，后续的代码都不会被执行 ","date":"2019-10-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/:5:0","tags":["Python学习之路"],"title":"Python学习之路-函数基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/"},{"categories":["Python"],"content":"嵌套调用 一个函数里面又调用了另外一个函数，这就是函数嵌套调用。如果函数中，调用了另外一个函数那么执行到调用 外层函数时，会先把被嵌套函数中的任务都执行完才会执行后续的代码 ","date":"2019-10-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/:6:0","tags":["Python学习之路"],"title":"Python学习之路-函数基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/"},{"categories":["Python"],"content":"模块中的函数 模块是 Python 程序架构的一个核心概念。模块就好比是工具包，要想使用这个工具包中的工具，就需要导入 import这个模块。每一个以扩展名 py 结尾的 Python 源代码文件都是一个模块。在模块中定义的全局变量、函数都是模块能够提供给外界直接使用的工具 注意 模块名也是一个标识符 ","date":"2019-10-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/:7:0","tags":["Python学习之路"],"title":"Python学习之路-函数基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/"},{"categories":["Python"],"content":"Pyc 文件 ","date":"2019-10-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/:8:0","tags":["Python学习之路"],"title":"Python学习之路-函数基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/"},{"categories":["Python"],"content":"简介 C 是 compiled 编译过 的意思。浏览程序目录会发现一个__pycache__的目录，目录下会有一个 xx.cpython-37.pyc 文件，cpython-37 表示 Python 解释器的版本.这个pyc文件是由 Python 解释器将模块的源码转换为字节码 提示 Python 这样保存字节码是作为一种启动速度的优化 ","date":"2019-10-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/:8:1","tags":["Python学习之路"],"title":"Python学习之路-函数基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/"},{"categories":["Python"],"content":"字节码 Python 在解释源程序时是分成两个步骤的 首先处理源代码，编译生成一个二进制字节码 再对字节码进行处理，才会生成 CPU 能够识别的机器码 有了模块的字节码文件之后，下一次运行程序时，如果在上次保存字节码之后没有修改过源代码，Python 将会加载 .pyc 文件并跳过编译这个步骤。当Python重编译时，它会自动检查源文件和字节码文件的时间戳。如果你又修改了源代码，下次程序运行时，字节码将自动重新创建 ","date":"2019-10-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/:8:2","tags":["Python学习之路"],"title":"Python学习之路-函数基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/"},{"categories":["Python"],"content":"程序就是用来处理数据的，而常量和变量就是最简单用来存储数据的 ","date":"2019-10-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/:0:0","tags":["Python学习之路"],"title":"Python学习之路-常量与变量","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/"},{"categories":["Python"],"content":"常量 ","date":"2019-10-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/:1:0","tags":["Python学习之路"],"title":"Python学习之路-常量与变量","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/"},{"categories":["Python"],"content":"定义 声明在文件的顶部 ","date":"2019-10-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/:1:1","tags":["Python学习之路"],"title":"Python学习之路-常量与变量","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/"},{"categories":["Python"],"content":"命名规范 全部大写 单词间用下划线分隔 ","date":"2019-10-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/:1:2","tags":["Python学习之路"],"title":"Python学习之路-常量与变量","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/"},{"categories":["Python"],"content":"变量 ","date":"2019-10-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/:2:0","tags":["Python学习之路"],"title":"Python学习之路-常量与变量","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/"},{"categories":["Python"],"content":"定义 变量在使用前都必须要要进行赋值，只有被赋值后变量才会被创建 ","date":"2019-10-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/:2:1","tags":["Python学习之路"],"title":"Python学习之路-常量与变量","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/"},{"categories":["Python"],"content":"命名规范 一般情况 当变量名需要由二个或多个单词组成时，每个单词都使用小写字母单词与单词之间使用 _下划线连接 驼峰命名法 当变量名是由二个或多个单词组成时，还可以利用驼峰命名法来命名 小驼峰式命名法：第一个单词以小写字母开始，后续单词的首字母大写 大驼峰式命名法：每一个单词的首字母都采用大写字母 注意 变量与常量都属于标识符，需要满足标识符的命名方式。标识符区分大小写。 提示 以上命名规范都不是强制的，命名规范可以更好的满足PEP 8和PEP 20并增加代码的识别和可读性 ","date":"2019-10-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/:2:2","tags":["Python学习之路"],"title":"Python学习之路-常量与变量","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/"},{"categories":["Python"],"content":"类型 在 Python 中定义变量是 不需要指定类型（在其他很多高级语言中都需要） 数据类型可以分为数字型和非数字型 数字型 整型(int) 浮点型float) 布尔型(bool) 真 True 非 0 数 —— 非零即真 假 False 0 复数型(complex) 主要用于科学计算，例如：平面场问题、波动问题、电感电容等问题 非数字型 字符串 列表 元组 字典 ","date":"2019-10-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/:2:3","tags":["Python学习之路"],"title":"Python学习之路-常量与变量","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/"},{"categories":["Python"],"content":"交互 数字型变量之间可以直接计算，bool型True为1，False为0 字符串变量之间使用+拼接字符串 字符串变量可以和整数使用*重复拼接相同的字符串 数字型变量和字符串之间不能进行其他计算 ","date":"2019-10-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/:2:4","tags":["Python学习之路"],"title":"Python学习之路-常量与变量","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/"},{"categories":["Python"],"content":"输入 变量也可以通过键盘输入的信息获取，这时可以使用input函数从键盘等待用户的输入 提示 input函数跟之前使用过的print函数一样都是Python3内置的函数，可以理解为提前准备好的功能，可以直接使用。 语法如下： 字符串变量 = input(\"提示信息：\") 注意 用户输入的任何内容Python 都认为是一个字符串 ","date":"2019-10-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/:2:5","tags":["Python学习之路"],"title":"Python学习之路-常量与变量","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/"},{"categories":["Python"],"content":"类型转换 函数 说明 int(x) 将x转换为整数 float(x) 将x转换为浮点数 str(x) 将x转换为字符串 ","date":"2019-10-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/:2:6","tags":["Python学习之路"],"title":"Python学习之路-常量与变量","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/"},{"categories":["Python"],"content":"格式化输出 想要输出固定字符串的同时一起输出变量的值，可以使用格式化操作符%，%和不同的字符连用可以输出不同类型的数据。 格式化字符 含义 %s 字符串 %d 有符号十进制整数，%06d表示输出的整数显示位数，不足的地方使用 0 补全 %f 浮点数，%.2f 表示小数点后只显示两位 %% 输出 % 提示 包含格式化操作符的字符串称为格式化字符串 ","date":"2019-10-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/:2:7","tags":["Python学习之路"],"title":"Python学习之路-常量与变量","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/"},{"categories":["Python"],"content":"非数字型变量 所有非数字型变量都支持以下特点： 都是一个序列 通过[]取值 通过for in遍历 计算长度、最大/最小值、比较、删除 链接 + 和 重复 * 切片 字符串 定义 字符串就是一串文本字符的数据类型，在 Python 中可以使用一对双引号\"或者一对单引号'定义一个字符串。 提示 当用双引号\"做字符串时内部可以用单引号'定义字符串；当用单引号'做字符串时内部可以用双引号\"定义字符串。 常用操作 判断类型 方法 说明 isspace() 如果 string 中只包含空格，则返回 True isalnum() 如果 string 至少有一个字符并且所有字符都是字母或数字则返回 True isalpha() 如果 string 至少有一个字符并且所有字符都是字母则返回 True isdecimal() 如果 string 只包含十进制数字则返回 True 否则返回 False isdigit() 如果 string 只包含数字则返回 True 否则返回 False isnumeric() 如果 string 中只包含数字字符，则返回 True，否则返回 False istitle() 如果 string 是标题化的(每个单词的首字母大写)则返回 True islower() 如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True isupper() 如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True 查找和替换 方法 说明 startswith(str) 检查字符串是否是以 str 开头，是则返回 True endswith(str) 检查字符串是否是以 str 结束，是则返回 True find(str, start=0, end=len(string)) 检测 str 是否包含在 string 中，如果 start 和 end 指定范围，则检查是否包含在指定范围内，如果是返回开始的索引值，否则返回 -1 rfind(str, start=0, end=len(string)) 类似于 find()，不过是从右边开始查找 index(str, start=0, end=len(string)) 跟 find() 方法类似，不过如果 str 不在 string 会报错 rindex(str, start=0, end=len(string)) 类似于 index()，不过是从右边开始 replace(old_str, new_str, num=string.count(old)) 把 string 中的 old_str 替换成 new_str，如果 num 指定，则替换不超过 num 次 大小写转换 方法 说明 capitalize() 把字符串的第一个字符大写 title() 把字符串的每个单词首字母大写 lower() 转换 string 中所有大写字符为小写 upper() 转换 string 中的小写字母为大写 swapcase() 翻转 string 中的大小写 文本对齐 方法 说明 ljust(width) 返回一个原字符串左对齐，并使用空格填充至长度 width 的新字符串 rjust(width) 返回一个原字符串右对齐，并使用空格填充至长度 width 的新字符串 center(width) 返回一个原字符串居中，并使用空格填充至长度 width 的新字符串 去除空白字符 方法 说明 lstrip() 截掉 string 左边（开始）的空白字符 rstrip() 截掉 string 右边（末尾）的空白字符 strip() 截掉 string 左右两边的空白字符 拆分和连接 方法 说明 partition(str) 把字符串 string 分成一个 3 元素的元组 (str前面, str, str后面) rpartition(str) 类似于 partition() 方法，不过是从右边开始查找 split(str=””, num) 以 str 为分隔符拆分 string，如果 num 有指定值，则仅分隔 num + 1 个子字符串，str 默认包含 ‘\\r’, ‘\\t’, ‘\\n’ 和空格 splitlines() 按照行('\\r’, ‘\\n’, ‘\\r\\n’)分隔，返回一个包含各行作为元素的列表 join(seq) 以 string 作为分隔符，将 seq 中所有的元素（的字符串表示）合并为一个新的字符串 列表 定义 list(列表)是专门用于存储一串信息的对象集合，用[]来定义，数据之间使用,分隔。列表的索引从0开始。 提示 索引就是数据在列表中的位置编号，索引又可以被称为下标。从列表中取值时，如果超出索引范围，程序会报错。 常用操作 增加 列表.insert(索引, 数据)：根据索引位置插入指定数据 列表.append(数据)：在末尾追加数据 列表.extend(list)：将另一个列表合并到当前列表中 修改 通过指定索引进行赋值操作 列表[索引] = 数据 删除 列表.remove[数据]：删除第一个出现的指定数据 列表.pop(索引)：删除指定索引数据并返回该值，不传索引则为删除末尾的数据 列表.clear：清空列表 del 列表[索引]：删除指定索引数据，不写[索引]则为删除整个列表 提示 del关键字可以删除任意变量，在对列表操作时指定索引就删除列表中指定索引的元素不指定索引则直接删除整个列表 统计 len(列表)：计算列表长度 count(数据)：统计数据在列表中出现的次数 排序 列表.sort()：升序排序，传入reverse=True则为降序排列 列表.reverse()：反转列表 元祖 定义 Tuple元祖表示多个元素组成的对象集合。用()来定义，数据之间使用,分隔。元祖的索引从0开始。与列表类似，不同之处在于元素的元素不能修改。 常规操作 统计值出现的次数 元祖.count(值) 返回索引所在的位置 元祖.index(值) 字典 定义 dict(字典)表示存储多个键值对的对象集合。用{}来定义，键与值之间用:分隔，键值对之间使用，分隔。字典的索引为键，键必须是唯一的，且只能使用字符串、数字或元祖。 常规操作 增加 通过对新的键进行赋值 dict['new_key'] = 'value' 修改 通过对存在的键进行修改 dict['key'] = 'value' 删除 dict.clear()：清空字典所有条目 del dict[‘key’]：通过对存在的键进行删除 del dict：删除整个字典 提示 字典是无序的对象集合，字符串、列表、元祖都是有序的对象集合。 字典和列表是可变对象集合，字符串、元祖为不可变对象集合。 内置方法 方法 说明 clear() 删除字典内所有元素 copy() 返回一个字典的浅拷贝 fromkeys(key, value) 创建一个新字典，以序列key中元素做字典的键，value为字典所有键对应的初始值 get(key, default=None) 返回指定键的值，如果值不在字典中返回default值 has_key(key) 如果键在字典dict里返回true，否则返回false items() 以列表返回可遍历的(键, 值) 元组数组 keys() 以列表返回一个字典所有的键 setdefault(key, default=None) 和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default update(dict2) 把字典dict2的键/值对更新到dict里 values() 以列表返回字典中的所有值 pop(key) 删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。 popitem() 返回并删除字典中的最后一对键和值。 公共方法 Python内置函数 函数 描述 备注 len(item) 计算容器中元素个数 del(item) 删除变量 del 有两种方式 max(item) 返回容器中元素最大值 如果是字典，只针对 key 比较 min(item) 返回容器中元素最小值 如果是字典，只针对 key 比较 切片 使用索引值来限定一个范围。列表和元组都是有序的集合，都能够通过索引值获取到对应的数据。字典是一个无序的集合，是使用键值对保存数据。 运算符 运算符 描述 支持的数据类型 + 合并 字符串、列表、元组 * 重复 字符串、列表、元组 in 元素是否存在 字符串、列表、元组、字典 not in 元素是否不存在 字符串、列表、元组、字典 \u003e \u003e= == \u003c \u003c= 元素比较 字符串、列表、元组 注意 in 在对字典操作时，判断的是字典的键。in和not in 被称为成员运算符 for 循环语法 可以通过for进行遍历 语法如下： for 变量 in 集合: 代码块 ","date":"2019-10-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/:2:8","tags":["Python学习之路"],"title":"Python学习之路-常量与变量","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/"},{"categories":["Python"],"content":"深入理解变量 ","date":"2019-10-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/:3:0","tags":["Python学习之路"],"title":"Python学习之路-常量与变量","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/"},{"categories":["Python"],"content":"引用 简介 变量和数据都是保存在内存中的，在Python中函数的参数传递以及返回值都是靠引用传递的 深入理解 在Python中变量和数据是分开存储的。数据保存在内存中的某个位置，变量则保存着数据在内存中的地址。变量中记录数据的地址就是引用，使用id()函数可以查看变量中保存数据所在的内存地址 注意 如果变量已经被定义，当给一个变量赋值的时候，本质上是修改了数据的引用，变量不再对之前的数据引用，变量 改为对新赋值的数据引用 提示 函数的实参/返回值都是是靠引用来传递来的 ","date":"2019-10-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/:3:1","tags":["Python学习之路"],"title":"Python学习之路-常量与变量","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/"},{"categories":["Python"],"content":"可变和不可变类型 不可变类型，内存中的数据不允许被修改：数字类型、字符串 、元组 可变类型，内存中的数据可以被修改：列表、dict 注意 字典的key只能使用不可变类型的数据。 可变类型的数据变化，是通过方法来实现的，如果给一个可变类型的变量，赋值了一个新的数据，引用会修改变量不再对之前的数据引用，改为对新赋值的数据引用 ","date":"2019-10-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/:3:2","tags":["Python学习之路"],"title":"Python学习之路-常量与变量","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/"},{"categories":["Python"],"content":"简介 上一篇讲到Python中的语句提到很多运算符，本篇来总结一下各类运算符的作用与用法。 ","date":"2019-10-12","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%BF%90%E7%AE%97%E7%AC%A6/:1:0","tags":["Python学习之路"],"title":"Python学习之路-运算符","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["Python"],"content":"算数运算符 运算符 描述 实例 + 加 1+1=2 - 减 1-1=0 * 乘 1*1=1 ** 幂次方 2**3=8 / 除 2/1=2 // 取整 5//2=2 % 取余 5%2=1 参考 在 Python 中 * 运算符还可以用于字符串，计算结果就是字符串重复指定次数的结果 ","date":"2019-10-12","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%BF%90%E7%AE%97%E7%AC%A6/:2:0","tags":["Python学习之路"],"title":"Python学习之路-运算符","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["Python"],"content":"比较运算符 运算符 描述 == 比较两个数据的值是否 相等，如果是，则条件成立，返回 True != 比较两个数据的值是否 不相等，如果是，则条件成立，返回 True \u003e 比较左边数的值是否 大于 右边数的值，如果是，则条件成立，返回 True \u003c 比较左边数数的值是否 小于 右边数的值，如果是，则条件成立，返回 True \u003e= 比较左边数的值是否 大于或等于 右边数的值，如果是，则条件成立，返回 True \u003c= 比较左边数数的值是否 小于或等于 右边数的值，如果是，则条件成立，返回 True 参考 Python中所有数据类型都可以用==与!=比较运算符 ","date":"2019-10-12","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%BF%90%E7%AE%97%E7%AC%A6/:3:0","tags":["Python学习之路"],"title":"Python学习之路-运算符","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["Python"],"content":"逻辑运算符 运算符 逻辑表达式 描述 and a and b 只有 a 和 b 的值都为 True，才会返回 True否则只要 a 或者 b 有一个值为 False，就返回 False or a or b 只要 a 或者 b 有一个值为 True，就返回 True只有 a 和 b 的值都为 False，才会返回 False not not a 如果 a 为 True，返回 False如果 a 为 False，返回 True ","date":"2019-10-12","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%BF%90%E7%AE%97%E7%AC%A6/:4:0","tags":["Python学习之路"],"title":"Python学习之路-运算符","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["Python"],"content":"赋值运算符 运算符 描述 实例 = 赋值运算符 c = a + b 将 a + b 的运算结果赋值为 c += 加法赋值运算符 c += a 等效于 c = c + a -= 减法赋值运算符 c -= a 等效于 c = c - a *= 乘法赋值运算符 c *= a 等效于 c = c * a /= 除法赋值运算符 c /= a 等效于 c = c / a //= 取整除赋值运算符 c //= a 等效于 c = c // a %= 取余数赋值运算符 c %= a 等效于 c = c % a **= 幂赋值运算符 c **= a 等效于 c = c** a 注意 赋值运算符中间不能使用空格 ","date":"2019-10-12","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%BF%90%E7%AE%97%E7%AC%A6/:5:0","tags":["Python学习之路"],"title":"Python学习之路-运算符","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["Python"],"content":"成员运算符 运算符 描述 实例 in 如果在指定的序列中找到值返回 True，否则返回 False 3 in (1, 2, 3) 返回 True not in 如果在指定的序列中没有找到值返回 True，否则返回 False 3 not in (1, 2, 3) 返回 False 注意 在对 字典 操作时，判断的是 字典的键 ","date":"2019-10-12","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%BF%90%E7%AE%97%E7%AC%A6/:6:0","tags":["Python学习之路"],"title":"Python学习之路-运算符","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["Python"],"content":"运算符的优先级 以下表格的算数优先级由高到最低顺序排列 运算符 描述 ** 幂 (最高优先级) * / % // 乘、除、取余数、取整除 + - 加法、减法 \u003c= \u003c \u003e \u003e= 比较运算符 == != 等于运算符 = %= /= //= -= += *= **= 赋值运算符 in not in 成员运算符 not or and 逻辑运算符 ","date":"2019-10-12","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%BF%90%E7%AE%97%E7%AC%A6/:7:0","tags":["Python学习之路"],"title":"Python学习之路-运算符","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["Python"],"content":"简介 Python的设计目标之一是让代码具备高度的可阅读性。在设计时尽量使用经常使用的标点符号和英文单字，让代码看起来整洁美观。 ","date":"2019-10-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%AD%E6%B3%95/:1:0","tags":["Python学习之路"],"title":"Python学习之路-语法","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%AD%E6%B3%95/"},{"categories":["Python"],"content":"缩进 在Python中缩进表示语句块的开始和结束，作用等同于Java、Go中的大括号。增加缩进表示语句块的开始，而减少缩进则表示语句块的结束。缩进成为了语法的一部分，违反了“缩进规则”的程序不能通过解释器解释。 提示 根据PEP 8的规定，使用4个空格来表示每级缩进。使用Tab字符和其它数目的空格虽然都可以被解释器识别，但不符合编码规范，偏向使用Tab字符的程序员可以设置文本编辑器将Tab键转换为4个空格。 ","date":"2019-10-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%AD%E6%B3%95/:2:0","tags":["Python学习之路"],"title":"Python学习之路-语法","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%AD%E6%B3%95/"},{"categories":["Python"],"content":"标识符 标识符就是名字。可用于标识符的字符为：大写字母A至Z和小写字母a至z，下划线_以及数字0至9，但不能以数字开头。不能定义关键字标识符。 有关包含下划线的标识符有以下命名约定： 类型 实例 备注 单下划线开头 _abc 私有化属性或方法。通过from M import *将不能导入。 单下划线结尾 acb_ 避免与python关键字的命名冲突。 双下划线开头 __abc 避免与子类中的属性命名冲突，无法在外部直接访问(名字重整所以访问不到) 双下划线开头双下划线结尾 __abc__ 用户名字空间的魔法对象或属性。例如:__name__ , 不要使用这样的方式命名变量或函数。 ","date":"2019-10-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%AD%E6%B3%95/:3:0","tags":["Python学习之路"],"title":"Python学习之路-语法","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%AD%E6%B3%95/"},{"categories":["Python"],"content":"关键字 关键字是保留标识符，不能用作变量名、函数名或任何其他标识符。Python共有35个关键字。 逻辑运算符 and：只有两边的值都为True才会返回True，否则只要两边有一个值为False，就返回False not：如果值为True，返回False。如果值为False，返回True or：只要两边有一个值为True，就返回True。只有两边的值都为False，才会返回False 协程 async：将普通函数和生成器函数包装成异步函数和异步生成器。 await：挂起自身的协程，并等待另一个协程完成直到返回结果(只能出现在通过async修饰的函数中，否则会报SyntaxError错误) 布尔值 False：不成立则为False，等同于0 True：成立则为True，等同于1 循环 break：跳出当前循环 continue：继续循环的下一个迭代 for：创建for循环 while：创建while循环 in：for循环迭代序列或者检查序列中是否存在值 类与函数 class：定义一个类 def：定义一个函数 lambda：创建匿名函数 return：退出函数并返回值 yield：结束函数并返回生成器 条件语句 assert：测试代码中的条件是否返回True，否则程序将引发AssertionError elif：等同于else if else：在条件为False时执行else下的代码块 if：创建条件语句，并且仅当条件为True时，才允许执行代码块。 异常 except：在try ... except块中使用了关键字 except。它定义 try 块引发错误时要运行的代码块。 finally：在try ... except块中使用。它定义的代码块，在try...except...else块结束时运行，无论try块是否引发错误，都将执行 finally 块。 raise：抛出异常。 with： 作用和使用try/finally语句一样，帮助我们简化异常处理。通常用于文件相关处理。 try：用于try...except块中，它定义了代码测试块是否包含任何错误。 模块 from：从模块中仅导入指定的部分 import：导入模块 as：给模块创建别名 变量 global：声明全局变量 is：判断两个变量是否相等 nonlocal：声明非局部变量 其他 del：删除对象 None：表示null值 pass：null语句(什么都不做的语句) 提示 刚开始接触关键字不用详细了解具体含义，先记住这些关键字不要让标识符取成关键字，后面慢慢接触到这些关键字的时候边了解边使用就可以 ","date":"2019-10-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%AD%E6%B3%95/:4:0","tags":["Python学习之路"],"title":"Python学习之路-语法","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%AD%E6%B3%95/"},{"categories":["Python"],"content":"控制流和语句 ","date":"2019-10-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%AD%E6%B3%95/:5:0","tags":["Python学习之路"],"title":"Python学习之路-语法","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%AD%E6%B3%95/"},{"categories":["Python"],"content":"控制流 在程序开发中，存在三种控制流： 顺序结构：从上到下顺序执行代码 分支结构：根据条件判断决定执行代码的分支 循环结构：让特定代码重复执行 根据控制流衍生出了各类语句 ","date":"2019-10-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%AD%E6%B3%95/:5:1","tags":["Python学习之路"],"title":"Python学习之路-语法","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%AD%E6%B3%95/"},{"categories":["Python"],"content":"赋值 等号=为赋值语句，支持同时给多个变量赋值，还可以通过赋值语句改变多个变量的值。 ","date":"2019-10-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%AD%E6%B3%95/:5:2","tags":["Python学习之路"],"title":"Python学习之路-语法","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%AD%E6%B3%95/"},{"categories":["Python"],"content":"判断 简介 又称为分支语句。当条件成立时做某件时间，不成立时做另一件事或者什么都不做。 用法 Python中的判断语句格式为： if 条件1: 满足条件1的代码块 elif 条件2: 满足条件2的代码块 else: 其他情况的代码块 通过if来发起判断语句，当if条件成立时执行if下的代码块，条件不成立时执行else下的代码块。当存在多个条件时可以通过elif来分隔各个条件，执行不同条件下的代码块。 ","date":"2019-10-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%AD%E6%B3%95/:5:3","tags":["Python学习之路"],"title":"Python学习之路-语法","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%AD%E6%B3%95/"},{"categories":["Python"],"content":"循环 简介 while循环是让指定代码按照条件指定执行次数 用法 Python中的判断语句格式为： while 条件(判断计数器是否达到目标次数): 满足条件代码块 ...... 处理条件(计数器+1) 技巧 Python计数从0开始 警告 Python计数从0开始 在使用while时要注意死循环的问题，由于某些原因，忘记在循环内部修改循环的判断条件，导致循环持续执行，程序无法终止！ 结束循环 可以通过break或者continue来结束当前循环。 break：某一条件满足时退出循环 continue：某一条件满足时不执行当前循环，进行下一次循环 ","date":"2019-10-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%AD%E6%B3%95/:5:4","tags":["Python学习之路"],"title":"Python学习之路-语法","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%AD%E6%B3%95/"},{"categories":["Python"],"content":"将注释放在Python语法前面足以提现它的重要性。 ","date":"2019-09-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%B3%A8%E9%87%8A/:0:0","tags":["Python学习之路"],"title":"Python学习之路-注释","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%B3%A8%E9%87%8A/"},{"categories":["Python"],"content":"注释的作用 一个好的程序中注释是不可缺失的一环。在程序中对某些代码进行标注说明，可以增强程序的可读性。在团队协同开发中，良好的注释可以提高开发效率。 ","date":"2019-09-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%B3%A8%E9%87%8A/:1:0","tags":["Python学习之路"],"title":"Python学习之路-注释","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%B3%A8%E9%87%8A/"},{"categories":["Python"],"content":"什么时候需要使用注释？ 注释不是越多越好，对于一目了然的代码，不需要添加注释 对于 复杂的操作，应该在操作开始前写上思路的注释 对于 不是一目了然的代码，应在其行尾添加注释(为了提高可读性，注释应该至少离开代码 2 个空格) 绝不要描述代码，假设阅读代码的人比你更懂 Python，他只是不知道你的代码要做什么 提示 在一些正规的开发团队，通常会有 代码审核 的惯例一个团队中彼此阅读对方的代码 ","date":"2019-09-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%B3%A8%E9%87%8A/:2:0","tags":["Python学习之路"],"title":"Python学习之路-注释","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%B3%A8%E9%87%8A/"},{"categories":["Python"],"content":"注释类型 ","date":"2019-09-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%B3%A8%E9%87%8A/:3:0","tags":["Python学习之路"],"title":"Python学习之路-注释","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%B3%A8%E9%87%8A/"},{"categories":["Python"],"content":"单行注释 以 # 开头，# 右边的所有东西都被当做说明文字，而不是真正要执行的程序，只起到辅助说明作用 提示 *为了保证代码的可读性，*# 后面建议先添加一个空格，然后再编写相应的说明文字。需要注意的是，为了保证代码的可读性，注释和代码之间 至少要有 两个空格 ","date":"2019-09-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%B3%A8%E9%87%8A/:3:1","tags":["Python学习之路"],"title":"Python学习之路-注释","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%B3%A8%E9%87%8A/"},{"categories":["Python"],"content":"多行注释 如果要写的注释信息很多，一行无法写完，就可以使用多行注释。在Python程序中使用多行注释，可以用一对连续的三个引号(单引号和双引号都可以)。 ","date":"2019-09-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%B3%A8%E9%87%8A/:3:2","tags":["Python学习之路"],"title":"Python学习之路-注释","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%B3%A8%E9%87%8A/"},{"categories":["Python"],"content":"文档 Python有一种独一无二的的注释方式: 使用文档注释。文档注释是包、模块、 类或函数里的第一个语句。这些注释可以通过对象的__doc__成员被自动提取, 并且被pydoc所用.对文档注释的惯例是使用三重双引号”\"\"( PEP-257 )。一个文档注释应该这样组织: 首先是一行以句号，问号或惊叹号结尾的概述(或者该文档注释单纯只有一行)。接着是一个空行，接着是文档注释剩下的部分，它应该与文档注释的第一行的第一个引号对齐。 ","date":"2019-09-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%B3%A8%E9%87%8A/:3:3","tags":["Python学习之路"],"title":"Python学习之路-注释","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%B3%A8%E9%87%8A/"},{"categories":["Python"],"content":"模块 每个文件应该包含一个许可样板. 根据项目使用的许可(例如, Apache 2.0, BSD, LGPL, GPL), 选择合适的样板. ","date":"2019-09-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%B3%A8%E9%87%8A/:3:4","tags":["Python学习之路"],"title":"Python学习之路-注释","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%B3%A8%E9%87%8A/"},{"categories":["Python"],"content":"函数和方法 下文所指的函数,包括函数、方法以及生成器。一个函数必须要有文档字符串, 除非它满足以下条件: 外部不可见 非常短小 简单明了 注释应该包含函数做什么，以及输入和输出的详细描述。通常不应该描述”怎么做”，除非是一些复杂的算法.。注释应该提供足够的信息，当别人编写代码调用该函数时，他不需要看一行代码，只要看文档字符串就可以了。 对于复杂的代码, 在代码旁边加注释会比使用函数注释更有意义. 关于函数的几个方面应该在特定的小节中进行描述记录，这几个方面如下文所述.。每节应该以一个标题行开始，标题行以冒号结尾， 除标题行外。节的其他内容应被缩进2个空格。 Args：列出每个参数的名字, 并在名字后使用一个冒号和一个空格。分隔对该参数的描述，如果描述太长超过了单行80字符，使用2或者4个空格的悬挂缩进(与文件其他部分保持一致)。描述应该包括所需的类型和含义。 如果一个函数接受foo(可变长度参数列表)或者**bar (任意关键字参数), 应该详细列出foo和**bar. Returns(或者 Yields: 用于生成器)： 描述返回值的类型和语义。如果函数返回None，这一部分可以省略。 Raises：列出与接口有关的所有异常。 ","date":"2019-09-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%B3%A8%E9%87%8A/:3:5","tags":["Python学习之路"],"title":"Python学习之路-注释","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%B3%A8%E9%87%8A/"},{"categories":["Python"],"content":"类 类应该在其定义下有一个用于描述该类的文档字符串. 如果你的类有公共属性(Attributes), 那么文档中应该有一个属性(Attributes)段. 并且应该遵守和函数参数相同的格式. 参考 Python风格规范-注释 ","date":"2019-09-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%B3%A8%E9%87%8A/:3:6","tags":["Python学习之路"],"title":"Python学习之路-注释","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%B3%A8%E9%87%8A/"},{"categories":["Python"],"content":"设计哲学 Python的设计哲学是“优雅”、“明确”、“简单”。它的重要准则被称为“Python之禅”。Python之禅又名PEP 20，在Python解释器内运行import this可以获得完整的列表，下面是我的翻译与解读： 提姆·彼得斯（Tim Peters）撰写的《 Python之禅 》 优雅胜于丑陋（以编写优雅的代码为目标） 明确胜于晦涩（明确的代码增强了程序的可读性） 简单胜于复杂（简单的代码能解决复杂的问题） 复杂胜于凌乱（如果项目变得复杂，那代码间也要保持简洁） 扁平胜于嵌套（优雅的代码应该是扁平的，不能有太多嵌套） 间隔胜于紧凑（优雅的代码应当有适当的间隔，不要写一些为了缩减代码丢失了可读性） 可读性很重要（代码的可读的非常重要） 即便假借特例的实用性之名，也不可违背这些规则（这些规则是写Python程序的必备条件） 不要包容所有错误，除非你确定需要这样做（代码中不能存在错误，要善于使用捕获异常） 当存在多种可能，不要尝试去猜测 而是尽量找一种，最好是唯一一种明显的解决方案 虽然这并不容易，因为你不是 Python 之父（虽然你不是Guido，在设计程序时应该多思考，找出最好的解决方案） 做也许好过不做，但不假思索就动手还不如不做（要思考好之后再开始写代码） 如果你无法向人描述你的方案，那肯定不是一个好方案；反之亦然（好的方案是人人都能懂得方案） 命名空间是一种绝妙的理念，我们应当多加利用（要善于利用命令空间） Python开发的哲学是“用一种方法，最好是只有一种方法来做一件事”。在设计Python程序时，如果面临多种选择，一般会拒绝花俏的语法，而选择明确没有或者很少有歧义的语法。 ","date":"2019-09-21","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC/:1:0","tags":["Python学习之路"],"title":"Python学习之路-编码风格","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC/"},{"categories":["Python"],"content":"编码规范 PEP 8是由Guido van Rossum , Barry Warsaw , Nick Coghlan三位共同编写的一个Python代码风格规范。可以在这里查看具体内容，如果英文不好可以在Python风格指南中查看主要的内容 ","date":"2019-09-21","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC/:2:0","tags":["Python学习之路"],"title":"Python学习之路-编码风格","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC/"},{"categories":["Python"],"content":"检查工具 pylint是一个Python代码风格的检查工具, 它依据的标准是Guido van Rossum的PEP 8。 pylint类似于PyChecker, 但提供了更多的功能, 如检查代码行的长度, 检查变量命名是否符合编码规范, 或检查声明的接口是否被真正的实现, 完整的检查功能请参见http://www.logilab.org/card/pylintfeatures。 pylint的最大优势在于其高度的可配置化和可定制化，你可以很容易地写一个小插件添加个人功能。 ","date":"2019-09-21","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC/:2:1","tags":["Python学习之路"],"title":"Python学习之路-编码风格","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC/"},{"categories":["Python"],"content":"用法示例 pylint.bat --reports=n --include-ids=y --disable-msg=W0122,W0702 xlsconverter.py \u003e lint_result.txt 其中： –reports=n 表示不产生输出报告 –include-ids=y 表示输出的错误信息包含错误编号 –disable-msg=W0122,W0702 表示W0122和W0702这两个警告信息被过滤掉了 xlsconverter.py 是被检查的脚本 检查的结果被输出到了lint_result.txt中。 提示 任何语言的程序员，编写出符合规范的代码，是开始程序生涯的第一步。PEP 20和PEP 8陪伴我们整个学习和使用Python的过程。 ","date":"2019-09-21","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC/:2:2","tags":["Python学习之路"],"title":"Python学习之路-编码风格","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC/"},{"categories":["Python"],"content":"Python解释器 ","date":"2019-09-14","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellopython/:1:0","tags":["Python学习之路"],"title":"Python学习之路-HelloPython","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellopython/"},{"categories":["Python"],"content":"简介 前面说到Python是解释型语言，Python解释器的作用就是用于\"翻译\"Python程序。Python规定了一个Python语法规则，根据该规则可编写Python解释器。 ","date":"2019-09-14","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellopython/:1:1","tags":["Python学习之路"],"title":"Python学习之路-HelloPython","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellopython/"},{"categories":["Python"],"content":"常见的Python解释器 CPython：官方提供的解释器，由C语言实现，这是最常用的Python解释器。 PyPy：一种用Python语言实现的解释器，可用于替代CPython。PyPy采用即时编译通常运行速度比CPython快很多。多数Python代码可以很好的运行在PyPy之上，除非代码依赖于CPython扩展， Jython:一种用Java语言实现的解释器，Jython可以直接调用Java的各种函数库。 ","date":"2019-09-14","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellopython/:1:2","tags":["Python学习之路"],"title":"Python学习之路-HelloPython","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellopython/"},{"categories":["Python"],"content":"安装 Python是一门跨平台的脚本语言，不同平台的安装过程稍有区别。 注意 以下安装部分内容仅针对CPython。内容参考Python官方的安装教程，由我摘选出来各平台比较方便快捷的安装方式。如果不符合需求，可以查看官方安装教程搜索需要的内容。 ","date":"2019-09-14","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellopython/:2:0","tags":["Python学习之路"],"title":"Python学习之路-HelloPython","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellopython/"},{"categories":["Python"],"content":"Linux Python预装在大多数Linux发行版上，并作为一个包提供给所有其他用户。 也可以从源代码编译最新版本的Python。 如果Python没有预先安装并且不在发行版提供的库中，也可以轻松地为自己使用的发行版创建包。 参阅以下链接： Debian、OpenSuse、Fedora、Slackware 从源代码编译 首先要做的是获取 source 。您可以下载最新版本的源代码，也可以直接提取最新的 clone 。 构建过程由常用命令组成： ./configure make make install 提示 特定Unix平台的配置选项和注意事项通常记录在Python源代码的根目录下的 README.rst 文件中。 警告 make install 可以覆盖或伪装 python3 二进制文件。因此，建议使用 make altinstall 而不是 make install ，因为后者只安装了 *exec_prefix*/bin/python*version* 。 ","date":"2019-09-14","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellopython/:2:1","tags":["Python学习之路"],"title":"Python学习之路-HelloPython","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellopython/"},{"categories":["Python"],"content":"Windows 从Python官方获取安装包 根据需求进行安装包安装 安装完毕后将Python解释器的路径添加到系统环境变量中 提示 √上Add Python 3.x to PATH后安装程序会自动将PythonPython解释器的路径添加到系统环境变量中) ","date":"2019-09-14","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellopython/:2:2","tags":["Python学习之路"],"title":"Python学习之路-HelloPython","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellopython/"},{"categories":["Python"],"content":"Mac OS X 通过Homebrew安装 提示 使用brew install python3默认安装最新版本，可以通过安装pyenv后安装指定版本的Python。根据需求自行选择 安装pyenv brew install pyenv 将pyenv添加到shell中 echo -e 'if which pyenv \u003e /dev/null; then eval \"$(pyenv init -)\"; fi'\u003e\u003e ~/.bash_profile 使shell生效 exec \"$SHELL\" 查看可安装的Python版本 pyenv install -l 安装需求的Python版本 pyenv install 3.7.1 指定全局的Python环境 pyenv global 3.7.1 查看已安装的Python版本和正在使用的Python版本 pyenv versions ","date":"2019-09-14","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellopython/:2:3","tags":["Python学习之路"],"title":"Python学习之路-HelloPython","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellopython/"},{"categories":["Python"],"content":"检查 安装完毕之后可以通过查看Python版本号的方式来检查是否安装成功 python3 -V Python 3.7.7 或者进入Python交互式命令行中查看，在交互式命令行输入python3能进入交互式命令行并且版本对则安装成功 ","date":"2019-09-14","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellopython/:2:4","tags":["Python学习之路"],"title":"Python学习之路-HelloPython","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellopython/"},{"categories":["Python"],"content":"执行程序的方式 ","date":"2019-09-14","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellopython/:3:0","tags":["Python学习之路"],"title":"Python学习之路-HelloPython","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellopython/"},{"categories":["Python"],"content":"交互式命令行 简介 在控制台输入Python3即可进入Python3解释器集成的一个交互式命令行，可以在交互式命令行中执行程序。 python3 Python 3.7.1 (default, Oct. 20, 2018, 15:43:33) [Clang 11.0.0 (clang-1100.0.33.17)] on darwin Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. \u003e\u003e\u003e 这里我们可以看到Python的版本、当前版本发布的时间和查询相关信息的指令，例如输入help()可以查询到帮助相关的信息。 使用 在交互式命令行中写入print('Hello Python!')按回车 \u003e\u003e\u003e print(\"Hello Python!\") Hello Python! 这里使用了Python一个内置的print()方法，其作用是将传入的对象在控制台打印出来。就这么简单的完成了学习Python的第一个程序，可以看到Python的语法非常简单易懂。 提示 通过quit()方法退出Python的交互式命令行。 ","date":"2019-09-14","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellopython/:3:1","tags":["Python学习之路"],"title":"Python学习之路-HelloPython","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellopython/"},{"categories":["Python"],"content":"通过Python解释器 简介 由于在交互式命令行中编写的Python代码无法保存，当需要保存代码的时候可以用文本编辑器或集成开发环境来编写Python代码。这时候就可以用Python解释器来执行Python程序。 文本编辑器是计算机软件中的一种。主要用于用来编写和查看文本文件。有一些特殊的文本编辑器支持增加自有的格式来丰富文档的表现形式。操作系统或者集成开发环境通常会带有可以查看和编辑纯文本的编辑器，可增加格式的文本编辑器通常是个人用户或者公司在制作需要格式的文件中使用。因为程序和程序的配置文件通常是以纯文本形式储存，所以程序员也需要使用纯文本编辑器来编辑程序和配置文件。 集成开发环境（Integrated Development Environment，简称IDE）是一种辅助程序开发人员开发软件的应用软件，在开发工具内部就可以辅助编写源代码文本、并编译打包成为可用的程序，有些甚至可以设计图形接口。IDE通常包括编程语言编辑器、自动构建工具、通常还包括调试器。 在初学阶段建议用文本编辑器来进行开发，更有利于掌握Python基础相关知识。 使用 首先打开一个文本编辑器(系统自带的即可)，写入print(\"Hello Python!\") 注意 这句话一定要顶格写，Python对缩进的要求非常严格。注意print方法名的小写和中英文字符问题！ 将文本保存为Hello.py在控制台中切换到当前目录，输入python3 Hello.py来运行该程序 python3 Hello.py Hello Python! 看到Hello Python!则第一个程序执行成功。 说明 Python程序以.py结尾。控制台中输入的python3为指定的Python解释器 ","date":"2019-09-14","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellopython/:3:2","tags":["Python学习之路"],"title":"Python学习之路-HelloPython","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellopython/"},{"categories":["Python"],"content":"本篇文章由我归纳总结而来，为想要了解学习Python的朋友提供参考。大部分内容参考维基百科 ","date":"2019-09-07","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/:0:0","tags":["Python学习之路"],"title":"Python学习之路-认识Python","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/"},{"categories":["Python"],"content":"简介 Python是一种广泛使用的解释型、高级和通用的编程语言。Python支持多种编程范型，包括函数式、指令式、结构化、面向对象和反射式编程。它拥有动态类型系统和垃圾回收功能，能够自动管理内存使用，并且其本身拥有一个巨大而广泛的标准库。 Python是一种易于学习又功能强大的编程语言。它提供了高效的高级数据结构，还能简单有效地面向对象编程。Python 优雅的语法和动态类型，以及解释型语言的本质，使它成为多数平台上写脚本和快速开发应用的理想语言。 ","date":"2019-09-07","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/:1:0","tags":["Python学习之路"],"title":"Python学习之路-认识Python","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/"},{"categories":["Python"],"content":"Python的起源 ","date":"2019-09-07","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/:2:0","tags":["Python学习之路"],"title":"Python学习之路-认识Python","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/"},{"categories":["Python"],"content":"诞生 由于吉多·范罗苏姆(Guido van Rossum)参与设计的ABC语言没有成功，他在1989年的圣诞节决定开发一个新的解释型语言作为ABC语言的替代者。在他看来ABC语言的失败的原因是其非开放的，他决心在Python中避免这个错误，后来由于他的开放形成了庞大的Python社区。之所以取名为Python，是因为他非常喜欢BBC电视剧中的蒙提·派森的飞行马戏团（Monty Python’s Flying Circus）。 ","date":"2019-09-07","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/:2:1","tags":["Python学习之路"],"title":"Python学习之路-认识Python","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/"},{"categories":["Python"],"content":"发展 1991年2月第一个Python解释器(标记为版本0.9.0)诞生。这时就已经存在了带继承的类、异常处理、函数和核心数据类型list、dict、str等 1994年1月Python达到了版本1.0。这个发行版主要新特征是包括了函数式编程工具lambda、map、filter和reduce。Python 1.4增加了受Modula-3启发的关键字参数和对复数的内建支持，还包含采取名字修饰的一种基本形式[数据隐藏。 2000年10月16日Python 2.0发布。增加了列表推导式，这是从函数式编程语言SETL和Haskell中引入的。它还向垃圾收集系统增加了环检测算法，并且支持Unicode。Python 2.1支持了嵌套作用域，就像其他静态作用域语言一样。Python 2.2的重大革新是将Python的类型(用C写成)和类(用Python写成)统一入一个层级，使得Python的对象模型成为纯粹和一致的面向对象的模型；还增加了迭代器，受CLU和Icon启发的生成器，和描述器协议。Python 2.4加入了集合数据类型，和函数修饰器。Python 2.5加入了with语句。 Python 3.0于2008年12月3日发布，它对语言做了较大修订而不能完全后向兼容。Python 3发行包括了2to3实用工具，它（至少部分的）自动将Python 2代码转换成Python 3代码。Python 3的很多新特性后来也被移植到旧的Python 2.6/2.7版本中。 Python 2.7的产品寿命结束日期最初设定为2015年，出于对大量的现存代码不能前向移植到Python 3的关切而延期至2020年。随着Python 2的产品寿命结束，只有Python 3.8和后续版本仍被完全支持。 在2020年12月，活跃的Python核心开发者选举Barry Warsaw、Brett Cannon、Carol Willing、Pablo Galindo Salgado和Thomas Wouters为2021年度“掌控委员会”的五位成员来领导这个项目。 ","date":"2019-09-07","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/:2:2","tags":["Python学习之路"],"title":"Python学习之路-认识Python","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/"},{"categories":["Python"],"content":"解释型语言与编译型语言 ","date":"2019-09-07","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/:3:0","tags":["Python学习之路"],"title":"Python学习之路-认识Python","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/"},{"categories":["Python"],"content":"区别 高级语言设计的程序必须经过“翻译”成机器语言以后才能被机器执行。“翻译”的方法有两种，一种是解释，一种是编译。两种方式的区别在于“翻译”时间点不同，解释型语言编写的程序不需要编译，程序在运行时才翻译成机器语言，每执 行一次都要翻译一次。编译型语言编写的程序在执行之前需要进行的编译，把程序编译成机器语言的文件，运行时不需要重新“翻译”，直接使用编译的结果就行了。 ","date":"2019-09-07","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/:3:1","tags":["Python学习之路"],"title":"Python学习之路-认识Python","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/"},{"categories":["Python"],"content":"对比 速度：编译型语言比解释型语言执行速度快 跨平台性：解释型语言比编译型语言跨平台性好 ","date":"2019-09-07","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/:3:2","tags":["Python学习之路"],"title":"Python学习之路-认识Python","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/"},{"categories":["Python"],"content":"特点 ","date":"2019-09-07","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/:4:0","tags":["Python学习之路"],"title":"Python学习之路-认识Python","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/"},{"categories":["Python"],"content":"完全面向对象的语言 在 Python 中一切皆对象 完全支持继承、重载、多重继承 支持重载运算符，也支持泛型设计 ","date":"2019-09-07","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/:4:1","tags":["Python学习之路"],"title":"Python学习之路-认识Python","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/"},{"categories":["Python"],"content":"拥有一个强大的标准库 ​ Python 语言的核心只包含 数字、字符串、列表、字典、文件 等常见类型和函数，而由 Python 标准库提供了 系统管理、网络通信、文本处理、数据库接口、图形系统、XML 处理 等额外的功能 ","date":"2019-09-07","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/:4:2","tags":["Python学习之路"],"title":"Python学习之路-认识Python","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/"},{"categories":["Python"],"content":"Python 社区 ​ 社区提供了数量庞大的第三方模块，使用方式与标准库类似。它们的功能覆盖 科学计算、人工智能、机器学习、Web 开发、数据库接口、图形系统 等多个领域 ","date":"2019-09-07","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/:4:3","tags":["Python学习之路"],"title":"Python学习之路-认识Python","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/"},{"categories":["Python"],"content":"为什么选择Python Life is short, you need Python。 ","date":"2019-09-07","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/:5:0","tags":["Python学习之路"],"title":"Python学习之路-认识Python","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/"},{"categories":["Python"],"content":"参考 提示 以下顺序不分先后 Python维基百科 解释型语言 编译型语言 ","date":"2019-09-07","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/:6:0","tags":["Python学习之路"],"title":"Python学习之路-认识Python","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/"},{"categories":["Python"],"content":"Python学习之路 Python 是一种易于学习又功能强大的编程语言。目前网上有许多Python相关文档，质量参差不齐，更新时间也都非常久远。也没有看到有相关系统全面的文档，所以我想通过我的努力打造一个全面且及时更新的Python教程。 由于本人能力有限，所以本文档仅适用于想系统的学习Python的朋友。如果发现文档中存在错误，请联系我修正；如果发现文档中存在侵权情况，请联系我删除相关内容。感谢您对Python社区的贡献。 通过本文档你能了解到从Python基础到Python标准库、Web开发、爬虫、数据分析、机器学习等方面的内容。由于Python2.7已于2020年1月1日起停止维护，本文档中的内容全部针对Python3.X版本。 Life is short, you need Python。接下来就让我们开始遨游在Python的世界中吧！ ","date":"2019-09-01","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%96%87%E6%A1%A3%E8%AF%B4%E6%98%8E/:1:0","tags":["Python学习之路"],"title":"Python学习之路-文档说明","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%96%87%E6%A1%A3%E8%AF%B4%E6%98%8E/"},{"categories":["Golang"],"content":"前言 最近对Go语言非常感兴趣，准备花一段时间来学习，此系列文章用于学习笔记整理与学习记录。 ","date":"2019-08-03","objectID":"/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/:1:0","tags":["Go"],"title":"Go语言学习之旅","uri":"/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/"},{"categories":["Golang"],"content":"简介 Go（又称 Golang）是 Google的 Robert Griesemer，Rob Pike 及 Ken Thompson 开发的一种静态强类型、编译型语言。Go 语言语法与 C相近，但功能上有：内存安全，GC（垃圾回收），结构形态及 CSP-style 并发计算。 ","date":"2019-08-03","objectID":"/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/:2:0","tags":["Go"],"title":"Go语言学习之旅","uri":"/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/"},{"categories":["Golang"],"content":"学习资料 Go官方提供的教程非常丰富： 官网、中文官网、Go指南 非官方推荐 书籍：Go 简易教程、Go 入门指南、Go 语言设计与实现 导航：Go网站导航 论坛：learnku 教程：Go语言学习之路 ","date":"2019-08-03","objectID":"/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/:3:0","tags":["Go"],"title":"Go语言学习之旅","uri":"/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/"},{"categories":["Golang"],"content":"安装 Go官方提供了丰富的安装方法，可以根据自己的系统与喜好进行安装 如果官方网站打开比较慢的话也可以通过Go语言中文网提供的包进行安装 注意 安装完毕记得添加环境变量！ ","date":"2019-08-03","objectID":"/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/:4:0","tags":["Go"],"title":"Go语言学习之旅","uri":"/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/"},{"categories":["Golang"],"content":"学习计划 基础：预计两周时间 ","date":"2019-08-03","objectID":"/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/:5:0","tags":["Go"],"title":"Go语言学习之旅","uri":"/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/"},{"categories":["爬虫"],"content":"Python爬虫实战之bilibili","date":"2019-07-20","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/","tags":["爬虫"],"title":"Python爬虫实战之bilibili","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/"},{"categories":["爬虫"],"content":"声明：以下内容均为我个人的理解，如果发现错误或者疑问可以联系我共同探讨 ","date":"2019-07-20","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/:0:0","tags":["爬虫"],"title":"Python爬虫实战之bilibili","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/"},{"categories":["爬虫"],"content":"爬虫介绍 ","date":"2019-07-20","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/:1:0","tags":["爬虫"],"title":"Python爬虫实战之bilibili","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/"},{"categories":["爬虫"],"content":"网站介绍 本次要爬取的网站为bilibili，它是国内知名的视频弹幕网站,这里有及时的动漫新番,活跃的ACG氛围,有创意的Up主。可以在这里找到许多欢乐。 ","date":"2019-07-20","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/:1:1","tags":["爬虫"],"title":"Python爬虫实战之bilibili","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/"},{"categories":["爬虫"],"content":"编写爬虫的原因和用途 bilibili已经从原来的小破站变成了现在现象级的多元化的社区网站，本次爬取它的目的是以它作为一个典型，告诉大家遇到各类型验证码的一种思路。 其实这类网站有个最简单的办法，就是提前登陆手动获取到cookie，然后根据cookie去请求我们需要爬取的网站。个人目的的爬虫可以用这类方法，比较省编写代码的时间。但是公司中可能会遇到众多账户的爬虫需求，一个一个手动登录去获取cookie就比较麻烦了，这时候使用Selenium自动化去获取效率就高很多了。 ","date":"2019-07-20","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/:1:2","tags":["爬虫"],"title":"Python爬虫实战之bilibili","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/"},{"categories":["爬虫"],"content":"Selenium ","date":"2019-07-20","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/:2:0","tags":["爬虫"],"title":"Python爬虫实战之bilibili","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/"},{"categories":["爬虫"],"content":"简介 正如他们官方的介绍Selenium automates browsers. That's it!，他是一个自动化的浏览器，可以模拟人的操作。 ","date":"2019-07-20","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/:2:1","tags":["爬虫"],"title":"Python爬虫实战之bilibili","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/"},{"categories":["爬虫"],"content":"使用教程 推荐通过Selenium中文网学习，非常全面！ ","date":"2019-07-20","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/:2:2","tags":["爬虫"],"title":"Python爬虫实战之bilibili","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/"},{"categories":["爬虫"],"content":"验证码分析 ","date":"2019-07-20","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/:3:0","tags":["爬虫"],"title":"Python爬虫实战之bilibili","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/"},{"categories":["爬虫"],"content":"滑动验证码 哔哩哔哩从之前的验证码是滑动验证码，主要思路就是找到缺口确定缺口的坐标，然后通过Selenium操作滑动到指定位置就行。类似的还有阿里系的大部分网页，比如飞猪、淘宝、天猫等，不过阿里系的不是每次都需要验证，得根据实际情况操作。 这种就是找到最右边的位置信息，然后滑动即可 这种需要先找到整个图片的位置，然后滑动先找到内容的轮廓在进行滑动，都是同一个思路演变的 ","date":"2019-07-20","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/:3:1","tags":["爬虫"],"title":"Python爬虫实战之bilibili","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/"},{"categories":["爬虫"],"content":"看图填答案系列 包括东方财富网上交易、bigquant等等，这类比较简单。将其下载下来根据验证码的情况进行处理然后交给各大云服务商的ORC服务识别就可以，都有免费试用的额度，根据自己的需求和喜好选择，也可以多试几家进行对比。 百度、腾讯、阿里、有道智云 ","date":"2019-07-20","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/:3:2","tags":["爬虫"],"title":"Python爬虫实战之bilibili","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/"},{"categories":["爬虫"],"content":"根据图片进行操作点击系列 目前多了很多这种验证码，这种的难度在于情况变化比较多，不仅限于汉字和数字，还有可能是图片等等，这时候自己想办法也能解决，但是策略一改变就比较麻烦，可以借助各类打码的平台，对内容进行识别，然后再根据内容去进行操作 易云打码、快识别网址、斐斐打码等等 ","date":"2019-07-20","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/:3:3","tags":["爬虫"],"title":"Python爬虫实战之bilibili","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/"},{"categories":["爬虫"],"content":"bilibili登陆分析 bilibili的最新的验证码属于第三种，在点击登陆按钮就会出现一个验证码的框,我们需要将这个图片下载下来给打码平台去识别，获得坐标信息然后再用Selenium进行点击操作 ​ bilibili验证码 ","date":"2019-07-20","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/:4:0","tags":["爬虫"],"title":"Python爬虫实战之bilibili","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/"},{"categories":["爬虫"],"content":"编写代码 ","date":"2019-07-20","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/:5:0","tags":["爬虫"],"title":"Python爬虫实战之bilibili","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/"},{"categories":["爬虫"],"content":"Selenium模拟登陆 import re import time import base64 import json import requests from selenium import webdriver from selenium.webdriver import ActionChains from selenium.webdriver.chrome.options import Options class Bilibili(object): def __init__(self): chrome_options = Options() # 设置无窗口模式 # chrome_options.add_argument('--headless') self.driver = webdriver.Chrome('./chromedriver', options=chrome_options) def login(self, username, password): # 开登陆页面 self.driver.get(\"https://passport.bilibili.com/login\") # 输入用户名和密码 self.driver.find_element_by_id('login-username').send_keys(username) self.driver.find_element_by_id('login-passwd').send_keys(password) # 点击登陆按钮 self.driver.find_element_by_class_name('btn-login').click() # 等待验证码出现 # self.driver.implicitly_wait(10) time.sleep(5) # 获取图片所在属性 img_style = self.driver.find_element_by_class_name('geetest_tip_img').get_attribute('style') # 通过正则表达式获得图片url url = re.findall('url\\(\"(.*?)\"\\)', img_style)[0] # 通过requests发送请求得到图片 response = requests.get(url).content # 将图片保存在本地 with open('./captcha.png', 'wb') as f: f.write(response) # 通过打码平台进行打码识别 result = self.captcha_recognition() # 识别成功 if result != \"\": # 对识别到的坐标进行分组处理 result_list = result.split('|') for result in result_list: x = result.split(',')[0] y = result.split(',')[1] # 根据坐标执行整个动作链 ActionChains(self.driver).move_to_element_with_offset(img_style, int(x), int(y)).click().perform() # 点击确定按钮 self.driver.find_element_by_class_name('geetest_commit').click() # 获得登陆后的cookie cookie = [item[\"name\"] + \"=\" + item[\"value\"] for item in self.driver.get_cookies()] self.driver.close() return cookie def captcha_recognition(self): \"\"\"验证码识别\"\"\" username = 'username' password = 'password' with open('./captcha.png', 'rb') as f: base64_data = base64.b64encode(f.read()) b64 = base64_data.decode() data = {\"username\": username, \"password\": password, \"typeid\": 27, \"image\": b64} result = json.loads(requests.post(\"http://api.ttshitu.com/predict\", json=data).text) if result['success']: return result[\"data\"][\"result\"] else: print(result[\"message\"]) return \"\" ","date":"2019-07-20","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/:5:1","tags":["爬虫"],"title":"Python爬虫实战之bilibili","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/"},{"categories":["爬虫"],"content":"Python爬虫实战之萝卜投研","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"声明：以下内容均为我个人的理解，如果发现错误或者疑问可以联系我共同探讨 ","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:0:0","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"爬虫介绍 ","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:1:0","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"网站介绍 本次要爬取的网站为*萝卜投研*，是利用人工智能、大数据、移动应用技术,建立的股票基本面分析智能投研平台，在进行投资交易的时候可以使用期研报与各类数据进行分析。 ","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:1:1","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"编写爬虫的原因和用途 本人闲暇时间会学习投资理财相关内容，萝卜投研可以获取许多财经类的信息与很多研报，本次想通过编写爬虫完成对目标数据完成持久化存储与相关舆情完成程序提醒的目标，由于网站内容十分丰富，一次很难将其全部爬取完毕，本次想通过Scrapy获取首页的投研信息，并完成翻页的目标，后期还会持续更新，尝试将整个网站都爬下来。（仅供个人研究使用） ","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:1:2","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"Scrapy ","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:2:0","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"简介 Scrapy是一个为了爬取网站数据，提取结构性数据编写的爬虫框架，只需要很少的代码就可以完成相关数据的抓取。 Scrapy是一个使用了Twisted的异步网络框架，可以大大提高我们的下载速度。 ","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:2:1","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"使用教程 Scrapy的相关使用教程可以通过官方文档来进行初步入门，了解各模块在框架中的作用，官方文档非常强大，建议先进行系统性的学习之后再开始使用。 学习Scrapy最重要的就是理解Scrapy的工作流程，跟着官方文档的例子去详细分析每一步的操作，与之前编写爬虫的流程相关性与区别。 ","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:2:2","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"抓包工具 ","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:3:0","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"什么是抓包工具 抓包工具是拦截查看网络数据包内容的软件。通过对抓获的数据包进行分析，可以得到有用的信息。 ","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:3:1","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"为什么要用 较为复杂的网站在进行爬取数据分析的时候使用浏览器中的调试工具会比较麻烦，这时候就可以用抓包工具去分析对应的请求，从而更快发现我们需要的数据所在的URL和整个请求的过程 ","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:3:2","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"使用与抓包工具的推荐 抓包工具的使用推荐学习朱安邦的博客中的教程，他讲了三个：Charles、Fiddler、wireshark，这些抓包工具功能各异，但基本原理相同，找一个顺手的学习基本上已经足够了。 ","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:3:3","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"业务逻辑分析 ","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:4:0","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"寻找加载数据的URL 通过对整个首页加载的流程进行抓包与分析，发现首页数据的URL为https://gw.datayes.com/rrp_mammon/web/feed/list，下一页的URL为：https://gw.datayes.com/rrp_mammon/web/feed/list?timeStamp=20210401170127\u0026feedIds=66233,66148， ","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:4:1","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"翻页参数解析 通过观察URL发现timeStamp和feedIds是两个控制翻页的参数，进一步多页进行请求发现20210401170127可以理解为一个时间节点，看到20200228猜测是本次刷新的时间，猜测后6位是当前时间的秒的时间戳，组织一下可以写成''.join(str(datetime.now())[:10].split('-'))+str(time.clock( )).split('.')[1] 再进行多页的数据获取后发现feedIds参数中的前四个是第一个响应中前四个数据的id，最后一个数为响应中最后一个数据的id，并且会随着访问变多而增加，每次新增的都是最后一个数据的id，将下一页的URL拼接起来,进行访问发现请求不到下一页的数据。通过复制原来的timeStamp发现可以访问，问题就出现在前面timeStamp的参数，刚刚再进行feedIds字段拼接的时候发现有三个字段是日期形式的，分别为：\"insertTime\"、updateTime、publishTime，进一步分析发现将其后面三个0去掉就是一个时间戳，对其转换发现就是我们需要的结果 ","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:4:2","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"模拟请求测试 ","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:5:0","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"scrapy shell scrapy shell可以帮助我们模拟请求地址，并进入一个交互式终端，在交互式终端中我们可以查看请求的各类信息，并进行调试。但scrapy shell也有缺陷，不能解析response的格式，看起来比较乱等，这时候可以通过结合Postman来协同调试。 ","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:5:1","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"Postman 简介 Postman是一种网页调试与发送网页http请求的chrome插件。我们可以用来很方便的模拟各种类型的请求来调试 接口。在爬虫中可以用于验证我们的思路。 使用与汉化 Postman官方的使用教程非常详细，可以跟着官方的使用教程中学习，如果想使用中文的版本可以在Postman汉化中下载。 实际使用 通过Postman发送请求，可以得到我们想要的数据，并且可以得到格式化后的数据，看起来条理更加清晰，再配合scrapy shell调试可以很容易就获得我们需要的数据 ","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:5:2","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"编写爬虫 ","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:6:0","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"创建爬虫项目 scrapy startproject datayes ","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:6:1","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"robots协议 在settings.py中可以通过设置ROBOTSTXT_OBEY = True遵守robots.txt 的规则。 ","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:6:2","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"创建爬虫 scrapy genspider mammon gw.datayes.com ","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:6:3","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"修改start_urls 默认的start_urls不是我们要爬取的链接，修改为我们需求的链接 start_urls = ['https://gw.datayes.com/rrp_mammon/web/feed/list'] ","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:6:4","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"完成parse方法 根据之前分析的结果设计方案完成parse，这次难度主要在于如何拼接next_url，由于feedIds参数存在着累加的关系所以将其放在了parse函数外让其可以再访问的时候累加处理。 class MammonSpider(scrapy.Spider): name = 'mammon' allowed_domains = ['gw.datayes.com'] start_urls = ['https://gw.datayes.com/rrp_mammon/web/feed/list'] # 构建一个基础next_url next_url = 'https://gw.datayes.com/rrp_mammon/web/feed/list?timeStamp=' # 构建一个基础feedIds feedIds = '\u0026feedIds=' def parse(self, response): # 将获取到的数据通过json转成字典的形式 result = json.loads(response.text) # 当访问成功时进行数据获取 if result['message'] == 'success': data_list = result['data']['list'] for data in data_list: item = {} detail_id = data['id'] # id # 通过详情页id构造详情页url并访问 detail_url = 'https://gw.datayes.com/rrp_mammon/web/feed?id=' + str(detail_id) yield scrapy.Request(detail_url, callback=self.detail_parse, meta={'item': item}) item['title'] = data['title'] # 标题 item['publish_time'] = int(data['publishTime'] / 1000) # 发布时间 item['author'] = data['roboColumn']['name'] # 作者 item['Avatar'] = data['roboColumn']['logo'] # 头像 related_list = data['related'] item['related_stocks'] = [] # 相关股票列表 for stocks in related_list: item['related_stocks'].append(stocks['targetName']) # 寻找出url的第0，1，2，3位置的id，加入feedIds if response.request.url == 'https://gw.datayes.com/rrp_mammon/web/feed/list' and data_list.index(data) in [0, 1, 2, 3]: self.feedIds = self.feedIds + str(detail_id) + ',' # 构建timeStamp参数 timeStamp = time.strftime(\"%Y%m%d%H%M%S\", time.localtime(item['publish_time'])) # 拼接feedIds参数 self.feedIds = self.feedIds + str(detail_id) + ',' # 组合next_url next_url = self.next_url + timeStamp + self.feedIds # 请求下一页 yield scrapy.Request(next_url, callback=self.parse) def detail_parse(self, response): result = json.loads(response.text) if result['message'] == 'success': item = response.meta['item'] item['content'] = result['data']['longDocContent'] yield item 通过爬虫观察到两日的cookie发生了变化，只有登录之后会保持cookie，并对cookie中的参数进行检测，找到cloud-sso-token为必要参数，并将其添加在settings.py中。 ","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:6:5","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"完成数据存储 先在settings.py中配置pipeline，和数据库相关参数 # Configure item pipelines # See https://docs.scrapy.org/en/latest/topics/item-pipeline.html ITEM_PIPELINES = { 'datayes.pipelines.DatayesPipeline': 300, } # MySQL相关配置 HOST = 'HOST', # 数据库地址 PORT = 3306, # 数据库端口 DB = 'DB', # 数据库名 USER = 'USER', # 数据库用户名 PASSWORD = 'PASSWORD', # 数据库密码 在我们定义的DatayesPipeline类中添加open_spider和close_spider方法，通过spider.settings来导入数据库相关参数 import pymysql class DatayesPipeline: # 爬虫开始时执行，只执行一次 def open_spider(self, spider): # 通过pymysql链接MySQL数据库 self.connect = pymysql.connect( host=spider.settings.HOST, # 数据库地址 port=spider.settings.PORT, # 数据库端口 db=spider.settings.DB, # 数据库名 user=spider.settings.USER, # 数据库用户名 passwd=spider.settings.PASSWORD, # 数据库密码 charset='utf8', # 编码方式 use_unicode=True) # 通过cursor执行增删查改 self.cursor = self.connect.cursor() # 爬虫结束时执行，只执行一次 def close_spider(self, spider): self.connect.close() def process_item(self, item, spider): self.cursor.execute( \"\"\"insert into mammon (title, publish_time,author,avatar,related_stocks,content)value (%s, %s,%s, %s,%s, %s)\"\"\", (item['title'], item['publish_time'], item['author'], item['avatar'], item['related_stocks'], item['content'])) # 提交sql语句 self.connect.commit() return item 最后创建数据库，开启爬虫进行数据爬取。 ","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:6:6","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"Python爬虫实战之叩富网","date":"2019-06-22","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"声明：以下内容均为我个人的理解，如果发现错误或者疑问可以联系我共同探讨 ","date":"2019-06-22","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:0:0","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"爬虫介绍 爬虫是一种按照一定规则自动抓取网络上的信息数据的程序。我们身处一个大数据的时代，可以通过爬虫获取到我们所需要的数据(遵从robots协议中的规则)。 ","date":"2019-06-22","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:1:0","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"网站介绍 叩富网是江西博辰网络科技公司旗下的一个专业网站。模拟炒股网站初建于2000年，2006年被博辰网络收购，并开始规范系统的运作。目前用户100多万，日均IP数10万左右。是国内唯一一家专业致力于模拟炒股开发和运营的网站。公司旗下有有奖大赛站、免费大赛站以及和其他证券公司合作的网站。 ","date":"2019-06-22","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:1:1","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"编写爬虫的原因和用途 本人闲暇时间会学习投资理财相关内容，并通过叩富网进行模拟炒股，本次想通过编写爬虫来程序化自己的模拟交易 ","date":"2019-06-22","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:1:2","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"robots协议 ","date":"2019-06-22","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:2:0","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"什么是robots协议 robots协议以robots.txt文件形式呈现，是网站中给各类爬虫规定爬取范围的文件，robots.txt存放在网站的根目录下。我们准备爬取某个网站时，首先应该查看我们需要的数据该网站是否允许我们爬取，当我们爬取规则之外的数据时，该网站有权利起诉我们非法获取数据。 ","date":"2019-06-22","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:2:1","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"robots协议的构成 由User-agent、Allow、Disallow构成。User-agent后面的内容是具体的爬虫名，如百度爬虫为Baiduspider，则代表所有爬虫。Allow后面的内容是允许爬取的URL路径，如/.jpg$表示可以爬取该网站下的所有.jpg图片，/表示所有路径均允许爬取。Disallow后面的内容是不允许爬取的URL路径，同Allow相反。 ","date":"2019-06-22","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:2:2","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"常见的规则有哪些 允许爬虫获取所有内容： User-agent: * Disallow: # 或者 User-agent: * Allow: / 禁止爬取所有内容： User-agent: * Disallow: / 禁止访问网站中所有动态页面 User-agent: * Disallow: /*?* 禁止搜索引擎抓取网站上所有图片 User-agent: * Disallow: /*.jpg$ Disallow: /*.jpeg$ Disallow: /*.gif$ Disallow: /*.png$ Disallow: /*.bmp$ ","date":"2019-06-22","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:2:3","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"Feeling 爬虫可以使我们更加高效的获取到互联网中的各类数据，但网络不是法外之地我们也要在合规合法的基础上进行爬取，尊重每一个网站开发者，敬畏法律。 ","date":"2019-06-22","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:2:4","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"requests requests库是学习爬虫入门最适合的一个第三方库，它是将Python内置的urllib进行深度封装的库。是一个非常成熟的HTTP客户端库，当然他也并非完美，我们后期也可以在其基础上进行补充形成适合自己的一个库。 ","date":"2019-06-22","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:3:0","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"快速上手 中文文档：https://docs.python-requests.org/zh_CN/latest/index.html 官方示例：https://docs.python-requests.org/zh_CN/latest/user/quickstart.html ","date":"2019-06-22","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:3:1","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"获取robots协议，查看可爬取范围 使用get请求获取协议内容，并将其输出控制台查看发现规则允许我们爬取整站内容 ","date":"2019-06-22","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:3:2","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"登陆叩富网 在Chrome浏览器中通过开发者选项中的Network选项卡中发现，登陆的时候有一个login.html 我们可以在里面看到请求URL、请求方式和Form Data所需要的内容，根据这个编写一个请求查看一下获取到的数据 由于是字符串格式，所以出现了我们看不懂的字符，通过json转成Python中的字典格式再查看 可以看到显示登陆成功了，接下来通过获取到的cookie就可以获取到我们需要的各种信息了 接下来我们将代码优化一下变成一个方法，让登陆后的cookie可以在以后任意需要的地方使用 import requests import json from lxml import etree def login(username, password): \"\"\" 登陆叩富网 :param username: 用户名 :param password: 密码 :return: 登陆成功返回cookie，失败抛出对应异常 \"\"\" login_url = 'http://www.cofool.com/Passport/login.html' data = { 'username': username, 'password': password } try: response = requests.post(url=login_url, data=data) except Exception as e: raise Exception(\"登陆失败，原因为：{}\".format(e)) content = json.loads(response.content.decode()) if content['status'] == 0: cookie = response.cookies.get_dict() return cookie else: raise Exception(\"登陆失败，原因为：{}\".format(content['info'])) 在出现登录失败的时候抛出异常，并显示错误信息 ","date":"2019-06-22","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:3:3","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"Feeling 爬虫是我们与开发者的博弈，我们需要站在他们的角度去分析他们开发的过程，从而更好的理解并去设计我们的相关爬虫程序。通常爬虫程序都不是一次就完成的，需要通过我们不断根据请求的反馈去修改程序，最终通过多层解析得到结果。 ","date":"2019-06-22","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:3:4","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"获取账户信息 ","date":"2019-06-22","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:4:0","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"练习区信息 通过对相关请求的分析，练习区信息在http://www.cofool.com/Trade/Stock/index/gid/2.html这个URL下 对页面分析我们所需要的数据在class为top_ts的div下 ","date":"2019-06-22","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:4:1","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"XPath XPath是一门在XML文档中查找信息的语言，可以帮助我们在爬虫中对获取数据进行查找得到我们需要的内容。 推荐从大佬崔庆才的个人博客学习XPath及爬虫的相关内容 开始通过XPath获取对应数据，考虑到多个数据在相同的font标签下，可以一次性获取所有标签然后进行处理 def get_account_info(query_category): \"\"\" 根据query_category获取账户相关信息 :param query_category: 查询类别信息,账户信息:ai 持仓状态:ap 当日委托:ac 当日成交:ad 历史成交:hd 股票收益明细:sd 日资产增长明细：da 月资产增长明细：ma 荣耀榜 ho :return: \"\"\" cookie = login('用户名', '密码') if query_category not in ['ai', 'ap', 'ac', 'ad', 'hd', 'sd', 'da', 'ma', 'ho']: raise Exception('查询类别不存在') if query_category == 'ai': url = 'http://www.cofool.com/Trade/Stock/index/gid/2.html' # 抓取账户相关数据 try: response = requests.get(url=url, cookies=cookie).content.decode() except Exception as e: raise Exception(\"获取账户数据失败，原因为：{}\".format(e)) if '总盈利率' not in response: raise Exception(\"获取账户数据失败，未获取到正确信息\") # 使用xpath对抓取到的数据进行清洗得到我们需要的数据 html = etree.HTML(response) account_info = html.xpath('//div [@class=\"top_ts\"]/div//font/text()') if len(account_info) != 4: raise Exception(\"获取账户数据失败，未获取足够的账户数据\") gross_profit_rate = account_info[0] # 总收益率 initial_funding = account_info[1] # 初始资金 number_of_participants = account_info[2] # 参赛人数 average_income = account_info[3] # 平均收益率 overall_ranking = html.xpath('//div [@class=\"top_ts\"]/div//p[2]/b/text()')[0] # 总排名 try: total_assets = float(''.join(re.search('\\d,\\d*,\\d*.\\d*', html.xpath( '//*[@id=\"left2\"]/table/tbody/tr[1]/td[@class=\"btom zjsr\"]/text()')[0])[0].split(','))) available_funds = float(''.join(re.search('\\d,\\d*,\\d*.\\d*', html.xpath( '//*[@id=\"left2\"]/table/tbody/tr[1]/td[@class=\"btom zjl\"]/text()')[0])[0].split(','))) except Exception as e: raise Exception(\"获取账户数据失败，{}\".format(e)) return {'总收益率': gross_profit_rate, '初始资金': initial_funding, '参赛人数': number_of_participants, '平均收益率': average_income, '总排名': overall_ranking, '总资产': total_assets, '可用资金': available_funds} ","date":"2019-06-22","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:4:2","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"持仓、交易、业绩信息 通过对相关请求的分析，当前持仓、当日委托、当日成交、历史成交与业绩报告都用同一个URL进行请求，只是请求中FormData部分数据不同，分析各页面数据发现当前持仓、当日委托、当日成交、历史成交数据类似，将其作为同一个类型进行爬取做简单修改即可。分页相关信息需要根据页码数据进行追加处理 ... url = 'http://www.cofool.com/Trade/Stock/tradeItem.html' data = {'gid': 'gid', 'uid': 'uid', 'web_id': 'web_id} # 根据查询条件设置对应的type值 if query_category == 'ap': data['type'] = 'position' elif query_category == 'ac': data['type'] = 'entrust' elif query_category == 'ad': data['type'] = 'turnover' elif query_category == 'hd': data['type'] = 'history' elif query_category == 'sd': data['type'] = 'earnings' elif query_category == 'da': data['type'] = 'dayasset' elif query_category == 'ma': data['type'] = 'monthasset' elif query_category == 'ho': data['type'] = 'honor' # 第一次获取对应信息，当信息不存在时返回'暂无交易的数据！' try: response = requests.post(url=url, data=data).content.decode() except Exception as e: raise Exception('获取账户数据失败，原因为：{}'.format(e)) if ' 暂无交易的数据！' in response: return '暂无交易的数据！' html = etree.HTML(response) # 当有信息时获取页码数值， number_of_pages = len(html.xpath('//div [@class = \"clearfix fr\"]/a/text()')) + 1 # 获取对应表头名 col_name = html.xpath('//tr/th/text()') # 设置临时存储字典 temp_dict = {} # 根据页码信息进行第二次访问获取信息 for i in range(1, number_of_pages + 1): # 添加页码数据 data['p'] = i try: response = requests.post(url=url, data=data).content.decode() except Exception as e: raise Exception('获取账户数据失败，原因为：{}'.format(e)) # 由于爬取的数据存在大量\\n和空格，先进行一次简单的清洗 response = re.sub('\\n\\s|\\s', '', response) html = etree.HTML(response) # 分别获取各列信息 for j in range(len(col_name)): xpath_index = j + 1 xpath_values = html.xpath('//tr/td[{}]//text()|//tr/td[{}]/font/text()|//tr/td[{}]/text()'.format(xpath_index, xpath_index,xpath_index)) if i == 1: temp_dict[col_name[j]] = xpath_values # 当出现第二页及其以上时，进行数据追加处理 else: temp_dict[col_name[j]].extend(xpath_values) return pd.DataFrame(temp_dict) ","date":"2019-06-22","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:4:3","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"Feeling 爬虫中数据清洗的过程通常也非常熬人，网站开发者的水平高低与反爬的难度，会导致许多数据清洗起来非常复杂，可能会花费大量的时间还得不到你想要的结果，这时候我们需要保持一颗平常心，针对出现的问题一个一个去解决，只要坚持下去一定能解决的！ ","date":"2019-06-22","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:4:4","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"账户操作 ","date":"2019-06-22","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:5:0","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"股票信息 接下来编写账户操作方面的爬虫，要交易首先要拿到进行交易股票的相关信息，通过分析相关请求后发现其URL为http://www.cofool.com/Trade/Stock/stockQuote.html,这个比较简单很快就可以完成对应代码 def get_stock_info(stock_code): \"\"\" 根据股票代码获取相关价格 :param code:股票代码 :return: 相关价格 \"\"\" url = \"http://www.cofool.com/Trade/Stock/stockQuote.html\" data = { \"code\": stock_code, \"uid\": 'uid', } cookie = login('账户名', '密码') try: response = json.loads(requests.post(url=url, data=data, cookies=cookie).content.decode(\"utf-8-sig\")) except Exception as e: raise Exception('获取账户数据失败，原因为：{}'.format(e)) stock_info = response[\"info\"] info_dict = { \"high_limit\": stock_info[\"surgedLimit\"], # 涨停价 \"low_limit\": stock_info[\"declineLimit\"], # 跌停价 \"stock_name\": stock_info['stockName'], # 股票名称 'currentPrice': stock_info[\"currentPrice\"], # 当前价 } return info_dict ","date":"2019-06-22","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:5:1","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"股票交易 通过观察发现买入与卖出操作的URL差距非常小，并且请求参数也高度相似，可以将其放在同一个方法中 def tradeing(stock_code, tradeing_type, amount=0): \"\"\" 股票交易，并返回交易状态 :param stock_code:股票代码 :param tradeing_type:交易类型 :param amount:交易数量,默认为0防止出现没有填写的情况 :return:交易状态 \"\"\" cookie = login('账户名', '密码') # 获取股票相关信息 info_dict = get_stock_info(stock_code) price = info_dict[\"high_limit\"] # 配置相关数据 data = { \"stockName\": info_dict['stock_name'], \"code\": stock_code, \"uid\": 'uid', \"gid\": 2, \"orderPrice\": price, \"orderAmount\": amount, \"declineLimit\": info_dict['low_limit'], \"surgedLimit\": info_dict['high_limit'] } if tradeing_type == 'buy': url = \"http://www.cofool.com/Trade/Stock/buy.html\" # 买入操作，检测买入数量防止超过最大买入数量 available_funds = get_account_info('ai')['可用资金'] if amount \u003c available_funds / float(price): data[\"orderAmount\"] = amount else: raise Exception('购买数量超过最大可购买数量') elif tradeing_type == 'sell': url = \"http://www.cofool.com/Trade/Stock/sell.html\" # 卖出操作，从持仓信息中获取可卖出数量 data[\"orderAmount\"] = get_amount(stock_code) try: content = \\ requests.post(url=url, data=data, cookies=cookie).content.decode(\"utf-8-sig\") status = json.loads(content, encoding=\"unicode_escape\")[\"status\"] except Exception as e: raise Exception('获取账户数据失败，原因为：{}'.format(e)) if status == 1: print(\"买入股票：{}，股数：{}\".format(stock_code, amount)) return 0 else: raise Exception(\"买入失败，失败原因为：{}\".format(json.loads(content, encoding=\"unicode_escape\")[\"info\"])) ","date":"2019-06-22","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:5:2","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"持仓数量 在卖出交易的时候需要获取账户中持仓的数量 def get_amount(code): \"\"\"根据股票代码获取可交易数量 :param code:股票代码 :return:对应股票可用数量 \"\"\" url = \"http://www.cofool.com/Trade/Stock/sellAmount\" data = { \"code\": code, \"uid\": 'uid', \"web_id\": 'web_id' } cookie = login('账户名', '密码') try: content = json.loads(requests.post(url=url, data=data, cookies=cookie).content.decode('unicode_escape')) except Exception as e: raise Exception(\"获取股数数据失败，{}\".format(e)) status = content['status'] if status == 1: amount = content['info']['frozen_amount'] return amount else: raise Exception(content['info']) 到这里叩富网的爬虫基本完成了，最后将转化为类就可以了，完整代码可以在我的GitHub仓库查看最新的代码 ","date":"2019-06-22","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:5:3","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["一篇文章学会系列"],"content":"一篇文章学会Vim","date":"2019-06-15","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Avim/","tags":["工具","教程"],"title":"一篇文章学会Vim","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Avim/"},{"categories":["一篇文章学会系列"],"content":"声明：以下内容均为我个人的理解，如果发现错误或者疑问可以联系我共同探讨 ","date":"2019-06-15","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Avim/:0:0","tags":["工具","教程"],"title":"一篇文章学会Vim","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Avim/"},{"categories":["一篇文章学会系列"],"content":"简介 Vim是一个高度可定制的终端文本编辑器，它可以很方便的创建和修改任何类型的文本。作为vi的升级版，有许多新的特性(以下列出的特性为比较常用的，详细特性可以查看help vi_diff.)： 无限撤销：可以无限制的撤销 可移植性：Vi仅在Unix上可用，Vim还可以在Windows、Macintosh，Amiga，OS / 2，VMS，QNX和其他系统上运行。 语法高亮：当用Vim进行编程的时候，他可以根据正在编辑的文件类型，使其以内容以不同的颜色或样式突出显示。Vim捆绑了数百种语法突出显示规则集。 图形用户界面：Vim在控制台上运行良好，也可以在许多GUI中本地运行，包括Mac OS和Windows。它还可以操作剪贴板。 vi兼容模式：紧要关头，您可以强制Vim像vi一样。使Vim与vi不兼容的所有改进和错误修复都已关闭，您将获得100％与vi兼容的编辑器。 Vim作为许多程序员最喜欢的文本编辑器之一，它具有像：多级撤销、代码补全、支持数百种编程语言和文本格式、强大的搜索和替换功能等。 ","date":"2019-06-15","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Avim/:1:0","tags":["工具","教程"],"title":"一篇文章学会Vim","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Avim/"},{"categories":["一篇文章学会系列"],"content":"安装与卸载 ","date":"2019-06-15","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Avim/:2:0","tags":["工具","教程"],"title":"一篇文章学会Vim","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Avim/"},{"categories":["一篇文章学会系列"],"content":"安装 Windows 先把安装包下载下来，然后根据提示安装。 Unix 在Github上下载源文件安装 Mac 在github下载，根据文件类型安装。 详细安装教程 ","date":"2019-06-15","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Avim/:2:1","tags":["工具","教程"],"title":"一篇文章学会Vim","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Avim/"},{"categories":["一篇文章学会系列"],"content":"卸载 Unix or Mac 源代码安装 在控制台输入 make uninstall 软件包管理器安装 根据不同软件包管理器的卸载命令卸载 Windows 找到安装目录下的 “uninstall-gui” 程序进行卸载 ","date":"2019-06-15","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Avim/:2:2","tags":["工具","教程"],"title":"一篇文章学会Vim","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Avim/"},{"categories":["一篇文章学会系列"],"content":"教程 ","date":"2019-06-15","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Avim/:3:0","tags":["工具","教程"],"title":"一篇文章学会Vim","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Avim/"},{"categories":["一篇文章学会系列"],"content":"vimtutor Vim自带教程vimtutor是你从零开始学习Vim最好的老师，教程包含了日常所需要的各个命令和功能，还有实操教学。如果你的系统语言是中文，那么打开vimtutor时默认是中文版的教程，中文版教程由梁昌泰 先生进行译制。在命令行中输入vimtutor，就可以打开该教程,学习完该教程大约需要30分钟左右。 有一款游戏Vim Adventure，可以作为学习Vim的一种放松。 Vimtutor章节小结 第一讲 光标在屏幕文本中的移动既可以用箭头键，也可以使用 hjkl 字母键。 ​ h (左移) j (下行) k (上行) l (右移) 欲进入 Vim 编辑器(从命令行提示符)，请输入：vim 文件名 \u003c回车\u003e 欲退出 Vim 编辑器，请输入 :q! \u003c回车\u003e 放弃所有改动。或者输入 :wq \u003c回车\u003e 保存改动。 在正常模式下删除光标所在位置的字符，请按： x 欲插入或添加文本，请输入： ​ i 输入欲插入文本 在光标前插入文本 ​ A 输入欲添加文本 在一行后添加文本 特别提示：按下 键会带您回到正常模式或者撤消一个不想输入或部分完整的命令。 第二讲 欲从当前光标删除至下一个单词，请输入：dw 欲从当前光标删除至当前行末尾，请输入：d$ 欲删除整行，请输入：dd 欲重复一个动作，请在它前面加上一个数字：2w 在正常模式下修改命令的格式是： operator [number] motion 其中： ​ operator - 操作符，代表要做的事情，比如 d 代表删除 ​ [number] - 可以附加的数字，代表动作重复的次数 ​ motion - 动作，代表在所操作的文本上的移动，例如 w 代表单词(word)，$ 代表行末等等。 欲移动光标到行首，请按数字0键：0 欲撤消以前的操作，请输入：u (小写的u)，欲撤消在一行中所做的改动，请输入：U (大写的U)，欲撤消以前的撤消命令，恢复以前的操作结果，请输入：CTRL-R 第三讲 要重新置入已经删除的文本内容，请按小写字母 p 键。该操作可以将已删除的文本内容置于光标之后。如果最后一次删除的是一个整行，那么该行将置于当前光标所在行的下一行。 要替换光标所在位置的字符，请输入小写的 r 和要替换掉原位置字符的新字符即可。 更改类命令允许您改变从当前光标所在位置直到动作指示的位置中间的文本。比如输入 ce 可以替换当前光标到单词的末尾的内容；输入 c$ 可以替换当前光标到行末的内容。 更改类命令的格式是： c [number] motion 第四讲 CTRL-G 用于显示当前光标所在位置和文件状态信息。 G 用于将光标跳转至文件最后一行。先敲入一个行号然后输入大写 G 则是将光标移动至该行号代表的行。gg 用于将光标跳转至文件第一行。 输入 / 然后紧随一个字符串是在当前所编辑的文档中正向查找该字符串。输入 ? 然后紧随一个字符串则是在当前所编辑的文档中反向查找该字符串。完成一次查找之后按 n 键是重复上一次的命令，可在同一方向上查找下一个匹配字符串所在；或者按大写 N 向相反方向查找下一匹配字符串所在。CTRL-O 带您跳转回较旧的位置，CTRL-I 则带您到较新的位置。 如果光标当前位置是括号(、)、[、]、{、}，按 % 会将光标移动到配对的括号上。 在一行内替换头一个字符串 old 为新的字符串 new，请输入 :s/old/new 在一行内替换所有的字符串 old 为新的字符串 new，请输入 :s/old/new/g 在两行内替换所有的字符串 old 为新的字符串 new，请输入 :#,#s/old/new/g 在文件内替换所有的字符串 old 为新的字符串 new，请输入 :%s/old/new/g 进行全文替换时询问用户确认每个替换需添加 c 标志 :%s/old/new/gc 第五讲 :!command 用于执行一个外部命令 command。 请看一些实际例子： (MS-DOS) (Unix) :!dir :!ls # 用于显示当前目录的内容。 :!del FILENAME :!rm FILENAME # 用于删除名为 FILENAME 的文件。 :w FILENAME 可将当前 VIM 中正在编辑的文件保存到名为 FILENAME 的文件中。 v motion :w FILENAME 可将当前编辑文件中可视模式下选中的内容保存到文件FILENAME 中。 :r FILENAME 可提取磁盘文件 FILENAME 并将其插入到当前文件的光标位置后面。 :r !dir 可以读取 dir 命令的输出并将其放置到当前文件的光标位置后面。 第六讲 输入小写的 o 可以在光标下方打开新的一行并进入插入模式。输入大写的 O 可以在光标上方打开新的一行。 输入小写的 a 可以在光标所在位置之后插入文本。输入大写的 A 可以在光标所在行的行末之后插入文本。 e 命令可以使光标移动到单词末尾。 操作符 y 复制文本，p 粘贴先前复制的文本。 输入大写的 R 将进入替换模式，直至按 键回到正常模式。 输入 :set xxx 可以设置 xxx 选项。一些有用的选项如下： ‘ic’ ‘ignorecase’ 查找时忽略字母大小写 ‘is’ ‘incsearch’ 查找短语时显示部分匹配 ‘hls’ ‘hlsearch’ 高亮显示所有的匹配短语 选项名可以用完整版本，也可以用缩略版本。 在选项前加上 no 可以关闭选项： :set noic 第七讲 输入 :help 或者按 键或 键可以打开帮助窗口。 输入 :help cmd 可以找到关于 cmd 命令的帮助。 输入 CTRL-W CTRL-W 可以使您在窗口之间跳转。 输入 :q 以关闭帮助窗口 您可以创建一个 vimrc 启动脚本文件用来保存您偏好的设置。 当输入 : 命令时，按 CTRL-D 可以查看可能的补全结果。 按 可以使用一个补全。 ","date":"2019-06-15","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Avim/:3:1","tags":["工具","教程"],"title":"一篇文章学会Vim","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Avim/"},{"categories":["一篇文章学会系列"],"content":"帮助 在控制台中输入vim就可以查看Vim的相关信息 根据图片所示我们可以知道，当前VIM的版本为8.0.1365，想退出需要输入”:q”，查看在线帮助文档可以输入”:help”，查看版本信息可以输入”:help version8” 在英文模式下输入”:help\"回车后便可以看到 在这里有详细的Vim教程，教你玩转Vim。 ","date":"2019-06-15","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Avim/:3:2","tags":["工具","教程"],"title":"一篇文章学会Vim","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Avim/"},{"categories":["一篇文章学会系列"],"content":"一篇文章学会Linux","date":"2019-06-09","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Alinux/","tags":["操作系统","教程"],"title":"一篇文章学会Linux","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Alinux/"},{"categories":["一篇文章学会系列"],"content":"声明：以下内容均为我个人的理解，如果发现错误或者疑问可以联系我共同探讨 ","date":"2019-06-09","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Alinux/:0:0","tags":["操作系统","教程"],"title":"一篇文章学会Linux","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Alinux/"},{"categories":["一篇文章学会系列"],"content":"简介 ","date":"2019-06-09","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Alinux/:1:0","tags":["操作系统","教程"],"title":"一篇文章学会Linux","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Alinux/"},{"categories":["一篇文章学会系列"],"content":"Linux Linux是一种自由和开放源码的类UNIX操作系统。该操作系统的内核由林纳斯·托瓦兹在1991年10月5日首次发布，在加上用户空间的应用程序之后，成为Linux操作系统。只要遵循GNU 通用公共许可证（GPL），任何个人和机构都可以自由地使用Linux的所有底层源代码，也可以自由地修改和再发布。大多数Linux系统还包括像提供GUI的X Window之类的程序。除了一部分专家之外，大多数人都是直接使用Linux 发行版，而不是自己选择每一样组件或自行设置。详细介绍 ","date":"2019-06-09","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Alinux/:1:1","tags":["操作系统","教程"],"title":"一篇文章学会Linux","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Alinux/"},{"categories":["一篇文章学会系列"],"content":"linux发行版 Linux发行版指的就是通常所说的“Linux操作系统”，它一般是由一些组织、团体、公司或者个人将Linux内核作为发行版的一部分制作并发行的。通常来讲，一个Linux发行版包括Linux内核，以及将整个软件安装到电脑上的一套安装工具，还有各种GNU软件，和其他的一些自由软件，在一些Linux发行版中可能会包含一些专有软件。当前，超过三百个发行版被积极的开发，最普遍被使用的发行版有大约十二个。较为知名的有Debian、Ubuntu、Fedora和openSUSE等。 Linux发行版份额排名，也可以在Linux终端用命令查看：wget -qO - 7z.cx/o|sh，Ubuntu以39.1%的占比遥遥领先，中国武汉深之度科技有限公司开发的deepin是国产Linux发行版中排名最高的，占比12.6%在排行榜中排名第三（截止于2020-01-10 13:54:19） ","date":"2019-06-09","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Alinux/:1:2","tags":["操作系统","教程"],"title":"一篇文章学会Linux","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Alinux/"},{"categories":["一篇文章学会系列"],"content":"安装 如果是初次安装系统建议先通过在虚拟机上安装。 ","date":"2019-06-09","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Alinux/:2:0","tags":["操作系统","教程"],"title":"一篇文章学会Linux","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Alinux/"},{"categories":["一篇文章学会系列"],"content":"下载 下面提供较为知名的Linux发行版下载地址 Ubuntu、manjaro、deepin、CentOS、Arch、Debian、Mint、Fedora Linux发行版提供了Server版和Desktop版，初次使用建议直接安装Server版。 ","date":"2019-06-09","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Alinux/:2:1","tags":["操作系统","教程"],"title":"一篇文章学会Linux","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Alinux/"},{"categories":["一篇文章学会系列"],"content":"安装 以Ubuntu Server 16.10为例 将镜像写入U盘后，开机以U盘为第一启动项启动，可以看到以下界面 选择第一项安装Ubuntu Server 下一步选择语言，这里选择英语，防止乱码与文件名是中文的问题 下一步选择区域，没有中国，所以先选其他 接下来选择亚洲Asia 接着选这中国 下一步选择字符集，这里选择美国的UTF-8字符集，即en_US.UTF-8 下一步检测键盘，选择否 接着让我们设置键盘的类型与布局 下一步是设置主机名称，默认为ubuntu，可以改为你喜欢的名称 设置用户名 下一步设置登陆账号 设置密码，可以在下面选择显示密码，可以确认一次 再次输入，确认密码 是否加密home文件夹，选择否 下一步系统根据区域推断出我们的市区是上海，没有问题，所以选择是 选择分区方式，这里选择Guided - use entire disk and set up LVM 选择安装的硬盘 这里告诉我们会格式化这个盘确认选择 选择自动安装 确认分区 确认安装 选择代理，没有就跳过 选择升级方式，这里选择不自动升级No automatic updates 安装完成后会重启，选择ubuntu启动即可 进入系统后输入用户名密码就可以登录上ubuntu了，到此安装完毕 ","date":"2019-06-09","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Alinux/:2:2","tags":["操作系统","教程"],"title":"一篇文章学会Linux","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Alinux/"},{"categories":["一篇文章学会系列"],"content":"linux 根目录 ","date":"2019-06-09","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Alinux/:3:0","tags":["操作系统","教程"],"title":"一篇文章学会Linux","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Alinux/"},{"categories":["Flask"],"content":"Flask搭建个人博客","date":"2019-05-26","objectID":"/flask%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","tags":["Flask"],"title":"Flask搭建个人博客","uri":"/flask%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Flask"],"content":"本教程中我们将从0开始搭建一个完整的个人博客。 开发环境说明 本教程开发环境为MacOS Mojave10.14.6，Python版本为3.6.6，flask版本为1.0.2。 为了避免不必要的麻烦，尽可能的与我的开发环境保持一致。Python版本必须为3.x以上，建议3.6.x的版本，flask版本必须为1.0.x。 ","date":"2019-05-26","objectID":"/flask%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:0:0","tags":["Flask"],"title":"Flask搭建个人博客","uri":"/flask%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Flask"],"content":"Flask入门教程","date":"2019-05-19","objectID":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/","tags":["Flask"],"title":"Flask入门教程","uri":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"categories":["Flask"],"content":"简介 Flask是由Armin ronacher于2010年用Python语言基于 Werkzeug 工具箱编写的轻量级Web开发框架。 ","date":"2019-05-19","objectID":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:1:0","tags":["Flask"],"title":"Flask入门教程","uri":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"categories":["Flask"],"content":"特点 Flask只提供核心功能，其他几乎所有的功能都需要用到拓展，比如可以通过Flask-SQLAlchemy拓展对数据库进行操作等等。 ","date":"2019-05-19","objectID":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:2:0","tags":["Flask"],"title":"Flask入门教程","uri":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"categories":["Flask"],"content":"核心 由Werkzeug与Jinja2组成，Werkzeug是一个全面的WSGI Web应用程序库，Jinja是一种现代且设计友好的Python模板语言。 ","date":"2019-05-19","objectID":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:3:0","tags":["Flask"],"title":"Flask入门教程","uri":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"categories":["Flask"],"content":"Flask常用扩展 Flask-SQLalchemy：操作数据库 Flask-script：插入脚本 Flask-migrate：管理迁移数据库 Flask-Session：Session存储方式指定 ","date":"2019-05-19","objectID":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:4:0","tags":["Flask"],"title":"Flask入门教程","uri":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"categories":["Flask"],"content":"相关文档 中文文档 英文文档 ","date":"2019-05-19","objectID":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:5:0","tags":["Flask"],"title":"Flask入门教程","uri":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"categories":["Flask"],"content":"Flask初体验 ","date":"2019-05-19","objectID":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:6:0","tags":["Flask"],"title":"Flask入门教程","uri":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"categories":["Flask"],"content":"安装并使用虚拟环境 virtualenv 创建和管理虚拟环境 # 安装 pip install virtualenv # 创建 virtualenv flask_env # 使用 source flask_env/bin/activate Pipenv 创建和管理虚拟环境 # 安装 pip install pipenv # 创建 pipenv install # 使用 pipenv shell ","date":"2019-05-19","objectID":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:6:1","tags":["Flask"],"title":"Flask入门教程","uri":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"categories":["Flask"],"content":"安装指定版本flask框架 sudo pip install flask==1.0.2 ","date":"2019-05-19","objectID":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:6:2","tags":["Flask"],"title":"Flask入门教程","uri":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"categories":["Flask"],"content":"创建一个文件，并带入编写第一个Flask程序 touch helloflask.py vim helloflask.py 在文件中写入以下代码 # 导入Flask类 from flask import Flask # 传递__name__参数，创建一个叫app的Flask实例，该实例将会成为我们的 WSGI 应用。 app = Flask(__name__) # 通过route装饰器来告诉Flask触发函数的URL @app.route('/') # index视图函数，在访问根路径时会调用该函数通过其返回值得到结果 def index(): return 'Hello Flask' if __name__ == '__main__': # 通过run方法启动web服务器 app.run() 退出编辑模式，运行该程序 python helloflask.py 可以看到以下结果 这样就启动了一个非常简单的内建的服务器。这个服务器用于测试应该是足够了，但是 用于生产可能是不够的。现在在浏览器中打开 http://127.0.0.1:5000/ ，应该可以看到 Hello Flask! 字样。 ","date":"2019-05-19","objectID":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:6:3","tags":["Flask"],"title":"Flask入门教程","uri":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"categories":["Flask"],"content":"相关配置参数 ","date":"2019-05-19","objectID":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:7:0","tags":["Flask"],"title":"Flask入门教程","uri":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"categories":["Flask"],"content":"初始化参数 创建Flask项目的第一步就是实例化Flask对象，以下是实例化对象需要的参数详解 import_name：Flask程序所在的包(模块)，传 __name__ 就可以， static_url_path：静态文件访问路径，可以不传，默认为：/ + static_folder static_folder：静态文件存储的文件夹，可以不传，默认为 static static_host：使用远程主机存储静态文件的地址，默认为None。当host_matching为True时，可以通过static_folder配置静态文件存储的文件夹 host_matching：设置url_map.host_matching属性，默认为False subdomain_matching：匹配路由时，请考虑与以下项相关的子域：data:`SERVER_NAME’。默认为False。 template_folder：模板文件存储的文件夹，可以不传，默认为 templates instance_path：默认情况下，应用程序的备用实例路径假定包或模块旁边的文件夹“instance”为实例路径。 instance_relative_config：如果将用于加载配置的相对文件名设置为“True”，则假定该文件名相对于实例路径而不是应用程序根。 root_path：默认情况下，Flask将自动计算应用程序根路径。在某些情况下，这无法实现（例如，如果包是Python 3命名空间包），需要手动定义。 ","date":"2019-05-19","objectID":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:7:1","tags":["Flask"],"title":"Flask入门教程","uri":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"categories":["Flask"],"content":"程序加载配置 在Flask程序运行前，我们可以给Flask设置相关配置，例如ENV(应用程序在什么环境中运行)，DEBUG(是否启用调试模式)TESTING(启用测试模式)等配置，常见的有两种方式来实现. 从配置文件中加载：app.config.from_pyfile() 创建一个配置文件 touch config.ini vim config.ini 写入配置信息 DEBUG = True 选择从配置文件加载 # 创建 Flask 类对象,指向程序所在的包的名称 app = Flask(__name__) # 从配置文件中加载配置 app.config.from_pyfile('config.ini') 从配置对象中加载：app.config.from_object() 创建一个配置类，然后将类名传入即可 # 配置类 class ConfigObject(object): DEBUG = True # 创建 Flask 类对象,指向程序所在的包的名称 app = Flask(__name__) # 从配置对象中加载配置 app.config.from_object(Config) ","date":"2019-05-19","objectID":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:7:2","tags":["Flask"],"title":"Flask入门教程","uri":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"categories":["Flask"],"content":"程序运行配置 这个demo中Flask项目程序启动的入口是app.run()。常见的配置选项有host, port,debug，分别是设置运行主机的ip地址，端口号，是否打开调试模式，当配置文件与这里都有debug时，最终会以这里的debug为准。 app.run(host=\"127.0.0.1\", port=8000) 路由 在Web开发中，路由是一种将URL转发到对应视图的程序。 ","date":"2019-05-19","objectID":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:7:3","tags":["Flask"],"title":"Flask入门教程","uri":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"categories":["一篇文章学会系列"],"content":"一篇文章学会Git","date":"2019-05-11","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/","tags":["工具","教程"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"简介 ","date":"2019-05-11","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:0","tags":["工具","教程"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"什么是Git Git是一个免费的开源分布式版本控制系统，也是目前为止世界上最先进的分布式版本控制系统。Git官方有一个视频介绍，可以点此观看 什么是版本控制系统？ 一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。简单点理解就是一个可以帮助我们记录文件修改的系统。Git官方有一个视频介绍，可以点此观看 什么是分布式版本控制系统？ 分布式版本控制系统时相对于集中式版本控制系统的。 集中式版本控制系统将仓库存放在中央服务器中集中管理，当你需要时从中央服务器中拉取最新的版本，修改完后将修改提交给中央服务器。这就会带来例如当中央服务器宕机时整个版本控制系统就会崩溃；推送或者拉取一个较大的文件时就会消耗很多时间等弊端。 分布式版本控制系统中，每个人电脑都是一个仓库，自己的文件可以在本地管理，当需要多人协同时只需要管理好本地仓库与协同仓库的版本即可 ","date":"2019-05-11","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:1","tags":["工具","教程"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"Git有什么作用 进行源代码管理 ","date":"2019-05-11","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:2","tags":["工具","教程"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"为什么要进行源代码管理 方便多人协同开发 方便代码版本控制 ","date":"2019-05-11","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:3","tags":["工具","教程"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"Git的特点 分布式版本控制系统，服务器和客户端都有版本控制能力,都能进行代码的提交、合并等操作。 在使用Git的时候会自动创建一个.git的隐藏文件夹作为本地仓库 ","date":"2019-05-11","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:4","tags":["工具","教程"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"Git操作流程 clone：第一次从Git服务器获取项目 add：将修改添加到本地仓库 commit：将修改提交到本地仓库 push：将本地仓库的修改提交到Git服务器 pull：将Git服务器中的项目获取到本地仓库 ","date":"2019-05-11","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:5","tags":["工具","教程"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"Git仓库 什么是仓库 仓库的英文名是repository，又被称为版本库。它是一个被Git管理的文件目录。 ","date":"2019-05-11","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:6","tags":["工具","教程"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"工作区，暂存区和仓库 工作区：对代码的新增，修改，删除等操作的区域。 暂存区：存储工作区的操作的区域。 仓库区：即本地仓库区域，会记录完成的操作与历史版本。 ","date":"2019-05-11","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:7","tags":["工具","教程"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"Git操作 安装 Mac 在mac上有多种方法可以安装Git，最简单的事通过Xcode命令行工具安装。 通过Xcode安装 1.下载并安装Xcode 2.在终端中运行git即可，如果尚未安装，它将提示您安装。 通过homebrew安装 1.安装homebrew $ /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" 2.安装git $ brew install git 通过安装包安装 1.点击此下载最新版本 2.下载完成后打开安装包，一直下一步安装即可 Linux 在Linux发行版上安装GIt，可以通过附带的软件包管理工具来安装 Debian/Ubuntu $ apt-get install git 其他发行版本见这个链接 Windows 下载安装包 根据操作系统位数选择，链接 安装默认选项安装即可 安装完成后通过可以通过git --version查看安装版本 ","date":"2019-05-11","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:8","tags":["工具","教程"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"配置Git 配置文件介绍 Git有一个git config的工具，可以设置和获取配置，用来控制Git外观及操作。这些变量可以存放在三个不同的位置，根据存放位置不同作用的范围也不同。 1./etc/gitconfig：包含系统上每个用户及其存储库的配置。 2.~/.gitconfig或~/.config/git/config：每个用户专属的配置 3.config.git/config：当前使用存储库的git目录，用于该存储库的配置 如果有相同配置项时，每个级别都会覆盖上一个级别中的值，即：3\u003e2\u003e1 可以使用一下命令查看所有设置以及设置的所属： $ git config --list --show-origin 常见配置 下面介绍一些常见配置 身份配置 安装完Git做的第一件事应该是设置用户名和电子邮箱。 $ git config --global user.name \"John Doe\" $ git config --global user.email johndoe@example.com 使用global后，该信息将会始终作用域Git操作上 Git编辑器配置 Git默认的编辑器是系统默认编辑器 如果要是用其他文本编辑器（例如vim），则可以执行以下操作： $ git config --global core.editor vim 查看配置 如果要查看配置，可以使用git config --list命令列出Git可以找到的所有设置 你可能会看到很多配置项，找不到你想要的，这时候你可以通过git config \u003ckey\u003e来查看特定的配置，例： $ git config user.name silencehuliang ","date":"2019-05-11","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:9","tags":["工具","教程"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"帮助 获取方式 Git获取帮助的方式有三种git help \u003cverb\u003e、git \u003cverb\u003e --help、man git-\u003cverb\u003e 例如，可以通过git help config获取config的相关帮助 如果只需要快速了解Git命令的可用选项也可以用-h来查看相关帮助 例如git add -h ","date":"2019-05-11","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:10","tags":["工具","教程"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"创建项目 1.将本地不收版本控制的目录转换为Git仓库 ①进入本地目录 $ cd ~/Desktop/project ②输入转化命令 $ git init 此时会在当前目录下创建一个.git目录，里面存放着Git仓库中所有的必须文件 $ ls -a . .. .git 2.从其他地方克隆现有的Git仓库 ①进入我们需要存放仓库的路径 $ cd ~/Desktop/ ②将现有的仓库克隆下来 $ git clone https://github.com/Silencehuliang/project ","date":"2019-05-11","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:11","tags":["工具","教程"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"查看状态 可以通过git status 查看仓库中稳健的状态 绿色表示文件在暂存区 红色表示文件在工作区 可以通过git add 将工作区文件添加到暂存区 添加项目中所有文件：git add . 添加指定文件：git add xxx.py 可以通过git commit将暂存区文件提交到仓库区 git commit -m \"修改描述\"，其中-m参数后面跟的是对本次修改的描述 git commit -am \"修改描述\",可以通过-am来实现添加和提交合并操作 ","date":"2019-05-11","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:13","tags":["工具","教程"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"查看历史版本 通过git log或者git relog可以查看历史版本 ","date":"2019-05-11","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:14","tags":["工具","教程"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"回退版本 通过版本号会退版本 git reset --hard 版本号 通过HEAD回退版本 当工作区文件发生了意外需要回退到上一个版本时可以通过 `git reset --hard HEAD` HEAD表示当前最新版本 HEAD^表示当前最新版本的前一个版本 HEAD^^表示当前最新版本的前两个版本，以此类推… HEAD~1表示当前最新版本的前一个版本 HEAD~10表示当前最新版本的前10个版本，以此类推… ","date":"2019-05-11","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:15","tags":["工具","教程"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"撤销修改 只能撤销工作区、暂存区的代码,不能撤销仓库区的代码 撤销仓库区的代码就相当于回退版本操作 撤销工作区代码 新加代码num3 = 30，不add到暂存区，保留在工作区 git checkout 文件名 撤销暂存区代码 新加代码num3 = 30，并add到暂存区 # 第一步：将暂存区代码撤销到工作区 git reset HEAD 文件名 # 第二步：撤销工作区代码 git checkout 文件名 ","date":"2019-05-11","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:16","tags":["工具","教程"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"对比版本 对比版本库与工作区 新加代码num3 = 30，不add到暂存区，保留在工作区 git diff HEAD -- xxx.py 对比版本库 新加代码num3 = 30，并add到暂存区 git diff HEAD HEAD^ -- xxx.py ","date":"2019-05-11","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:17","tags":["工具","教程"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"删除文件 删除文件分为确定删除和误删 在项目中新建test.py文件，并添加和提交到仓库 确定删除处理： # 删除文件 rm 文件名 # git确定删除文件，对比添加文件git add git rm 文件名 # 删除后记录删除操作版本 git commit -m '删除描述' 误删处理：撤销修改即可 # 删除文件 rm 文件名 # git撤销修改 git checkout -- 文件名 ","date":"2019-05-11","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:18","tags":["工具","教程"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"代码冲突 提示：多人协同开发时，避免不了会出现代码冲突的情况 原因：多人同时修改了同一个文件 危害：会影响正常的开发进度 注意：一旦出现代码冲突，必须先解决再做后续开发 解决冲突 原则：谁冲突谁解决，并且一定要协商解决 方案：保留所有代码 或者 保留某一人代码 解决完冲突代码后，依然需要add、commit、push，如果执行pull没有影响，就算真正解决了冲突代码 补充： 容易冲突的操作方式 多个人同时操作了同一个文件 一个人一直写不提交 修改之前不更新最新代码 提交之前不更新最新代码 擅自修改同事代码 减少冲突的操作方式 养成良好的操作习惯,先pull在修改,修改完立即commit和push 一定要确保自己正在修改的文件是最新版本的 各自开发各自的模块 如果要修改公共文件,一定要先确认有没有人正在修改 下班前一定要提交代码,上班第一件事拉取最新代码 一定不要擅自修改同事的代码 ","date":"2019-05-11","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:19","tags":["工具","教程"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"标签 当某一个大版本完成之后,需要打一个标签 作用： 记录大版本 备份大版本代码 在本地打标签 git tag -a 标签名 -m '标签描述' 推送标签到远程仓库 git push origin 标签名 删除本地和远程标签 # 删除本地标签 git tag -d 标签名 # 删除远程仓库标签 git push origin --delete tag 标签名 ","date":"2019-05-11","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:20","tags":["工具","教程"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"分支 作用： 区分生产环境代码以及开发环境代码 研究新的功能或者攻关难题 解决线上bug 特点： 项目开发中公用分支包括master、dev 分支master是默认分支，用于发布，当需要发布时将dev分支合并到master分支 分支dev是用于开发的分支，开发完阶段性的代码后，需要合并到master分支 查看当前分支 git branch 创建并切换到dev分支 git checkout -b dev 设置本地分支跟踪远程指定分支（将分支推送到远程） git push -u origin dev 分支合并到master分支 先切换到master分支 git checkout master 分支合并到master分支 git merge dev ","date":"2019-05-11","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:21","tags":["工具","教程"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["Django"],"content":"Django2.x搭建博客","date":"2019-04-20","objectID":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/","tags":["博客","Django"],"title":"Django2.x搭建博客","uri":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Django"],"content":"声明：以下内容均为我个人的理解，如果发现错误或者疑问可以联系我共同探讨 ","date":"2019-04-20","objectID":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:0:0","tags":["博客","Django"],"title":"Django2.x搭建博客","uri":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Django"],"content":"简介 学完Django2.x可以搭建一个个人博客练练手 ","date":"2019-04-20","objectID":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:1:0","tags":["博客","Django"],"title":"Django2.x搭建博客","uri":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Django"],"content":"教程 ","date":"2019-04-20","objectID":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:2:0","tags":["博客","Django"],"title":"Django2.x搭建博客","uri":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Django"],"content":"创建项目 通过pycharm创建博客项目与虚拟环境 ","date":"2019-04-20","objectID":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:2:1","tags":["博客","Django"],"title":"Django2.x搭建博客","uri":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Django"],"content":"修改相关设置 允许任何域名 在开发和测试的时候可以将这里填为*，后期部署上线后修改为指定域名即可 ALLOWED_HOSTS = ['*'] 注册应用 INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', # 注册应用，当使用pycharm创建时会帮我们自动创建 'post.apps.PostConfig', ] 配置模版 TEMPLATES = [ { # 选择我们的模板引擎，刚刚用pycharm创建时已选择django自带的模板引擎 'BACKEND': 'django.template.backends.django.DjangoTemplates', # 注册我们模版文件夹的位置，刚刚用pycharm创建时已将名字定为`templates` 'DIRS': [os.path.join(BASE_DIR, 'templates')] , 'APP_DIRS': True, 'OPTIONS': { 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', ], }, }, ] 注册完后，在项目根目录中（即manage.py所在的目录）创建templates文件夹，使用pycharm创建项目会自动帮我们创建 配置数据库 DATABASES = { 'default': { # 选择使用的数据库类型，这里为mysql 'ENGINE': 'django.db.backends.mysql', # 数据库名称 'NAME': 'djangoblog', # 数据库用户名 'USER': 'root', # 数据库密码 'PASSWORD': '123456', # 数据库ip，留空默认为localhost 'HOST': '', # 数据库端口，留空默认为3306 'PORT': '3306', } } 创建mysql数据库 在注册完数据库后创建mysql数据库 \u003e\u003e\u003e mysql -uroot -p mysql\u003e create database djangoblog charset=utf8; mysql\u003e show databases; +--------------------+ | Database | +--------------------+ | information_schema | | blog | | djangoblog | | mysql | | performance_schema | | sys | +--------------------+ 6 rows in set (0.01 sec) 数据库迁移 接下来进行数据库迁移，并创建django-admin管理员 按照之前的文章：Django2.0正确配置MySQL，配置好MySQL数据库 接下来再进行数据库迁移 (DjangoBlogEnv) hls-MacBook-Pro:DjangoBlog hl$ python manage.py makemigrations No changes detected (DjangoBlogEnv) hls-MacBook-Pro:DjangoBlog hl$ python manage.py migrate Operations to perform: Apply all migrations: admin, auth, contenttypes, sessions Running migrations: Applying contenttypes.0001_initial... OK Applying auth.0001_initial... OK Applying admin.0001_initial... OK Applying admin.0002_logentry_remove_auto_add... OK Applying admin.0003_logentry_add_action_flag_choices... OK Applying contenttypes.0002_remove_content_type_name... OK Applying auth.0002_alter_permission_name_max_length... OK Applying auth.0003_alter_user_email_max_length... OK Applying auth.0004_alter_user_username_opts... OK Applying auth.0005_alter_user_last_login_null... OK Applying auth.0006_require_contenttypes_0002... OK Applying auth.0007_alter_validators_add_error_messages... OK Applying auth.0008_alter_user_username_max_length... OK Applying auth.0009_alter_user_last_name_max_length... OK Applying auth.0010_alter_group_name_max_length... OK Applying auth.0011_update_proxy_permissions... OK Applying sessions.0001_initial... OK 出现Applying sessions.0001_initial… OK 代表mysql数据库已配置完成，接下来创建django-admin管理员 (DjangoBlogEnv) hls-MacBook-Pro:DjangoBlog hl$ python manage.py createsuperuser 用户名 (leave blank to use 'hl'): silencehl 电子邮件地址: silencehuliang@163.com Password: Password (again): 密码跟 用户名 太相似了。 密码长度太短。密码必须包含至少 8 个字符。 这个密码太常见了。 Bypass password validation and create user anyway? [y/N]: y Superuser created successfully. 出现Superuser created successfully.这一阶段数据库配置已完成，这里产生的数据库是Django自带的一些库 其他设置 区域语言设置，防止admin界面乱码 # 设置语言为中文 LANGUAGE_CODE = 'zh-hans' # 设置时区为上海 TIME_ZONE = 'Asia/Shanghai' 静态文件夹与多媒体文件夹设置 # 设置静态文件目录和名称 STATIC_URL = '/static/' # 设置静态文件夹目录的路径 STATICFILES_DIRS = ( os.path.join(BASE_DIR, 'static'), ) # 设置多媒体文件目录和名称 MEDIA_URL = '/media/' # 设置多媒体文件目录的路径 MEDIA_ROOT = os.path.join(BASE_DIR, 'media') 在settings.py里设置完毕后，我们在项目中也创建这两个文件在，在项目根目录中创建static与media这两个文件夹 配置pycharm运行参数 配置完成后点击pycharm中的运行按钮，在浏览器中输入127.0.0.1:8000访问，出现小火箭升空表示Django安装成功， 访问Django-admin界面， 在浏览器中输入127.0.0.1:8000/admin，看到Django管理，需要输入用户名密码，输入用户名密码后可以跳转到Django管理页面表示Django-admin设置成功 ","date":"2019-04-20","objectID":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:2:2","tags":["博客","Django"],"title":"Django2.x搭建博客","uri":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Django"],"content":"数据库表分析 文章表 字段 类型 备注 id PrimaryKey 主键 title CharField 标题 create_time DateTimeField 创建时间 views PositiveIntegerField 阅读数 summary TextField 摘要 content TextField 内容 category_id ForeignKey 外键，分类id tag_id ManyToManyField 外键，标签id 分类表 字段 类型 备注 id PrimaryKey 主键 name CharField 分类名 标签表 字段 类型 备注 id PrimaryKey 主键 name CharField 标签名 用户表 字段 类型 备注 id PrimaryKey 主键 name CharField 用户名 password CharField 密码 评论表 字段 类型 备注 id PrimaryKey 主键 user_id ManyToManyField 外键，用户名id blog_id ManyToManyField 外键，博客id create_time DateTimeField 创建时间 content TextField 评论内容 Parent_id PositiveIntegerField 父评论id ","date":"2019-04-20","objectID":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:2:3","tags":["博客","Django"],"title":"Django2.x搭建博客","uri":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Django"],"content":"编写模型类代码 根据数据库设计表格完成模型类代码 # DjangoBlog/post/models.py from django.db import models class Category(models.Model): \"\"\"分类\"\"\" name = models.CharField('分类', max_length=100) class Meta: verbose_name = '分类' verbose_name_plural = verbose_name def __str__(self): return self.name class Tags(models.Model): \"\"\"标签\"\"\" name = models.CharField('标签', max_length=100) class Meta: verbose_name = '标签' verbose_name_plural = verbose_name def __str__(self): return self.name class Article(models.Model): \"\"\"博客\"\"\" title = models.CharField('标题', max_length=100) create_time = models.DateTimeField('创建时间', auto_now_add=True) views = models.PositiveIntegerField('阅读数', default=0) summary = models.TextField('摘要') content = models.TextField('内容') category_id = models.ForeignKey(Category, on_delete=models.DO_NOTHING, verbose_name='分类') tag_id = models.ManyToManyField(Tags, verbose_name='标签') class Meta: verbose_name = '文章' verbose_name_plural = '文章' def __str__(self): return self.title class User(models.Model): \"\"\"用户\"\"\" name = models.CharField('用户名', max_length=100) password = models.CharField('密码', max_length=100) class Meta: verbose_name = '用户名' verbose_name_plural = verbose_name def __str__(self): return self.name class Comment(models.Model): \"\"\"评论\"\"\" user = models.ManyToManyField(User, verbose_name='用户') article = models.ManyToManyField(Article, verbose_name='博客') create_time = models.DateTimeField('创建时间', auto_now_add=True) content = models.TextField('内容') Parent_id = models.PositiveIntegerField('父评论id') class Meta: verbose_name = '评论' verbose_name_plural = verbose_name def __str__(self): return self.content 数据库迁移 (DjangoBlogEnv) hls-MacBook-Pro:DjangoBlog hl$ python manage.py makemigrations Migrations for 'blog': blog/migrations/0001_initial.py - Create model Article - Create model Category - Create model Tags - Create model User - Create model Comment - Add field category_id to article - Add field tag_id to article (DjangoBlogEnv) hls-MacBook-Pro:DjangoBlog hl$ python manage.py migrate Operations to perform: Apply all migrations: admin, auth, blog, contenttypes, sessions Running migrations: Applying blog.0001_initial... OK ","date":"2019-04-20","objectID":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:2:4","tags":["博客","Django"],"title":"Django2.x搭建博客","uri":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Django"],"content":"用django-admin管理 数据库迁移完成会在post应用下生成一个迁移的文件，接下来在django-admin中注册模型，便于我们用django-admin管理 /post/admin.py from django.contrib import admin from .models import Article, Category, Tags, User, Comment @admin.register(Article) class ArticleAdmin(admin.ModelAdmin): # 在后台显示的字段 list_display = ('id', 'title', 'create_time', 'category_id', 'views') # 分页的个数 list_per_page = 10 # 按时间倒序排序 ordering = ('-create_time',) # 点击修改的字段 list_display_links = ('id', 'title') @admin.register(Category) class CategoryAdmin(admin.ModelAdmin): list_display = ('id', 'name') @admin.register(Tags) class TagsAdmin(admin.ModelAdmin): list_display = ('id', 'name') @admin.register(User) class UserAdmin(admin.ModelAdmin): list_display = ('id', 'name', 'password') @admin.register(Comment) class CommentAdmin(admin.ModelAdmin): list_display = ('id', 'content', 'create_time') 登陆Django管理后台，查看模型是否可以被管理，尝试点击添加与修改，没问题就说明注册成功 ","date":"2019-04-20","objectID":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:2:5","tags":["博客","Django"],"title":"Django2.x搭建博客","uri":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Django"],"content":"集成Markdown 很多人喜欢用markdown格式写博客，我们可以通过集成Django-mdeditor 来实现这个功能 1.安装django-mdeditor pip install django-mdeditor 2.在apps中注册 INSTALLED_APPS = [ ... 'mdeditor', ] 3.在media下创建editor文件夹 cd media mkdir editor 4.集成到路由中 /blog/urls.py from django.conf.urls import url, include from django.conf.urls.static import static from django.conf import settings ... urlpatterns = [ ... url(r'mdeditor/', include('mdeditor.urls')) ] if settings.DEBUG: # static files (images, css, javascript, etc.) urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT) 5.集成到models中 from mdeditor.fields import MDTextField class Article(models.Model): ... content = MDTextField() ... 再次进入admin，选择文章修改就可以看到集成的markdown编辑器了 ","date":"2019-04-20","objectID":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:2:6","tags":["博客","Django"],"title":"Django2.x搭建博客","uri":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Django"],"content":"实现视图 首先找到一套你喜欢的模版，将模版下载下来，html部分放入templates中，其他静态文件放入static中 将重复出现的部分提取出来，这个根据自己的模版抽取，每个都不相同，静态文件加载 如果一次没有提取好，可以慢慢一点点的抽取，对于一个后端程序员来说这个是一个慢工出细活的过程.可以写一个简单的视图，然后开着Django一边抽取一遍调试 接下来实现首页试图 首先在urls.py中配置路由 DjangoBlog/u rls.py ... from blog import views urlpatterns = [ ... path('', views.index, name='index') ] 这里path里第一个参数为访问的url，匹配采用正则表达式，第二个参数为视图函数，第三个为取的名字 接下来在blog应用的views.py中编写视图函数 blog/views.py ... def index(request): return render(request, 'index.html') 这样当我们重新访问127.0.0.1:8000时，我们修改的前端代码就被加载了 接下来我们实现将分类加载,将index视图修改为一下代码 blog/views.py ... from .models import Category # 从models里导入Category类 def index(request): categorys = Category.objects.all() # 把查询出来的分类封装到上下文里 context = { 'categorys': categorys, } print(context) return render(request, 'index.html', context) 在前端代码中渲染，我们找到base.html,将ul标签中的除首页以外的代码改为一下代码 \u003cheader class=\"header-navigation\" id=\"header\"\u003e \u003cnav\u003e \u003cdiv class=\"logo\"\u003e\u003ca href=\"/\"\u003e胡亮个人博客\u003c/a\u003e\u003c/div\u003e \u003ch2 id=\"mnavh\"\u003e\u003cspan class=\"navicon\"\u003e\u003c/span\u003e\u003c/h2\u003e \u003cul id=\"starlist\"\u003e \u003cli\u003e\u003ca href=\"index.html\"\u003e首页\u003c/a\u003e\u003c/li\u003e \u003c/ul\u003e \u003c/nav\u003e \u003c/header\u003e 这样分类栏就加载出来了，如果没有数据可以通过admin添加数据 ","date":"2019-04-20","objectID":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:2:7","tags":["博客","Django"],"title":"Django2.x搭建博客","uri":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Django"],"content":"Django配置文件详解","date":"2019-04-13","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E6%A8%A1%E6%9D%BF/","tags":["Django","教程"],"title":"Django基础教程之模板","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E6%A8%A1%E6%9D%BF/"},{"categories":["Django"],"content":"声明：以下内容均为我个人的理解，如果发现错误或者疑问可以联系我共同探讨 本教程为Django基础教程系列第六篇，前面篇章在以下链接： Django基础教程之Django介绍 Django基础教程之工程搭建 Django基础教程之配置文件详解 Django基础教程之请求与响应 Django基础教程之类视图与中间件 ","date":"2019-04-13","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E6%A8%A1%E6%9D%BF/:0:0","tags":["Django","教程"],"title":"Django基础教程之模板","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E6%A8%A1%E6%9D%BF/"},{"categories":["Django"],"content":"由于发现目前网上有很多大神的教学文章都比较出色，我就不班门弄斧继续出Django相关教程，以后会继续跟大家分享在使用Django中遇到的问题与解决方案，下面推荐几个比较好的学习Django的博客，大家可以根据自己情况选择学习 菜鸟教程 追梦人物的博客 Django中文网 Django官方文档 ","date":"2019-04-13","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E6%A8%A1%E6%9D%BF/:1:0","tags":["Django","教程"],"title":"Django基础教程之模板","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E6%A8%A1%E6%9D%BF/"},{"categories":["Django"],"content":"Django基础教程之类视图与中间件","date":"2019-03-30","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/","tags":["Django","教程"],"title":"Django基础教程之类视图与中间件","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"categories":["Django"],"content":"声明：以下内容均为我个人的理解，如果发现错误或者疑问可以联系我共同探讨 本教程为Django基础教程系列第五篇，前面篇章在以下链接： Django基础教程之Django介绍 Django基础教程之工程搭建 Django基础教程之配置文件详解 Django基础教程之请求与响应 ","date":"2019-03-30","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/:0:0","tags":["Django","教程"],"title":"Django基础教程之类视图与中间件","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"categories":["Django"],"content":"类视图 以函数的方式定义的视图称为函数视图，函数视图便于理解。但是遇到一个视图对应的路径提供了多种不同HTTP请求方式的支持时，便需要在一个函数中编写不同的业务逻辑，代码可读性与复用性都不佳。 在Django中也可以使用类来定义一个视图，称为类视图。使用类视图可以将视图对应的不同请求方式以类中的不同方法来区别定义。 类视图的好处 代码可读性好 类视图相对于函数视图有更高的复用性， 如果其他地方需要用到某个类视图的某个特定逻辑，直接继承该类视图即可 类视图使用 定义类视图需要继承自Django提供的父类View，可使用from django.views.generic import View或者from django.views.generic.base import View 导入 配置路由时，使用类视图的as_view()方法来添加。 ","date":"2019-03-30","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/:1:0","tags":["Django","教程"],"title":"Django基础教程之类视图与中间件","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"categories":["Django"],"content":"类视图原理 类视图使用装饰器 类视图Mixin扩展类 ","date":"2019-03-30","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/:1:1","tags":["Django","教程"],"title":"Django基础教程之类视图与中间件","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"categories":["Django"],"content":"中间件 Django中的中间件是一个轻量级、底层的插件系统，可以介入Django的请求和响应处理过程，修改Django的输入或输出。中间件的设计为开发者提供了一种无侵入式的开发方式，增强了Django框架的健壮性。 我们可以使用中间件，在Django处理视图的不同阶段对输入或输出进行干预。 ","date":"2019-03-30","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/:2:0","tags":["Django","教程"],"title":"Django基础教程之类视图与中间件","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"categories":["Django"],"content":"中间件的定义方法 定义一个中间件工厂函数，然后返回一个可以别调用的中间件。 中间件工厂函数需要接收一个可以调用的get_response对象。 返回的中间件也是一个可以被调用的对象，并且像视图一样需要接收一个request对象参数，返回一个response对象。 定义好中间件后，需要在settings.py 文件中添加注册中间件 ","date":"2019-03-30","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/:2:1","tags":["Django","教程"],"title":"Django基础教程之类视图与中间件","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"categories":["Django"],"content":"多个中间件的执行顺序 在请求视图被处理前，中间件由上至下依次执行 在请求视图被处理后，中间件由下至上依次执行 ","date":"2019-03-30","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/:2:2","tags":["Django","教程"],"title":"Django基础教程之类视图与中间件","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"categories":["Django"],"content":"Django基础教程之请求与相应","date":"2019-03-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/","tags":["Django","教程"],"title":"Django基础教程之请求与相应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/"},{"categories":["Django"],"content":"Django基础教程之Django介绍 Django基础教程之工程搭建 Django基础教程之配置文件详解 声明：以下内容均为我个人的理解，如果发现错误或者疑问可以联系我共同探讨 本教程为Django基础教程系列第四篇，前面篇章在以下链接： Django基础教程之Django介绍 Django基础教程之工程搭建 Django基础教程之配置文件详解 ","date":"2019-03-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/:0:0","tags":["Django","教程"],"title":"Django基础教程之请求与相应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/"},{"categories":["Django"],"content":"前言 在Django基础教程之工程搭建中，视图相关部分提到过Django中视图的功能是接受请求，进行业务处理，返回响应。今天就来研究一下Django中的请求与相应部分。 ","date":"2019-03-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/:1:0","tags":["Django","教程"],"title":"Django基础教程之请求与相应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/"},{"categories":["Django"],"content":"请求 利用HTTP协议向服务器传参有几种途径？ 提取URL的特定部分，可以通过服务器端路由中用正则表达式截取； 查询字符串（query string)； 请求体（body）中发送的数据，比如表单数据、json、xml； 在http报文的头（header）中。 ","date":"2019-03-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/:2:0","tags":["Django","教程"],"title":"Django基础教程之请求与相应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/"},{"categories":["Django"],"content":"URL路径参数 在定义路由URL时，可以使用正则表达式提取参数的方法从URL中获取请求参数，Django会将提取的参数直接传递到视图的传入参数中。 未命名参数按定义顺序传递， 如 url(r'^weather/([a-z]+)/(\\d{4})/$', views.weather), def weather(request, city, year): print('city=%s' % city) print('year=%s' % year) return HttpResponse('OK') 命名参数按名字传递，如 url(r'^weather/(?P\u003ccity\u003e[a-z]+)/(?P\u003cyear\u003e\\d{4})/$', views.weather), def weather(request, year, city): print('city=%s' % city) print('year=%s' % year) return HttpResponse('OK') ","date":"2019-03-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/:2:1","tags":["Django","教程"],"title":"Django基础教程之请求与相应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/"},{"categories":["Django"],"content":"QueryDict对象 与python字典不同，QueryDict类型的对象用来处理同一个键带有多个值的情况，HttpRequest对象的属性GET、POST都是QueryDict类型的对象 get方法：根据键获取值，如果一个键同时拥有多个值将获取最后一个值，如果键不存在则返回None值，可以设置默认值进行后续处理 getlist方法：根据键获取值，值以列表返回，可以获取指定键的所有值，如果键不存在则返回空列表，可以设置默认值进行后续处理 ","date":"2019-03-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/:2:2","tags":["Django","教程"],"title":"Django基础教程之请求与相应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/"},{"categories":["Django"],"content":"查询字符串Query String 获取请求路径中的查询字符串参数，可以通过request.GET属性获取，返回QueryDict对象。查询字符串不区分请求方式，即假使客户端进行POST方式的请求，依然可以通过request.GET获取请求中的查询字符串数据。 ","date":"2019-03-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/:2:3","tags":["Django","教程"],"title":"Django基础教程之请求与相应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/"},{"categories":["Django"],"content":"请求体 请求体数据格式不固定，可以是表单类型字符串，可以是JSON字符串，可以是XML字符串，应区别对待。 可以发送请求体数据的请求方式有POST、PUT、PATCH、DELETE。 Django默认开启了CSRF防护，会对上述请求方式进行CSRF防护验证，在测试时可以关闭CSRF防护机制，方法为在settings.py文件中注释掉CSRF中间件 ","date":"2019-03-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/:2:4","tags":["Django","教程"],"title":"Django基础教程之请求与相应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/"},{"categories":["Django"],"content":"表单 Form Data 前端发送的表单类型的请求体数据，可以通过request.POST属性获取，返回QueryDict对象。request.POST只能用来获取POST方式的请求体表单数据。 ","date":"2019-03-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/:2:5","tags":["Django","教程"],"title":"Django基础教程之请求与相应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/"},{"categories":["Django"],"content":"非表单类型 Non-Form Data 非表单类型的请求体数据，Django无法自动解析，可以通过request.body属性获取最原始的请求体数据，自己按照请求体格式（JSON、XML等）进行解析。request.body返回bytes类型。 ","date":"2019-03-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/:2:6","tags":["Django","教程"],"title":"Django基础教程之请求与相应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/"},{"categories":["Django"],"content":"请求头 可以通过request.META属性获取请求头headers中的数据，request.META为字典类型。 常见的请求头如： CONTENT_LENGTH – 请求体的长度。 CONTENT_TYPE – 请求体的类型。 HTTP_ACCEPT – 响应的可接受内容类型。 HTTP_ACCEPT_ENCODING – 可接受的响应码。 HTTP_ACCEPT_LANGUAGE – 响应的可接受语言。 HTTP_HOST – 客户端发送的HTTP主机报头。 HTTP_REFERER – 参考页面。 HTTP_USER_AGENT – 客户机的用户代理字符串。 QUERY_STRING – 查询字符串，作为单个(未解析的)字符串。 REMOTE_ADDR – 客户端的IP地址。 REMOTE_HOST – 客户机的主机名。 REMOTE_USER – Web服务器认证的用户。 REQUEST_METHOD – 请求方式字符串，如\"GET\"或\"POST”。 SERVER_NAME – 服务器的主机名。 SERVER_PORT – 服务器的端口。 ","date":"2019-03-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/:2:7","tags":["Django","教程"],"title":"Django基础教程之请求与相应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/"},{"categories":["Django"],"content":"其他常用HttpRequest对象属性 method：一个字符串，表示请求使用的HTTP方法，常用值包括：‘GET’、‘POST’。 user：请求的用户对象。 path：一个字符串，表示请求的页面的完整路径，不包含域名和参数部分。 encoding：一个字符串，表示提交的数据的编码方式。 如果为None则表示使用浏览器的默认设置，一般为utf-8。 这个属性是可写的，可以通过修改它来修改访问表单数据使用的编码，接下来对属性的任何访问将使用新的encoding值。 FILES：一个类似于字典的对象，包含所有的上传文件。 ","date":"2019-03-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/:2:8","tags":["Django","教程"],"title":"Django基础教程之请求与相应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/"},{"categories":["Django"],"content":"响应 视图在接收请求并处理后，必须返回HttpResponse对象或子对象。HttpRequest对象由Django创建，HttpResponse对象由开发人员创建。 ","date":"2019-03-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/:3:0","tags":["Django","教程"],"title":"Django基础教程之请求与相应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/"},{"categories":["Django"],"content":"HttpResponse 可以使用django.http.HttpResponse来构造响应对象。也可通过HttpResponse对象属性来设置响应体、状态码： content：表示返回的内容。 status_code：返回的HTTP响应状态码。 响应头可以直接将HttpResponse对象当做字典进行响应头键值对的设置 ","date":"2019-03-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/:3:1","tags":["Django","教程"],"title":"Django基础教程之请求与相应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/"},{"categories":["Django"],"content":"HttpResponse子类 Django提供了一系列HttpResponse的子类，可以快速设置状态码 HttpResponseRedirect 301 HttpResponsePermanentRedirect 302 HttpResponseNotModified 304 HttpResponseBadRequest 400 HttpResponseNotFound 404 HttpResponseForbidden 403 HttpResponseNotAllowed 405 HttpResponseGone 410 HttpResponseServerError 500 ","date":"2019-03-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/:3:2","tags":["Django","教程"],"title":"Django基础教程之请求与相应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/"},{"categories":["Django"],"content":"JsonResponse 若要返回json数据，可以使用JsonResponse来构造响应对象，作用： 帮助我们将数据转换为json字符串 设置响应头Content-Type为 application/json ","date":"2019-03-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/:3:3","tags":["Django","教程"],"title":"Django基础教程之请求与相应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/"},{"categories":["Django"],"content":"redirect重定向 ","date":"2019-03-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/:3:4","tags":["Django","教程"],"title":"Django基础教程之请求与相应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/"},{"categories":["Django"],"content":"Cookie Cookie，有时也用其复数形式Cookies，指某些网站为了辨别用户身份、进行session跟踪而储存在用户本地终端上的数据（通常经过加密）。Cookie最早是网景公司的前雇员Lou Montulli在1993年3月的发明。Cookie是由服务器端生成，发送给User-Agent（一般是浏览器），浏览器会将Cookie的key/value保存到某个目录下的文本文件内，下次请求同一网站时就发送该Cookie给服务器（前提是浏览器设置为启用cookie）。Cookie名称和值可以由服务器端开发自己定义，这样服务器可以知道该用户是否是合法用户以及是否需要重新登录等。服务器可以利用Cookies包含信息的任意性来筛选并经常性维护这些信息，以判断在HTTP传输中的状态。Cookies最典型记住用户名。 Cookie是存储在浏览器中的一段纯文本信息，建议不要存储敏感信息如密码，因为电脑上的浏览器可能被其它人使用。 ","date":"2019-03-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/:4:0","tags":["Django","教程"],"title":"Django基础教程之请求与相应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/"},{"categories":["Django"],"content":"Cookie的特点 Cookie以键值对的格式进行信息的存储。 Cookie基于域名安全，不同域名的Cookie是不能互相访问的，如访问itcast.cn时向浏览器中写了Cookie信息，使用同一浏览器访问baidu.com时，无法访问到itcast.cn写的Cookie信息。 当浏览器请求某网站时，会将浏览器存储的跟网站相关的所有Cookie信息提交给网站服务器。 ","date":"2019-03-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/:4:1","tags":["Django","教程"],"title":"Django基础教程之请求与相应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/"},{"categories":["Django"],"content":"设置Cookie 可以通过HttpResponse对象中的set_cookie方法来设置cookie。 ","date":"2019-03-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/:4:2","tags":["Django","教程"],"title":"Django基础教程之请求与相应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/"},{"categories":["Django"],"content":"读取Cookie 可以通过HttpRequest对象的COOKIES属性来读取本次请求携带的cookie值。request.COOKIES为字典类型。 ","date":"2019-03-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/:4:3","tags":["Django","教程"],"title":"Django基础教程之请求与相应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/"},{"categories":["Django"],"content":"Session **Django项目默认启用Session。**如需禁用session，将上图中的session中间件注释掉即可。 ","date":"2019-03-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/:5:0","tags":["Django","教程"],"title":"Django基础教程之请求与相应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/"},{"categories":["Django"],"content":"存储方式 在settings.py文件中，可以设置session数据的存储方式，可以保存在数据库、本地缓存等。 数据库 存储在数据库中，如下设置可以写，也可以不写，这是默认存储方式。 SESSION_ENGINE='django.contrib.sessions.backends.db' 如果存储在数据库中，需要在项INSTALLED_APPS中安装Session应用。 INSTALLED_APPS = [ ... 'django.contrib.sessions', ... ] 存储在数据库中会生成一个diango_session的表，表结构为：键、值、过期时间 本地缓存 存储在本机内存中，如果丢失则不能找回，比数据库的方式读写更快。 SESSION_ENGINE='django.contrib.sessions.backends.cache' 混合存储 优先从本机内存中存取，如果没有则从数据库中存取。 SESSION_ENGINE='django.contrib.sessions.backends.cached_db' Redis 在redis中保存session，需要引入第三方扩展，我们可以使用django-redis来解决。 1） 安装扩展 pip install django-redis 2）配置 在settings.py文件中做如下设置 CACHES = { \"default\": { \"BACKEND\": \"django_redis.cache.RedisCache\", \"LOCATION\": \"redis://127.0.0.1:6379/1\", \"OPTIONS\": { \"CLIENT_CLASS\": \"django_redis.client.DefaultClient\", } } } SESSION_ENGINE = \"django.contrib.sessions.backends.cache\" SESSION_CACHE_ALIAS = \"default\" 注意 如果redis的ip地址不是本地回环127.0.0.1，而是其他地址，访问Django时，可能出现Redis连接错误，如下： 解决方法： 修改redis的配置文件，添加特定ip地址。 Session操作 通过HttpRequest对象的session属性进行会话的读写操作。 1） 以键值对的格式写session。 request.session['键']=值 2）根据键读取值。 request.session.get('键',默认值) 3）清除所有session，在存储中删除值部分。 request.session.clear() 4）清除session数据，在存储中删除session的整条数据。 request.session.flush() 5）删除session中的指定键及值，在存储中只删除某个键及对应的值。 del request.session['键'] 6）设置session的有效期 request.session.set_expiry(value) 如果value是一个整数，session将在value秒没有活动后过期。 如果value为0，那么用户session的Cookie将在用户的浏览器关闭时过期。 如果value为None，那么session有效期将采用系统默认值，默认为两周，可以通过在settings.py中设置SESSION_COOKIE_AGE来设置全局默认值。 ","date":"2019-03-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/:5:1","tags":["Django","教程"],"title":"Django基础教程之请求与相应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/"},{"categories":["Django"],"content":"Django配置文件详解","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"声明：以下内容均为我个人的理解，如果发现错误或者疑问可以联系我共同探讨 本教程为Django基础教程系列第三篇，前面篇章在以下链接： Django基础教程之Django介绍 Django基础教程之工程搭建 ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:0:0","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"简介 学习Django可以从Django配置文件的各项开始，由简入深的了解其作用，从而一步一步学习。本篇文章主要是介绍各项的作用以及如何配置，可以根据需求按需配置。 ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:1:0","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"内容 ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:0","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"绝对路径映射 ABSOLUTE_URL_OVERRIDES 作用：将应用的模型字符串映射到采用模型对象并返回其url，基于get_absolute_url方法。无论实际模型类名称的大小写如何，此设置中使用的模型名称均应全部小写。 ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:1","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"管理员 ADMINS 作用：用于接收代码错误的人员列表，列表中的元素格式为（全名，电子邮箱） ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:2","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"Django项目根路径 BASE_DIR 作用：以项目根路径为基础衍生其他文件 BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) 从内到外一步一步剖析 __file__：返回当前文件 os.path.abspath(__file__)：返回当前文件的绝对路径 os.path.dirname(os.path.abspath(__file__))：返回当前文件的父目录 os.path.dirname(os.path.dirname(os.path.abspath(__file__)))：返回当前文件父目录的父目录 可能这样还不太清楚，将__file__换成settings.py,可以看出来BASE_DIR是manage.py所在的目录，即整个项目的根目录 ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:3","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"秘钥 SECRET_KEY 作用：校验，主要用于表单、session、csrf SECRET_KEY = \"adsasdasdsafdasfldasfklasdlfnlasdnfklnasdfklnasldfklkdasf\" ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:4","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"调试模式 DEBUG 作用：当开启时，运行出现bug会在前端直接显示，开发，测试过程可以开启 DEBUG = True ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:5","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"允许访问的主机 ALLOWED_HOSTS 作用：在开发的时候可以使用*，当项目上线后需要更换为指定的主机(域名和ip都可以) ALLOWED_HOSTS = [] ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:6","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"应用、模块注册 INSTALLED_APPS 作用：将独立的应用或模块接入Django（注意应用名称或者模块名称必须是唯一的） INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', ] 通常INSTALLED_APPS默认包含以下Django自带的应用 django.contrib.admin：管理员站点，可以通过admin管理项目（数据、用户、权限等），使用admin必须完成以下配置 他依赖django.contrib.auth、django.contrib.contenttypes、django.contrib.sessions、django.contrib.messages四个模块 MIDDLEWARE设置必须包括 django.contrib.auth.middleware.AuthenticationMiddleware并且django.contrib.messages.middleware.MessageMiddleware 在项目url配置中必须加入admin urls.py from django.contrib import admin from django.urls import path urlpatterns = [ path('admin/', admin.site.urls), ] 可以使用django-admin createsuperuser创建管理员用户 django.contrib.auth：认证授权系统。主要负责校验用户信息与用户权限，由以下部分组成 用户：用户管理 权限：以二进制的形式标识指定用户是否可以执行的特殊任务 组：管理多个用户的权限 可配置的密码哈希话系统 为登录用户或限制内容提供表单和视图工具 可插拔的后端系统 需要注意的是它不提供密码强度检查、限制登录尝试、第三方身份验证，对象级权限 django.contrib.contenttypes：内容类型框架,他可以跟踪Django驱动的项目中安装的所有模型，为模型提供高级的通用界面 django.contrib.sessions：会话框架 django.contrib.messages：消息框架 staticfiles：管理静态文件框架 除了这些常见的自带应用外，在我们使用自己注册的应用和第三方模块时，记得第一时间来这里注册，否则会用不了哦 ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:7","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"中间件 MIDDLEWARE 作用：中间件是Django请求/响应处理的钩子框架，用于改变Django的输入或输出 中间件可以放在Python路径上的任何地方，可以自己编写中间件，中间件可以是函数也可以是类。 函数形式的中间件 def simple_middleware(get_response): # 首次配置和初始化 def middleware(request): # 每个请求之前或调用视图函数之前执行的代码 response = get_response(request) # 每个响应、请求或者调用视图函数之后执行的代码 return response return middleware 类形式的中间件 def __init__(self, get_response): self.get_response = get_response # 首次配置和初始化 def __call__(self, request): # 每个请求之前或调用视图函数之前执行的代码 response = self.get_response(request) # 每个响应、请求或者调用视图函数之后执行的代码 return response 上述方法中调用get_response方法并不是实际视图中的，而是处理程序的包装方法，它负责应用视图中间件，调用具有适当的URL参数的视图，并应用模板响应和第三方中间件。 在使用类形式的中间件时，__init__方法必须接受get_response参数，还可以初始化中间件的一些局部状态。 想使用中间件就必须在settings.py文件中的MIDDLEWARE中激活。激活的方式是使用字符串表示指向中间件完整的Python路径 在Django中MIDDLEWARE可以为空，但是强烈建议至少激活CommonMiddleware 由于某些中间件也会依赖其他中间件所以中间件在MIDDLEWARE中的顺序很重要，Django会按自上而下的顺序调用中间件 ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:8","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"路由根路径 ROOT_URLCONF 作用：Django在处理请求时会最先从此处寻找url 需要注意的是，此处的路径是基于BASE_DIR的路径 ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:9","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"模板引擎配置 TEMPLATES 作用：在Django中使用模板引擎的设置列表，列表中每个元素都是一个字典，字典里配置模板引擎 常用的配置参数： BACKEND：项目使用的模板引擎，Django内置了两个 django.template.backends.django.DjangoTemplates django.template.backends.jinja2.Jinja2 DIRS：模板文件夹的位置 APP_DIRS：模板引擎是否在已安装的应用中讯在模板源文件 OPTIONS：传给后端模板的额外参数 ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:10","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"内置服务器的路径 WSGI_APPLICATION 作用：用于调式Django程序的内置服务器， ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:11","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"数据库配置 DATABASES 在mysite/mysite/settings.py中，默认的数据库为SQLite，还支持PostgreSQL、mysql、oracle等其他第三方（这些非官方后端支持的Django版本和ORM功能差异很大。有关这些非官方后端的具体功能的查询以及任何支持查询，应该针对每个第三方项目提供的支持渠道） DATABASES = { 'default': { 'ENGINE': 'django.db.backends.sqlite3', 'NAME': os.path.join(BASE_DIR, 'db.sqlite3'), } } ENGINE，数据库引擎，可选的ENGINE还有 django.db.backends.postgresql、django.db.backends.mysql、django.db.backends.oracle、第三方数据库 NAME，数据库名称，如果使用SQLite,他会在根目录生成一个数据库文件 当不使用SQLite时，还会有一下常用参数，其他参数可以查阅文档DATABASES NAME：数据库名字 USER：数据库的用户名 PASSWORD：数据库的密码 HOST：数据库的主机 PORT：数据库的端口 OPTIONS：连接到数据库时要使用的其他参数。可用参数取决于数据库后端。 TEST：测试数据库 测试数据库也具备一些设置，也是采用键值对的方式对数据库进行设置 CHARSET：创建测试数据库时使用的字符集编码 COLLATION：创建测试数据库时使用的排序规则 DEPENDENCIES：数据库的创建顺序依耐性 MIRROR：测试期间该数据库应镜像的数据库别名。 NAME：运行测试套件时要使用的数据库的名称。 SERIALIZE：一个布尔值，用于控制默认测试运行程序在运行测试之前是否将数据库序列化为内存中的JSON字符串。False如果没有任何带有测试类，可以将其设置为加快创建时间。 TEMPLATE：PostgreSQL的特定设置。从中创建测试数据库的模板（例如'template0'）的名称。 CREATE_DB：默认为True，Oracle特定的设置。如果将其设置为False，则测试表空间将不会在测试开始时自动创建，也不会在测试结束时自动删除。 CREATE_USER：默认为True，Oracle特定的设置。如果将其设置为False，则不会在测试开始时自动创建测试用户，并在测试结束时自动将其删除。 USER：默认为None，Oracle特定的设置。连接到运行测试时将使用的Oracle数据库时使用的用户名。如果未提供，则Django将使用。'test_' + USER PASSWORD：默认为None，Oracle特定的设置。连接到运行测试时将使用的Oracle数据库的密码。如果未提供，Django将生成一个随机密码。 TBLSPACE：默认为None，Oracle特定的设置。运行测试时将使用的表空间的名称。如果未提供，则Django将使用。'test_' + USER TBLSPACE_TMP：默认为None，Oracle特定的设置。运行测试时将使用的临时表空间的名称。如果未提供，则Django将使用。'test_' + USER + '_temp' DATAFILE：默认为None，这是Oracle特定的设置。用于TBLSPACE的数据文件的名称。如果未提供，则Django将使用。TBLSPACE + '.dbf' DATAFILE_TMP：默认为None，Oracle特定的设置。用于TBLSPACE_TMP的数据文件的名称。如果未提供，则Django将使用。TBLSPACE_TMP + '.dbf' DATAFILE_MAXSIZE：默认为500M，Oracle特定的设置。允许DATAFILE增大到的最大大小。 DATAFILE_TMP_MAXSIZE：默认为500M，Oracle特定的设置。DATAFILE_TMP允许增加到的最大大小。 DATAFILE_SIZE：默认为50M，Oracle特定的设置。DATAFILE的初始大小。 DATAFILE_TMP_SIZE：默认为50M，Oracle特定的设置。DATAFILE_TMP的初始大小。 DATAFILE_EXTSIZE：默认为25M，Oracle特定的设置。需要更多空间时，DATAFILE_TMP的扩展量。 其他的配置： ATOMIC_REQUESTS：默认为False，当设置为True时将每个视图包装在该数据库的事务中 AUTOCOMMIT:默认为True，当设置为False时警用Django的事务管理，可以自己编写事务管理机制 CONN_MAX_AGE：数据库连接的生存期，以秒为单位。用于0在每个请求结束时关闭数据库连接-Django的历史行为-并 None用于无限的持久连接。 TIME_ZONE：默认为None，用一个字符串表示存储在此数据库中的时区 ​ ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:12","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"数据库路由器列表 DATABASE_ROUTERS 作用：执行数据库查询时将用来确定要使用哪个数据库的路由器列表。 ​ ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:13","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"阈值检查 DATA_UPLOAD_MAX_NUMBER_FIELDS 作用：调用SuspiciousOperation检查GET或POST接受的最大值，当设为None时禁用检查 ​ ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:14","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"显示日期的默认格式 DATE_FORMAT 作用：在任何地方显示日期字段的默认格式。 ​ ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:15","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"密码强度列表 AUTH_PASSWORD_VALIDATORS 作用：用于检查用户密码强度的验证器列表 ​ ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:16","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"语言 LANGUAGE_CODE 作用：项目语言，默认为‘en-us’ ​ ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:17","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"时区 TIME_ZONE 作用：一个字符串表达的时区默认为’UTC’ ​ ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:18","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"翻译系统 USE_I18N 作用：指定是否启用Django的翻译系统，默认为True ​ ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:19","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"本地化 USE_L10N 作用：指定默认情况下是否启用数据本地化格式，默认为True ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:20","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"时区 USE_TZ 作用：指定日期时间默认情况下是否支持时区 ​ ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:21","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"静态文件夹的路径 STATIC_URL 作用：引用位于静态文件时使用的URL ​ ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:22","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"静态文件的绝对路径 STATIC_ROOT 作用：在部署时收集静态文件的绝对路径 ​ ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:23","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"Django介绍","date":"2019-03-09","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/","tags":["Django","教程"],"title":"Django基础教程之工程搭建","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/"},{"categories":["Django"],"content":"声明：以下内容均为我个人的理解，如果发现错误或者疑问可以联系我共同探讨 本教程为Django基础教程系列第二篇，前面篇章在以下链接： Django基础教程之Django介绍 ","date":"2019-03-09","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/:0:0","tags":["Django","教程"],"title":"Django基础教程之工程搭建","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/"},{"categories":["Django"],"content":"简介 每个工程项目的开始阶段往往决定了项目的大致走向，在工程搭建的过程中要为后面的项目开发做好准备。 为了不受Python环境的影响，最好建立虚拟环境，在虚拟环境中搭建项目 ","date":"2019-03-09","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/:1:0","tags":["Django","教程"],"title":"Django基础教程之工程搭建","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/"},{"categories":["Django"],"content":"教程 ","date":"2019-03-09","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/:2:0","tags":["Django","教程"],"title":"Django基础教程之工程搭建","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/"},{"categories":["Django"],"content":"安装环境 安装virtualenv virtualenv是一个用于创建Python虚拟环境的工具包，可以通过pip直接安装 pip3 install virtualenv 创建虚拟环境 virtualenv --python=/usr/bin/python3 django2.2.2_py3 django2.2.2_py3为虚拟环境的名字，这里是以Django的版本+Python版本命名，–python指定了Python的位置。 激活虚拟环境 source django2.2.2_py3/bin/activate 激活完成后会在命令行最前面显示当前的虚拟环境名 安装Django 本教程使用django2.2.2版本 pip install django==2.2.2 ","date":"2019-03-09","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/:2:1","tags":["Django","教程"],"title":"Django基础教程之工程搭建","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/"},{"categories":["Django"],"content":"项目工程 在Django中，项目的工程目录可以通过Django提供的命令来创建。 创建 创建工程的命令为： django-admin startproject 工程名称 例如你想在做面食创建一个demo的工程项目，可以执行如下命令： cd ~/Desktop/ django-admin startproject demo 执行完毕后，会在当前目录即Desktop目录下生成一个名为demo的目录，该目录存放着整个Django工程 工程目录说明 查看创建的工程目录，结构如下 (django2.2.2_py3) ~/Desktop/demo$ tree . |-- demo | |-- __init__.py | |-- settings.py | |-- urls.py | `-- wsgi.py `-- manage.py 1 directory, 5 files demo：与项目同名的目录，存放项目相关文件。 settings.py：项目的配置文件。 urls.py：项目的总URL配置文件。 wsgi.py：项目与WSGI兼容的Web服务器入口。 manage.py 项目管理文件，通过它管理项目，同时也是启动项目的入口。 运行开发服务器 在开发阶段，为了能够快速预览到开发的效果，Djnago提供了一个纯python编写的轻量级web服务器，提供开发阶段使用。 运行服务器命令如下： python manage.py runserver 默认IP是127.0.0.1，默认端口为8000，可以写指定IP与端口，格式为：ip:端口 启动后可以看到以下信息 (django2.2.2_py3) ~/Desktop/demo$ python manage.py runserver Watching for file changes with StatReloader Performing system checks... System check identified no issues (0 silenced). You have 17 unapplied migration(s). Your project may not work properly until you apply the migrations for app(s): admin, auth, contenttypes, sessions. Run 'python manage.py migrate' to apply them. February 17, 2019 - 05:29:56 Django version 2.2.2, using settings 'demo.settings' Starting development server at http://127.0.0.1:8000/ Quit the server with CONTROL-C. 在浏览器中输入网址“127.0.0.1:8000”便可看到效果。 django默认工作在调式Debug模式下，如果增加、修改、删除文件，服务器会自动重启。 按ctrl+c停止服务器。 ","date":"2019-03-09","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/:2:2","tags":["Django","教程"],"title":"Django基础教程之工程搭建","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/"},{"categories":["Django"],"content":"应用 在Web开发中通常一个大型项目是由无数个应用构成的。将开发中的工程项目拆分成不同的功能模块，可以让各功能模块之间保持相对独立，更利于我们开发与管理。 创建 Django为我们提供了创建应用的命令，创建应用的命令为： python manage.py startapp 子应用名称 需要注意的是，创建应用时必须在manage.py所在的目录下 现在创建一个用户相关的应用users，可以执行： python manage.py startapp users 执行后，可以看到工程目录中多出了一个名为users的子目录。 应用目录说明 (django2.2.2_py3) ~/Desktop/demo$ ls db.sqlite3 demo manage.py users (django2.2.2_py3) ~/Desktop/demo$ tree . |-- db.sqlite3 |-- demo | |-- __init__.py | |-- __pycache__ | | |-- __init__.cpython-36.pyc | | |-- settings.cpython-36.pyc | | |-- urls.cpython-36.pyc | | `-- wsgi.cpython-36.pyc | |-- settings.py | |-- urls.py | `-- wsgi.py |-- manage.py `-- users |-- __init__.py |-- admin.py |-- apps.py |-- migrations | `-- __init__.py |-- models.py |-- tests.py `-- views.py 4 directories, 17 files admin.py：后台管理配置信息。 apps.py：配置信息。 migrations 存放数据库迁移历史文件。 models.py：保存数据库模型类。 tests.py：用于开发测试用例，编写单元测试。 注册应用 创建完应用后Django并不能自动将项目与应用联系起来，需要我们在工程配置文件settings.py中注册才能使用。 在工程配置文件settings.py中的INSTALLED_APPS项负责注册安装好的应用，初始工程中的INSTALLED_APPS如下： 这些默认应用的作用可以看这篇文章：Django配置文件详解 注册一个应用的方法是将应用的配置信息文件apps.py中的Config类添加到INSTALLED_APPS列表中。 例如，注册刚创建的users应用，可在INSTALLED_APPS列表中添加**‘users.apps.UsersConfig’**。 创建视图 视图用于编写应用的业务逻辑，Django的视图是在应用中views.py中的 进入users应用，在views.py中编写视图代码。 from django.http import HttpResponse def index(request): \"\"\" 视图index :param request: 包含了请求信息的请求对象 :return: 响应对象 \"\"\" return HttpResponse(\"hello Django\") 说明： Django基础教程之Django介绍中提到过，Django中视图的功能是接受请求，进行业务处理，返回响应。在这里request是接受请求的对象，业务处理是生成hello Django字符串，而HttpResponse是返回响应的对象。 ","date":"2019-03-09","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/:2:3","tags":["Django","教程"],"title":"Django基础教程之工程搭建","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/"},{"categories":["Django"],"content":"路由 什么是路由 在Django中，路由是将请求的URL分发给视图的系统。 路由定义的位置 一般情况下会有两种路由定义的位置，一种是项目工程的urls.py中，一种是每个应用下的urls.py中。项目工程的urls.py是Django解析路由的入口 路由解析顺序 Django在接收到请求时会先从项目工程urls.py中的urlpatterns列表中从上至下的顺序查找对应路由规则，如果发现规则为include包含，则再进入被包含的urls中的urlpatterns列表由上至下进行查询。 路由命名 在定义路由的时候，可以为路由命名，方便查找特定视图的具体路径信息。 在定义include函数定义路由时，可以使用namespace参数定义路由的命名空间，如 url(r'^users/', include('users.urls', namespace='users')), 命名空间表示，凡是users.urls中定义的路由，均属于namespace指明的users名下。 命名空间的作用：避免不同应用中的路由使用了相同的名字发生冲突，使用命名空间区别开。 在定义普通路由时，可以使用name参数指明路由的名字，如 urlpatterns = [ url(r'^index/$', views.index, name='index'), ] 路径结尾斜线的说明 Django中定义路由时，通常以斜线结尾，其好处是用户访问不以斜线结尾的相同路径时，Django会把用户重定向到以斜线/结尾的路径上，而不会返回404不存在。如 urlpatterns = [ url(r'^index/$', views.index, name='index'), ] 用户访问 index 或者 index/ 网址，均能访问到index视图。 虽然路由结尾带斜线能带来上述好处，但是却违背了HTTP中URL表示资源位置路径的设计理念。具体是否结尾带斜线以个人风格为准。 接下来我们要通过路由将工程-\u003e应用-\u003e视图给联系起来 首先在工程的总路由中添加users应用的路由信息 from django.contrib import admin + from django.urls import path, include urlpatterns = [ path('admin/', admin.site.urls), + path('users/', include('users.urls')), ] 说明： ‘users/‘表示所有/users/开头的请求 include表示以/users/匹配到users应用中urls.py的所有路由，即只要请求的URL是/users/开头都会去users应用中的urls.py中匹配剩下的路由。 将总路由引到users应用后，需要修改users应用中urls.py的信息 from django.conf.urls import url,re_path from . import views # urlpatterns是被django自动识别的路由列表变量 urlpatterns = [ # re_path是通过正则表达式来构造路由 # re_path(路由正则表达式，视图) re_path(r'^index/$', views.index), ] 说明： 现在完整的请求url为：/users/index/ 路由修改完成后，重启Django程序，就可以在浏览器中看到返回的信息了 ","date":"2019-03-09","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/:2:4","tags":["Django","教程"],"title":"Django基础教程之工程搭建","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/"},{"categories":["Django"],"content":"Django初体验","date":"2019-03-02","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/","tags":["Django","教程"],"title":"Django基础教程之初体验","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["Django"],"content":"声明：以下内容均为我个人的理解，如果发现错误或者疑问可以联系我共同探讨 ","date":"2019-03-02","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/:0:0","tags":["Django","教程"],"title":"Django基础教程之初体验","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["Django"],"content":"简介 在Django2.0以后，Django已经不支持python2.7，所以我们需要一个python3的系统环境，这里一python3.6为例 ","date":"2019-03-02","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/:1:0","tags":["Django","教程"],"title":"Django基础教程之初体验","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["Django"],"content":"安装Django ","date":"2019-03-02","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/:2:0","tags":["Django","教程"],"title":"Django基础教程之初体验","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["Django"],"content":"三种方式安装 pip安装 一般情况下安装python后会帮你安装好pip，当你没安装时使用这个链接安装,记得更新到最新版本 安装并使用virtualenv 在创建好并激活的虚拟环境中输入一下命令 $ pip install Django 通过第三方软件包 管理系统集成的Django 安装开发版本 安装好git 输入一下命令下载Django $ git clone https://github.com/django/django.git 安装并使用virtualenv 在创建好并激活的虚拟环境中输入一下命令 $ pip install -e django/ 安装好Django后可以通过一下命令查看当前Django版本 $ python -m django --version ","date":"2019-03-02","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/:2:1","tags":["Django","教程"],"title":"Django基础教程之初体验","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["Django"],"content":"Django初体验 ","date":"2019-03-02","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/:3:0","tags":["Django","教程"],"title":"Django基础教程之初体验","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["Django"],"content":"安装并使用virtualenv 详细过程见这个链接 ","date":"2019-03-02","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/:3:1","tags":["Django","教程"],"title":"Django基础教程之初体验","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["Django"],"content":"创建Django项目 在项目存放目录打开命令行运行一下命令： $ django-admin startproject mysite 这句话执行过后会在当前目录生成一个名字为mysite的Django项目，目录结构为下 mysite/ manage.py mysite/ __init__.py settings.py urls.py wsgi.py 这些目录和文件的作用： mysite/目录：存放项目的容器，他的名字不重要可以更换为你喜欢的任何名字 manage.py：Django项目的启动文件，他可以让你通过各种方式管理Django项目。 mysite/mysite/目录：项目目录，里面存放项目相关的文件 mysite/mysite/settings.py：Django项目的配置文件 mysite/mysite/urls.py：Django项目的url声明文件,他将url对应相关的app的视图 mysite/mysite/wsgi.py：Django项目wsgi服务器的入口 当输入以下命令，并进入浏览器输入：http://127.0.0.1:8000/看到Django启动成功 $ python manage.py runserver 这里能启动成功是因为Django自带一个简易的服务器（用纯 Python 写的轻量级的 Web 服务器）。他能帮助我们快速开发。 ","date":"2019-03-02","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/:3:2","tags":["Django","教程"],"title":"Django基础教程之初体验","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["Django"],"content":"创建一个应用 将当前目录切换到manage.py所在的目录，输入下面的命令创建一个应用: $ python manage.py startapp demo 该应用的目录结构大致如下 demo/ __init__.py admin.py apps.py migrations/ __init__.py models.py tests.py views.py 这些目录和文件的作用： admin.py：管理admin后台相关数据库模型 apps.py：该应用的相关配置 migrations/文件夹及其内容：数据库迁移相关的文件夹，里面存放着迁移版本，迁移信息等 models.py：编写模型类的文件 tests.py：用于测试的文件 view.py：编写视图的文件 我们还要在项目配置文件中注册该app，打开settings.py文件，找到INSTALLED_APPS，在列表的最后添加demoapp mysite/settings.py INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', # 注册demo 'demo.apps.DemoConfig' ] ","date":"2019-03-02","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/:3:3","tags":["Django","教程"],"title":"Django基础教程之初体验","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["Django"],"content":"编写第一个视图 视图在应用的views.py中编写 demo/views.py from django.http import HttpResponse def index(request): return HttpResponse(\"Hello, world!\") 为了能看到效果我们还需要配置一下url，在demo目录下创建一个urls.py，并输入一下代码 /demo/urls.py from django.urls import path from . import views urlpatterns = [ path(\"\",views.index,name='index'), ] 更改项目url，通过修改项目urls.py文件修改路由 /mysite/urls.py from django.contrib import admin from django.urls import include, path urlpatterns = [ path('demo/', include('demo.urls')), path('admin/', admin.site.urls), ] 这里include是将demo/的路由转发到demo应用的urls.py里。每当 Django 遇到 include时，它会截断与此项匹配的 URL 的部分，并将剩余的字符串发送到 对应urls.py以供进一步处理。 path有五个参数：route、view、kwargs、name、Pattern，其中route、view是必须传入的参数 route：匹配url的准则（类似于正则表达式）。当Django响应一个请求时，他会从urlpatterns的第一项开始，按顺序依次匹配，知道找到匹配的项 view：目标视图函数。当route找到匹配的项后，会调用当前的视图函数，并传入一个HttpRequest对象作为第一个参数，route中的参数一关键字参数的形式传入 kwargs：关键字参数。任意个关键字参数可以作为一个字典传递给目标视图函数。 name：为url取的名字。他可以使Django在任意地方引用他 Pattern：匹配模式 现在可以启动Django程序来看是否正常工作 ","date":"2019-03-02","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/:3:4","tags":["Django","教程"],"title":"Django基础教程之初体验","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["Django"],"content":"数据库 创建数据库 进入mysql并创建一个test数据库，字符设置为utf8 $ mysql -uroot -p mysql\u003e create database test charset=utf8; Query OK, 1 row affected (0.00 sec) 数据库配置 首先我们需要配置mysite/setting.py中的数据库DATABASES选项，Django默认是sqlite数据库，如果个人项目不大的情况下可以使用这个，也可以使用自己熟悉的数据库，Django不仅支持sqlite，postgresql，mysql，或oracle，还支持很多有第三方插件的数据库，我使用mysql数据库 /mysite/settings.py DATABASES = { 'default': { 'ENGINE': 'django.db.backends.mysql', # 数据库名 'NAME': 'test', # 用户名 'USER': 'root', # 密码 'PASSWORD': 'mysql' # 主机,默认为localhost 'HOST': '' # 端口号，默认为3306 'PORT': '' } } 数据库迁移 因为Django自带应用已经为我们编写了一些数据模型，即时我们不编写任何模型也可以直接使用数据库迁移命令进行迁移 $ python manage.py migrate 会看到初始化了很多用户、权限相关的表 创建一个管理员账号，依次输入用户名、邮箱、密码、确认密码，建议密码设置复杂点 $ python manage.py createsuperuser 用户名 (leave blank to use '02'): admin 电子邮件地址: 1@gmail.com Password: Password (again): 密码跟 用户名 太相似了。 密码长度太短。密码必须包含至少 8 个字符。 这个密码太常见了。 Bypass password validation and create user anyway? [y/N]: y Superuser created successfully. 接下来启动项目，并在浏览器中输入http://127.0.0.1:8000/admin，进入后台管理界面 输入账号密码，点击登录即可 数据库迁移，需要三步 编写models.py文件，改变模型。 运行 python manage.py makemigrations为模型的改变生成迁移文件。 运行 python manage.py migrate 来应用数据库迁移。 创建一个图书模型 在demo应用下创建一个图书模型 /demo/models.py from django.db import models class Books(models.Model): # 书名 book_name = models.CharField(max_length=200) # 作者 author = models.CharField(max_length=50) 建立的模型有两个字段，书名和作者，使用了字符类型，增加了长度限制（注意在使用CharField时必须要添加max_length限制） 创建迁移模型并生成迁移文件 $ python manage.py makemigrations demo Migrations for 'demo': demo\\migrations\\0001_initial.py - Create model Books 会出现创建了Books这个模型，在demo应用的migrations文件夹下会多一个0001_initila.py的迁移文件，可以使用python manage.py sqlmigrate demo 0001可以查看这次数据库迁移的操作与具体的SQL语句 $ python manage.py sqlmigrate demo 0001 BEGIN; -- -- Create model Books -- CREATE TABLE `demo_books` (`id` integer AUTO_INCREMENT NOT NULL PRIMARY KEY, `book_name` varchar(200) NOT NULL, `auhtor` varchar(50) NOT NULL); COMMIT; 需要注意一下几点： 输出的内容与使用的数据库有关。 数据库的表名默认是“应用名_模型名的小写”，也可以自定义表名。 主键会默认自动创建，也可以自定义主键。 Django会为使用的数据库定制相关SQL语句，例如主键：integer AUTO_INCREMENT NOT NULL PRIMARY KEY，varchar：NOT NULL sqlmigrate命令并没有真正执行迁移命令，他只是将迁移命令执行的流程输出到屏幕上，供你查看 执行check命令对项目做检查 $ python manage.py check System check identified no issues (0 silenced). 没有问题后执行迁移命令 $ python manage.py migrate Operations to perform: Apply all migrations: admin, auth, contenttypes, demo, sessions Running migrations: Applying demo.0001_initial... OK 看到以上内容即完成了数据库迁移 通过Python命令行尝试 $ python manage.py shell \u003e\u003e\u003e from demo.models import Books \u003e\u003e\u003e ggzh = Books(book_name=\"硅谷之火\",author=\"迈克尔.斯韦因\") \u003e\u003e\u003e ggzh.save() \u003e\u003e\u003e ggzh.id 1 \u003e\u003e\u003e ggzh.book_name '硅谷之火' \u003e\u003e\u003e ggzh.author '迈克尔.斯韦因' \u003e\u003e\u003e Books.objects.all() \u003cQuerySet [\u003cBooks: Books object (1)\u003e]\u003e 这里我们看到\u003cQuerySet [\u003cBooks: Books object (1)\u003e]\u003e这个并不能让我们知道这个对象的细节，通过修改Books模型来修复这个问题 /demo/models.py class Books(models.Model): # 书名 book_name = models.CharField(max_length=200) # 作者 author = models.CharField(max_length=50) def __str__(self): return self.book_name 修改完成后重新进入交互终端，再次查询就可以显示书名了，这里可以自己定义想显示的字段或内容 $ python manage.py shell \u003e\u003e\u003e from demo.models import Books \u003e\u003e\u003e Books.objects.all() \u003cQuerySet [\u003cBooks: 硅谷之火\u003e]\u003e 再添加一本书，聚合函数 \u003e\u003e\u003e qbsz = Books(book_name=\"史蒂夫*乔布斯传\",author=\"沃尔特·艾萨克森\") \u003e\u003e\u003e qbsz.save() \u003e\u003e\u003e Books.objects.all() \u003cQuerySet [\u003cBooks: 硅谷之火\u003e, \u003cBooks: 史蒂夫*乔布斯传\u003e]\u003e \u003e\u003e\u003e Books.objects.count() 2 \u003e\u003e\u003e Books.objects.filter(book_name=\"硅谷之火\") \u003cQuerySet [\u003cBooks: 硅谷之火\u003e]\u003e 接下来我们将Books模型添加到admin管理，通过register方法，将Books交给admin管理 /demo/admin from django.contrib import admin from .models import Books admin.site.register(Books) 重新运行项目，在地址栏输入：http://127.0.0.1:8000/admin/，输入账号密码登录即可查看到这个模型 点进去可以查看该模型的数据，右上角可以添加，动作可以删除，点图书名可以看到更多细节 ","date":"2019-03-02","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/:3:5","tags":["Django","教程"],"title":"Django基础教程之初体验","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["Django"],"content":"视图与模板 在models.py中添加一个图书模型 /demo/models.py from django.db import models class Books(models.Model): # 书名 name = models.CharField('书名', max_length=200) # 作者 author = models.CharField('作者', max_length=50) publish_house = models.CharField('出版社', max_length=50) publish_date = models.CharField('出版日期', max_length=50) price = models.IntegerField('价格') synopsis = models.TextField('简介') def __str__(self): return self.name 在admin.py中注册Books 迁移数据库 在Django后台中添加图书数据 在应用的views.py中编写一个展示图书的视图 /demo/views.py from django.http import HttpResponse from .models import Books def book_list(request): book_list = Books.objects.all() books = {book.name : book.id for book in book_list} return render(request, 'index.html', context={'books': books}) 通过模板渲染 在templates目录下新建一个index.html文件 /tempaltes/index.html \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv\u003e图书管理系统：\u003c/div\u003e \u003cul\u003e \u003c/ul\u003e \u003c/body\u003e \u003c/html\u003e 在项目的urls.py文件中添加一个关于图书的路由 /mysite/urls.py from django.contrib import admin from django.urls import path from demo import views urlpatterns = [ path('admin/', admin.site.urls), path('book/', include('demo.urls')), ] 在demo目录中新建一个urls.py文件，并添加一个路由 /demo/urls.py from django.urls import path from . import views urlpatterns = [ path('', views.book_list, name='index'), ] 启动项目，访问：http://127.0.0.1:8000/book/ 图书列表页完成了，接下来编写图书详情页 在demo项目中的urls.py文件中添加一个详情页的路由 /demo/urls.py from django.urls import path from . import views urlpatterns = [ path('', views.book_list, name='index'), path('\u003cint:id\u003e/', views.detail, name='detail'), ] 在demo项目中的views.py文件中编写详情页相关视图函数 /demo/views.py def detail(request, id): book = Books.objects.filter(id=id).all()[0] content = { \"name\": book.name, \"author\": book.author, 'publish_house': book.publish_house, 'publish_date': book.publish_date, 'price': book.price, 'synopsis': book.synopsis } return render(request, 'detail.html', context=content) 在templates文件夹里新建一个detail.html文件,并写入一下代码 /templates/detail.html \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ctable\u003e \u003ctr\u003e \u003ctd\u003e书名\u003c/td\u003e \u003ctd\u003e作者\u003c/td\u003e \u003ctd\u003e出版社\u003c/td\u003e \u003ctd\u003e出版日期\u003c/td\u003e \u003ctd\u003e价格\u003c/td\u003e \u003ctd\u003e简介\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e{{ name }}\u003c/td\u003e \u003ctd\u003e{{ author }}\u003c/td\u003e \u003ctd\u003e{{ publish_house }}\u003c/td\u003e \u003ctd\u003e{{ publish_date }}\u003c/td\u003e \u003ctd\u003e{{ price }}\u003c/td\u003e \u003ctd\u003e{{ synopsis }}\u003c/td\u003e \u003c/tr\u003e \u003c/table\u003e \u003c/body\u003e \u003c/html\u003e 启动项目，访问：http://127.0.0.1:8000/book/，点击其中一个图书就可以看到详情页，或者直接选择一个id访问详情页，这时候就会出现一个问题，当访问一个不存在的id时就会出错，我们需要定制一下错误页面，修改detail视图函数。 /demo/views.py from django.http import Http404 ... def detail(request, id): books = Books.objects.filter(id=id).all() if len(books): book = books[0] content = { \"name\": book.name, \"author\": book.author, 'publish_house': book.publish_house, 'publish_date': book.publish_date, 'price': book.price, 'synopsis': book.synopsis } return render(request, 'detail.html', context=content) else: raise Http404(\"图书不存在\") 这里调用的是Django自带的404错误页面，我们需要返回错误说明 ","date":"2019-03-02","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/:3:6","tags":["Django","教程"],"title":"Django基础教程之初体验","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["Django"],"content":"Django介绍","date":"2019-02-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BB%8B%E7%BB%8D/","tags":["Django","教程"],"title":"Django基础教程之介绍","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BB%8B%E7%BB%8D/"},{"categories":["Django"],"content":"声明：以下内容均为我个人的理解，如果发现错误或者疑问可以联系我共同探讨 本教程为Django基础教程系列第一篇 ","date":"2019-02-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BB%8B%E7%BB%8D/:0:0","tags":["Django","教程"],"title":"Django基础教程之介绍","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BB%8B%E7%BB%8D/"},{"categories":["Django"],"content":"前言 为什么网上有很多Django的学习资料，我还想自己写一个Django的教程呢，一是想通过写教程发现自己的不足，二是想通过自己的总结让那些想学习Django的小伙伴们少走一些弯路，当然我写的内容有可能也是错的，欢迎大家纠正，我们可以共同探讨，共同进步。 ","date":"2019-02-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BB%8B%E7%BB%8D/:1:0","tags":["Django","教程"],"title":"Django基础教程之介绍","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BB%8B%E7%BB%8D/"},{"categories":["Django"],"content":"简介 Django是一个高级Python Web框架，可以快速开发和简洁实用的设计。Django负责处理网站开发中遇到的问题，编程人员只需要专注于应用编写，无需重新造轮子。它是免费和开源的。 ","date":"2019-02-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BB%8B%E7%BB%8D/:2:0","tags":["Django","教程"],"title":"Django基础教程之介绍","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BB%8B%E7%BB%8D/"},{"categories":["Django"],"content":"特点 ","date":"2019-02-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BB%8B%E7%BB%8D/:3:0","tags":["Django","教程"],"title":"Django基础教程之介绍","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BB%8B%E7%BB%8D/"},{"categories":["Django"],"content":"完备性 Django原生提供了众多的功能组件，对于开发人员来说Django几乎做到了开箱即用。 ","date":"2019-02-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BB%8B%E7%BB%8D/:3:1","tags":["Django","教程"],"title":"Django基础教程之介绍","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BB%8B%E7%BB%8D/"},{"categories":["Django"],"content":"安全 Django认真对待安全性，并帮助开发人员避免许多常见的安全性错误，例如SQL注入，跨站点脚本编写，跨站点请求伪造和点击劫持。其用户身份验证系统提供了一种安全的方式来管理用户帐户和密码。 ","date":"2019-02-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BB%8B%E7%BB%8D/:3:2","tags":["Django","教程"],"title":"Django基础教程之介绍","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BB%8B%E7%BB%8D/"},{"categories":["Django"],"content":"可扩展性 Django强调代码复用，多个组件可以以\"插件\"的形式服务于整个框架，Django还有许多功能强大的第三方插件，你也可以开发自己的工具包。 ","date":"2019-02-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BB%8B%E7%BB%8D/:3:3","tags":["Django","教程"],"title":"Django基础教程之介绍","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BB%8B%E7%BB%8D/"},{"categories":["Django"],"content":"MVT模式 Django采用MVT程序设计模式 M全拼为Model，主要封装对数据库层的访问，对数据库中的数据进行增、删、改、查操作。 V全拼为View，用于接收请求，进行业务处理，返回应答。 T全拼为Template，用于封装结果，负责封装构造要返回的html。 ","date":"2019-02-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BB%8B%E7%BB%8D/:4:0","tags":["Django","教程"],"title":"Django基础教程之介绍","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BB%8B%E7%BB%8D/"},{"categories":["Django"],"content":"Django学习资料 Django官网 Django项目Github Django Book 教程 Mozilla Django教程 ","date":"2019-02-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BB%8B%E7%BB%8D/:5:0","tags":["Django","教程"],"title":"Django基础教程之介绍","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BB%8B%E7%BB%8D/"},{"categories":["Django"],"content":"Django2.x配置mysql","date":"2019-02-17","objectID":"/django2.x%E9%85%8D%E7%BD%AEmysql/","tags":["msql","Django"],"title":"Django2.x配置mysql","uri":"/django2.x%E9%85%8D%E7%BD%AEmysql/"},{"categories":["Django"],"content":"声明：以下内容均为我个人的理解，如果发现错误或者疑问可以联系我共同探讨 ","date":"2019-02-17","objectID":"/django2.x%E9%85%8D%E7%BD%AEmysql/:0:0","tags":["msql","Django"],"title":"Django2.x配置mysql","uri":"/django2.x%E9%85%8D%E7%BD%AEmysql/"},{"categories":["Django"],"content":"简介 在Django中使用mysql数据库是很常见的,但是升级到Django2.0以后，已经不支持Python2.x，mysql的配置也需要随之改变 ","date":"2019-02-17","objectID":"/django2.x%E9%85%8D%E7%BD%AEmysql/:1:0","tags":["msql","Django"],"title":"Django2.x配置mysql","uri":"/django2.x%E9%85%8D%E7%BD%AEmysql/"},{"categories":["Django"],"content":"配置 ","date":"2019-02-17","objectID":"/django2.x%E9%85%8D%E7%BD%AEmysql/:2:0","tags":["msql","Django"],"title":"Django2.x配置mysql","uri":"/django2.x%E9%85%8D%E7%BD%AEmysql/"},{"categories":["Django"],"content":"配置settings.py DATABASES = { 'default': { 'ENGINE': 'django.db.backends.mysql', 'NAME': 'dbname', 'USER': 'dbuser', 'PASSWORD': 'dbpassword', 'HOST':'dbhost', 'PORT':'dbport' } } ","date":"2019-02-17","objectID":"/django2.x%E9%85%8D%E7%BD%AEmysql/:2:1","tags":["msql","Django"],"title":"Django2.x配置mysql","uri":"/django2.x%E9%85%8D%E7%BD%AEmysql/"},{"categories":["Django"],"content":"使用pymysql 由于安装mysqlclient不支持python3，所以使用pymysql包，安装pymysql并导入 pip install pymysql 配置pymysql，在settings.py所在的目录下的__init__.py文件中导入 import pymysql pymysql.install_as_MySQLdb() ","date":"2019-02-17","objectID":"/django2.x%E9%85%8D%E7%BD%AEmysql/:2:2","tags":["msql","Django"],"title":"Django2.x配置mysql","uri":"/django2.x%E9%85%8D%E7%BD%AEmysql/"},{"categories":["Django"],"content":"修改源码中的问题 由于在python3中不在使用mysqlclient，所以源码中限制mysqlclient版本这一代码就不适用于现在的环境 文件路径django\\db\\backends\\mysql\\base.py，将版本限制异常给注释掉在文件的第35-36行 # if version \u003c (1, 3, 13): # raise ImproperlyConfigured('mysqlclient 1.3.13 or newer is required; you have %s.' % Database.__version__) 由于python2的str是字节流(类似于bytes类型)需要通过decode转换成unicode类型才能使用，但在python3中str默认unicode类型不需要转换且没有decode解码所以要将这里的代码修改。在最新的Django源码中已经将这里修改了(可以通过Django官网或github查看)，在最新的源码中使用django.utils.encoding中force_str方法解决了该问题，force_str方法实际上是force_text方法，force_text方法通过判断传入参数的类型后将类型转为unicode类型的str之后返回 \\django\\utils\\encoding.py ······ def force_text(s, encoding='utf-8', strings_only=False, errors='strict'): \"\"\" Similar to smart_text, except that lazy instances are resolved to strings, rather than kept as lazy objects. If strings_only is True, don't convert (some) non-string-like objects. \"\"\" # Handle the common case first for performance reasons. if issubclass(type(s), str): return s if strings_only and is_protected_type(s): return s try: if isinstance(s, bytes): s = str(s, encoding, errors) else: s = str(s) except UnicodeDecodeError as e: raise DjangoUnicodeDecodeError(s, *e.args) return s 最后修改\\django\\db\\backends\\mysql\\operations.py文件中的last_executed_query方法（记得导入force_str） from django.utils.encoding import force_str ··· def last_executed_query(self, cursor, sql, params): # With MySQLdb, cursor objects have an (undocumented) \"_executed\" # attribute where the exact query sent to the database is saved. # See MySQLdb/cursors.py in the source distribution. # MySQLdb returns string, PyMySQL bytes. return force_str(getattr(cursor, '_executed', None), errors='replace') ","date":"2019-02-17","objectID":"/django2.x%E9%85%8D%E7%BD%AEmysql/:2:3","tags":["msql","Django"],"title":"Django2.x配置mysql","uri":"/django2.x%E9%85%8D%E7%BD%AEmysql/"},{"categories":["Python"],"content":"Python时间合集","date":"2019-01-26","objectID":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/","tags":["时间"],"title":"Python时间合集","uri":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/"},{"categories":["Python"],"content":"声明：以下内容均为我个人的理解，如果发现错误或者疑问可以联系我共同探讨 ","date":"2019-01-26","objectID":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/:0:0","tags":["时间"],"title":"Python时间合集","uri":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/"},{"categories":["Python"],"content":"python3中时间的表示形式 ","date":"2019-01-26","objectID":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/:1:0","tags":["时间"],"title":"Python时间合集","uri":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/"},{"categories":["Python"],"content":"格式化时间字符串 格式化时间字符串（string_time）,指格式化输出指定输出参数的格式与相对位置的字符串参数，与python中的format作用类似，常见的格式化时间字符串：\"%Y-%m-%d %H:%M:%S %z,%a,%A,%b,%B,%c,%I,%p” 常用的表 名 称 含 义 例 子 %Y 有世纪并用0填充的十进制数年份 0001, 0002, …, 2013, 2014, …, 9998, 9999 %m 用零填充十进制数的月份 01, 02, …, 12 %d 用零填充十进制数的月中的某一天 01, 02, …, 31 %H 24小时格式的用0填充的十进制数小时 00, 01, …, 23 %M 用0填充的十进制数分钟 00, 01, …, 59 %S 用0填充的十进制数秒 00, 01, …, 59 %z 用零填充的十进制小时分钟秒毫秒的时差 (empty), +0000, -0400, +1030, +063415, -030712.345216 %a 根据区域设置的缩写的星期名称 Sun, Mon, …, Sat (en_US) So, Mo, …, Sa (de_DE) %A 根据区域设置的完整星期名称 Sunday, Monday, …, Saturday (en_US) Sonntag, Montag, …, Samstag (de_DE) 吐槽一下官网注释秒的范围是0-59，实测0-61都可以 官方的完整表： 以下是C标准（1989版）所需的所有格式代码的列表，这些代码适用于具有标准C实现的所有平台。请注意，1999版C标准添加了其他格式代码。 名 称 含 义 例 子 %a 根据区域设置的缩写的星期名称 Sun, Mon, …, Sat (en_US)So, Mo, …, Sa (de_DE) %A 根据区域设置的完整星期名称 Sunday, Monday, …, Saturday (en_US)Sonntag, Montag, …, Samstag (de_DE) %w 将工作日变成十进制数，其中0表示星期日，6表示星期六 0, 1, …, 6 %d 用零填充十进制数的月中的某一天 01, 02, …, 31 %b 根据区域设置的缩写月份名 Jan, Feb, …, Dec (en_US);Jan, Feb, …, Dez (de_DE) %B 根据区域改变月份全称 January, February, …, December (en_US)Januar, Februar, …, Dezember (de_DE) %m 用零填充十进制数的月份 01, 02, …, 12 %y 没有世纪并用0填充的十进制数年份 00, 01, …, 99 %Y 有世纪并用0填充的十进制数年份 0001, 0002, …, 2013, 2014, …, 9998, 9999 ","date":"2019-01-26","objectID":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/:1:1","tags":["时间"],"title":"Python时间合集","uri":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/"},{"categories":["Python"],"content":"时间戳 时间戳（Timestamp）,指字符串或编码信息用于辨识记录下来的时间日期，维基百科解释的不容易懂，我的个人理解是从1970年1月1日到现在过去了多少秒。 ","date":"2019-01-26","objectID":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/:1:2","tags":["时间"],"title":"Python时间合集","uri":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/"},{"categories":["Python"],"content":"时间元祖 时间元祖(struct_time),指包含9个特殊元素的元祖，（tm_year，tm_mon，tm_mday，tm_hour，tm_min，tm_sec，tm_wday，tm_yday，tm_isdst），详情见下表格 名 称 含 义 值 tm_year 年 具体年份，例：2017 tm_mon 月 1-12 tm_mday 日 1-31 tm_hour 时 1-23 tm_min 分 0-59 tm_sec 秒 0-61 tm_wday 周 0-6（从周末开始） tm_yday 在一年中的第几天 1-666 tm_isdst 是否为夏令时 -1,0,1（能表示true和flase的值） ","date":"2019-01-26","objectID":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/:1:3","tags":["时间"],"title":"Python时间合集","uri":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/"},{"categories":["Python"],"content":"时间对象 时间对象（time_object）,指通过某些时间类生成的对象，例如datetime对象。 ","date":"2019-01-26","objectID":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/:1:4","tags":["时间"],"title":"Python时间合集","uri":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/"},{"categories":["Python"],"content":"python中两大时间库： ","date":"2019-01-26","objectID":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/:2:0","tags":["时间"],"title":"Python时间合集","uri":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/"},{"categories":["Python"],"content":"time 简介： 常用于具体时间操作 常量 Variables with simple values，值简单的变量 altzone，-32400 daylight，0 timezone，-28800 _STRUCT_TM_ITEMS，11 variables with complex values，值复杂的变量 tzname 但是如果直接调用会得到一个乱码的值，看不懂，查阅资料后发现通过重新编码解码可以看到真实值，这里很感谢这个爱思考的博主，这里编码解码参考他的博客，这条博文在这里：https://www.cnblogs.com/luo630/p/9555684.html，里面讲的很详细 \u003e\u003e\u003e time.tzname[0].encode('latin-1').decode('gbk') '中国标准时间' \u003e\u003e\u003e time.tzname[1].encode('latin-1').decode('gbk') '中国夏令时' 方法： asctime：将时间元组转换为字符串，当没有传入参数时，调用localtime()返回的当前时间，参数类型：元祖，返回类型：字符串。例如： \u003e\u003e\u003e import time \u003e\u003e\u003e time.asctime() 'Tue Jun 11 16:07:40 2017' \u003e\u003e\u003e time.asctime((2017,6,11,16,7,40,59,59,59)) # 这里必须要穿一个包含9个数字的元组，且年月日时分都必须符合时间逻辑，秒必须小于等于61，不知道为什么是61，后面三位逻辑暂时还没弄明白，但是跟前面对应的年月日有关 'Thu Jun 11 16:07:40 2017' clock：计时器函数，在进程结束后返回从开始到第一次调用该函数使用的时间，返回类型：浮点数。例如： \u003e\u003e\u003e time.clock() 5e-07 \u003e\u003e\u003e time.sleep(1) \u003e\u003e\u003e time.clock() 11.9833418 \u003e\u003e\u003e time.sleep(10) \u003e\u003e\u003e time.clock() 35.1999596 ctime：将时间戳转换为以本地时间为单位的字符串。相当于asctime(localtime(seconds))。当没有传入参数时，使用localtime()返回的当前时间。参数类型：时间戳，返回类型：字符串。例如： \u003e\u003e\u003e time.ctime(1555555550) 'Thu Apr 18 10:45:50 2017' \u003e\u003e\u003e time.ctime() 'Tue Jun 11 17:08:44 2017' get_clock_info：获取有关指定时钟的信息作为命名空间对象。支持的时钟名称和读取其值的相应函数是： ‘clock’： time.clock() ‘monotonic’： time.monotonic() ‘perf_counter’： time.perf_counter() ‘process_time’： time.process_time() ‘thread_time’： time.thread_time() ‘time’： time.time() 结果具有以下属性： adjustable：True如果时钟可以自动更改（例如通过NTP守护程序）或由系统管理员手动更改，False否则 implementation：用于获取时钟值的基础C函数的名称。有关可能的值，请参阅时钟ID常量。 单调：True如果时钟不能倒退， False否则分辨率：时钟的分辨率（秒）（float） gmtime：将时间戳转换为时间元祖，当没有传入参数时，返回当前世界标准时间的时间元祖。参数类型：时间戳，返回类型：元祖（但是查看源码只有一个pass）。例如： \u003e\u003e\u003e time.gmtime(1555555550) time.struct_time(tm_year=2017, tm_mon=4, tm_mday=18, tm_hour=2, tm_min=45, tm_sec=50, tm_wday=3, tm_yday=108, tm_isdst=0) \u003e\u003e\u003e time.gmtime() time.struct_time(tm_year=2017, tm_mon=6, tm_mday=11, tm_hour=9, tm_min=18, tm_sec=54, tm_wday=1, tm_yday=162, tm_isdst=0) localtime：与gmtime功能类似，但是返回的时间变成了当地时间。例如： \u003e\u003e\u003e time.localtime(1555555550) time.struct_time(tm_year=2017, tm_mon=4, tm_mday=18, tm_hour=10, tm_min=45, tm_sec=50, tm_wday=3, tm_yday=108, tm_isdst=0) \u003e\u003e\u003e time.localtime() time.struct_time(tm_year=2017, tm_mon=6, tm_mday=11, tm_hour=17, tm_min=28, tm_sec=34, tm_wday=1, tm_yday=162, tm_isdst=0) mktime：将时间元祖转化为时间戳，返回时间戳。参数类型：时间元祖（9个元素），返回类型：时间戳。例如： \u003e\u003e\u003e time.mktime((2017,4,18,10,45,50,3,108,0)) 1555555550.0 monotonic: 一个单调的计时器，不能倒转。不知道从什么时候开始的，返回类型：浮点型。例如： \u003e\u003e\u003e def func(): ... print(time.monotonic()) ... time.sleep(1) ... \u003e\u003e\u003e i = 0 \u003e\u003e\u003e while i\u003c5: ... func() ... i+=1 ... 461875.89 461876.89 461877.89 461878.89 461879.89 perf_counter：性能计数器用于基准测试。不服跑个分！返回类型：浮点型。例如： \u003e\u003e\u003e time.perf_counter() 3674.2299851 \u003e\u003e\u003e time.perf_counter() 3675.2086447 \u003e\u003e\u003e time.perf_counter() 3675.9990329 process_time：用于分析的进程时间:内核和用户空间CPU时间的总和。返回类型：浮点型。例如： \u003e\u003e\u003e time.process_time() 4.40625 sleep:将执行延迟数秒。参数类型：int or float ,返回类型：无，这就不演示了…浪费时间 strftime：根据格式规范将时间元组转换为字符串。有关格式化代码，请参阅库参考手册。当没有传入参数时，使用localtime()返回的当前时间。传入参数：配对字符串,时间元祖（与字符串配对），返回参数：时间字符串,例： # 根据前面的格式化字符串来生成对应时间字符串 \u003e\u003e\u003e time.strftime(\"%Y-%m-%d%H:%M:%S\", (2017, 1, 1, 1, 1, 1, 1, 13, 0)) '2017-01-01 01:01:01' \u003e\u003e\u003e time.strftime(\"%Y-%m-%d%H:%M:%S %I\", (2017, 1, 1, 1, 1, 1, 1, 13, 0)) '2017-01-01 01:01:01 01' \u003e\u003e\u003e time.strftime(\"%Y-%m-%d%H:%M:%S %z,%a,%A,%b,%B,%c,%I,%p\", (2017, 1, 1, 1, 1, 1, 1, 13, 0)) '2017-01-01 01:01:01 +0800,Tue,Tuesday,Jan,January,Tue Jan 1 01:01:01 2017,01,AM' strptime：根据格式规范将字符串解析为时间元组。有关格式化代码，请参阅库参考手册(与strftime ())。传入参数：时间字符串，配对字符串。返回参数：时间元祖 例： python \u003e\u003e\u003e time.strptime(\"2017-01-01 01:01:02\", \"%Y-%m-%d %H:%M:%S\") time.struct_time(tm_year=2017, tm_mon=1, tm_mday=1, tm_hour=1, tm_min=1, tm_sec=2, tm_wday=1, tm_yday=1, tm_isdst=-1) time：以秒为单位返回从纪元开始的当前时间。如果系统时钟提供这些信息，那么可能只存在几分之一秒。就是我们常说的时间戳。返回参数：浮点数 ","date":"2019-01-26","objectID":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/:2:1","tags":["时间"],"title":"Python时间合集","uri":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/"},{"categories":["Python"],"content":"datetime 由五个模块组成 date： 简介 表示日期的类。常用的属性有year, month, day。 常量 date.min = date(1, 1, 1)，date.max = date(9999, 12, 31)，date.resolution = timedelta(days=1)，分别规定了date对象的最小值、最大值，date对象的最小单位，为天 类方法 fromtimestamp：将时间戳转化为date对象，参数类型：float，int，返回类型：date对象 \u003e\u003e\u003e from datetime import date \u003e\u003e\u003e date.fromtimestamp(1560415206) datetime.date(2017, 6, 13) \u003e\u003e\u003e type(date.fromtimestamp(1560415206)) \u003cclass 'datetime.date'\u003e today：获得今天的日期，返回类型：date对象 \u003e\u003e\u003e date.today() datetime.date(2017, 6, 13) \u003e\u003e\u003e type(date.today()) \u003cclass 'datetime.date'\u003e fromordinal：跟fromtimestamp类似 \u003e\u003e\u003e date.fromtimestamp(1560415206) datetime.date(2017, 6, 13) \u003e\u003e\u003e type(date.fromtimestamp(1560415206)) \u003cclass 'datetime.date'\u003e 实例方法 ctime：返回将日期对象转化为标准时间日期的 00:00:00 \u003e\u003e\u003e date(2017,6,13).ctime() 'Thu Jun 13 00:00:00 2017' strftime，返回将date对象转化为指定格式的date对象 \u003e\u003e\u003e d = date(2017,1,1) \u003e\u003e\u003e d.strftime(\"%d/%m/%y\") '01/01/17' \u003e\u003e\u003e type(d) \u003cclass 'datetime.date'\u003e isoformat,返回将date对象转化为’YYYY-MM-DD’格式的date对象, \u003e\u003e\u003e d = date(2017,2,2) \u003e\u003e\u003e d.isoformat() '2017-02-02' \u003e\u003e\u003e type(d) \u003cclass 'datetime.date'\u003e timetuple,返回与time.localtime()兼容的本地时间元组 \u003e\u003e\u003e date(2017,7,7).timetuple() time.struct_time(tm_year=2017, tm_mon=7, tm_mday=7, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=4, tm_yday=188, tm_isdst=-1) toordinal,按年、月、日返回子午线格列高利教序数。返回类型：int \u003e\u003e\u003e d = date(2017,7,7).toordinal() \u003e\u003e\u003e type(d) \u003cclass 'int'\u003e replace,根据传入的年月日修改date对象的年月日,参数类型：int,返回类型:date对象 \u003e\u003e\u003e d = date(2017,7,7) \u003e\u003e\u003e d.replace(month=8,day=8) datetime.date(2017, 8, 8) weekday,根据date对象，判断该日期为星期几,返回类型：int,0-6分别对应星期一到星期天 \u003e\u003e\u003e d = date(2017,6,12) \u003e\u003e\u003e a = d.weekday() 0 \u003e\u003e\u003e type(a) \u003cclass 'int'\u003e isoweekday，根据date对象，判断该日期为星期几,返回类型：int,1-7分别对应星期一到星期天 \u003e\u003e\u003e d = date(2017,6,12) \u003e\u003e\u003e a = d.isoweekday() 1 \u003e\u003e\u003e type(a) \u003cclass 'int'\u003e isocalendar,根据date对象，判断该日期为第几周的星期几，返回类型：包含年，第几周，星期几的元祖 \u003e\u003e\u003e d = date(2017,6,12) \u003e\u003e\u003e d.isocalendar() (2017, 24, 1) \u003e\u003e\u003e d = date(2017,7,12) \u003e\u003e\u003e d.isocalendar() (2017, 28, 3) 魔法属性 year,month,day：返回年、月、日 \u003e\u003e\u003e d = date(2017,6,13) \u003e\u003e\u003e d.year 2017 \u003e\u003e\u003e d.month 6 \u003e\u003e\u003e d.day 13 time 简介 表示时间的类。常用的属性有hour, minute, second, microsecond。 参数 hour=0, minute=0, second=0, microsecond=0, tzinfo=None, fold=0， hour，minute，小时和分钟必须传入，小时为0-23，分钟为0-59 second，microsecond，秒和毫秒，默认为0，可以不传，秒为0-59，毫秒为0-999999 tzinfo，时区默认为None,可以填你想要的时区 fold，在[0,1]。用于消除重复间隔期间的墙壁时间的歧义。(当时钟在夏令时结束时回滚，或由于政治原因降低当前区域的UTC偏移量时，会出现重复间隔。)值0(1)表示具有相同壁面时间表示的两个时刻中较早(较晚)的时刻。 常量 time.min，最早可表示的时间，时间(0,0,0,0)。 time.max，最新可表示时间，时间(23,59,59,999999)。 time.resolution在不相等的时间对象之间可能存在的最小差异是时间增量(微秒=1)，不过请注意，不支持对时间对象进行算术。 魔法属性 hour、minute、second、microsecond、tzinfo、fold分别返回时、分、秒、毫秒、时区与折叠关键字 \u003e\u003e\u003e from datetime import time \u003e\u003e\u003e t = time(9,9) \u003e\u003e\u003e t.hour 9 \u003e\u003e\u003e t.minute 9 \u003e\u003e\u003e t.second 0 \u003e\u003e\u003e t.microsecond 0 \u003e\u003e\u003e t.tzinfo \u003e\u003e\u003e t.fold 0 实例方法 isoformat，返回按ISO格式格式化的时间字符串。完整的格式是’HH:MM:SS.mmmmmm+zz:zz’可选参数：timespec，指定附加的数量所包括的时间条款 \u003e\u003e\u003e t = time(8,8) \u003e\u003e\u003e a = t.isoformat() \u003e\u003e\u003e a '08:08:00' \u003e\u003e\u003e type(a) \u003cclass 'str'\u003e strftime，返回一个表示时间的字符串，由显式格式字符串控制。参数 datetime.time(9, 9) \u003e\u003e\u003e t = time(9,9) \u003e\u003e\u003e t datetime.time(9, 9) \u003e\u003e\u003e t.strftime(\"%H/%H/%S\") '09/09/00' replace,返回根据关键字替换datetime.time对象中的值,参数：hour, minute, second, microsecond, tzinfo,fold \u003e\u003e\u003e time(9,9).replace(8,8) datetime.time(8, 8) utcoffset,根据utc返回以东的时区偏移（可以理解为时差），以分钟为单位，如果没有设置tzinfo则返回none。 \u003e\u003e\u003e class UTC(tzinfo): ... def __init__(self,offset = 0): ... self._offset = offset ... def utcoffset(self,dt): ... return timedelta(hours=self._offset) ... def tzname(self,dt): ... return \"UTC +%s\" % self._offset ... def dst(self, dt): ... return timedelta(hours=self._offset) ... \u003e\u003e\u003e time(9,9).utcoffset() \u003e\u003e\u003e \u003e\u003e\u003e time(9,9,tzinfo=UTC(8)).utcoffset() datetime.timedelta(0, 28800) tzname,返回时区的名字 \u003e\u003e\u003e time(9,9,tzinfo=UTC(8)).tzname() 'UTC +8' dst,返回dst偏移信息，如果没有则返回none \u003e\u003e\u003e time(9,9,tzinfo=UTC(8)).dst() datetime.timedelta(0, 28800) \u003e\u003e\u003e time(9,9).dst() \u003e\u003e\u003e datetime 简介 表示日期+时间 参数 year, month, day, hour=0, minute=0, second=0, microsecond=0, tzinfo=None, fold=0，年，月，日参数是必需的。 tzinfo可以是None，或者是tzinfo子类的实例。其余参数可以是整数，在以下范围内： MINYEAR \u003c= year \u003c= MAXYEAR， 1 \u003c= month \u003c= 12， 1 \u003c= day \u003c= number of days in the given month and year， 0 \u003c= ho","date":"2019-01-26","objectID":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/:2:2","tags":["时间"],"title":"Python时间合集","uri":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/"},{"categories":["Python"],"content":"Python搭建虚拟环境","date":"2019-01-20","objectID":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/","tags":["虚拟环境"],"title":"Python搭建虚拟环境","uri":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"},{"categories":["Python"],"content":"声明：以下内容均为我个人的理解，如果发现错误或者疑问可以联系我共同探讨 ","date":"2019-01-20","objectID":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/:0:0","tags":["虚拟环境"],"title":"Python搭建虚拟环境","uri":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"},{"categories":["Python"],"content":"为什么要搭建虚拟环境。 平时开发的过程中会遇到不同的项目，往往不同的项目之间需要的第三方包会有所差异，如果我们都在系统的python环境中会导致遇到很多问题，通过虚拟环境搭建一套独立的python运行环境，可以让项目之间互不干扰。 ","date":"2019-01-20","objectID":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/:1:0","tags":["虚拟环境"],"title":"Python搭建虚拟环境","uri":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"},{"categories":["Python"],"content":"如何搭建 一般我们搭建虚拟环境都会用上virtualenv，它是一个可以创建并管理python虚拟环境的第三方包。 ","date":"2019-01-20","objectID":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/:2:0","tags":["虚拟环境"],"title":"Python搭建虚拟环境","uri":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"},{"categories":["Python"],"content":"安装 不论是windows还是linux还是mac都可以直接通过pip 安装，需要注意的是系统中存在两个python的时候，注意pip的版本，选择对应的版本安装 pip install virtualenv ","date":"2019-01-20","objectID":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/:2:1","tags":["虚拟环境"],"title":"Python搭建虚拟环境","uri":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"},{"categories":["Python"],"content":"创建虚拟环境 我们通常会创建一个文件夹为env(当然你也可以去任何你喜欢的名字)，专门用来存放不同的虚拟环境 进入到env文件夹中通过命令创建一个虚拟环境，名为first_env virtualenv first_env 相关参数说明 -p:选择要使用的Python解释器，默认为安装virtualenv的解释器 –prompt=xx:将xx设置为虚拟环境的提示前缀 ","date":"2019-01-20","objectID":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/:2:2","tags":["虚拟环境"],"title":"Python搭建虚拟环境","uri":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"},{"categories":["Python"],"content":"使用虚拟环境 Windows 进入虚拟环境的Scripts目录 在此处打开命令行工具 输入activate，当命令提示符多了一个虚拟环境名字的前缀时即激活成功 Linux or Mac 通过source激活使用，当命令提示符多了一个虚拟环境名字的前缀时即激活成功 source first_env/bin/activate ","date":"2019-01-20","objectID":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/:2:3","tags":["虚拟环境"],"title":"Python搭建虚拟环境","uri":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"},{"categories":["Python"],"content":"退出虚拟环境 在当前虚拟环境中输入deactivate，当命令提示符虚拟环境名字的前缀消失时即退出 ","date":"2019-01-20","objectID":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/:2:4","tags":["虚拟环境"],"title":"Python搭建虚拟环境","uri":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"},{"categories":["Python"],"content":"删除虚拟环境 在我们不需要这个虚拟环境的时候只需要将该虚拟环境的整个包删除即可 ","date":"2019-01-20","objectID":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/:2:5","tags":["虚拟环境"],"title":"Python搭建虚拟环境","uri":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"},{"categories":["Python"],"content":"Pipenv ","date":"2019-01-20","objectID":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/:3:0","tags":["虚拟环境"],"title":"Python搭建虚拟环境","uri":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"},{"categories":["Python"],"content":"简介 Pipenv是Kenneth Reitz在2017年1月发布的Python依赖管理工具，现在由PyPA维护。可以把它看做是pip和virtualenv的组合。 ","date":"2019-01-20","objectID":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/:3:1","tags":["虚拟环境"],"title":"Python搭建虚拟环境","uri":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"},{"categories":["Python"],"content":"为什么使用Pipenv Pipenv会自动帮你管理虚拟环境和依赖文件，并且提供了一系列命令和选项来帮助你实现各种依赖和环境管理相关的操作。简而言之，它更方便、完善和安全。 ","date":"2019-01-20","objectID":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/:3:2","tags":["虚拟环境"],"title":"Python搭建虚拟环境","uri":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"},{"categories":["Python"],"content":"如何使用Pipenv 安装 pip install pipenv 创建 在项目根目录下执行pipenv install，Pipenv会根据项目文件夹的名称创建一个虚拟环境，并且会在项目根目录下生成 Pipfile 和 Pipfile.lock 用于管理项目依赖（以后使用 Pipenv 安装的依赖会自动写入 Pipfile 文件，无需再手动维护 requirements.txt 文件) 提示 默认情况下Pipenv会将虚拟环境创建在~/.virtualenvs 目录下，在项目根目录下执行 pipenv --venv 可以查看到项目对应的虚拟环境的具体位置 激活使用 两种方式 在项目根目录下执行pipenv shell 在项目根目录下执行pipenv run + 命令 ","date":"2019-01-20","objectID":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/:3:3","tags":["虚拟环境"],"title":"Python搭建虚拟环境","uri":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"},{"categories":["Python"],"content":"Python2与Python3的区别","date":"2019-01-13","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"声明：以下内容均为我个人的理解，如果发现错误或者疑问可以联系我共同探讨 ","date":"2019-01-13","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:0:0","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"简介 目前用Python开发的项目有两个Python版本，分别是Python2.x与Python3.x，由于Python3相对于python2有着较大的升级，所以Python3将会是现在与未来的主流版本。 ","date":"2019-01-13","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:1:0","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"Python3时间轴 Python3.0发布于2008.12.3 Python3.1发布于2009.6.27 Python3.2发布于2011.2.20 Python 3.3 发布于 2012.9.29 Python 3.4 发布于 2014.3.16 Python 3.5 发布于 2015.9.13 Python 3.6 发布于 2016.12.23 Python3.7发布于2018.6.27 Python3.8发布于2019.10.14 Python 3.9发布于 2020.10.5 为了不带入过多的累赘，在Python3.0设计的时候没有考虑向下兼容，所以早期的项目都无法在Python3.0上正常运行。为了早期的项目可以逐步迁移到Python3.0，Python官方提供了Python2.6过度版本（基于Python2的语法与库，允许使用部分Python3的语法和函数），2010年中推出Python2.7为最后一个Python2.x版本(Python2.7在2020年1月1日以后官方停止维护)。了解Python3版本的变化对我们日常开发与项目维护都十分重要 ","date":"2019-01-13","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:1:1","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"Python3.0后的变化 ","date":"2019-01-13","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:0","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"解释器名称 Python2.x的解释器为python，Python3.x的解释器为python3 其他语言实现的解释器： PyPy Python实现的Python解释器，支持 JIT 即时编译 cpython C语言基于官方版本实现的Python解释器 Jython 运行在Java上的Python解释器 IronPython 运行在.NET与Mono平台的Python解释器 ","date":"2019-01-13","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:1","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"字符串 Python2中字符串是基于ASCII编码的str字符串，当调用字符串变量时会打印其bytes值（16进制表示的字符串内存地址）。 而unicode是一个单独的类型。 Python3中字符串原生支持unicode，byte也变成了一个单独的字节类，并且Python3源码文件默认使用utf-8编码所以中文也可以做变量名。 ","date":"2019-01-13","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:2","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"import Python2中import导包采用相对路径，导致标准库导入变困难。 Python3中import导包采用绝对路径 ","date":"2019-01-13","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:3","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"print Python2中的print是一种特殊的语句，在Python3中print变成了print函数 ","date":"2019-01-13","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:4","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"range函数与xrange函数 xrange函数在Python3中被废弃，range函数的机制进行修改实现了xrange函数返回可迭代对象的效果 ","date":"2019-01-13","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:5","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"老式类与新式类 Python2中存在老式类与新式类，在Python3中统一采用新式类（新式类申明要求继承object），且必须使用新式类应用多重继承 ","date":"2019-01-13","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:6","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"除法与取余 Python2 中若两个整形进行运算，结果为整形，但若其中有一个浮点数类型，则结果为浮点数。python3为真除法，运算结果为float类型。 Python2 中取余返回小于除法运算结果的最大整数，从类型上讲，与”/“运算符返回类型逻辑一致。Python3中与python2作用相同。 ","date":"2019-01-13","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:7","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"raw_input函数与input函数 raw_input函数在Python3中被废弃，统一使用input函数 ","date":"2019-01-13","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:8","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"缩进 Python3采用更严格的缩进方式，tab和space不能共存 ","date":"2019-01-13","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:9","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"long long整型被Python3废弃，统一使用int，int具有long的特性 ","date":"2019-01-13","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:10","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"file file函数被废弃，统一使用open函数 ","date":"2019-01-13","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:11","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"不等运算符 Python3废除\u003c\u003e，只有!= ","date":"2019-01-13","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:12","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"方法返回值 Python3 中这些方法再不再返回 list 对象：dictionary 关联的 keys()、values()、items()，zip()，map()，filter()，但是可以通过 list 强行转换 ","date":"2019-01-13","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:13","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"next()函数 迭代器 iterator 的 next()函数被 Python3 废弃，统一使用 next(iterator) ","date":"2019-01-13","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:14","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"exec exec 语句被 python3 废弃，统一使用 exec 函数 ","date":"2019-01-13","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:15","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"has_key 函数 has_key 函数被 Python 废弃，统一使用 in 关键词 ","date":"2019-01-13","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:16","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"round函数 Python2中，round函数返回float类型值。Python3中，round函数返回int类型值。 ","date":"2019-01-13","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:17","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"比较操作符 Python2中任意两个对象都可以比较。Python3中只有同一类型数据的对象才可以进行比较。 ","date":"2019-01-13","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:18","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["系统优化"],"content":"Windows10在此处打开cmd","date":"2019-01-05","objectID":"/windows10%E5%9C%A8%E6%AD%A4%E5%A4%84%E6%89%93%E5%BC%80cmd/","tags":["cmd"],"title":"Windows10在此处打开cmd","uri":"/windows10%E5%9C%A8%E6%AD%A4%E5%A4%84%E6%89%93%E5%BC%80cmd/"},{"categories":["系统优化"],"content":"声明：以下内容均为我个人的理解，如果发现错误或者疑问可以联系我共同探讨 在Windows10中我们经常需要在某个文件夹下打开cmd窗口，虽然可以在地址栏输入cmd打开，但还是比较麻烦，可以修改注册表添加一个右键菜单来解决这个问题。 ","date":"2019-01-05","objectID":"/windows10%E5%9C%A8%E6%AD%A4%E5%A4%84%E6%89%93%E5%BC%80cmd/:0:0","tags":["cmd"],"title":"Windows10在此处打开cmd","uri":"/windows10%E5%9C%A8%E6%AD%A4%E5%A4%84%E6%89%93%E5%BC%80cmd/"},{"categories":["系统优化"],"content":"步骤 新建一个文本文档 将 一下内容复制粘贴到文本文档中 Windows Registry Editor Version 5.00 [-HKEY_CLASSES_ROOT\\Directory\\shell\\runas] [HKEY_CLASSES_ROOT\\Directory\\shell\\runas] @=\"Open cmd here as admin\" \"HasLUAShield\"=\"\" [HKEY_CLASSES_ROOT\\Directory\\shell\\runas\\command] @=\"cmd.exe /s /k pushd \\\"%V\\\"\" [-HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\runas] [HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\runas] @=\"Open cmd here as admin\" \"HasLUAShield\"=\"\" [HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\runas\\command] @=\"cmd.exe /s /k pushd \\\"%V\\\"\" [-HKEY_CLASSES_ROOT\\Drive\\shell\\runas] [HKEY_CLASSES_ROOT\\Drive\\shell\\runas] @=\"Open cmd here as admin\" \"HasLUAShield\"=\"\" [HKEY_CLASSES_ROOT\\Drive\\shell\\runas\\command] @=\"cmd.exe /s /k pushd \\\"%V\\\"\" 另存为xxx.reg文件 双击运行 ","date":"2019-01-05","objectID":"/windows10%E5%9C%A8%E6%AD%A4%E5%A4%84%E6%89%93%E5%BC%80cmd/:0:1","tags":["cmd"],"title":"Windows10在此处打开cmd","uri":"/windows10%E5%9C%A8%E6%AD%A4%E5%A4%84%E6%89%93%E5%BC%80cmd/"},{"categories":["年终总结"],"content":"前言 不知不觉又到年底了，2018年6月我从母校毕业，进入社会，体会到了社会的残酷。我是幸运的，成功通过校招进入了一家企业，去到了上有天堂下有苏杭的杭州。在经历过一些痛苦后我决定出去闯一闯，年末又成功在上海找到工作。不幸的是家庭中发生了一系列的变故，让我对亲情是否可靠又产生了怀疑，难道血缘关系都不能带来相互的羁绊吗，我现在回答不上来，只希望少点这种糟心的事。 ","date":"2018-12-30","objectID":"/2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/:1:0","tags":["生活"],"title":"2018年终总结","uri":"/2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"},{"categories":["年终总结"],"content":"收获爱情 没想到在我离开母校之后还能追到追了3年都没追到的女神。虽然现在我们是异地恋，但是我想这是上天在看到我Never give up的信念后给予我的礼物吧。说实话这感觉就跟做梦一样，之前经常幻想在一起后的生活是啥样的，现在感觉全都是我无法想到的情况。我们是熟悉的，从大一就开始认识，一起参加社团，参加各种活动，经常互相吐槽。我们是陌生的，在一起后才发现你是这么的柔弱，想法是那么的奇妙。不过跟你在一起越久我就越发的喜欢上你，虽然今年跟你见面的机会很少，但每一次都让我感受到了爱情的美妙。逐渐对你了解的越多发现你跟别的女孩都不一样。我会努力赚钱，给你带来更好的生活的！ ","date":"2018-12-30","objectID":"/2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/:2:0","tags":["生活"],"title":"2018年终总结","uri":"/2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"},{"categories":["年终总结"],"content":"百万负翁 在武汉买房这是我之前从来都没想过的事，不过今年竟然那么巧合的实现了。我哥是做房产中介的，他朋友要结婚了，想把手上的房置换出去我家刚拿到拆迁款不久，身上有点余钱我妈就去看了看房子，发现还挺不错，然后就叫上我一起再去看，位置在3环和4环之前，听说附近马上要搞军运会应该会涨起来。户型和面积都很不错，符合我的要求，就算不拿来住就当投资也是一个不错的选择。就这样，我爸妈替我买了人生的第一套房，我也成了百万负翁，每月房贷5500+，跟爸妈商量着先让他们帮我还，等我找到工作了我再慢慢承担房贷，他们也答应了，现在身上压力很大。。。。 ","date":"2018-12-30","objectID":"/2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/:3:0","tags":["生活"],"title":"2018年终总结","uri":"/2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"},{"categories":["年终总结"],"content":"来上海打拼 从杭州回来后就一直在考虑去哪里打工，问了很多朋友，自己也考虑了很多。想从北上深选一个。北京机会多，工资高，但是空气差，住房条件很差。深圳互联网企业很多，政府的人才引进项目也很有吸引力但是相对的竞争也很大，而且环境氛围不太好。最后选择了上海，不过这是一个完全陌生的城市，当时我也很忐忑，不过在Boss直聘上投的简历很快有了回应，有公司已经向我发出了面试邀请，一冲动买了一张晚上的高铁票就出发了。最后经历了几天面试找到了一家我觉得不错还很适合我的公司，虽然不大，但是氛围很好，我感觉我能学到很多东西。 ","date":"2018-12-30","objectID":"/2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/:4:0","tags":["生活"],"title":"2018年终总结","uri":"/2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"},{"categories":["年终总结"],"content":"IG夺冠 这是中国LOL崭新的篇章，我是LOL的内测玩家，但最开始没有玩下去，因为那时候DOTA更火DOTA2也出来了，到S4看到当时的OMG的一场50血翻盘的比赛，震惊我了，那时候中国的LOL还恐韩，那时候的OMG就专门灭韩国对，看起来真过瘾啊，后来随着OMG的落寞也对LOL关注少了，到2018年8月IG老板王思聪上场比赛，那时候又吸引了我的关注，后面开始看IG的比赛，在LPL里每次都差一步，被巅峰期的小狗给带走了。到S8全球总决赛，随着RNG被G2击败这次网上都说是最没有希望的一年，很多人都小看了IG，结果他摧枯拉朽2个3:0带走了G2和FNC，给LPL带来了第一座世界赛的奖杯，这是具有历史意义的一天！虽然IG里有两个韩援，但是Rookie在韩国接受采访时说的中文！我觉得这就是属于LPL的冠军！ ","date":"2018-12-30","objectID":"/2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/:5:0","tags":["生活"],"title":"2018年终总结","uri":"/2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"},{"categories":["年终总结"],"content":"展望 2018年已经过去，希望2019年我能更进一步在上海扎根，学更多东西，尽快承担起家里的责任。 有几个小目标： 坚持每周写一篇博文 多出去走走看看，了解上海这桌大都市，认识更多的朋友 开始偿还房贷，减轻爸妈的负担 开始攒钱，争取攒够5万块 希望明年年终总结的时候小目标都能实现！ ","date":"2018-12-30","objectID":"/2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/:6:0","tags":["生活"],"title":"2018年终总结","uri":"/2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"},{"categories":["生活"],"content":"新的开始 ","date":"2018-12-16","objectID":"/%E4%B8%8A%E6%B5%B7%E6%88%91%E6%9D%A5%E4%BA%86/:1:0","tags":["上海"],"title":"上海我来了","uri":"/%E4%B8%8A%E6%B5%B7%E6%88%91%E6%9D%A5%E4%BA%86/"},{"categories":["生活"],"content":"序 现在还记得来上海那天在高铁上还在Boss直聘上跟几个面试官约面试，那时候真的很兴奋，感觉大展拳脚的时候到了！到上海的时候已经是晚上10点多了，万幸赶上了末班地铁，发现提前定好的青旅离虹桥站还挺近的，半个小时地铁就能到。由于身上钱不多订的是一个8人间的上下铺，我入住的时候好多人都已经准备休息了，我很快洗漱完毕就躺床上了，第一天晚上超级兴奋，根本睡不着(其实还因为有人打呼噜，太吵了，我睡眠质量又不太好！！！) ","date":"2018-12-16","objectID":"/%E4%B8%8A%E6%B5%B7%E6%88%91%E6%9D%A5%E4%BA%86/:1:1","tags":["上海"],"title":"上海我来了","uri":"/%E4%B8%8A%E6%B5%B7%E6%88%91%E6%9D%A5%E4%BA%86/"},{"categories":["生活"],"content":"面试 到上海的第二天就开始准备面试和考察面试的公司。通过地图发现要面试的这几家都很近，很快制定了面试的方案。幸运的是，第三天的面试两家都很成功，成功通过了技术面，不幸的是HR面薪资没有给到我想要的，我决定再多面几家。直到第五天，面了有5，6家了，还是没找到适合自己的，我开始有点慌了,先在美团上把青旅续费了一周时间。然后准备下一家面试给出的面试题，让我按照要求写一个程序出来，如果写的可以就能参加第二面。由于之前没接触过这个包，在网上简单学习了一下入门就开始写代码了，经过一个下午的努力终于完成了代码，发给面试官，然后开始了等消息时间，庆幸的是晚上得到了面试的邀请。面试过程非常nice，问完我问题后，他开始给我介绍他的目标与构想，我感觉非常符合我的预期，很快就收到了HR面的邀请，心里暗自高兴，虽然工资跟前几家差不多，但是这个Leader跟我非常聊得来，在面试的过程中他提出问题涉及到我不熟悉的地方他会指引我的思路，让我想出更好的解决方案，让我感觉就在跟朋友探讨一样，我非常想入职该公司！很快，当天晚上就收到了入职申请，那天是星期四，HR问我明天能不能来上班，我想都没想就说：能！ ","date":"2018-12-16","objectID":"/%E4%B8%8A%E6%B5%B7%E6%88%91%E6%9D%A5%E4%BA%86/:1:2","tags":["上海"],"title":"上海我来了","uri":"/%E4%B8%8A%E6%B5%B7%E6%88%91%E6%9D%A5%E4%BA%86/"},{"categories":["生活"],"content":"租房 由于周五就入职开始上班，周末跟上海的几个朋友聚了一下，导致一直没有时间找房子。还好有一个玩的不错的小伙伴，他找到了一个合适的两居室，我看了一下，当天晚上就一起跟房东签了。从最开始来睡在8人间上下铺的青旅(如果是来上海玩还挺不错的，前台小姐姐人超好的，而且还能认识很多五湖四海的朋友)，到现在找到工作后和志同道合的小伙伴一起合租了一个60+平的两室，生活质量提高了不少，终于不用睡上铺听下铺打呼噜声了，就是房租很肉疼，租的娄山关路这块的房子，一套5800，押一付三。非常感谢爸妈对我提供的资金支持，等赚到钱了我会好好孝顺你们的。 ","date":"2018-12-16","objectID":"/%E4%B8%8A%E6%B5%B7%E6%88%91%E6%9D%A5%E4%BA%86/:1:3","tags":["上海"],"title":"上海我来了","uri":"/%E4%B8%8A%E6%B5%B7%E6%88%91%E6%9D%A5%E4%BA%86/"},{"categories":["生活"],"content":"新的公司 目前对就职的新公司非常满意，老板很开明，让我们有很大的自由发挥空间。Leader人超棒，不仅在工作上给予了我很多帮助，在生活上也教会我很多东西。同事也都超好，大家就跟朋友一样，还经常一起聚会玩狼人杀。 ","date":"2018-12-16","objectID":"/%E4%B8%8A%E6%B5%B7%E6%88%91%E6%9D%A5%E4%BA%86/:1:4","tags":["上海"],"title":"上海我来了","uri":"/%E4%B8%8A%E6%B5%B7%E6%88%91%E6%9D%A5%E4%BA%86/"},{"categories":["生活"],"content":"感想 来上海有一个半月的时间了，对这个城市的初映象还蛮好的。最开始来的时候像个乡下人，一直在惊叹，哇上海都是4车道的大马路耶，上海好多高楼耶，上海的环卫和绿植都做得好好耶。不得不说上海的基础建设非常的棒，希望小武汉也快点跟上脚步。 现在发现刚开始买高铁票来上海可能有点点冲动，但那时候我非常想去一个更大的地方发展。从实习的公司离职其实心里很忐忑，害怕自己找不到新的工作，但来到上海发现这边对学历的包容度还是很高的，只要你有足够的能力，他们愿意给你机会。 ","date":"2018-12-16","objectID":"/%E4%B8%8A%E6%B5%B7%E6%88%91%E6%9D%A5%E4%BA%86/:1:5","tags":["上海"],"title":"上海我来了","uri":"/%E4%B8%8A%E6%B5%B7%E6%88%91%E6%9D%A5%E4%BA%86/"}]