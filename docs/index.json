[{"categories":["Python"],"content":"前言 前面几篇学习了Flask的基础知识，从今天开始开发一个个人博客项目来练练手。 ","date":"2020-06-13","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/:1:0","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:开发准备","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/"},{"categories":["Python"],"content":"项目分析 关于个人博客的Web项目，主要为自己提供一个记录与技术输出的平台。 以个人编写或者转载优秀的文章作为博文的主要来源 基于 Flask 框架，以 前后端不分离 的形式实现具体业务逻辑 ","date":"2020-06-13","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/:2:0","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:开发准备","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/"},{"categories":["Python"],"content":"技术实现 基于Python 3.7.7 + Flask框架实现 数据存储使用Redis + MySQL 实现 第三方扩展：七牛云(文件存储平台) 布署：基于macOS 10.15.4系统，使用 Gunicorn + Nginx 进行布署 ","date":"2020-06-13","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/:2:1","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:开发准备","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/"},{"categories":["Python"],"content":"功能模块 博客模块 首页博客列表 博客详情 关于模块 个人信息展示 联系模块 联系我功能 后台管理 博文的管理 访问数据统计 ","date":"2020-06-13","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/:2:2","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:开发准备","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/"},{"categories":["Python"],"content":"具体需求 首页 根据近期文章列表展示 翻页加载更多数据 点击新窗口跳转到文章详情页 顶部显示博客各大版块 右侧显示最新文章、归档、分类、标签云与RSS订阅相关信息 文章详情 文章内容 html 数据展示 可以评论该文章 右侧显示文章目录、最新文章、归档、分类、标签云与RSS订阅 关于页 展示作者相关信息 联系页 填写相关信息提供联系作者功能 后台-登录 提供后台登录页面 后台-用户统计 登录到后台界面之后展示用户统计界面 显示各类用户访问数据 展示当前月访问新增人数 展示当前日访问新增人数 后台-发布文章 \u0008提供markdown编辑器进行文章实时预览 发布文章 草稿文章 文章信息展示 进入默认展示所有文章数据 可以根据文章标题搜索文章 文章分类管理 展示所有分类列表 可以添加/修改分类 ","date":"2020-06-13","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/:2:3","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:开发准备","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/"},{"categories":["Python"],"content":"项目框架搭建 ","date":"2020-06-13","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/:3:0","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:开发准备","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/"},{"categories":["Python"],"content":"创建项目 新建项目，虚拟环境选择python3版本，创建 manage.py 文件 from flask import Flask app = Flask(__name__) @app.route('/') def hello_world(): return 'Hello World!' if __name__ == '__main__': app.run() ","date":"2020-06-13","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/:3:1","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:开发准备","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/"},{"categories":["Python"],"content":"使用 GIT 管理源代码 git相关内容可以查看之前的相关文章 本地提交 初始化git Desktop % cd flaskblog flaskblog % git init Initialized empty Git repository in /Users/huliang/Desktop/flaskblog/.git/ 配置当前项目git提交信息(可省略此步，如不配置则使用全局配置) flaskblog % git config user.email xxx@xxx.com flaskblog % git config user.name xxxx 添加忽略文件 flaskblog % touch .gitignore 设置忽略文件内容(后续根据需要再添加) .idea *.py[cod] 添加所有文件到暂存区 flaskblog % git add . 提交到本地仓库并填写注释 flaskblog % git commit -m'初次提交' 远程提交 使用GitHub：https://github.com/ 作为在线 git 源代码仓库 在GitHub上创建名为flaskblog的仓库 创建完成后将本地项目提交至仓库中 flaskblog % cd flaskblog flaskblog % git remote add origin xxx/flaskblog.git flaskblog % git push -u origin master ","date":"2020-06-13","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/:3:2","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:开发准备","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/"},{"categories":["Python"],"content":"项目基本配置 Config类 先在当前类中定义配置的类，并从中加载配置 ... app = Flask(__name__) class Config(object): \"\"\"工程配置信息\"\"\" DEBUG = True app.config.from_object(Config) ... 运行测试 SQLAlchemy 导入数据库扩展，并在配置中填写相关配置 from flask_sqlalchemy import SQLAlchemy ... class Config(object): \"\"\"工程配置信息\"\"\" DEBUG = True # 数据库的配置信息 SQLALCHEMY_DATABASE_URI = \"mysql://root:mysql@127.0.0.1:3306/flaskblog\" SQLALCHEMY_TRACK_MODIFICATIONS = False app.config.from_object(Config) db = SQLAlchemy(app) 在终端创建数据库 mysql\u003e create database flaskblog charset utf8; 运行测试 Redis 创建redis存储对象，并在配置中填写相关配置 import redis ... class Config(object): \"\"\"工程配置信息\"\"\" ... # redis配置 REDIS_HOST = \"127.0.0.1\" REDIS_PORT = 6379 app.config.from_object(Config) db = SQLAlchemy(app) redis_store = redis.StrictRedis(host=Config.REDIS_HOST, port=Config.REDIS_PORT) 运行测试 CSRF 包含请求体的请求都需要开启CSRF from flask_wtf.csrf import CSRFProtect ... app.config.from_object(Config) ... CSRFProtect(app) CSRFProtect只做验证工作，cookie中的 csrf_token 和表单中的 csrf_token 需要我们自己实现 Session 利用 flask-session扩展，将 session 数据保存到 Redis 中 from flask_session import Session ... class Config(object): \"\"\"工程配置信息\"\"\" SECRET_KEY = \"EjpNVSNQTyGi1VvWECj9TvC/+kq3oujee2kTfQUs8yCM6xX9Yjq52v54g+HVoknA\" ... # flask_session的配置信息 SESSION_TYPE = \"redis\" # 指定 session 保存到 redis 中 SESSION_USE_SIGNER = True # 让 cookie 中的 session_id 被加密签名处理 SESSION_REDIS = redis.StrictRedis(host=REDIS_HOST, port=REDIS_PORT) # 使用 redis 的实例 PERMANENT_SESSION_LIFETIME = 86400 # session 的有效期，单位是秒 app.config.from_object(Config) ... Session(app) 运行测试 Flask-Script与数据库迁移扩展 from flask_script import Manager from flask_migrate import Migrate, MigrateCommand ... manager = Manager(app) Migrate(app, db) manager.add_command('db', MigrateCommand) ... if __name__ == '__main__': manager.run() 运行测试 ","date":"2020-06-13","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/:3:3","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:开发准备","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/"},{"categories":["Python"],"content":"代码抽取 目标 将特定逻辑代码抽取到指定的类中，各司其职，放便后续项目维护 配置文件 在与 manage.py 同级目录下创建 config.py 文件，用作于项目的配置文件 import redis class Config(object): \"\"\"工程配置信息\"\"\" SECRET_KEY = \"EjpNVSNQTyGi1VvWECj9TvC/+kq3oujee2kTfQUs8yCM6xX9Yjq52v54g+HVoknA\" DEBUG = True # 数据库的配置信息 SQLALCHEMY_DATABASE_URI = \"mysql://root:mysql@127.0.0.1:3306/flaskblog\" SQLALCHEMY_TRACK_MODIFICATIONS = True # redis配置 REDIS_HOST = \"127.0.0.1\" REDIS_PORT = 6379 # session 配置 SESSION_TYPE = \"redis\" # 指定 session 保存到 redis 中 SESSION_USE_SIGNER = True # 让 cookie 中的 session_id 被加密签名处理 SESSION_REDIS = redis.StrictRedis(host=REDIS_HOST, port=REDIS_PORT) # 使用 redis 的实例 PERMANENT_SESSION_LIFETIME = 86400 # session 的有效期，单位是秒 在 manager.py 中引入 Config 类，直接使用 from config import Config app = Flask(__name__) # 配置 app.config.from_object(Config) 运行测试 业务逻辑独立 在整个项目文件夹中，除了启动文件 manage.py 和配置文件 config.py 放在根目录，其他具体业务逻辑文件都放在一个单独的文件夹内，与 manage.py 同级 创建 blog Package，与 manage.py 同级 manage.py 只做最基本的启动工作，将 app 的创建操作移动到 blog 的 __init__.py 文件中 import redis from flask import Flask from flask_sqlalchemy import SQLAlchemy from flask_wtf.csrf import CSRFProtect from flask_session import Session from config import Config app = Flask(__name__) # 配置 app.config.from_object(Config) # 配置数据库 db = SQLAlchemy(app) # 配置redis redis_store = redis.StrictRedis(host=Config.REDIS_HOST, port=Config.REDIS_PORT) # 开启csrf保护 CSRFProtect(app) # 设置session保存位置 Session(app) manage.py 的代码为 from flask_script import Manager from flask_migrate import Migrate, MigrateCommand from blog import app, db # Flask-script manager = Manager(app) # 数据库迁移 Migrate(app, db) manager.add_command('db', MigrateCommand) @app.route('/index') def index(): return 'index' if __name__ == '__main__': manager.run() 运行测试 项目多种配置 一个web程序在开发阶段可能与生产阶段所需要的配置信息可能不一样，所以为了实现此功能，可以给不同情况创建不同的配置类，比如开发阶段使用的配置类名为 DevelopementConfig，生产阶段使用的配置类名为 ProdutionConfig，修改 config.py 文件的配置文件如下 import redis class Config(object): \"\"\"工程配置信息\"\"\" SECRET_KEY = \"EjpNVSNQTyGi1VvWECj9TvC/+kq3oujee2kTfQUs8yCM6xX9Yjq52v54g+HVoknA\" # 数据库的配置信息 SQLALCHEMY_DATABASE_URI = \"mysql://root:mysql@127.0.0.1:3306/flaskblog\" SQLALCHEMY_TRACK_MODIFICATIONS = False # redis配置 REDIS_HOST = \"127.0.0.1\" REDIS_PORT = 6379 # flask_session的配置信息 SESSION_TYPE = \"redis\" # 指定 session 保存到 redis 中 SESSION_USE_SIGNER = True # 让 cookie 中的 session_id 被加密签名处理 SESSION_REDIS = redis.StrictRedis(host=REDIS_HOST, port=REDIS_PORT) # 使用 redis 的实例 PERMANENT_SESSION_LIFETIME = 86400 # session 的有效期，单位是秒 class DevelopementConfig(Config): \"\"\"开发模式下的配置\"\"\" DEBUG = True class ProductionConfig(Config): \"\"\"生产模式下的配置\"\"\" pass 接下来思考如何能才更快速的针对不同的布署环境去使用不同的配置 工厂类方法 要在不同环境下去使用不同的配置，那么可以在 manage.py 文件中给 blog 包传入不同的配置信息，让 ihome 去根据传入指定配置去创建 app，所以可以在 blog 的 __init__.py 文件中添加一个工厂方法，根据传入的配置不同创建其对应的应用实例 在 config.py 文件中添加以下代码 # 定义配置字典 config = { \"development\": DevelopementConfig, \"production\": ProductionConfig } 修改 blog 文件夹下 __init__.py，添加 create_app 的工厂方法 def create_app(config_name): \"\"\"通过传入不同的配置名字，初始化其对应配置的应用实例\"\"\" pass 修改 manage.py 文件中的代码 from blog import create_app, db # 创建 app，并传入配置模式：development / production app = create_app('development') 将 __init__.py 文件中创建 app 实例的方法移动到 create_app 方法中 from config import config # 数据库 db = SQLAlchemy() redis_store = None def create_app(config_name): \"\"\"通过传入不同的配置名字，初始化其对应配置的应用实例\"\"\" app = Flask(__name__) # 配置 app.config.from_object(config[config_name]) # 配置数据库 db.init_app(app) # 配置redis global redis_store redis_store = redis.StrictRedis(host=config[config_name].REDIS_HOST, port=config[config_name].REDIS_PORT) # 开启csrf保护 CSRFProtect(app) # 设置session保存位置 Session(app) return app ","date":"2020-06-13","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/:3:4","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:开发准备","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/"},{"categories":["Python"],"content":"日志 ","date":"2020-06-13","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/:4:0","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:开发准备","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/"},{"categories":["Python"],"content":"简介 日志是一种可以追踪某些软件运行时所发生事件的方法。软件开发人员可以向他们的代码中调用日志记录相关的方法来表明发生了某些事情。一个事件可以用一个可包含可选变量数据的消息来描述。此外，事件也有重要性的概念，这个重要性也可以被称为严重性级别（level） ","date":"2020-06-13","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/:4:1","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:开发准备","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/"},{"categories":["Python"],"content":"作用 通过log的分析，可以方便用户了解系统或软件、应用的运行情况；如果你的应用log足够丰富，也可以分析以往用户的操作行为、类型喜好、地域分布或其他更多信息；如果一个应用的log同时也分了多个级别，那么可以很轻易地分析得到该应用的健康状况，及时发现问题并快速定位、解决问题，补救损失。 简单来讲就是我们通过记录和分析日志可以了解一个系统或软件程序运行情况是否正常，也可以在应用程序出现故障时快速定位问题。不仅在开发中，在运维中日志也很重要 日志的作用可以简单总结为以下几点：程序调试、了解软件程序运行情况，是否正常、软件程序运行故障分析与问题定位、如果应用的日志信息足够详细和丰富，还可以用来做用户行为分析 ","date":"2020-06-13","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/:4:2","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:开发准备","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/"},{"categories":["Python"],"content":"等级 我们先来思考下下面的两个问题： 作为开发人员，在开发一个应用程序时需要什么日志信息？在应用程序正式上线后需要什么日志信息？ 作为应用运维人员，在部署开发环境时需要什么日志信息？在部署生产环境时需要什么日志信息？ 在软件开发阶段或部署开发环境时，为了尽可能详细的查看应用程序的运行状态来保证上线后的稳定性，我们可能需要把该应用程序所有的运行日志全部记录下来进行分析，这是非常耗费机器性能的。当应用程序正式发布或在生产环境部署应用程序时，我们通常只需要记录应用程序的异常信息、错误信息等，这样既可以减小服务器的I/O压力，也可以更加方便的进行故障排查。那么，怎样才能在不改动应用程序代码的情况下实现在不同的环境记录不同详细程度的日志呢？这就是日志等级的作用了，我们通过配置文件指定我们需要的日志等级就可以了。不同的应用程序所定义的日志等级可能会有所差别，分的详细点的会包含以下几个等级： FATAL/CRITICAL = 重大的，危险的 ERROR = 错误 WARNING = 警告 INFO = 信息 DEBUG = 调试 NOTSET = 没有设置 ","date":"2020-06-13","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/:4:3","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:开发准备","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/"},{"categories":["Python"],"content":"字段信息与日志格式 输出一条日志时，日志内容和日志级别是需要开发人员明确指定的。对于而其它字段信息，只需要是否显示在日志中就可以了。 ","date":"2020-06-13","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/:4:4","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:开发准备","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/"},{"categories":["Python"],"content":"功能的实现 Python 自身提供了一个用于记录日志的标准库模块：logging。 logging 模块 简介 logging 模块定义的函数和类为应用程序和库的开发实现了一个灵活的事件日志系统。logging 模块是 Python 的一个标准库模块，由标准库模块提供日志记录 API 的关键好处是所有 Python 模块都可以使用这个日志记录功能。 日志级别 logging模块默认定义了以下几个日志等级，它允许开发人员自定义其他日志级别，但是这是不被推荐的，尤其是在开发供别人使用的库时，因为这会导致日志级别的混乱。 DEBUG 最详细的日志信息，典型应用场景是 问题诊断 INFO 信息详细程度仅次于DEBUG，通常只记录关键节点信息，用于确认一切都是按照我们预期的那样进行工作 WARNING 当某些不期望的事情发生时记录的信息（如，磁盘可用空间较低），但是此时应用程序还是正常运行的 ERROR 由于一个更严重的问题导致某些功能不能正常运行时记录的信息 FATAL/CRITICAL 整个系统即将/完全崩溃 开发应用程序或部署开发环境时，可以使用 DEBUG 或 INFO 级别的日志获取尽可能详细的日志信息来进行开发或部署调试；应用上线或部署生产环境时，应该使用 WARNING 或 ERROR 或 CRITICAL 级别的日志来降低机器的I/O压力和提高获取错误日志信息的效率。 提示 日志级别的指定通常都是在应用程序的配置文件中进行指定的。 使用方式介绍 loggers 提供应用程序代码直接使用的接口 handlers 用于将日志记录发送到指定的目的位置 filters 提供更细粒度的日志过滤功能，用于决定哪些日志记录将会被输出（其它的日志记录将会被忽略） formatters 用于控制日志信息的最终输出格式 # 设置日志的记录等级 logging.basicConfig(level=logging.DEBUG) # 调试debug级 # 创建日志记录器，指明日志保存的路径、每个日志文件的最大大小、保存的日志文件个数上限 file_log_handler = RotatingFileHandler(\"logs/log\", maxBytes=1024*1024*100, backupCount=10) # 创建日志记录的格式 日志等级 输入日志信息的文件名 行数 日志信息 formatter = logging.Formatter('%(levelname)s%(filename)s:%(lineno)d%(message)s') # 为刚创建的日志记录器设置日志记录格式 file_log_handler.setFormatter(formatter) # 为全局的日志工具对象（flask app使用的）添加日志记录器 logging.getLogger().addHandler(file_log_handler) 函数记录 最简单的日志输出 先来试着分别输出一条不同日志级别的日志记录： import logging logging.debug(\"This is a debug log.\") logging.info(\"This is a info log.\") logging.warning(\"This is a warning log.\") logging.error(\"This is a error log.\") logging.critical(\"This is a critical log.\") 也可以这样写： logging.log(logging.DEBUG, \"This is a debug log.\") logging.log(logging.INFO, \"This is a info log.\") logging.log(logging.WARNING, \"This is a warning log.\") logging.log(logging.ERROR, \"This is a error log.\") logging.log(logging.CRITICAL, \"This is a critical log.\") 修改配置改变输出内容 logging.basicConfig(level=logging.DEBUG) 切记 设置 Configurations 中的 Working directory 为当前项目 ","date":"2020-06-13","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/:4:5","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:开发准备","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/"},{"categories":["Python"],"content":"集成日志到当前项目 在 config.py 文件中在不同的环境的配置下添加日志级别 class Config(object): ... # 默认日志等级 LOG_LEVEL = logging.DEBUG class ProductionConfig(Config): \"\"\"生产模式下的配置\"\"\" LOG_LEVEL = logging.ERROR 在 blog 目录下的 init.py 文件中添加日志配置的相关方法 def setup_log(config_name): \"\"\"配置日志\"\"\" # 设置日志的记录等级 logging.basicConfig(level=config[config_name].LOG_LEVEL) # 调试debug级 # 创建日志记录器，指明日志保存的路径、每个日志文件的最大大小、保存的日志文件个数上限 file_log_handler = RotatingFileHandler(\"logs/log\", maxBytes=1024 * 1024 * 100, backupCount=10) # 创建日志记录的格式 日志等级 输入日志信息的文件名 行数 日志信息 formatter = logging.Formatter('%(levelname)s%(filename)s:%(lineno)d%(message)s') # 为刚创建的日志记录器设置日志记录格式 file_log_handler.setFormatter(formatter) # 为全局的日志工具对象（flask app使用的）添加日志记录器 logging.getLogger().addHandler(file_log_handler) 在 create_app 方法中调用上一步创建的方法，并传入 config_name def create_app(config_name): ... # 配置项目日志 setup_log(config_name) app = Flask(__name__) ... 在项目根目录下创建日志目录文件夹 logs 提示 运行项目，当前项目日志已输出到 logs 的目录下自动创建的 log 文件中 在 logs 文件夹下创建 .gitkeep 文件，以便能将 logs 文件夹添加到远程仓库，并在 .gitignore 文件中添加忽略提交生成的日志文件 logs/log* 在 Flask框架 中，其自己对 Python 的 logging 进行了封装，在 Flask 应用程序中，可以以如下方式进行输出 log: current_app.logger.debug('debug') current_app.logger.error('error') ","date":"2020-06-13","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/:4:6","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:开发准备","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/"},{"categories":["Python"],"content":"蓝图 项目的蓝图模块可以按以下方式来分： 按功能模块来分，比如：文章模块、关于模块 按接口版本来分，某个版本的接口放一个文件夹下面 因为本项目是前后端不分离的项目，界面数据大部分都使用模板的形式进行渲染，很少涉及到通过接口的形式返回数据，所以本项目使用按功能模块来划分蓝图。 在 blog 目录下创建 modules Package，modules 存放当前项目所有的模块 在 modules 文件夹下创建 index 文件夹， 并在此文件夹下创建 views.py 文件，将 manage.py 中定义的路由拷贝至该文件中 @app.route('/index') def index(): return 'index' 暂时忽略报错，此处的index文件夹就是一个模块 到这一步 manage.py 中内容基本上都抽取完成，剩余内容如下： from flask_script import Manager from flask_migrate import Migrate, MigrateCommand from info import create_app, db app = create_app('development') # 添加扩展命令行 manager = Manager(app) # 数据库迁移 Migrate(app, db) manager.add_command('db', MigrateCommand) if __name__ == '__main__': manager.run() 在 index 文件夹中的 __init__.py创建其自已的蓝图 from flask import Blueprint index_blu = Blueprint(\"index\", __name__) from . import views 在 views.py 中导入蓝图，并使用该蓝图注册路由 from . import index_blu @index_blu.route('/index') def index(): return 'index' 将上一步创建出来的蓝图注册到 app 中 def create_app(config_name): ... # 注册蓝图 from info.modules.index import index_blu app.register_blueprint(index_blu) return app 运行测试 ","date":"2020-06-13","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/:5:0","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:开发准备","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/"},{"categories":["Python"],"content":"数据库表 ","date":"2020-06-13","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/:6:0","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:开发准备","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/"},{"categories":["Python"],"content":"分析 根据需求分析需要4个表格： 文章(Post)： 字段 类型 条件 备注 title CharField max_length=100 标题 body TextField - 正文 created_time DateTimeField - 创建时间 last_modified_time DateTimeField - 最后修改时间 abstract CharField max_length=200, blank=True 摘要 category ForeignKey Category, on_delete=models.CASCADE 分类 tags ManyToManyField Tag, blank=True 标签 author ForeignKey User, on_delete=models.CASCADE 作者 分类(Category)： 字段 类型 条件 备注 name CharField max_length=100 分类名 标签(Tag)： 字段 类型 条件 备注 name CharField max_length=100 标签名 用户(Info)： 字段 类型 条件 备注 name CharField max_length=50 作者名 homepage CharField max_length=100 主页 ","date":"2020-06-13","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/:6:1","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:开发准备","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/"},{"categories":["Python"],"content":"数据库表迁移 确认当前配置的数据库是否存在 mysql\u003e use flaskblog; 将 constants.py 和 models.py 文件拷贝到项目的 blog 目录下 提示 constants.py 是当前项目中要使用的一些常量，预先定义好的，models.py 文件中需要使用到该文件中的一些常量 并在 manage.py 中导入 models form info import models 提示 在迁移的时候以便能读取到对应模型 执行数据库迁移 flaskblog % python manage.py db init flaskblog % python manage.py db migrate -m\"initial\" flaskblog % python manage.py db upgrade 查看数据库表是否创建完成 mysql\u003e show tables; 执行导入初始分类的 SQL 语句 mysql\u003e source info_info_category.sql 提示 生成的迁移文件不需要提交到 git 保存，所以需要在 .gitignore 文件中添加以下内容以便忽略迁移所生成的系列文件 migrations ","date":"2020-06-13","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/:6:2","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:开发准备","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/"},{"categories":["Python"],"content":"测试数据的添加 先添加分类测试数据 mysql\u003e source 路径/flaskblog_category.sql 再添加新闻测试数据 mysql\u003e source 路径/flaskblog_blog.sql ","date":"2020-06-13","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/:6:3","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:开发准备","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/"},{"categories":["Python"],"content":"静态文件导入 在项目 blog 目录下创建 static 文件夹 将前端人员开发好的 blog 和 admin 两个静态文件夹拖入到项目 news文件夹内代表新闻前台页面 admin文件夹内代表新闻的后台页面 运行项目，使用浏览器访问：http://127.0.0.1:5000/static/blog/index.html 查看效果 ","date":"2020-06-13","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/:7:0","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:开发准备","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/"},{"categories":["Python"],"content":"注册根路由 ","date":"2020-06-13","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/:8:0","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:开发准备","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/"},{"categories":["Python"],"content":"创建模板目录 在 static 同级目录创建 templates 文件夹，并在此目录下创建 post 文件夹用于存放新闻前台模板文件。(此步可以省略，只是在 Pycharm 中标识该目录为模板目录)设置 templates 目录成模板目录属性，操作方式：右键点击 templates 目录，选择 Mark Directory as -\u003e Template Folder如果没有设置模板语言，会弹出是否设置模板语言，点击 Yes，跳转到模板语言设置界面，设置模板语言为 Jinja2 ","date":"2020-06-13","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/:8:1","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:开发准备","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/"},{"categories":["Python"],"content":"添加模板并创建根路由视图函数 使用 Pycharm 将 static/news/index.html 文件移动到 templates/news/ 目录下，并在 index.py 中添加根路由访问视图 from . import index_blu from flask import render_template @index_blu.route('/') def index(): return render_template('news/index.html') 运行，访问根路由测试 ","date":"2020-06-13","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/:8:2","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:开发准备","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/"},{"categories":["Python"],"content":"网站图标展示 自定义视图函数，访问网站图标，send_static_file 是系统访问静态文件所调用的方法 @index_blu.route('/favicon.ico') def favicon(): return current_app.send_static_file('news/favicon.ico') ","date":"2020-06-13","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/:9:0","tags":["Python学习之路"],"title":"Python学习之路-Flask项目:开发准备","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-flask%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/"},{"categories":["Python"],"content":"简介 Python中的拷贝机制有两种，一种是深拷贝一种是浅拷贝，下面深入学习一下： ","date":"2020-04-25","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/:1:0","tags":["Python学习之路"],"title":"Python学习之路-深拷贝与浅拷贝","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/"},{"categories":["Python"],"content":"浅拷贝 ","date":"2020-04-25","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/:2:0","tags":["Python学习之路"],"title":"Python学习之路-深拷贝与浅拷贝","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/"},{"categories":["Python"],"content":"简介 浅拷贝是对于一个对象的顶层拷贝，通俗的理解是：拷贝了引用，并没有拷贝内容。 ","date":"2020-04-25","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/:2:1","tags":["Python学习之路"],"title":"Python学习之路-深拷贝与浅拷贝","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/"},{"categories":["Python"],"content":"例子 \u003e\u003e\u003e a = [1,2,3] \u003e\u003e\u003e b = a \u003e\u003e\u003e id(a) 4382391344 \u003e\u003e\u003e id(b) 4382391344 a和b指向的数据的内存地址相同，说明变量在赋值时就是将数据的引用复制了一份给另一个变量 ","date":"2020-04-25","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/:2:2","tags":["Python学习之路"],"title":"Python学习之路-深拷贝与浅拷贝","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/"},{"categories":["Python"],"content":"深拷贝 ","date":"2020-04-25","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/:3:0","tags":["Python学习之路"],"title":"Python学习之路-深拷贝与浅拷贝","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/"},{"categories":["Python"],"content":"简介 深拷贝是对于一个对象所有层次的拷贝(递归) ","date":"2020-04-25","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/:3:1","tags":["Python学习之路"],"title":"Python学习之路-深拷贝与浅拷贝","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/"},{"categories":["Python"],"content":"例子 \u003e\u003e\u003e c = copy.deepcopy(a) \u003e\u003e\u003e id(a) 4382391344 \u003e\u003e\u003e id(c) 4383457680 \u003e\u003e\u003e id(a[0]) 4379642784 \u003e\u003e\u003e id(b[0]) 4379642784 \u003e\u003e\u003e id(c[0]) 4379642784 浅拷贝列表里的元素也是直接拷贝的引用，深拷贝则是进行了深层次的拷贝，所有内存地址都不一样 ","date":"2020-04-25","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/:3:2","tags":["Python学习之路"],"title":"Python学习之路-深拷贝与浅拷贝","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/"},{"categories":["Python"],"content":"copy 浅拷贝可以使用copy.copy来实现。对不可变类型和可变类型的copy不同，copy.copy对于可变类型会进行浅拷贝，对于不可变类型不会拷贝仅仅是指向。 \u003e\u003e\u003e a.append(4) \u003e\u003e\u003e a [1, 2, 3, 4] \u003e\u003e\u003e b [1, 2, 3, 4] \u003e\u003e\u003e d [1, 2, 3] ","date":"2020-04-25","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/:4:0","tags":["Python学习之路"],"title":"Python学习之路-深拷贝与浅拷贝","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/"},{"categories":["Python"],"content":"copy.copy和copy.deepcopy的区别 \u003e\u003e\u003e a = [1,2,3] \u003e\u003e\u003e b = (a,) \u003e\u003e\u003e c = [b,] \u003e\u003e\u003e d = copy.copy(c) \u003e\u003e\u003e c [([1, 2, 3],)] \u003e\u003e\u003e d [([1, 2, 3],)] \u003e\u003e\u003e a.append(4) \u003e\u003e\u003e c [([1, 2, 3, 4],)] \u003e\u003e\u003e d [([1, 2, 3, 4],)] \u003e\u003e\u003e id(c) 4383457680 \u003e\u003e\u003e id(d) 4382391344 \u003e\u003e\u003e id(c[0]) 4383618320 \u003e\u003e\u003e id(d[0]) 4383618320 d = c让d这个变量指向c指向的空间，d = copy.copy是赋值所有c指向的数据到一个新的空间，但是不会递归copy \u003e\u003e\u003e e = copy.deepcopy(c) \u003e\u003e\u003e c [([1, 2, 3, 4],)] \u003e\u003e\u003e e [([1, 2, 3, 4],)] \u003e\u003e\u003e id(c) 4383457680 \u003e\u003e\u003e id(e) 4383582240 \u003e\u003e\u003e id(c[0]) 4383618320 \u003e\u003e\u003e id(e[0]) 4384001616 \u003e\u003e\u003e a.append(5) \u003e\u003e\u003e c [([1, 2, 3, 4, 5],)] \u003e\u003e\u003e d [([1, 2, 3, 4, 5],)] \u003e\u003e\u003e e [([1, 2, 3, 4],)] 当使用copy.deepcopy后会将c指向的空间进行递归copy，相当于进行了深层次的拷贝，所以改变a不会影响到e ","date":"2020-04-25","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/:4:1","tags":["Python学习之路"],"title":"Python学习之路-深拷贝与浅拷贝","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/"},{"categories":["Python"],"content":"简介 Python的内存管理机制可以总结为：引用计数、垃圾回收、内存池。 ","date":"2020-04-18","objectID":"/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/:1:0","tags":["Python学习之路"],"title":"Python学习之路-内存管理","uri":"/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"},{"categories":["Python"],"content":"引用计数 引用计数是一种非常高效的内存管理手段， 当一个 Python 对象被引用时其引用计数增加 1， 当其不再被一个变量引用时则计数减 1. 当引用计数等于 0 时对象被删除。 ","date":"2020-04-18","objectID":"/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/:2:0","tags":["Python学习之路"],"title":"Python学习之路-内存管理","uri":"/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"},{"categories":["Python"],"content":"垃圾回收 ","date":"2020-04-18","objectID":"/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/:3:0","tags":["Python学习之路"],"title":"Python学习之路-内存管理","uri":"/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"},{"categories":["Python"],"content":"引用计数 引用计数也是一种垃圾收集机制，而且也是一种最直观，最简单的垃圾收集技术。当 Python 的某 个对象的引用计数降为 0 时，说明没有任何引用指向该对象，该对象就成为要被回收的垃圾了。比如 某个新建对象，它被分配给某个引用，对象的引用计数变为 1。如果引用被删除，对象的引用计数为 0， 那么该对象就可以被垃圾回收。不过如果出现循环引用的话，引用计数机制就不再起有效的作用了 ","date":"2020-04-18","objectID":"/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/:3:1","tags":["Python学习之路"],"title":"Python学习之路-内存管理","uri":"/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"},{"categories":["Python"],"content":"标记清除 如果两个对象的引用计数都为 1，但是仅仅存在他们之间的循环引用，那么这两个对象都是需要被 回收的，也就是说，它们的引用计数虽然表现为非 0，但实际上有效的引用计数为 0。所以先将循环引 用摘掉，就会得出这两个对象的有效计数。 ","date":"2020-04-18","objectID":"/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/:3:2","tags":["Python学习之路"],"title":"Python学习之路-内存管理","uri":"/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"},{"categories":["Python"],"content":"分代回收 从前面“标记-清除”这样的垃圾收集机制来看，这种垃圾收集机制所带来的额外操作实际上与系统 中总的内存块的数量是相关的，当需要回收的内存块越多时，垃圾检测带来的额外操作就越多，而垃圾 回收带来的额外操作就越少；反之，当需回收的内存块越少时，垃圾检测就将比垃圾回收带来更少的额 外操作。 ","date":"2020-04-18","objectID":"/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/:3:3","tags":["Python学习之路"],"title":"Python学习之路-内存管理","uri":"/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"},{"categories":["Python"],"content":"内存池 ","date":"2020-04-18","objectID":"/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/:4:0","tags":["Python学习之路"],"title":"Python学习之路-内存管理","uri":"/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"},{"categories":["Python"],"content":"简介 Python 的内存机制呈现金字塔形状，-1，-2 层主要有操作系统进行操作，第 0 层是 C 中的 malloc，free 等内存分配和释放函数进行操作，第 1 层和第 2 层是内存池，有 Python 的接口函数 PyMem_Malloc 函数实现，当对象小于256K 时有该层直接分配内存，第 3 层是最上层，也就是我们对 Python 对象的直接操作。 Python 在运行期间会大量地执行 malloc 和 free 的操作，频繁地在用户态和核心态之间进行切换，这将严重影响 Python 的执行效率。为了加速 Python 的执行效率，Python 引入了一个内存池机制，用于管理对小块内存的申请和释放。 Python 内部默认的小块内存与大块内存的分界点定在 256 个字节，当申请的内存小于 256 字节时，PyObject_Malloc 会在内存池中申请内存；当申请的内存大于 256 字节时，PyObject_Malloc 的行为将蜕化为 malloc 的行为。当然，通过修改 Python 源代码，我们可以改变这个默认值，从而改 变 Python 的默认内存管理行为。 ","date":"2020-04-18","objectID":"/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/:4:1","tags":["Python学习之路"],"title":"Python学习之路-内存管理","uri":"/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"},{"categories":["Python"],"content":"调优手段 手动垃圾回 调高垃圾回收阈值 避免循环引用（手动解循环引用和使用弱引用） ","date":"2020-04-18","objectID":"/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/:4:2","tags":["Python学习之路"],"title":"Python学习之路-内存管理","uri":"/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"},{"categories":["Python"],"content":"内存泄露 是什么？ 指由于疏忽或错误造成程序未能释放已经不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。导致程序运行速度减慢甚至系统崩溃等严重后果。 有 del() 函数的对象间的循环引用是导致内存泄漏的主凶。 如何避免？ 不使用一个对象时使用:del object 来删除一个对象的引用计数就可以有效防止内存泄漏问题。 通过 Python 扩展模块 gc 来查看不能回收的对象的详细信息。 可以通过 sys.getrefcount(obj) 来获取对象的引用计数，并根据返回值是否为 0 来判断是否内存 泄漏。 ","date":"2020-04-18","objectID":"/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/:4:3","tags":["Python学习之路"],"title":"Python学习之路-内存管理","uri":"/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"},{"categories":["Python"],"content":"主从 ","date":"2020-04-11","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E8%BF%9B%E9%98%B6/:1:0","tags":["Python学习之路"],"title":"Python学习之路-Redis进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"概念 ⼀个master可以拥有多个slave，⼀个slave⼜可以拥有多个slave，如此下去，形成了强⼤的多级服务器集群架构。master用来写数据，slave用来读数据，经统计：网站的读写比率是10:1，通过主从配置可以实现读写分离。master和slave都是一个redis实例(redis服务) ","date":"2020-04-11","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E8%BF%9B%E9%98%B6/:1:1","tags":["Python学习之路"],"title":"Python学习之路-Redis进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"配置 主服务器 修改etc/redis/redis.conf文件 sudo vi redis.conf bind 192.168.1.1 重启redis服务 sudo service redis stop redis-server redis.conf 从服务器 复制etc/redis/redis.conf文件 sudo cp redis.conf ./slave.conf 修改redis/slave.conf文件 sudo vi slave.conf 编辑内容 bind 192.168.1.1 slaveof 192.168.1.1 6379 port 6378 配置redis服务 sudo redis-server slave.conf 查看主从关系 redis-cli -h 192.168.26.128 info Replication ","date":"2020-04-11","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E8%BF%9B%E9%98%B6/:1:2","tags":["Python学习之路"],"title":"Python学习之路-Redis进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"数据操作 在master和slave分别执⾏info命令，查看输出信息 进入主客户端 redis-cli -h 192.168.1.1 -p 6379 进入从的客户端 redis-cli -h 192.168.26.128 -p 6378 在master上写数据 在slave上读数据 ","date":"2020-04-11","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E8%BF%9B%E9%98%B6/:1:3","tags":["Python学习之路"],"title":"Python学习之路-Redis进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"集群 ","date":"2020-04-11","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E8%BF%9B%E9%98%B6/:2:0","tags":["Python学习之路"],"title":"Python学习之路-Redis进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"为什么要有 之前我们已经讲了主从的概念，一主可以多从，如果同时的访问量过大(1000w),主服务肯定就会挂掉，数据服务就挂掉了或者发生自然灾难。大公司都会有很多的服务器(华东地区、华南地区、华中地区、华北地区、西北地区、西南地区、东北地区、台港澳地区机房) ","date":"2020-04-11","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E8%BF%9B%E9%98%B6/:2:1","tags":["Python学习之路"],"title":"Python学习之路-Redis进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"概念 集群是一组相互独立的、通过高速网络互联的计算机，它们构成了一个组，并以单一系统的模式加以管理。一个客户与集群相互作用时，集群像是一个独立的服务器。集群配置是用于提高可用性和可缩放性。当请求到来首先由负载均衡服务器处理，把请求转发到另外的一台服务器上。 ","date":"2020-04-11","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E8%BF%9B%E9%98%B6/:2:2","tags":["Python学习之路"],"title":"Python学习之路-Redis进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"分类 软件层面：只有一台电脑，在这一台电脑上启动了多个redis服务。 硬件层面：存在多台实体的电脑，每台电脑上都启动了一个redis或者多个redis服务。 ","date":"2020-04-11","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E8%BF%9B%E9%98%B6/:2:3","tags":["Python学习之路"],"title":"Python学习之路-Redis进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"搭建 配置机器1 在conf⽬录下创建⽂件7000.conf，编辑内容如下 port 7000 bind 192.168.1.1 daemonize yes pidfile 7000.pid cluster-enabled yes cluster-config-file 7000_node.conf cluster-node-timeout 15000 appendonly yes 在conf⽬录下创建⽂件7001.conf，编辑内容如下 port 7001 bind 192.168.1.1 daemonize yes pidfile 7001.pid cluster-enabled yes cluster-config-file 7001_node.conf cluster-node-timeout 15000 appendonly yes 在conf⽬录下创建⽂件7002.conf，编辑内容如下 port 7002 bind 192.168.1.1 daemonize yes pidfile 7002.pid cluster-enabled yes cluster-config-file 7002_node.conf cluster-node-timeout 15000 三个⽂件的配置区别在port、pidfile、cluster-config-file三项 使⽤配置⽂件启动redis服务 redis-server 7000.conf redis-server 7001.conf redis-server 7002.conf 配置机器2 在conf⽬录下创建⽂件7003.conf，编辑内容如下 port 7003 bind 192.168.1.2 daemonize yes pidfile 7003.pid cluster-enabled yes cluster-config-file 7003_node.conf cluster-node-timeout 15000 appendonly yes 在conf⽬录下创建⽂件7004.conf，编辑内容如下 port 7004 bind 192.168.1.2 daemonize yes pidfile 7004.pid cluster-enabled yes cluster-config-file 7004_node.conf cluster-node-timeout 15000 appendonly yes 在conf⽬录下创建⽂件7005.conf，编辑内容如下 port 7005 bind 192.168.1.2 daemonize yes pidfile 7005.pid cluster-enabled yes cluster-config-file 7005_node.conf cluster-node-timeout 15000 appendonly yes 三个⽂件的配置区别在port、pidfile、cluster-config-file三项 使⽤配置⽂件启动redis服务 redis-server 7003.conf redis-server 7004.conf redis-server 7005.conf 创建集群 redis的安装包中包含了redis-trib.rb，⽤于创建集群，接下来的操作在191.168.1.1机器上进⾏将命令复制，这样可以在任何⽬录下调⽤此命令： sudo cp /usr/share/doc/redis-tools/examples/redis-trib.rb /usr/local/bin/ 安装ruby环境，因为redis-trib.rb是⽤ruby开发的 sudo apt-get install ruby 在提示信息处输⼊y，然后回⻋继续安装 运⾏如下命令创建集群 redis-trib.rb create --replicas 1 191.168.1.1:7000 192.168.1.1:7001 192.168.1.1:7002 192.168.1.2:7003 192.168.1.2:7004 192.168.1.2:7000 执⾏上⾯这个指令在某些机器上可能会报错，主要原因是由于安装的ruby不是最新版本！天朝的防⽕墙导致⽆法下载最新版本，所以需要设置 gem 的源解决办法如下： -- 先查看⾃⼰的 gem 源是什么地址 gem source -l -- 如果是https://rubygems.org/ 就需要更换 -- 更换指令为 gem sources --add https://gems.ruby-china.org/ --remove https://rubygems.org/ -- 通过 gem 安装 redis 的相关依赖 sudo gem install redis -- 然后重新执⾏指令 提示完成，集群搭建成功 数据验证 当前搭建的主服务器为7000、7001、7003，对应的从服务器是7004、7005、7002，在192.168.1.2机器上连接7002，加参数-c表示连接到集群 redis-cli -h 172.16.179.131 -c -p 7002 写⼊数据，⾃动跳到了7003服务器，并写⼊数据成功，在7003可以获取数据，如果写入数据又重定向到7000(负载均衡) ","date":"2020-04-11","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E8%BF%9B%E9%98%B6/:2:4","tags":["Python学习之路"],"title":"Python学习之路-Redis进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"在哪个服务器上写数据：CRC16 redis cluster在设计的时候，就考虑到了去中⼼化，去中间件，也就是说，集群中 的每个节点都是平等的关系，都是对等的，每个节点都保存各⾃的数据和整个集 群的状态。每个节点都和其他所有节点连接，⽽且这些连接保持活跃，这样就保 证了我们只需要连接集群中的任意⼀个节点，就可以获取到其他节点的数据 Redis集群没有并使⽤传统的⼀致性哈希来分配数据，⽽是采⽤另外⼀种叫做哈希 槽 (hash slot)的⽅式来分配的。redis cluster 默认分配了 16384 个slot，当我们 set⼀个key 时，会⽤CRC16算法来取模得到所属的slot，然后将这个key 分到哈 希槽区间的节点上，具体算法就是：CRC16(key) % 16384。所以我们在测试的 时候看到set 和 get 的时候，直接跳转到了7000端⼝的节点 Redis 集群会把数据存在⼀个 master 节点，然后在这个 master 和其对应的salve 之间进⾏数据同步。当读取数据时，也根据⼀致性哈希算法到对应的 master 节 点获取数据。只有当⼀个master 挂掉之后，才会启动⼀个对应的 salve 节点，充 当 master 需要注意的是：必须要3个或以上的主节点，否则在创建集群时会失败，并且当存 活的主节点数⼩于总节点数的⼀半时，整个集群就⽆法提供服务了 ","date":"2020-04-11","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E8%BF%9B%E9%98%B6/:2:5","tags":["Python学习之路"],"title":"Python学习之路-Redis进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"Python交互 安装包：pip install redis-py-cluster，redis-py-cluster源码地址https://github.com/Grokzen/redis-py-cluster 创建⽂件redis_cluster.py，示例码如下： from rediscluster import * if __name__ == '__main__': try: # 构建所有的节点，Redis会使⽤CRC16算法，将键和值写到某个节点上 startup_nodes = [ {'host': '192.168.26.128', 'port': '7000'}, {'host': '192.168.26.130', 'port': '7003'}, {'host': '192.168.26.128', 'port': '7001'}, ] # 构建StrictRedisCluster对象 src=StrictRedisCluster(startup_nodes=startup_nodes,decode_responses=True) # 设置键为name、值为itheima的数据 result=src.set('name','itheima') print(result) # 获取键为name name = src.get('name') print(name) except Exception as e: print(e) ","date":"2020-04-11","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E8%BF%9B%E9%98%B6/:2:6","tags":["Python学习之路"],"title":"Python学习之路-Redis进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"前言 在Python中操作Redis可以直接用redis模块 ","date":"2020-03-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-python%E6%93%8D%E4%BD%9Credis/:1:0","tags":["Python学习之路"],"title":"Python学习之路-Python操作redis","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-python%E6%93%8D%E4%BD%9Credis/"},{"categories":["Python"],"content":"安装 安装Redis的有3种方式https://github.com/andymccurdy/redis-py 第一种：进⼊虚拟环境py_django，联⽹安装包redis pip install redis 第二种：进⼊虚拟环境py_django，联⽹安装包redis easy_install redis 第三种：到中⽂官⽹-客户端下载redis包的源码，使⽤源码安装： 下载：执行 wget https://github.com/andymccurdy/redis-py/archive/master.zip 解压：unzip master.zip 安装：先进入文件夹cd redis-py-master通过setup.py安装sudo python setup.py install ","date":"2020-03-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-python%E6%93%8D%E4%BD%9Credis/:2:0","tags":["Python学习之路"],"title":"Python学习之路-Python操作redis","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-python%E6%93%8D%E4%BD%9Credis/"},{"categories":["Python"],"content":"使用 ","date":"2020-03-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-python%E6%93%8D%E4%BD%9Credis/:3:0","tags":["Python学习之路"],"title":"Python学习之路-Python操作redis","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-python%E6%93%8D%E4%BD%9Credis/"},{"categories":["Python"],"content":"引入 引⼊模块：from redis import * 注意 这个模块中提供了StrictRedis对象(Strict严格)，⽤于连接redis服务器，并按照不同类型提供 了不同⽅法，进⾏交互操作 ","date":"2020-03-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-python%E6%93%8D%E4%BD%9Credis/:3:1","tags":["Python学习之路"],"title":"Python学习之路-Python操作redis","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-python%E6%93%8D%E4%BD%9Credis/"},{"categories":["Python"],"content":"StrictRedis对象 通过创建对象，指定参数host、port与指定的服务器和端⼝连接，host默认为localhost，port默认为6379，db默认为0 sr = StrictRedis(host='localhost', port=6379, db=0) # 简写 sr=StrictRedis() 提示 根据不同的类型，拥有不同的实例⽅法可以调⽤，与前⾯学的redis命令对应，⽅法需要的参数与命令的参数⼀致 ","date":"2020-03-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-python%E6%93%8D%E4%BD%9Credis/:3:2","tags":["Python学习之路"],"title":"Python学习之路-Python操作redis","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-python%E6%93%8D%E4%BD%9Credis/"},{"categories":["Python"],"content":"指令 string set setex mset append get mget key keys exists type delete expire getrange ttl hash hset hmset hkeys hget hmget hvals hdel list lpush rpush linsert lrange lset lrem set sadd smembers srem zset zadd zrange zrangebyscore zscore zrem zremrangebyscore ","date":"2020-03-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-python%E6%93%8D%E4%BD%9Credis/:3:3","tags":["Python学习之路"],"title":"Python学习之路-Python操作redis","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-python%E6%93%8D%E4%BD%9Credis/"},{"categories":["Python"],"content":"前言 前面学习数据库的时候学习了用的最多的关系型数据库MySQL，这次来学习用的最多的非关系型数据库Redis。 ","date":"2020-03-21","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E5%9F%BA%E7%A1%80/:1:0","tags":["Python学习之路"],"title":"Python学习之路-Redis基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E5%9F%BA%E7%A1%80/"},{"categories":["Python"],"content":"简介 Redis是一个使用ANSI C编写的开源、支持网络、基于内存、分布式、可选持久性的键值对存储数据库。根据月度排行网站DB-Engines.com的数据，Redis是最流行的键值对存储数据库。 ","date":"2020-03-21","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E5%9F%BA%E7%A1%80/:2:0","tags":["Python学习之路"],"title":"Python学习之路-Redis基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E5%9F%BA%E7%A1%80/"},{"categories":["Python"],"content":"安装 ","date":"2020-03-21","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E5%9F%BA%E7%A1%80/:3:0","tags":["Python学习之路"],"title":"Python学习之路-Redis基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E5%9F%BA%E7%A1%80/"},{"categories":["Python"],"content":"下载 使用以下命令下载，提取和编译Redis： $ wget https://download.redis.io/releases/redis-5.0.7.tar.gz $ tar xzf redis-5.0.7.tar.gz $ cd redis-5.0.7 $ make ","date":"2020-03-21","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E5%9F%BA%E7%A1%80/:3:1","tags":["Python学习之路"],"title":"Python学习之路-Redis基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E5%9F%BA%E7%A1%80/"},{"categories":["Python"],"content":"运行 src 目录 中现在提供了已编译的二进制文件 。使用以下命令运行Redis： $ src/redis-server ","date":"2020-03-21","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E5%9F%BA%E7%A1%80/:3:2","tags":["Python学习之路"],"title":"Python学习之路-Redis基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E5%9F%BA%E7%A1%80/"},{"categories":["Python"],"content":"测试 可以使用内置客户端与Redis进行交互： $ src/redis-cli redis\u003e set foo bar OK redis\u003e get foo \"bar\" ","date":"2020-03-21","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E5%9F%BA%E7%A1%80/:3:3","tags":["Python学习之路"],"title":"Python学习之路-Redis基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E5%9F%BA%E7%A1%80/"},{"categories":["Python"],"content":"常用配置 Redis的配置信息在/etc/redis/redis.conf下，使用vi进行编辑配置： sudo vi /etc/redis/redis.conf ip与端口 绑定绑定⼀个真实ip。端⼝默认为6379 bind 127.0.0.1 port 6379 如果需要远程访问，可将ip⾏注释 守护进程 如果以守护进程运⾏，则不会在命令⾏阻塞，类似于服务。如果以⾮守护进程运⾏，则当前终端被阻塞。设置为yes表示守护进程，设置为no表示⾮守护进程。推荐设置为yes daemonize yes 数据⽂件 # 数据文件名 dbfilename dump.rdb # 存储路径 dir /var/lib/redis ⽇志⽂件 # 日志文件存储位置 logfile \"/var/log/redis/redis-server.log\" 数据库 数据库个数，默认有16个 database 16 主从复制 类似于双机备份 slaveof 其他配置 redis-5.0.3配置https://blog.csdn.net/suprezheng/article/details/90679790 ","date":"2020-03-21","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E5%9F%BA%E7%A1%80/:3:4","tags":["Python学习之路"],"title":"Python学习之路-Redis基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E5%9F%BA%E7%A1%80/"},{"categories":["Python"],"content":"相关命令 ","date":"2020-03-21","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E5%9F%BA%E7%A1%80/:4:0","tags":["Python学习之路"],"title":"Python学习之路-Redis基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E5%9F%BA%E7%A1%80/"},{"categories":["Python"],"content":"服务端 启动服务端的命令为：redis-server。 查看帮助⽂档：redis-server --help 查看redis服务器进程：ps aux | grep redis 杀死redis服务器：sudo kill -9 pid 指定加载的配置文件：sudo redis-server /etc/redis/redis.conf ","date":"2020-03-21","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E5%9F%BA%E7%A1%80/:4:1","tags":["Python学习之路"],"title":"Python学习之路-Redis基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E5%9F%BA%E7%A1%80/"},{"categories":["Python"],"content":"客户端 进入客户端的命令为：redis-cli 查看帮助⽂档：redis-cli --help 运⾏测试命令：ping 127.0.0.1:6379\u003e ping PONG 切换数据库，数据库没有名称，默认有16个，通过0-15来标识，连接redis默认选择第一个数据库 \u003e select 2 OK 127.0.0.1:6379[2]\u003e ","date":"2020-03-21","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E5%9F%BA%E7%A1%80/:4:2","tags":["Python学习之路"],"title":"Python学习之路-Redis基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E5%9F%BA%E7%A1%80/"},{"categories":["Python"],"content":"数据结构 redis是key-value的数据结构，每条数据都是⼀个键值对，键的类型是字符串 注意 键不能重复 值的类型分为五种： 字符串string：字符串类型是Redis中最为基础的数据存储类型，一个 key 对应一个 value。 提示 string类型在Redis中是二进制安全的。这便意味着该类型可以接受任何格式的数据，比如JPEG图像数据或JSON对象描述信息等。在Redis中字符串类型的Value最多可以容纳的数据长度是512M。 哈希hash：是一个键值(key=\u003evalue)对集合。特别适合用于存储对象。 列表list：简单的字符串列表，按照插入顺序排序。可以添加一个元素到列表的头部(左边)或者尾部(右边)。 集合set：string 类型的无序集合。通过哈希表实现的，添加，删除，查找的复杂度都是 O(1)。 有序集合zset：和 set 一样也是string类型元素的集合，且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的,但分数(score)却可以重复。 ","date":"2020-03-21","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E5%9F%BA%E7%A1%80/:5:0","tags":["Python学习之路"],"title":"Python学习之路-Redis基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E5%9F%BA%E7%A1%80/"},{"categories":["Python"],"content":"数据操作 ","date":"2020-03-21","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E5%9F%BA%E7%A1%80/:6:0","tags":["Python学习之路"],"title":"Python学习之路-Redis基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E5%9F%BA%E7%A1%80/"},{"categories":["Python"],"content":"string 存储 设置键值：set key value，例： 127.0.0.1:6379[2]\u003e set name xiaoliang OK 设置键值及过期时间，单位为秒：setex key seconds value，例： 127.0.0.1:6379[2]\u003e setex name 3 xiaoliang OK 设置多个键值：mset key1 value1 key2 value2 ...，例： 127.0.0.1:6379[2]\u003e mset name xiaoliang age 18 OK 追加值：append key value，例： 127.0.0.1:6379[2]\u003e set name xiaoliang OK 127.0.0.1:6379[2]\u003e append name liang (integer) 14 127.0.0.1:6379[2]\u003e get name \"xiaoliangliang\" 获取 根据键获取值，如果不存在此键则返回nil：get key，例： 127.0.0.1:6379[2]\u003e get name \"xiaoliang\" 根据多个键获取多个值：mget key1 key2 ...，例： 127.0.0.1:6379[2]\u003e mget name age 1) \"xiaoliang\" 2) \"18\" 查看所有键：keys * 查找键，参数⽀持正则表达式：keys pattern，例： 127.0.0.1:6379[2]\u003e keys n* 1) \"name\" 判断键是否存在，如果存在返回1，不存在返回0：exists key，例： 127.0.0.1:6379[2]\u003e exists name (integer) 1 127.0.0.1:6379[2]\u003e exists namee (integer) 0 查看键对应的value的类型：type key，例： 127.0.0.1:6379[2]\u003e type name string 删除 删除键及对应的值：del key1 key2 ...，例： del name age (integer) 2 mget name age (nil) (nil) - 设置过期时间，以秒为单位：`expire key seconds`，例 ```redis 127.0.0.1:6379[2]\u003e expire name 10 (integer) 1 127.0.0.1:6379[2]\u003e ttl name (integer) 4 注意 如果没有指定过期时间则⼀直存在，直到使⽤DEL移除 ","date":"2020-03-21","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E5%9F%BA%E7%A1%80/:6:1","tags":["Python学习之路"],"title":"Python学习之路-Redis基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E5%9F%BA%E7%A1%80/"},{"categories":["Python"],"content":"hash 存储 设置单个属性：hset key field value，例： 127.0.0.1:6379[2]\u003e hset user name xiaoliang (integer) 1 提示 可能会出现错误：MISCONF Redis is configured to save RDB snapshots, but is currently not able to persist on disk. Commands that may modify the data set are disabled. Please check Redis logs for details about the error. Redis被配置为保存数据库快照，但它目前不能持久化到硬盘。用来修改集合数据的命令不能用 原因：强制关闭Redis快照导致不能持久化。 解决方案：运行config set stop-writes-on-bgsave-error no　命令后，关闭配置项stop-writes-on-bgsave-error解决该问题。 设置多个属性：hmset key field1 value1 field2 value2 ...，例： 127.0.0.1:6379[2]\u003e hset user name xiaoliang age 18 (integer) 1 获取 获取指定键所有的属性：hkeys key，例： 127.0.0.1:6379[2]\u003e hkeys user 1) \"name\" 2) \"age\" 获取⼀个属性的值：hget key field，例： 127.0.0.1:6379[2]\u003e hget user name \"xiaoliang\" 获取多个属性的值：hmget key field1 field2 ...，例： 127.0.0.1:6379[2]\u003e hmget user name age 1) \"xiaoliang\" 2) \"18\" 获取所有属性的值：hvals key，例： 127.0.0.1:6379[2]\u003e hvals user 1) \"xiaoliang\" 2) \"18\" 删除 删除整个hash键及值，使⽤del命令 删除属性，属性对应的值会被⼀起删除：hdel key field1 field2 ...，例子： 127.0.0.1:6379[2]\u003e hdel user age (integer) 1 127.0.0.1:6379[2]\u003e hkeys user 1) \"name\" ","date":"2020-03-21","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E5%9F%BA%E7%A1%80/:6:2","tags":["Python学习之路"],"title":"Python学习之路-Redis基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E5%9F%BA%E7%A1%80/"},{"categories":["Python"],"content":"list 存储 在左侧插⼊数据：lpush key value1 value2 ...，例： 127.0.0.1:6379[2]\u003e lpush name si liang (integer) 2 127.0.0.1:6379[2]\u003e lrange name 0 2 1) \"liang\" 2) \"si\" 在右侧插⼊数据：rpush key value1 value2 ...，例： 127.0.0.1:6379[2]\u003e rpush name liang si (integer) 4 127.0.0.1:6379[2]\u003e lrange name 0 4 1) \"liang\" 2) \"si\" 3) \"liang\" 4) \"si\" 在指定元素的前或后插⼊新元素：linsert key before或after 现有元素 新元素，例： 127.0.0.1:6379[2]\u003e linsert name before si yao (integer) 5 127.0.0.1:6379[2]\u003e lrange name 0 6 1) \"liang\" 2) \"yao\" 3) \"si\" 4) \"liang\" 5) \"si\" 获取 返回列表⾥指定范围内的元素：lrange key start stop()，例： 提示 start、stop为元素的下标索引，索引从左侧开始，第⼀个元素为0，索引可以是负数，表示从尾部开始计数，如-1表示最后⼀个元素 # 获取name列表所有元素 127.0.0.1:6379[2]\u003e lrange name 0 -1 1) \"liang\" 2) \"yao\" 3) \"si\" 4) \"liang\" 5) \"si\" 设置指定索引位置的元素值：lset key index value，例： 提示 索引从左侧开始，第⼀个元素为0。索引可以是负数，表示尾部开始计数，如-1表示最后⼀个元素 127.0.0.1:6379[2]\u003e lset name 4 si OK 127.0.0.1:6379[2]\u003e lrange name 0 -1 1) \"liang\" 2) \"yao\" 3) \"si\" 4) \"liang\" 5) \"si\" 删除 删除指定元素：lrem key count value，例： 提示 将列表中前count次出现的值为value的元素移除，count \u003e 0: 从头往尾移除，count \u003c 0: 从尾往头移除，count = 0: 移除所有 127.0.0.1:6379[2]\u003e lrem name 0 liang (integer) 2 127.0.0.1:6379[2]\u003e lrange name 0 -1 1) \"yao\" 2) \"si\" 3) \"si\" ","date":"2020-03-21","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E5%9F%BA%E7%A1%80/:6:3","tags":["Python学习之路"],"title":"Python学习之路-Redis基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E5%9F%BA%E7%A1%80/"},{"categories":["Python"],"content":"set 存储 添加元素：sadd key member1 member2 ...，例： 127.0.0.1:6379[2]\u003e sadd name liang si (integer) 2 获取 返回所有的元素：smembers key，例： 127.0.0.1:6379[2]\u003e smembers name 1) \"si\" 2) \"liang\" 删除 删除指定元素：srem key，例： 127.0.0.1:6379[2]\u003e srem name liang (integer) 1 127.0.0.1:6379[2]\u003e smembers name 1) \"si\" ","date":"2020-03-21","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E5%9F%BA%E7%A1%80/:6:4","tags":["Python学习之路"],"title":"Python学习之路-Redis基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E5%9F%BA%E7%A1%80/"},{"categories":["Python"],"content":"zset 存储 添加：zadd key score1 member1 score2 member2 ...，例： 127.0.0.1:6379[2]\u003e zadd name 2 liang 1 si (integer) 2 获取 返回指定范围内的元素：zrange key start stop，例： 提示 start、stop为元素的下标索引，索引从左侧开始，第⼀个元素为0，索引可以是负数，表示从尾部开始计数，如-1表示最后⼀个元素 127.0.0.1:6379[2]\u003e zrange name 0 -1 1) \"si\" 2) \"liang\" 返回score值在min和max之间的成员：zrangebyscore key min max，例： 127.0.0.1:6379[2]\u003e zrangebyscore name 1 2 1) \"si\" 2) \"liang\" 返回成员member的score值：zscore key member，例： 127.0.0.1:6379[2]\u003e zscore name liang \"2\" ","date":"2020-03-21","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E5%9F%BA%E7%A1%80/:6:5","tags":["Python学习之路"],"title":"Python学习之路-Redis基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E5%9F%BA%E7%A1%80/"},{"categories":["Python"],"content":"删除 删除指定元素：zrem key member1 member2 ...，例： 127.0.0.1:6379[2]\u003e zrem name liang (integer) 1 127.0.0.1:6379[2]\u003e zrange name 0 -1 1) \"si\" 删除权重在指定范围的元素：zremrangebyscore key min max，例： 127.0.0.1:6379[2]\u003e zremrangebyscore name 0 2 (integer) 1 127.0.0.1:6379[2]\u003e zrange name 0 -4 (empty array) ","date":"2020-03-21","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E5%9F%BA%E7%A1%80/:6:6","tags":["Python学习之路"],"title":"Python学习之路-Redis基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-redis%E5%9F%BA%E7%A1%80/"},{"categories":["Hugo"],"content":"前言 由于前一段时间学习了Golang，在家查阅相关资料的时候发现了Hugo这个用Go语言编写的静态网站生成器，根据网站的介绍它有着速度快，易用，可配置程度高等特点，而且文章依赖于Markdown生成，非常适合作为博客、文档、个人简历这类型的网站，于是我准备用Hugo搭建一个属于自己的博客，并将之前写的文章都搬运过来，最后通过GitHub Pages部署，一起开始吧！ ","date":"2020-02-07","objectID":"/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%80%9A%E8%BF%87github/:1:0","tags":["Hugo","博客"],"title":"使用Hugo搭建自己的博客并通过GitHub Pages部署","uri":"/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%80%9A%E8%BF%87github/"},{"categories":["Hugo"],"content":"使用Hugo搭建博客 ","date":"2020-02-07","objectID":"/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%80%9A%E8%BF%87github/:2:0","tags":["Hugo","博客"],"title":"使用Hugo搭建自己的博客并通过GitHub Pages部署","uri":"/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%80%9A%E8%BF%87github/"},{"categories":["Hugo"],"content":"安装 Mac和Linux可以直接用Homebrew安装 brew install hugo Windows在github上下载解压后安装， 注意 Windows安装完毕记得添加环境变量！ 此外Hugo官方还提供了多种安装方式，选择自己喜欢的即可 安装完毕后，可以通过查询Hugo版本验证是否安装成功 hugo version ","date":"2020-02-07","objectID":"/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%80%9A%E8%BF%87github/:2:1","tags":["Hugo","博客"],"title":"使用Hugo搭建自己的博客并通过GitHub Pages部署","uri":"/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%80%9A%E8%BF%87github/"},{"categories":["Hugo"],"content":"创建新站点 hugo new site SilenceBlog 创建成功图片 ","date":"2020-02-07","objectID":"/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%80%9A%E8%BF%87github/:2:2","tags":["Hugo","博客"],"title":"使用Hugo搭建自己的博客并通过GitHub Pages部署","uri":"/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%80%9A%E8%BF%87github/"},{"categories":["Hugo"],"content":"添加并配置主题 Hugo收录的主题非常多，可以在主题库中寻找自己喜欢的 从GitHub下载主题到站点存放主题的目录中： git clone https://github.com/dillonzq/LoveIt.git SilenceBlog/themes/LoveIt 将主题添加到站点的配置文件中： echo theme = \\\"LoveIt\\\" \u003e\u003e config.toml 查看主题官方文档，并根据自己的情况进行配置 信息 LoveIt主题说明、主题文档相关配置介绍 ","date":"2020-02-07","objectID":"/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%80%9A%E8%BF%87github/:2:3","tags":["Hugo","博客"],"title":"使用Hugo搭建自己的博客并通过GitHub Pages部署","uri":"/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%80%9A%E8%BF%87github/"},{"categories":["Hugo"],"content":"添加一篇文章并在本地查看效果 可以在content/posts/下手动创建一个Markdown文件，但是需要我们手动输入所有内容。也可以直接通过new命令来创建文章，创建好的文章已经存在相应的模板内容 hugo new posts/firstpost.md 输入完后会提是我们创建成功和文章所在的位置 接下来可以打开这个文件进行编辑，当我们编辑完毕保存退出后，可以启动Hugo服务器查看效果 hugo server -D 启动后我们可以看到，本次启动的一些信息 在浏览器中打开http://localhost:1313/即可查看效果，并且效果是实时更新的，会随着对站点博客的操作自动更新相应的效果 最后当我们完成博客内容想对博客部署的时候可以通过hugo命令进行建立静态页面 hugo -d 文件路径 提示 默认情况下会保存在./public/目录中 信息 更详细的内容可以查看Hugo官方文档 ","date":"2020-02-07","objectID":"/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%80%9A%E8%BF%87github/:2:4","tags":["Hugo","博客"],"title":"使用Hugo搭建自己的博客并通过GitHub Pages部署","uri":"/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%80%9A%E8%BF%87github/"},{"categories":["Hugo"],"content":"通过GitHub Pages部署 ","date":"2020-02-07","objectID":"/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%80%9A%E8%BF%87github/:3:0","tags":["Hugo","博客"],"title":"使用Hugo搭建自己的博客并通过GitHub Pages部署","uri":"/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%80%9A%E8%BF%87github/"},{"categories":["Hugo"],"content":"什么是GitHub Pages GitHub Pages 是一种静态网站托管服务，它可以直接从 GitHub 上的仓库中获取 HTML、CSS 和 JavaScript 文件，并通过构建过程选择性地运行这些文件，然后发布一个网站。 上面我们通过hugo -D命令正是将站点生成一个静态网站，可以完美配合GitHub Pages进行部署 ","date":"2020-02-07","objectID":"/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%80%9A%E8%BF%87github/:3:1","tags":["Hugo","博客"],"title":"使用Hugo搭建自己的博客并通过GitHub Pages部署","uri":"/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%80%9A%E8%BF%87github/"},{"categories":["Hugo"],"content":"部署方式 1.首先我们要创建一个Github 仓库，仓库名必须是\u003cuser\u003e.github.io的形式，如果是组织则为\u003corganization\u003e.github.io。仓库的可见性必须是Public。 提示 用户名的大小写不会影响GitHub Pages的部署。例如我的仓库为：Silencehuliang/silencehuliang.github.io 2.接下来进入仓库的设置页对GitHub Pages进行配置，找到GitHub Pages所在的位置，按下图配置好分支和站点存放路径即可 3.配置完毕后，把仓库克隆下来，使用hugo -D 路径将站点生成的静态文件存放在配置文件中选择的路径下即可。最后将文件提交上去就可以打开对应域名进行查看了。 ","date":"2020-02-07","objectID":"/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%80%9A%E8%BF%87github/:3:2","tags":["Hugo","博客"],"title":"使用Hugo搭建自己的博客并通过GitHub Pages部署","uri":"/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%80%9A%E8%BF%87github/"},{"categories":["Hugo"],"content":"出现问题的解决方案 当我们将文件提交上去之后打开对应域名发现并没有我们想要的内容时可以通过查看提交记录查看错误原因，点击Deatils可以找到具体位置的具体错误 还可以在GitHub Pages的设置出找到错误原因 信息 更详细的内容可以查看Hugo官方部署文档或GitHub Pages入门教程文档 ","date":"2020-02-07","objectID":"/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%80%9A%E8%BF%87github/:3:3","tags":["Hugo","博客"],"title":"使用Hugo搭建自己的博客并通过GitHub Pages部署","uri":"/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%80%9A%E8%BF%87github/"},{"categories":["Python"],"content":"视图 ","date":"2020-02-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/:1:0","tags":["Python学习之路"],"title":"Python学习之路-MySQL进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"前言 对于复杂的查询，往往是有多个数据表进行关联查询而得到，如果数据库因为需求等原因发生了改变，为了保证查询出来的数据与之前相同，则需要在多个地方进行修改，维护起来非常麻烦。可以通过定义视图来解决 ","date":"2020-02-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/:1:1","tags":["Python学习之路"],"title":"Python学习之路-MySQL进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"简介 通俗的讲，视图就是一条SELECT语句执行后返回的结果集。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。视图是对若干张基本表的引用，一张虚表，查询语句执行的结果，不存储具体的数据（基本表数据发生了改变，视图也会跟着改变）；方便操作，特别是查询操作，减少复杂的SQL语句，增强可读性； ","date":"2020-02-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/:1:2","tags":["Python学习之路"],"title":"Python学习之路-MySQL进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"定义 建议以v_开头 create view 视图名称 as select语句; ","date":"2020-02-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/:1:3","tags":["Python学习之路"],"title":"Python学习之路-MySQL进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"查看 查看表会将所有的视图也列出来 show tables; ","date":"2020-02-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/:1:4","tags":["Python学习之路"],"title":"Python学习之路-MySQL进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"使用 视图的用途就是查询 select * from v_stu_score; ","date":"2020-02-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/:1:5","tags":["Python学习之路"],"title":"Python学习之路-MySQL进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"删除 drop view 视图名称; 例： drop view v_stu_sco; ","date":"2020-02-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/:1:6","tags":["Python学习之路"],"title":"Python学习之路-MySQL进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"作用 提高了重用性，就像一个函数 对数据库重构，却不影响程序的运行 提高了安全性能，可以对不同的用户 让数据更加清晰 ","date":"2020-02-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/:1:7","tags":["Python学习之路"],"title":"Python学习之路-MySQL进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"事务 ","date":"2020-02-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/:2:0","tags":["Python学习之路"],"title":"Python学习之路-MySQL进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"前言 事务广泛的运用于订单系统、银行系统等多种场景。 ","date":"2020-02-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/:2:1","tags":["Python学习之路"],"title":"Python学习之路-MySQL进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"简介 所谓事务,它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。 ","date":"2020-02-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/:2:2","tags":["Python学习之路"],"title":"Python学习之路-MySQL进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"四大特性(ACID) 原子性(Atomicity)：一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性 一致性(Consistency)：数据库总是从一个一致性的状态转换到另一个一致性的状态。（在前面的例子中，一致性确保了，即使在执行第三、四条语句之间时系统崩溃，支票账户中也不会损失200美元，因为事务最终没有提交，所以事务中所做的修改也不会保存到数据库中。） 隔离性(Isolation)：通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的。（在前面的例子中，当执行完第三条语句、第四条语句还未开始时，此时有另外的一个账户汇总程序开始运行，则其看到支票帐户的余额并没有被减去200美元。） 持久性(Durability)：一旦事务提交，则其所做的修改会永久保存到数据库。（此时即使系统崩溃，修改的数据也不会丢失。） ","date":"2020-02-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/:2:3","tags":["Python学习之路"],"title":"Python学习之路-MySQL进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"命令 表的引擎类型必须是innodb类型才可以使用事务，这是mysql表的默认引擎，查看表的创建语句，可以看到engine=innodb -- 选择数据库 use jing_dong; -- 查看goods表 show create table goods; 开启事务 开启事务后执行修改命令，变更会维护到本地缓存中，而不维护到物理表中，命令如下： begin; 或者 start transaction; 提交事务 将缓存中的数据变更维护到物理表中，命令如下 commit; 回滚事务 放弃缓存中变更的数据，命令如下： rollback; 注意 修改数据的命令会自动的触发事务，包括insert、update、delete 而在SQL语句中有手动开启事务的原因是：可以进行多次数据的修改，如果成功一起成功，否则一起会滚到之前的数据 ","date":"2020-02-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/:2:4","tags":["Python学习之路"],"title":"Python学习之路-MySQL进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"索引 ","date":"2020-02-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/:3:0","tags":["Python学习之路"],"title":"Python学习之路-MySQL进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"前言 一般的应用系统对比数据库的读写比例在10:1左右(即有10次查询操作时有1次写的操作)，而且插入操作和更新操作很少出现性能问题，遇到最多、最容易出问题还是一些复杂的查询操作，所以查询语句的优化显然是重中之重。当数据库中数据量很大时，查找数据会变得很慢，可以通过创建索引的方式进行优化。 ","date":"2020-02-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/:3:1","tags":["Python学习之路"],"title":"Python学习之路-MySQL进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"简介 索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。更通俗的说，数据库索引好比是一本书前面的目录，能加快数据库的查询速度。 ","date":"2020-02-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/:3:2","tags":["Python学习之路"],"title":"Python学习之路-MySQL进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"目的 索引的目的在于提高查询效率，可以类比字典，如果要查“mysql”这个单词，我们肯定需要定位到m字母，然后从下往下找到y字母，再找到剩下的sql。如果没有索引，那么你可能需要把所有单词看一遍才能找到你想要的，如果我想找到m开头的单词呢？或者ze开头的单词呢？是不是觉得如果没有索引，这个事情根本无法完成？ ","date":"2020-02-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/:3:3","tags":["Python学习之路"],"title":"Python学习之路-MySQL进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"原理 除了词典，生活中随处可见索引的例子，如火车站的车次表、图书的目录等。它们的原理都是一样的，通过不断的缩小想要获得数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，也就是我们总是通过同一种查找方式来锁定数据。数据库也是一样，但显然要复杂许多，因为不仅面临着等值查询，还有范围查询(\u003e、\u003c、between、in)、模糊查询(like)、并集查询(or)等等。数据库应该选择怎么样的方式来应对所有的问题呢？我们回想字典的例子，能不能把数据分成段，然后分段查询呢？最简单的如果1000条数据，1到100分成第一段，101到200分成第二段，201到300分成第三段……这样查第250条数据，只要找第三段就可以了，一下子去除了90%的无效数据。 ","date":"2020-02-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/:3:4","tags":["Python学习之路"],"title":"Python学习之路-MySQL进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"使用 查看索引 show index from 表名; 创建索引 如果指定字段是字符串，需要指定长度，建议长度与定义字段时的长度一致，字段类型如果不是字符串，可以不填写长度部分 create index 索引名称 on 表名(字段名称(长度)) 删除索引 drop index 索引名称 on 表名; ","date":"2020-02-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/:3:5","tags":["Python学习之路"],"title":"Python学习之路-MySQL进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"注意： 要注意的是，建立太多的索引将会影响更新和插入的速度，因为它需要同样更新每个索引文件。对于一个经常需要更新和插入的表格，就没有必要为一个很少使用的where字句单独建立索引了，对于比较小的表，排序的开销不会很大，也没有必要建立另外的索引。建立索引会占用磁盘空间。 ","date":"2020-02-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/:3:6","tags":["Python学习之路"],"title":"Python学习之路-MySQL进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"账户管理 在生产环境下操作数据库时，绝对不可以使用root账户连接，而是创建特定的账户，授予这个账户特定的操作权限，然后连接进行操作，主要的操作就是数据的crud。MySQL账户体系：根据账户所具有的权限的不同，MySQL的账户可以分为以下几种： 服务实例级账号：，启动了一个mysqld，即为一个数据库实例；如果某用户如root,拥有服务实例级分配的权限，那么该账号就可以删除所有的数据库、连同这些库中的表 数据库级别账号：对特定数据库执行增删改查的所有操作 数据表级别账号：对特定表执行增删改查等所有操作 字段级别的权限：对某些表的特定字段进行操作 存储程序级别的账号：对存储程序进行增删改查的操作 账户的操作主要包括创建账户、删除账户、修改密码、授权权限等 注意： 进行账户操作时，需要使用root账户登录，这个账户拥有最高的实例级权限 通常都使用数据库级操作权限 ","date":"2020-02-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/:4:0","tags":["Python学习之路"],"title":"Python学习之路-MySQL进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"授予权限 需要使用实例级账户登录后操作，以root为例 主要操作包括： 查看所有用户 修改密码 删除用户 查看所有用户 所有用户及权限信息存储在mysql数据库的user表中 查看user表的结构 desc user; 主要字段说明： Host表示允许访问的主机 User表示用户名 authentication_string表示密码，为加密后的值 查看所有用户 select host,user,authentication_string from user; 创建账户、授权 需要使用实例级账户登录后操作，以root为例 常用权限主要包括：create、alter、drop、insert、update、delete、select 如果分配所有权限，可以使用all privileges grant 权限列表 on 数据库 to '用户名'@'访问主机' identified by '密码'; 修改权限 grant 权限名称 on 数据库 to 账户@主机 with grant option; 修改密码 使用root登录，修改mysql数据库的user表，使用password()函数进行密码加密 update user set authentication_string=password('新密码') where user='用户名'; 注意修改完成后需要刷新权限 刷新权限：flush privileges 远程登录（危险慎用） 如果向在一个Ubuntu中使用msyql命令远程连接另外一台mysql服务器的话，通过以下方式即可完成，但是此方法仅仅了解就好了，不要在实际生产环境中使用，修改 /etc/mysql/mysql.conf.d/mysqld.cnf 文件把bind-address = 127.0.0.1注释掉，然后重启msyql service mysql restart 如果依然连不上，可能原因： 1)网络不通：通过 ping xxx.xxx.xx.xxx可以发现网络是否正常 2)查看数据库是否配置了bind_address参数：本地登录数据库查看my.cnf文件和数据库当前参数show variables like ‘bind_address’；如果设置了bind_address=127.0.0.1 那么只能本地登录 3)查看数据库是否设置了skip_networking参数：如果设置了该参数，那么只能本地登录mysql数据库 4)端口指定是否正确 删除账户 使用root登录 drop user '用户名'@'主机'; 使用root登录，删除mysql数据库的user表中数据 delete from user where user='用户名'; 推荐使用第一种删除用户, 如果使用第一种删除失败，采用第二种方式 ","date":"2020-02-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/:4:1","tags":["Python学习之路"],"title":"Python学习之路-MySQL进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"主从同步 ","date":"2020-02-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/:5:0","tags":["Python学习之路"],"title":"Python学习之路-MySQL进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"简介 主从同步使得数据可以从一个数据库服务器复制到其他服务器上，在复制数据时，一个服务器充当主服务器（master），其余的服务器充当从服务器（slave）。因为复制是异步进行的，所以从服务器不需要一直连接着主服务器，从服务器甚至可以通过拨号断断续续地连接主服务器。通过配置文件，可以指定复制所有的数据库，某个数据库，甚至是某个数据库上的某个表。 ","date":"2020-02-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/:5:1","tags":["Python学习之路"],"title":"Python学习之路-MySQL进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"好处 通过增加从服务器来提高数据库的性能，在主服务器上执行写入和更新，在从服务器上向外提供读功能，可以动态地调整从服务器的数量，从而调整整个数据库的性能。 提高数据安全，因为数据已复制到从服务器，从服务器可以终止复制进程，所以，可以在从服务器上备份而不破坏主服务器相应数据 在主服务器上生成实时数据，而在从服务器上分析这些数据，从而提高主服务器的性能 ","date":"2020-02-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/:5:2","tags":["Python学习之路"],"title":"Python学习之路-MySQL进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"机制 Mysql服务器之间的主从同步是基于二进制日志机制，主服务器使用二进制日志来记录数据库的变动情况，从服务器通过读取和执行该日志文件来保持和主服务器的数据一致。 在使用二进制日志时，主服务器的所有操作都会被记录下来，然后从服务器会接收到该日志的一个副本。从服务器可以指定执行该日志中的哪一类事件（譬如只插入数据或者只更新数据），默认会执行日志中的所有语句。 每一个从服务器会记录关于二进制日志的信息：文件名和已经处理过的语句，这样意味着不同的从服务器可以分别执行同一个二进制日志的不同部分，并且从服务器可以随时连接或者中断和服务器的连接。 主服务器和每一个从服务器都必须配置一个唯一的ID号（在my.cnf文件的[mysqld]模块下有一个server-id配置项），另外，每一个从服务器还需要通过CHANGE MASTER TO语句来配置它要连接的主服务器的ip地址，日志文件名称和该日志里面的位置（这些信息存储在主服务器的数据库里） ","date":"2020-02-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/:5:3","tags":["Python学习之路"],"title":"Python学习之路-MySQL进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"基本步骤 有很多种配置主从同步的方法，可以总结为如下的步骤： 在主服务器上，必须开启二进制日志机制和配置一个独立的ID 在每一个从服务器上，配置一个唯一的ID，创建一个用来专门复制主服务器数据的账号 在开始复制进程前，在主服务器上记录二进制文件的位置信息 如果在开始复制之前，数据库中已经有数据，就必须先创建一个数据快照（可以使用mysqldump导出数据库，或者直接复制数据文件） 配置从服务器要连接的主服务器的IP地址和登陆授权，二进制日志文件名和位置 ","date":"2020-02-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/:5:4","tags":["Python学习之路"],"title":"Python学习之路-MySQL进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"详细配置 主和从的身份可以自己指定，我们将虚拟机Ubuntu中MySQL作为主服务器，将Windows中的MySQL作为从服务器。 在主从设置前，要保证Ubuntu与Windows间的网络连通。 备份主服务器原有数据到从服务器 如果在设置主从同步前，主服务器上已有大量数据，可以使用mysqldump进行数据备份并还原到从服务器以实现数据的复制。 在主服务器Ubuntu上进行备份，执行命令： mysqldump -uroot -pmysql --all-databases --lock-all-tables \u003e ~/master_db.sql 说明： -u ：用户名 -p ：示密码 –all-databases ：导出所有数据库 –lock-all-tables ：执行操作时锁住所有表，防止操作时有数据修改 ~/master_db.sql :导出的备份数据（sql文件）位置，可自己指定 数据还原 在从服务器命令行中执行还原操作: mysql –uroot –pmysql \u003c master_db.sql 配置主服务器master 编辑设置mysqld的配置文件，设置log_bin和server-id sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf 重启mysql服务 sudo service mysql restart 登入主服务器Ubuntu中的mysql，创建用于从服务器同步数据使用的帐号 mysql –uroot –pmysql GRANT REPLICATION SLAVE ON *.* TO 'slave'@'%' identified by 'slave'; FLUSH PRIVILEGES; 获取主服务器的二进制日志信息 SHOW MASTER STATUS; File为使用的日志文件名字，Position为使用的文件位置，这两个参数须记下，配置从服务器时会用到 配置从服务器slave 编辑从服务器配置文件将server-id修改为2，并保存退出 重启MySQL服务 service mysql restart 设置连接到master主服务器 change master to master_host='10.211.55.5', master_user='slave', master_password='slave',master_log_file='mysql-bin.000006', master_log_pos=590; 注： master_host：主服务器Ubuntu的ip地址 master_log_file: 前面查询到的主服务器日志文件名 master_log_pos: 前面查询到的主服务器日志文件位置 开启同步，查看同步状态 start slave; show slave status ; 测试主从同步 在主服务器创建一个数据库，在从服务器中查看新建的数据库是否存在 ","date":"2020-02-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/:5:5","tags":["Python学习之路"],"title":"Python学习之路-MySQL进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-mysql%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"简介 ","date":"2020-02-02","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-python%E6%93%8D%E4%BD%9Cmysql/:1:0","tags":["Python学习之路"],"title":"Python学习之路-Python操作MySQL","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-python%E6%93%8D%E4%BD%9Cmysql/"},{"categories":["Python"],"content":"PyMySQL PyMySQL是在 Python3.x 版本中用于连接MySQL服务器的一个库，PyMySQL遵循Python数据库 API v2.0 规范，并包含了 pure-Python MySQL 客户端库。 ","date":"2020-02-02","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-python%E6%93%8D%E4%BD%9Cmysql/:2:0","tags":["Python学习之路"],"title":"Python学习之路-Python操作MySQL","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-python%E6%93%8D%E4%BD%9Cmysql/"},{"categories":["Python"],"content":"安装 pip install pymsql ","date":"2020-02-02","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-python%E6%93%8D%E4%BD%9Cmysql/:2:1","tags":["Python学习之路"],"title":"Python学习之路-Python操作MySQL","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-python%E6%93%8D%E4%BD%9Cmysql/"},{"categories":["Python"],"content":"连接 通过Connection对象与数据库建立连接 from pymysql import connect conn=connect(参数列表) 参数host：连接的MySQL主机，如果本机是localhost 参数port：连接的MySQL主机的端口，默认是3306 参数database：数据库的名称 参数user：连接的用户名 参数password：连接的密码 参数charset：通信采用的编码方式，推荐使用utf8 对象的方法 close()：关闭连接 commit()：提交 cursor()：返回Cursor对象，用于执行SQL语句并获得结果 ","date":"2020-02-02","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-python%E6%93%8D%E4%BD%9Cmysql/:2:2","tags":["Python学习之路"],"title":"Python学习之路-Python操作MySQL","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-python%E6%93%8D%E4%BD%9Cmysql/"},{"categories":["Python"],"content":"执行sql语句 通过Cursor对象的execute()方法执行sql语句，调用Connection对象的cursor()方法获取Cursor对象 cs=conn.cursor() cs.execute(\"SQL语句\") 对象的方法 close()：关闭 execute(operation [, parameters ])：执行语句，返回受影响的行数，主要用于执行insert、update、delete语句，也可以执行create、alter、drop等语句 fetchone()：执行查询语句时，获取查询结果集的第一个行数据，返回一个元组 fetchall()：执行查询时，获取结果集的所有行，一行构成一个元组，再将这些元组装入一个元组返回 对象的属性 rowcount只读属性，表示最近一次execute()执行后受影响的行数 connection获得当前连接对象 ","date":"2020-02-02","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-python%E6%93%8D%E4%BD%9Cmysql/:2:3","tags":["Python学习之路"],"title":"Python学习之路-Python操作MySQL","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-python%E6%93%8D%E4%BD%9Cmysql/"},{"categories":["Python"],"content":"SQL注入 sql语句的参数化，可以有效防止sql注入 ","date":"2020-02-02","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-python%E6%93%8D%E4%BD%9Cmysql/:2:4","tags":["Python学习之路"],"title":"Python学习之路-Python操作MySQL","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-python%E6%93%8D%E4%BD%9Cmysql/"},{"categories":["Python"],"content":"简介 数据库就是一种特殊的文件，其中存储着需要的数据。 ","date":"2020-01-31","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/:1:0","tags":["Python学习之路"],"title":"Python学习之路-数据库入门","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/"},{"categories":["Python"],"content":"类型 当前主要使用两种类型的数据库：关系型数据库、非关系型数据库，本篇主要讨论关系型数据库，对于非关系型数据库会在后面学习。所谓的关系型数据库RDBMS，是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。 关系型数据库的主要产品： oracle：在以前的大型项目中使用,银行,电信等项目 mysql：web时代使用最广泛的关系型数据库 ms sql server：在微软的项目中使用 sqlite：轻量级数据库，主要应用在移动平台 ","date":"2020-01-31","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/:2:0","tags":["Python学习之路"],"title":"Python学习之路-数据库入门","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/"},{"categories":["Python"],"content":"RDBMS和数据库的关系 图片取材于布布扣，更详细的内容可以参考其博客 ","date":"2020-01-31","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/:3:0","tags":["Python学习之路"],"title":"Python学习之路-数据库入门","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/"},{"categories":["Python"],"content":"SQL SQL(Structured Query Language)是结构化查询语言，是一种用来操作RDBMS的数据库语言，当前关系型数据库都支持使用SQL语言进行操作，也就是说可以通过 SQL 操作oracle，sql，server，mysql，sqlite 等等所有的关系型的数据库。 SQL语句主要分为： DQL：数据查询语言，用于对数据进行查询，如select DML：数据操作语言，对数据进行增加、修改、删除，如insert、udpate、delete TPL：事务处理语言，对事务进行处理，包括begin transaction、commit、rollback DCL：数据控制语言，进行授权与权限回收，如grant、revoke DDL：数据定义语言，进行数据库、表的管理等，如create、drop CCL：指针控制语言，通过控制指针完成表的操作，如declare cursor 提示 SQL 是一门特殊的语言,专门用来操作关系数据库。不区分大小写 ","date":"2020-01-31","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/:4:0","tags":["Python学习之路"],"title":"Python学习之路-数据库入门","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/"},{"categories":["Python"],"content":"MySQL ","date":"2020-01-31","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/:5:0","tags":["Python学习之路"],"title":"Python学习之路-数据库入门","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/"},{"categories":["Python"],"content":"简介 MySQL是一个关系型数据库管理系统，由瑞典MySQL AB公司开发，后来被Sun公司收购，Sun公司后来又被Oracle公司收购，目前属于Oracle旗下产品。MySQL官方网站 ","date":"2020-01-31","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/:5:1","tags":["Python学习之路"],"title":"Python学习之路-数据库入门","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/"},{"categories":["Python"],"content":"特点 使用C和C++编写，并使用了多种编译器进行测试，保证源代码的可移植性 支持多种操作系统，如Linux、Windows、AIX、FreeBSD、HP-UX、MacOS、NovellNetware、OpenBSD、OS/2 Wrap、Solaris等 为多种编程语言提供了API，如C、C++、Python、Java、Perl、PHP、Eiffel、Ruby等 支持多线程，充分利用CPU资源 优化的SQL查询算法，有效地提高查询速度 提供多语言支持，常见的编码如GB2312、BIG5、UTF8 提供TCP/IP、ODBC和JDBC等多种数据库连接途径 提供用于管理、检查、优化数据库操作的管理工具 大型的数据库。可以处理拥有上千万条记录的大型数据库 支持多种存储引擎 MySQL 软件采用了双授权政策，它分为社区版和商业版，由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，一般中小型网站的开发都选择MySQL作为网站数据库 MySQL使用标准的SQL数据语言形式 Mysql是可以定制的，采用了GPL协议，你可以修改源码来开发自己的Mysql系统 在线DDL更改功能 复制全局事务标识 复制无崩溃从机 复制多线程从机 提示 开源、免费、不要钱、使用范围广，跨平台支持性好，提供了多种语言调用的API，是学习数据库开发的首选 ","date":"2020-01-31","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/:5:2","tags":["Python学习之路"],"title":"Python学习之路-数据库入门","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/"},{"categories":["Python"],"content":"安装与配置 安装服务器端 在终端中输入如下命令，回车后，然后按照提示输入 sudo apt-get install mysql-server 启动服务 sudo service mysql start 查看进程中是否存在mysql服务 ps ajx|grep mysql 停止服务 sudo service mysql stop 重启服务 sudo service mysql restart 配置 配置文件目录为/etc/mysql/mysql.cnf 主要配置项如下： bind-address表示服务器绑定的ip，默认为127.0.0.1 port表示端口，默认为3306 datadir表示数据库目录，默认为/var/lib/mysql general_log_file表示普通日志，默认为/var/log/mysql/mysql.log log_error表示错误日志，默认为/var/log/mysql/error.log 安装客户端 在终端运行如下命令，按提示填写信息 sudo apt-get install mysql-client 详细连接的命令可以查看帮助文档 mysql --help ","date":"2020-01-31","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/:5:3","tags":["Python学习之路"],"title":"Python学习之路-数据库入门","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/"},{"categories":["Python"],"content":"数据完整性 一个数据库就是一个完整的业务单元，可以包含多张表，数据被存储在表中。在表中为了更加准确的存储数据，保证数据的正确有效，可以在创建表的时候，为表添加一些强制性的验证，包括数据字段的类型、约束 数据类型 可以通过查看帮助文档查阅所有支持的数据类型 使用数据类型的原则是：够用就行，尽量使用取值范围小的，而不用大的，这样可以更多的节省存储空间 常用数据类型如下： 整数：int，bit 小数：decimal 字符串：varchar,char 日期时间: date, time, datetime 枚举类型(enum) 特别说明的类型如下： decimal表示浮点数，如decimal(5,2)表示共存5位数，小数占2位 char表示固定长度的字符串，如char(3)，如果填充’ab’时会补一个空格为'ab ' varchar表示可变长度的字符串，如varchar(3)，填充’ab’时就会存储’ab’ 字符串text表示存储大文本，当字符大于4000时推荐使用 对于图片、音频、视频等文件，不存储在数据库中，而是上传到某个服务器上，然后在表中存储这个文件的保存路径 更全的数据类型可以参考http://blog.csdn.net/anxpp/article/details/51284106 约束 主键primary key：物理上存储的顺序 非空not null：此字段不允许填写空值 惟一unique：此字段的值不允许重复 默认default：当不填写此值时会使用默认值，如果填写时以填写为准 外键foreign key：对关系字段进行约束，当为关系字段填写值时，会到关联的表中查询此值是否存在，如果存在则填写成功，如果不存在则填写失败并抛出异常 说明：虽然外键约束可以保证数据的有效性，但是在进行数据的crud（增加、修改、删除、查询）时，都会降低数据库的性能，所以不推荐使用，那么数据的有效性怎么保证呢？答：可以在逻辑层进行控制 数值类型(常用) 类型 字节大小 有符号范围(Signed) 无符号范围(Unsigned) TINYINT 1 -128 ~ 127 0 ~ 255 SMALLINT 2 -32768 ~ 32767 0 ~ 65535 MEDIUMINT 3 -8388608 ~ 8388607 0 ~ 16777215 INT/INTEGER 4 -2147483648 ~2147483647 0 ~ 4294967295 BIGINT 8 -9223372036854775808 ~ 9223372036854775807 0 ~ 18446744073709551615 字符串 类型 字节大小 示例 CHAR 0-255 类型:char(3) 输入 ‘ab’, 实际存储为’ab ‘, 输入’abcd’ 实际存储为 ‘abc’ VARCHAR 0-255 类型:varchar(3) 输 ‘ab’,实际存储为’ab’, 输入’abcd’,实际存储为’abc’ TEXT 0-65535 大文本 日期时间类型 类型 字节大小 示例 DATE 4 ‘2020-01-01’ TIME 3 ‘12:29:59’ DATETIME 8 ‘2020-01-01 12:29:59’ YEAR 1 ‘2017’ TIMESTAMP 4 ‘1970-01-01 00:00:01’ UTC ~ ‘2038-01-01 00:00:01’ UTC ","date":"2020-01-31","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/:5:4","tags":["Python学习之路"],"title":"Python学习之路-数据库入门","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/"},{"categories":["Python"],"content":"命令行脚本 登陆与退出 最基本的连接命令如下，输入后回车 mysql -u root -p # 回车后输入密码 退出 quit 或者 exit 或 ctrl+d 登录成功后，输入如下命令查看效果 查看版本：select version(); 显示当前时间：select now(); 数据库相关操作 查看所有数据库 show databases; 使用数据库 use 数据库名; 查看当前使用的数据库 select database(); 创建数据库 create database 数据库名 charset=utf8; 删除数据库 drop database 数据库名; 数据表相关操作 查看当前数据库中所有表 show tables; 查看表结构 desc 表名; 创建表 提示 auto_increment表示自动增长 CREATE TABLE table_name( column1 datatype contrai, column2 datatype, column3 datatype, ..... columnN datatype, PRIMARY KEY(one or more columns) ); 提示 auto_increment表示自动增长 修改表-添加字段 alter table 表名 add 列名 类型; 修改表-修改字段：重命名版 alter table 表名 change 原名 新名 类型及约束; 修改表-修改字段：不重命名版 alter table 表名 modify 列名 类型及约束; 修改表-删除字段 alter table 表名 drop 列名; 删除表 drop table 表名; 查看表的创建语句 show create table 表名; 增删改查 查询 查询所有列 select * from 表名; 查询指定列 select 列1,列2,... from 表名; 提示 可以使用as为列或表指定别名 条件查询 使用where子句对表中的数据筛选，结果为true的行会出现在结果集中，语法如下： select * from 表名 where 条件; where后面支持多种运算符，进行条件的处理：比较运算符、逻辑运算符、模糊查询、范围查询、空判断 模糊查询 like %表示任意多个任意字符 _表示一个任意字符 select * from 表名 where 条件 like '模糊查询字符%'; 范围查询 select * from 表名 where 条件 in('范围查询'); 提示 in表示在一个非连续的范围内 空判断 select * from 表名 where 条件 is null; 提示 null与'‘是不同的，判空is null 优先级 优先级由高到低的顺序为：小括号，not，比较运算符，逻辑运算符，and比or先运算，如果同时出现并希望先算or，需要结合()使用。 增加 全列插入：值的顺序与表中字段的顺序对应 insert into 表名 values(...) 提示 说明：主键列是自动增长，但是在全列插入时需要占位，通常使用0或者 default 或者 null 来占位，插入成功后以实际数据为准 部分列插入：值的顺序与给出的列顺序对应 insert into 表名(列1,...) values(值1,...) 全列多行插入：值的顺序与给出的列顺序对应 insert into 表名 values(...),(...)...; 或 insert into 表名(列1,...) values(值1,...),(值1,...)...; 提示 上面的语句一次可以向表中插入一行数据，还可以一次性插入多行数据，这样可以减少与数据库的通信 修改 update 表名 set 列1=值1,列2=值2... where 条件 删除 delete from 表名 where 条件 逻辑删除，本质就是修改操作 update 表名 set isdelete=1 where 条件; 排序 为了方便查看数据，可以对数据进行排序，语法如下： select * from 表名 order by 列1 asc|desc [,列2 asc|desc,...] 行数据按照列1进行排序，如果某些行列1的值相同时，则按照列2排序，以此类推。默认按照列值从小到大排列。asc从小到大排列，即升序。desc从大到小排序，即降序。 聚合函数 为了快速得到统计数据，经常会用到如下5个聚合函数 总数 count(*)表示计算总行数，括号中写星与列名，结果是相同的 select count(*) from 表名; 最大值 max(列)表示求此列的最大值 select max(列) from 表名 where 条件; 最小值 min(列)表示求此列的最小值 select min(列) from 表名 where 条件; 求和 sum(列)表示求此列的和 select sum(列) from 表名 where 条件; 平均值 avg(列)表示求此列的平均值 select avg(列) from 表名 where 条件; 分组 group by，将查询结果按照1个或多个字段进行分组，字段值相同的为一组。可用于单个字段分组，也可用于多个字段分组 group by + group_concat() group_concat(字段名)可以作为一个输出字段来使用，表示分组之后，根据分组结果，使用group_concat()来放置每一组的某字段的值的集合 group by + 集合函数 通过group_concat()的启发，我们既然可以统计出每个分组的某字段的值的集合，那么我们也可以通过集合函数来对这个值的集合做一些操作 group by + having having 条件表达式：用来分组查询后指定一些条件来输出查询结果。having作用和where一样，但having只能用于group by group by + with rollup with rollup的作用是：在最后新增一行，来记录当前列里所有记录的总和 分页 当数据量过大时，在一页中查看数据是一件非常麻烦的事情，可以通过分行来解决，语法如下： select * from 表名 limit start,count 从start开始，获取count条数据 连接查询 当查询结果的列来源于多张表时，需要将多张表连接成一个大的数据集，再选择合适的列返回，mysql支持三种类型的连接查询，分别为： 内连接查询：查询的结果为两个表匹配到的数据 右连接查询：查询的结果为两个表匹配到的数据，右表特有的数据，对于左表中不存在的数据使用null填充 左连接查询：查询的结果为两个表匹配到的数据，左表特有的数据，对于右表中不存在的数据使用null填充 语法如下： select * from 表1 inner或left或right join 表2 on 表1.列 = 表2.列 子查询 在一个 select 语句中,嵌入了另外一个 select 语句, 那么被嵌入的 select 语句称之为子查询语句 主查询和子查询的关系 子查询是嵌入到主查询中；子查询是辅助主查询的,要么充当条件,要么充当数据源；子查询是可以独立存在的语句,是一条完整的 select 语句 子查询分类 标量子查询: 子查询返回的结果是一个数据(一行一列) 列子查询: 返回的结果是一列(一列多行) 行子查询: 返回的结果是一行(一行多列) 子查询中特定关键字使用 in 范围 格式: 主查询 where 条件 in (列子查询) 备份 运行mysqldump命令 mysqldump –uroot –p 数据库名 \u003e python.sql; # 按提示输入mysql的密码 恢复 连接mysql，创建新的数据库，退出连接，执行如下命令 mysql -uroot –p 新数据库名 \u003c python.sql # 根据提示输入mysql密码 ","date":"2020-01-31","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/:5:5","tags":["Python学习之路"],"title":"Python学习之路-数据库入门","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/"},{"categories":["Python"],"content":"数据库设计 关系型数据库建议在E-R模型的基础上，需要根据产品经理的设计策划，抽取出来模型与关系，制定出表结构，这是项目开始的第一步。在开发中有很多设计数据库的软件，常用的如power designer，db desinger等，这些软件可以直观的看到实体及实体间的关系。设计数据库，可能是由专门的数据库设计人员完成，也可能是由开发组成员完成，一般是项目经理带领组员来完成。 三范式 经过研究和对使用中问题的总结，对于设计数据库提出了一些规范，这些规范被称为范式(Normal Form)。目前有迹可寻的共有8种范式，一般需要遵守3范式即可： 第一范式（1NF）：强调的是列的原子性，即列不能够再分成其他几列。 第二范式（2NF）：首先是 1NF，另外包含两部分内容，一是表必须有一个主键；二是没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分。 第三范式（3NF）：首先是 2NF，另外非主键列必须直接依赖于主键，不能存在传递依赖。即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。 E-R模型 E表示entry，实体，设计实体就像定义一个类一样，指定从哪些方面描述对象，一个实体转换为数据库中的一个表 R表示relationship，关系，关系描述两个实体之间的对应规则，关系的类型包括包括一对一、一对多、多对多 关系也是一种数据，需要通过一个字段存储在表中 实体A对实体B为1对1，则在表A或表B中创建一个字段，存储另一个表的主键值 实体A对实体B为1对多：在表B中创建一个字段，存储表A的主键值 实体A对实体B为多对多：新建一张表C，这个表只有两个字段，一个用于存储A的主键值，一个用于存储B的主键值 逻辑删除 对于重要数据，并不希望物理删除，一旦删除，数据无法找回 删除方案：设置isDelete的列，类型为bit，表示逻辑删除，默认值为0 对于非重要数据，可以进行物理删除 数据的重要性，要根据实际开发决定 ","date":"2020-01-31","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/:5:6","tags":["Python学习之路"],"title":"Python学习之路-数据库入门","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/"},{"categories":["Python"],"content":"简介 正则表达式是计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些匹配某个模式的文本。 ","date":"2020-01-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:1:0","tags":["Python学习之路"],"title":"Python学习之路-正则表达式","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["Python"],"content":"RE模块 在Python中需要通过正则表达式对字符串进行匹配的时候，可以使用一个模块：re ","date":"2020-01-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:2:0","tags":["Python学习之路"],"title":"Python学习之路-正则表达式","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["Python"],"content":"语法 # 导入re模块 import re # 使用match方法进行匹配操作 result = re.match(\"正则表达式要匹配的字符串\") # 如果上一步匹配到数据的话，可以使用group方法来提取数据 result.group() re.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。 ","date":"2020-01-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:2:1","tags":["Python学习之路"],"title":"Python学习之路-正则表达式","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["Python"],"content":"正则表达式 单字符匹配 字符 功能 . 匹配任意1个字符（除了\\n） [ ] 匹配[ ]中列举的字符 \\d 匹配数字，即0-9 \\D 匹配非数字，即不是数字 \\s 匹配空白，即 空格，tab键 \\S 匹配非空白 \\w 匹配单词字符，即a-z、A-Z、0-9、_ \\W 匹配非单词字符 多个字符匹配 字符 功能 * 匹配前一个字符出现0次或者无限次，即可有可无 + 匹配前一个字符出现1次或者无限次，即至少有1次 ? 匹配前一个字符出现1次或者0次，即要么有1次，要么没有 {m} 匹配前一个字符出现m次 {m,n} 匹配前一个字符出现从m到n次 开头结尾匹配 字符 功能 ^ 匹配字符串开头 $ 匹配字符串结尾 分组匹配 字符 功能 | 匹配左右任意一个表达式 (ab) 将括号中字符作为一个分组 \\num 引用分组num匹配到的字符串 (?P\u003cname\u003e) 分组起别名 (?P=name) 引用别名为name分组匹配到的字符串 ","date":"2020-01-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:2:2","tags":["Python学习之路"],"title":"Python学习之路-正则表达式","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["Python"],"content":"高级用法 search re.search 扫描整个字符串并返回第一个成功的匹配。 语法 import re ret = re.search(r\"正则表达式\", \"正则表达式要匹配的字符串\") ret.group() match与search的区别 re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配。 findall 在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果没有找到匹配的，则返回空列表。 注意 match 和 search 是匹配一次 findall 匹配所有。 语法 import re ret = re.findall(r\"正则表达式\", \"正则表达式要匹配的字符串\") print(ret) sub 用于替换字符串中的匹配项。 语法 import re ret = re.sub(r\"正则表达式\", '替换的字符串', \"正则表达式要匹配的字符串\") print(ret) split 按照能够匹配的子串将字符串分割后返回列表 语法 import re ret = re.split(r\"正则表达式\",\"正则表达式要匹配的字符串\") print(ret) ","date":"2020-01-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:2:3","tags":["Python学习之路"],"title":"Python学习之路-正则表达式","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["Python"],"content":"贪婪和非贪婪 Python里数量词默认是贪婪的（在少数语言里也可能是默认非贪婪），总是尝试匹配尽可能多的字符；非贪婪则相反，总是尝试匹配尽可能少的字符。在”*”,”?”,“+”,\"{m,n}“后面加上？，使贪婪变成非贪婪。 正则表达式模式中使用到通配字，那它在从左到右的顺序求值时，会尽量“抓取”满足匹配最长字符串，在我们上面的例子里面，“.+”会从字符串的启始处抓取满足模式的最长字符，其中包括我们想得到的第一个整型字段的中的大部分，“\\d+”只需一位字符就可以匹配，所以它匹配了数字“4”，而“.+”则匹配了从字符串起始到这个第一位数字4之前的所有字符。 解决方式：非贪婪操作符“？”，这个操作符可以用在”*”,“+”,”?“的后面，要求正则匹配的越少越好。 ","date":"2020-01-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:2:4","tags":["Python学习之路"],"title":"Python学习之路-正则表达式","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["Python"],"content":"r的作用 Python中字符串前面加上 r 表示原生字符串，与大多数编程语言相同，正则表达式里使用\\作为转义字符，这就可能造成反斜杠困扰。假如你需要匹配文本中的字符\\，那么使用编程语言表示的正则表达式里将需要4个反斜杠\\：前两个和后两个分别用于在编程语言里转义成反斜杠，转换成两个反斜杠后再在正则表达式里转义成一个反斜杠。Python里的原生字符串很好地解决了这个问题，有了原生字符串，你再也不用担心是不是漏写了反斜杠，写出来的表达式也更直观。 ","date":"2020-01-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:2:5","tags":["Python学习之路"],"title":"Python学习之路-正则表达式","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["生活"],"content":"前言 没想到这次新冠这么严重，年都不能好好过了，还好家里备了很多吃的，应该还够坚持一周的吧，节约点吃吧。。。 ","date":"2020-01-25","objectID":"/%E6%96%B0%E5%86%A0%E6%84%9F%E6%83%B3/:1:0","tags":["新冠"],"title":"新冠感想","uri":"/%E6%96%B0%E5%86%A0%E6%84%9F%E6%83%B3/"},{"categories":["生活"],"content":"感想 这次新冠最大的感触生命真的很珍贵，一个亲戚在武汉的某个医院上班，见过很多生离死别，她发过来的视频真的很震撼，第一次离我这么近。武汉那边水深火热，人心惶惶的，但看到那么多为新冠付出的人，我相信一切都会好起来的，这次对我们中华民族的打击可能会让我们停下前进的脚步，但绝不会击垮我们。我们有那么多可爱的人，上海第一时间就派出了援汉的医疗队，他们不惧死亡，只为拯救更多的中华儿女。有时候我也会向往米国的自由，但是假如他们受到这般打击，他们绝对会一塌糊涂，他们没有我们的凝聚力，国家不会放弃任何一个人。这几年来，我越来越感受到祖国的强大，各行各业也都有了起色，我相信我们这股凝聚力能让疫情早点恢复，可能还需要些时间，但都会好起来的，全国人民都跟我们一起共度难关。就想国庆看的电影我和我的祖国里那样，不管是大人物还是小人物，我们都在自己的岗位上努力，让祖国变得更好，我们有人民的军队和人民的医生，他们敢于在祖国人民身处危难的时候挺身而出，有他们的无私奉献，中国才能这么强大。 最后，希望大家都在坚持一下，在居家隔离一段时间，为医护人员减少点负担，一起加油💪 ","date":"2020-01-25","objectID":"/%E6%96%B0%E5%86%A0%E6%84%9F%E6%83%B3/:2:0","tags":["新冠"],"title":"新冠感想","uri":"/%E6%96%B0%E5%86%A0%E6%84%9F%E6%83%B3/"},{"categories":["生活"],"content":"前言 不知道该说我是幸运呢还是不幸，22号坐火车从上海回到武汉，转火车回黄石的时候差点没赶上火车，最后5分钟进的站，上车不到一分钟就开车了，晚上刚刚到家就听到武汉要封城的消息，结果第二天一醒来就听到真的封城的消息，要是没有赶上火车，可能我就回不来了。。。 ","date":"2020-01-22","objectID":"/%E6%AD%A6%E6%B1%89%E5%B0%81%E5%9F%8E%E4%BA%86/:1:0","tags":["武汉"],"title":"武汉封城了","uri":"/%E6%AD%A6%E6%B1%89%E5%B0%81%E5%9F%8E%E4%BA%86/"},{"categories":["生活"],"content":"感慨 现在还不清楚具体情况，不过听说黄石马上也要封城了，应该是比较严重了吧，未来还不知道会发生什么情况，希望这场风波能早点过去吧。武汉目前情况比较严重了，感染人数每天也在指数增长，希望能早点好起来吧。马上过年了，大家出门记得做好防护呀！一定要劝父母长辈们一起做好防护，他们都不当回事，现在武汉都封城了，说明问题的严重性了，一定一定要劝住他们，一起做好防护，保护好自己，保护你们的家人，咱们一起共度难关！干巴爹！ ","date":"2020-01-22","objectID":"/%E6%AD%A6%E6%B1%89%E5%B0%81%E5%9F%8E%E4%BA%86/:2:0","tags":["武汉"],"title":"武汉封城了","uri":"/%E6%AD%A6%E6%B1%89%E5%B0%81%E5%9F%8E%E4%BA%86/"},{"categories":["Python"],"content":"简介 协程，又称微线程，纤程。英文名Coroutine。协程是python个中另外一种实现多任务的方式，只不过比线程更小占用更小执行单元（理解为需要的资源）。 为啥说它是一个执行单元，因为它自带CPU上下文。这样只要在合适的时机， 我们可以把一个协程 切换到另一个协程。 只要这个过程中保存或恢复 CPU上下文那么程序还是可以运行的。 通俗的理解：在一个线程中的某个函数，可以在任何地方保存当前函数的一些临时变量等信息，然后切换到另外一个函数中执行，注意不是通过调用函数的方式做到的，并且切换的次数以及什么时候再切换到原来的函数都由开发者自己确定 ","date":"2020-01-18","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/:1:0","tags":["Python学习之路"],"title":"Python学习之路-多任务:协程","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/"},{"categories":["Python"],"content":"协程和线程差异 在实现多任务时, 线程切换从系统层面远不止保存和恢复 CPU上下文这么简单。 操作系统为了程序运行的高效性每个线程都有自己缓存Cache等等数据，操作系统还会帮你做这些数据的恢复操作。 所以线程的切换非常耗性能。但是协程的切换只是单纯的操作CPU的上下文，所以一秒钟切换个上百万次系统都抗的住。 ","date":"2020-01-18","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/:2:0","tags":["Python学习之路"],"title":"Python学习之路-多任务:协程","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/"},{"categories":["Python"],"content":"迭代 迭代是访问集合元素的一种方式。使用for…in…的循环语法从其中依次拿到数据进行使用，我们把这样的过程称为遍历，也叫迭代。 ","date":"2020-01-18","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/:3:0","tags":["Python学习之路"],"title":"Python学习之路-多任务:协程","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/"},{"categories":["Python"],"content":"迭代器 迭代器是一个可以记住遍历的位置的对象。迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。 ","date":"2020-01-18","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/:4:0","tags":["Python学习之路"],"title":"Python学习之路-多任务:协程","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/"},{"categories":["Python"],"content":"可迭代对象 把可以通过for…in…这类语句迭代读取一条数据供我们使用的对象称之为可迭代对象（Iterable）。可以使用 isinstance() 判断一个对象是否是可迭代对象 Iterable 对象。 ","date":"2020-01-18","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/:5:0","tags":["Python学习之路"],"title":"Python学习之路-多任务:协程","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/"},{"categories":["Python"],"content":"可迭代对象的本质 我们分析对可迭代对象进行迭代使用的过程，发现每迭代一次（即在for…in…中每循环一次）都会返回对象中的下一条数据，一直向后读取数据直到迭代了所有数据后结束。那么，在这个过程中就应该有一个“人”去记录每次访问到了第几条数据，以便每次迭代都可以返回下一条数据。我们把这个能帮助我们进行数据迭代的“人”称为迭代器(Iterator)。 可迭代对象的本质就是可以向我们提供一个这样的中间“人”即迭代器帮助我们对其进行迭代遍历使用。 可迭代对象通过__iter__方法向我们提供一个迭代器，我们在迭代一个可迭代对象的时候，实际上就是先获取该对象提供的一个迭代器，然后通过这个迭代器来依次获取对象中的每一个数据. 那么也就是说，一个具备了__iter__方法的对象，就是一个可迭代对象。 注意 可以通过iter()函数获取这些可迭代对象的迭代器(iter()函数实际上就是调用了可迭代对象的__iter__方法)，然后我们可以对获取到的迭代器不断使用next()函数来获取下一条数据(使用next()函数的时候，调用的就是迭代器对象的__next__方法)。当我们已经迭代完最后一个数据之后，再次调用next()函数会抛出StopIteration的异常，来告诉我们所有数据都已迭代完成，不用再执行next()函数了。 ","date":"2020-01-18","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/:5:1","tags":["Python学习之路"],"title":"Python学习之路-多任务:协程","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/"},{"categories":["Python"],"content":"for…in…循环的本质 for item in Iterable 循环的本质就是先通过iter()函数获取可迭代对象Iterable的迭代器，然后对获取到的迭代器不断调用next()方法来获取下一个值并将其赋值给item，当遇到StopIteration的异常后循环结束。 ","date":"2020-01-18","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/:5:2","tags":["Python学习之路"],"title":"Python学习之路-多任务:协程","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/"},{"categories":["Python"],"content":"生成器 ","date":"2020-01-18","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/:6:0","tags":["Python学习之路"],"title":"Python学习之路-多任务:协程","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/"},{"categories":["Python"],"content":"简介 生成器是一类特殊的迭代器。利用迭代器，我们可以在每次迭代获取数据（通过next()方法）时按照特定的规律进行生成。但是我们在实现一个迭代器时，关于当前迭代到的状态需要我们自己记录，进而才能根据当前状态生成下一个数据。为了达到记录当前状态，并配合next()函数进行迭代使用，我们可以采用更简便的语法，即生成器(generator) ","date":"2020-01-18","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/:6:1","tags":["Python学习之路"],"title":"Python学习之路-多任务:协程","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/"},{"categories":["Python"],"content":"创建生成器方法 只要把一个列表生成式的 改成 ( )，如下 In [1]: A = [ x*2 for x in range(5)] In [2]: A Out[2]: [0, 2, 4, 6, 8] In [3]: B = ( x*2 for x in range(5)) In [4]: B Out[4]: \u003cgenerator object \u003cgenexpr\u003e at 0x7f626c132db0\u003e 创建 L 和 G 的区别仅在于最外层的 [ ] 和 ( ) ， L 是一个列表，而 G 是一个生成器。我们可以直接打印出列表L的每一个元素，而对于生成器G，我们可以按照迭代器的使用方法来使用，即可以通过next()函数、for循环、list()等方法使用。 In [5]: next(G) Out[5]: 0 In [6]: next(G) Out[6]: 2 In [7]: next(G) Out[7]: 4 In [8]: next(G) Out[8]: 6 In [9]: next(G) Out[9]: 8 In [10]: next(G) --------------------------------------------------------------------------- StopIteration Traceback (most recent call last) \u003cipython-input-24-380e167d6934\u003e in \u003cmodule\u003e() ----\u003e 1 next(G) StopIteration: In [11]: In [12]: G = ( x*2 for x in range(5)) In [13]: for x in G: ....: print(x) ....: 0 2 4 6 8 In [14]: 将原本在迭代器__next__方法中实现的基本逻辑放到一个函数中来实现，但是将每次迭代返回数值的return换成了yield，此时新定义的函数便不再是函数，而是一个生成器了。简单来说：只要在def中有yield关键字的 就称为 生成器。用生成器实现斐波那契数列 In [15]: def fib(n): ....: current = 0 ....: num1, num2 = 0, 1 ....: while current \u003c n: ....: num = num1 ....: num1, num2 = num2, num1+num2 ....: current += 1 ....: yield num ....: return 'done' ....: In [16]: F = fib(5) In [17]: next(F) Out[17]: 1 In [18]: next(F) Out[18]: 1 In [19]: next(F) Out[19]: 2 In [20]: next(F) Out[20]: 3 In [21]: next(F) Out[21]: 5 In [22]: next(F) --------------------------------------------------------------------------- StopIteration Traceback (most recent call last) \u003cipython-input-22-8c2b02b4361a\u003e in \u003cmodule\u003e() ----\u003e 1 next(F) StopIteration: done 此时按照调用函数的方式( 案例中为F = fib(5) )使用生成器就不再是执行函数体了，而是会返回一个生成器对象（ 案例中为F ），然后就可以按照使用迭代器的方式来使用生成器了。 In [23]: for n in fib(5): ....: print(n) ....: 1 1 2 3 5 但是用for循环调用generator时，发现拿不到generator的return语句的返回值。如果想要拿到返回值，必须捕获StopIteration错误，返回值包含在StopIteration的value中： In [25]: g = fib(5) In [26]: while True: ....: try: ....: x = next(g) ....: print(\"value:%d\"%x) ....: except StopIteration as e: ....: print(\"生成器返回值:%s\"%e.value) ....: break ....: value:1 value:1 value:2 value:3 value:5 生成器返回值:done ","date":"2020-01-18","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/:6:2","tags":["Python学习之路"],"title":"Python学习之路-多任务:协程","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/"},{"categories":["Python"],"content":"使用send唤醒 我们除了可以使用next()函数来唤醒生成器继续执行外，还可以使用send()函数来唤醒执行。使用send()函数的一个好处是可以在唤醒的同时向断点处传入一个附加数据。 例子：执行到yield时，gen函数作用暂时保存，返回i的值; temp接收下次c.send(“python”)，send发送过来的值，c.next()等价c.send(None) In [27]: def gen(): ....: i = 0 ....: while i\u003c5: ....: temp = yield i ....: print(temp) ....: i+=1 ....: 使用send In [28]: f = gen() In [29]: next(f) Out[29]: 0 In [30]: f.send('haha') haha Out[30]: 1 In [31]: next(f) None Out[31]: 2 In [32]: f.send('haha') haha Out[32]: 3 使用next函数 In [33]: f = gen() In [34]: next(f) Out[34]: 0 In [35]: next(f) None Out[35]: 1 In [36]: next(f) None Out[36]: 2 In [37]: next(f) None Out[37]: 3 In [38]: next(f) None Out[38]: 4 In [39]: next(f) None --------------------------------------------------------------------------- StopIteration Traceback (most recent call last) \u003cipython-input-17-468f0afdf1b9\u003e in \u003cmodule\u003e() ----\u003e 1 next(f) StopIteration: 使用__next__()方法（不常使用） In [40]: f = gen() In [41]: f.__next__() Out[41]: 0 In [42]: f.__next__() None Out[42]: 1 In [43]: f.__next__() None Out[43]: 2 In [44]: f.__next__() None Out[44]: 3 In [45]: f.__next__() None Out[45]: 4 In [46]: f.__next__() None --------------------------------------------------------------------------- StopIteration Traceback (most recent call last) \u003cipython-input-24-39ec527346a9\u003e in \u003cmodule\u003e() ----\u003e 1 f.__next__() StopIteration: ","date":"2020-01-18","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/:6:3","tags":["Python学习之路"],"title":"Python学习之路-多任务:协程","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/"},{"categories":["Python"],"content":"简单实现协程 import time def work1(): while True: print(\"----work1---\") yield time.sleep(0.5) def work2(): while True: print(\"----work2---\") yield time.sleep(0.5) def main(): w1 = work1() w2 = work2() while True: next(w1) next(w2) if __name__ == \"__main__\": main() 运行结果： ----work1--- ----work2--- ----work1--- ----work2--- ----work1--- ----work2--- ----work1--- ----work2--- ----work1--- ----work2--- ----work1--- ----work2--- ...省略... ","date":"2020-01-18","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/:7:0","tags":["Python学习之路"],"title":"Python学习之路-多任务:协程","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/"},{"categories":["Python"],"content":"greenlet 为了更好使用协程来完成多任务，python中的greenlet模块对其封装，从而使得切换任务变的更加简单 ","date":"2020-01-18","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/:8:0","tags":["Python学习之路"],"title":"Python学习之路-多任务:协程","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/"},{"categories":["Python"],"content":"安装 使用如下命令安装greenlet模块: sudo pip3 install greenlet ","date":"2020-01-18","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/:8:1","tags":["Python学习之路"],"title":"Python学习之路-多任务:协程","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/"},{"categories":["Python"],"content":"简单实现 from greenlet import greenlet import time def test1(): while True: print \"---A--\" gr2.switch() time.sleep(0.5) def test2(): while True: print \"---B--\" gr1.switch() time.sleep(0.5) gr1 = greenlet(test1) gr2 = greenlet(test2) #切换到gr1中运行 gr1.switch() 运行效果： ---A-- ---B-- ---A-- ---B-- ---A-- ---B-- ---A-- ---B-- ...省略... ","date":"2020-01-18","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/:8:2","tags":["Python学习之路"],"title":"Python学习之路-多任务:协程","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/"},{"categories":["Python"],"content":"gevent greenlet已经实现了协程，但是这个还的人工切换，是不是觉得太麻烦了，不要捉急，python还有一个比greenlet更强大的并且能够自动切换任务的模块gevent 其原理是当一个greenlet遇到IO(指的是input output 输入输出，比如网络、文件操作等)操作时，比如访问网络，就自动切换到其他的greenlet，等到IO操作完成，再在适当的时候切换回来继续执行。 由于IO操作非常耗时，经常使程序处于等待状态，有了gevent为我们自动切换协程，就保证总有greenlet在运行，而不是等待IO ","date":"2020-01-18","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/:9:0","tags":["Python学习之路"],"title":"Python学习之路-多任务:协程","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/"},{"categories":["Python"],"content":"安装 使用如下命令安装gevent模块: pip3 install gevent ","date":"2020-01-18","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/:9:1","tags":["Python学习之路"],"title":"Python学习之路-多任务:协程","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/"},{"categories":["Python"],"content":"简单实现 import gevent def f(n): for i in range(n): print(gevent.getcurrent(), i) g1 = gevent.spawn(f, 5) g2 = gevent.spawn(f, 5) g3 = gevent.spawn(f, 5) g1.join() g2.join() g3.join() 运行结果 \u003cGreenlet at 0x10e49f550: f(5)\u003e 0 \u003cGreenlet at 0x10e49f550: f(5)\u003e 1 \u003cGreenlet at 0x10e49f550: f(5)\u003e 2 \u003cGreenlet at 0x10e49f550: f(5)\u003e 3 \u003cGreenlet at 0x10e49f550: f(5)\u003e 4 \u003cGreenlet at 0x10e49f910: f(5)\u003e 0 \u003cGreenlet at 0x10e49f910: f(5)\u003e 1 \u003cGreenlet at 0x10e49f910: f(5)\u003e 2 \u003cGreenlet at 0x10e49f910: f(5)\u003e 3 \u003cGreenlet at 0x10e49f910: f(5)\u003e 4 \u003cGreenlet at 0x10e49f4b0: f(5)\u003e 0 \u003cGreenlet at 0x10e49f4b0: f(5)\u003e 1 \u003cGreenlet at 0x10e49f4b0: f(5)\u003e 2 \u003cGreenlet at 0x10e49f4b0: f(5)\u003e 3 \u003cGreenlet at 0x10e49f4b0: f(5)\u003e 4 可以看到，3个greenlet是依次运行而不是交替运行 ","date":"2020-01-18","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/:9:2","tags":["Python学习之路"],"title":"Python学习之路-多任务:协程","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/"},{"categories":["Python"],"content":"切换执行 import gevent def f(n): for i in range(n): print(gevent.getcurrent(), i) #用来模拟一个耗时操作，注意不是time模块中的sleep gevent.sleep(1) g1 = gevent.spawn(f, 5) g2 = gevent.spawn(f, 5) g3 = gevent.spawn(f, 5) g1.join() g2.join() g3.join() 运行结果 \u003cGreenlet at 0x7fa70ffa1c30: f(5)\u003e 0 \u003cGreenlet at 0x7fa70ffa1870: f(5)\u003e 0 \u003cGreenlet at 0x7fa70ffa1eb0: f(5)\u003e 0 \u003cGreenlet at 0x7fa70ffa1c30: f(5)\u003e 1 \u003cGreenlet at 0x7fa70ffa1870: f(5)\u003e 1 \u003cGreenlet at 0x7fa70ffa1eb0: f(5)\u003e 1 \u003cGreenlet at 0x7fa70ffa1c30: f(5)\u003e 2 \u003cGreenlet at 0x7fa70ffa1870: f(5)\u003e 2 \u003cGreenlet at 0x7fa70ffa1eb0: f(5)\u003e 2 \u003cGreenlet at 0x7fa70ffa1c30: f(5)\u003e 3 \u003cGreenlet at 0x7fa70ffa1870: f(5)\u003e 3 \u003cGreenlet at 0x7fa70ffa1eb0: f(5)\u003e 3 \u003cGreenlet at 0x7fa70ffa1c30: f(5)\u003e 4 \u003cGreenlet at 0x7fa70ffa1870: f(5)\u003e 4 \u003cGreenlet at 0x7fa70ffa1eb0: f(5)\u003e 4 ","date":"2020-01-18","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/:9:3","tags":["Python学习之路"],"title":"Python学习之路-多任务:协程","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/"},{"categories":["Python"],"content":"给程序打补丁 from gevent import monkey import gevent import random import time def coroutine_work(coroutine_name): for i in range(10): print(coroutine_name, i) time.sleep(random.random()) gevent.joinall([ gevent.spawn(coroutine_work, \"work1\"), gevent.spawn(coroutine_work, \"work2\") ]) 运行结果 work1 0 work1 1 work1 2 work1 3 work1 4 work1 5 work1 6 work1 7 work1 8 work1 9 work2 0 work2 1 work2 2 work2 3 work2 4 work2 5 work2 6 work2 7 work2 8 work2 9 ","date":"2020-01-18","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/:9:4","tags":["Python学习之路"],"title":"Python学习之路-多任务:协程","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/"},{"categories":["Python"],"content":"monkey from gevent import monkey import gevent import random import time # 有耗时操作时需要 monkey.patch_all() # 将程序中用到的耗时操作的代码，换为gevent中自己实现的模块 def coroutine_work(coroutine_name): for i in range(10): print(coroutine_name, i) time.sleep(random.random()) gevent.joinall([ gevent.spawn(coroutine_work, \"work1\"), gevent.spawn(coroutine_work, \"work2\") ]) 运行结果 work1 0 work2 0 work1 1 work1 2 work1 3 work2 1 work1 4 work2 2 work1 5 work2 3 work1 6 work1 7 work1 8 work2 4 work2 5 work1 9 work2 6 work2 7 work2 8 work2 9 ","date":"2020-01-18","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/:9:5","tags":["Python学习之路"],"title":"Python学习之路-多任务:协程","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/"},{"categories":["Python"],"content":"进程、线程、协程对比 进程是资源分配的单位 线程是操作系统调度的单位 进程切换需要的资源很最大，效率很低 线程切换需要的资源一般，效率一般（当然了在不考虑GIL的情况下） 协程切换任务资源很小，效率高 多进程、多线程根据cpu核数不一样可能是并行的，但是协程是在一个线程中 所以是并发 ","date":"2020-01-18","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/:10:0","tags":["Python学习之路"],"title":"Python学习之路-多任务:协程","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E7%A8%8B/"},{"categories":["Python"],"content":"简介 一个程序运行起来后，代码+用到的资源 称之为进程，它是操作系统分配资源的基本单元。不仅可以通过线程完成多任务，进程也是可以的。 ","date":"2020-01-11","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%BF%9B%E7%A8%8B/:1:0","tags":["Python学习之路"],"title":"Python学习之路-多任务:进程","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%BF%9B%E7%A8%8B/"},{"categories":["Python"],"content":"状态 工作中，任务数往往大于cpu的核数，即一定有一些任务正在执行，而另外一些任务在等待cpu进行执行，因此导致了有了不同的状态 就绪态：运行的条件都已经慢去，正在等在cpu执行 执行态：cpu正在执行其功能 等待态：等待某些条件满足，例如一个程序sleep了，此时就处于等待态 ","date":"2020-01-11","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%BF%9B%E7%A8%8B/:2:0","tags":["Python学习之路"],"title":"Python学习之路-多任务:进程","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%BF%9B%E7%A8%8B/"},{"categories":["Python"],"content":"multiprocessing模块 ","date":"2020-01-11","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%BF%9B%E7%A8%8B/:3:0","tags":["Python学习之路"],"title":"Python学习之路-多任务:进程","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%BF%9B%E7%A8%8B/"},{"categories":["Python"],"content":"简介 multiprocessing模块是跨平台版本的多进程模块，提供了一个Process类来代表一个进程对象，这个对象可以理解为是一个独立的进程，可以执行另外的事情 ","date":"2020-01-11","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%BF%9B%E7%A8%8B/:3:1","tags":["Python学习之路"],"title":"Python学习之路-多任务:进程","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%BF%9B%E7%A8%8B/"},{"categories":["Python"],"content":"语法 from multiprocessing import Process p = Process(target=\"函数名\") p.start() Process([group [, target [, name [, args [, kwargs]]]]]) target：如果传递了函数的引用，可以任务这个子进程就执行这里的代码 args：给target指定的函数传递的参数，以元组的方式传递 kwargs：给target指定的函数传递命名参数 name：给进程设定一个名字，可以不设定 group：指定进程组，大多数情况下用不到 Process创建的实例对象的常用方法： start()：启动子进程实例（创建子进程） is_alive()：判断进程子进程是否还在活着 join([timeout])：是否等待子进程执行结束，或等待多少秒 terminate()：不管任务是否完成，立即终止子进程 Process创建的实例对象的常用属性： name：当前进程的别名，默认为Process-N，N为从1开始递增的整数 pid：当前进程的pid（进程号） 注意 可以通过os.getpid()来获取进程号。进程间不同享全局变量。 ","date":"2020-01-11","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%BF%9B%E7%A8%8B/:3:2","tags":["Python学习之路"],"title":"Python学习之路-多任务:进程","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%BF%9B%E7%A8%8B/"},{"categories":["Python"],"content":"进程间通信 ","date":"2020-01-11","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%BF%9B%E7%A8%8B/:4:0","tags":["Python学习之路"],"title":"Python学习之路-多任务:进程","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%BF%9B%E7%A8%8B/"},{"categories":["Python"],"content":"简介 Process之间有时需要通信，操作系统提供了很多机制来实现进程间的通信。 ","date":"2020-01-11","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%BF%9B%E7%A8%8B/:4:1","tags":["Python学习之路"],"title":"Python学习之路-多任务:进程","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%BF%9B%E7%A8%8B/"},{"categories":["Python"],"content":"Queue 可以使用multiprocessing模块的Queue实现多进程之间的数据传递，Queue本身是一个消息列队程序。 初始化Queue()对象时（例如：q=Queue()），若括号中没有指定最大可接收的消息数量，或数量为负值，那么就代表可接受的消息数量没有上限（直到内存的尽头）； Queue.qsize()：返回当前队列包含的消息数量； Queue.empty()：如果队列为空，返回True，反之False ； Queue.full()：如果队列满了，返回True,反之False； Queue.get([block[, timeout]])：获取队列中的一条消息，然后将其从列队中移除，block默认值为True； 1）如果block使用默认值，且没有设置timeout（单位秒），消息列队如果为空，此时程序将被阻塞（停在读取状态），直到从消息列队读到消息为止，如果设置了timeout，则会等待timeout秒，若还没读取到任何消息，则抛出\"Queue.Empty\"异常； 2）如果block值为False，消息列队如果为空，则会立刻抛出\"Queue.Empty\"异常； Queue.get_nowait()：相当Queue.get(False)； Queue.put(item,[block[, timeout]])：将item消息写入队列，block默认值为True； 1）如果block使用默认值，且没有设置timeout（单位秒），消息列队如果已经没有空间可写入，此时程序将被阻塞（停在写入状态），直到从消息列队腾出空间为止，如果设置了timeout，则会等待timeout秒，若还没空间，则抛出\"Queue.Full\"异常； 2）如果block值为False，消息列队如果没有空间可写入，则会立刻抛出\"Queue.Full\"异常； Queue.put_nowait(item)：相当Queue.put(item, False)； ","date":"2020-01-11","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%BF%9B%E7%A8%8B/:4:2","tags":["Python学习之路"],"title":"Python学习之路-多任务:进程","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%BF%9B%E7%A8%8B/"},{"categories":["Python"],"content":"进程池 当需要创建的子进程数量不多时，可以直接利用multiprocessing中的Process动态成生多个进程，但如果是上百甚至上千个目标，手动的去创建进程的工作量巨大，此时就可以用到multiprocessing模块提供的Pool方法。 初始化Pool时，可以指定一个最大进程数，当有新的请求提交到Pool中时，如果池还没有满，那么就会创建一个新的进程用来执行该请求；但如果池中的进程数已经达到指定的最大值，那么该请求就会等待，直到池中有进程结束，才会用之前的进程来执行新的任务。 multiprocessing.Pool常用函数解析： apply_async(func[, args[, kwds]]) ：使用非阻塞方式调用func（并行执行，堵塞方式必须等待上一个进程退出才能执行下一个进程），args为传递给func的参数列表，kwds为传递给func的关键字参数列表； close()：关闭Pool，使其不再接受新的任务； terminate()：不管任务是否完成，立即终止； join()：主进程阻塞，等待子进程的退出， 必须在close或terminate之后使用； 如果要使用Pool创建进程，就需要使用multiprocessing.Manager()中的Queue()，而不是multiprocessing.Queue()，否则会得到一条如下的错误信息： RuntimeError: Queue objects should only be shared between processes through inheritance. ","date":"2020-01-11","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%BF%9B%E7%A8%8B/:4:3","tags":["Python学习之路"],"title":"Python学习之路-多任务:进程","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%BF%9B%E7%A8%8B/"},{"categories":["Python"],"content":"简介 什么叫“多任务”呢？简单地说，就是操作系统可以同时运行多个任务。操作系统轮流让各个任务交替执行，表面上看，每个任务都是交替执行的，但是，由于CPU的执行速度实在是太快了，我们感觉就像所有任务都在同时执行一样。真正的并行执行多任务只能在多核CPU上实现，但是，由于任务数量远远多于CPU的核心数量，所以，操作系统也会自动把很多任务轮流调度到每个核心上执行。 拓展 并发：指的是任务数多余cpu核数，通过操作系统的各种任务调度算法，实现用多个任务“一起”执行（实际上总有一些任务不在执行，因为切换任务的速度相当快，看上去一起执行而已）。 并行：指的是任务数小于等于cpu核数，即任务真的是一起执行的。 ","date":"2020-01-04","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%BA%BF%E7%A8%8B/:1:0","tags":["Python学习之路"],"title":"Python学习之路-多任务:线程","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%BA%BF%E7%A8%8B/"},{"categories":["Python"],"content":"线程 ","date":"2020-01-04","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%BA%BF%E7%A8%8B/:2:0","tags":["Python学习之路"],"title":"Python学习之路-多任务:线程","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%BA%BF%E7%A8%8B/"},{"categories":["Python"],"content":"简介 线程是程序的最小执行流单元，是程序中一个单一的顺序控制流程 ","date":"2020-01-04","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%BA%BF%E7%A8%8B/:2:1","tags":["Python学习之路"],"title":"Python学习之路-多任务:线程","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%BA%BF%E7%A8%8B/"},{"categories":["Python"],"content":"threading模块 python的thread模块是比较底层的模块，python的threading模块是对thread做了一些包装的，可以更加方便的被使用 语法 import threading t = threading.Thread(target=\"函数名\") t.start() 当调用start()时，才会真正的创建线程，并且开始执行。主线程会等待所有的子线程结束后才结束 查看线程数量 可以通过len(threading.enumerate())查看当前线程数量 注意点 线程执行代码的封装 通过使用threading模块能完成多任务的程序开发，为了让每个线程的封装性更完美，所以使用threading模块时，往往会定义一个新的子类class，只要继承threading.Thread就可以了，然后重写run方法。 拓展 python的threading.Thread类有一个run方法，用于定义线程的功能函数，可以在自己的线程类中覆盖该方法。而创建自己的线程实例后，通过Thread类的start方法，可以启动该线程，交给python虚拟机进行调度，当该线程获得执行的机会时，就会调用run方法执行线程。 线程的执行顺序 多线程程序的执行顺序是不确定的。当执行到sleep语句时，线程将被阻塞（Blocked），到sleep结束后，线程进入就绪（Runnable）状态，等待调度。而线程调度将自行选择一个线程执行。上面的代码中只能保证每个线程都运行完整个run函数，但是线程的启动顺序、run函数中每次循环的执行顺序都不能确定。 拓展 每个线程默认有一个名字，尽管上面的例子中没有指定线程对象的name，但是python会自动为线程指定一个名字。 当线程的run()方法结束时该线程完成。 无法控制线程调度程序，但可以通过别的方式来影响线程调度的方式。 共享全局变量 在一个进程内的所有线程共享全局变量，很方便在多个线程间共享数据，缺点就是线程是对全局变量随意遂改可能造成多线程之间对全局变量的混乱（即线程非安全）。 多线程开发可能遇到的问题 假设两个线程t1和t2都要对全局变量g_num(默认是0)进行加1运算，t1和t2都各对g_num加10次，g_num的最终的结果应该为20。 但是由于是多线程同时操作，有可能出现下面情况： 在g_num=0时，t1取得g_num=0。此时系统把t1调度为”sleeping”状态，把t2转换为”running”状态，t2也获得g_num=0 然后t2对得到的值进行加1并赋给g_num，使得g_num=1 然后系统又把t2调度为”sleeping”，把t1转为”running”。线程t1又把它之前得到的0加1后赋值给g_num。 这样导致虽然t1和t2都对g_num加1，但结果仍然是g_num=1 如果多个线程同时对同一个全局变量操作，会出现资源竞争问题，从而数据结果会不正确 互斥锁 简介 当多个线程几乎同时修改某一个共享数据的时候，需要进行同步控制，线程同步能够保证多个线程安全访问竞争资源，最简单的同步机制是引入互斥锁。 互斥锁为资源引入一个状态：锁定/非锁定 某个线程要更改共享数据时，先将其锁定，此时资源的状态为“锁定”，其他线程不能更改；直到该线程释放资源，将资源的状态变成“非锁定”，其他的线程才能再次锁定该资源。互斥锁保证了每次只有一个线程进行写入操作，从而保证了多线程情况下数据的正确性。 threading模块中定义了Lock类，可以方便的处理锁定： # 创建锁 mutex = threading.Lock() # 锁定 mutex.acquire() # 释放 mutex.release() 注意 如果这个锁之前是没有上锁的，那么acquire不会堵塞 如果在调用acquire对这个锁上锁之前 它已经被 其他线程上了锁，那么此时acquire会堵塞，直到这个锁被解锁为止 上锁解锁过程 当一个线程调用锁的acquire()方法获得锁时，锁就进入“locked”状态。 每次只有一个线程可以获得锁。如果此时另一个线程试图获得这个锁，该线程就会变为“blocked”状态，称为“阻塞”，直到拥有锁的线程调用锁的release()方法释放锁之后，锁进入“unlocked”状态。 线程调度程序从处于同步阻塞状态的线程中选择一个来获得锁，并使得该线程进入运行（running）状态。 优缺点 优点：确保了某段关键代码只能由一个线程从头到尾完整地执行 缺点：阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了；由于可以存在多个锁，不同的线程持有不同的锁，并试图获取对方持有的锁时，可能会造成死锁 死锁 在线程间共享多个资源的时候，如果两个线程分别占有一部分资源并且同时等待对方的资源，就会造成死锁。尽管死锁很少发生，但一旦发生就会造成应用的停止响应。 如何避免死锁 程序设计时要尽量避免 添加超时时间等 ","date":"2020-01-04","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%BA%BF%E7%A8%8B/:2:2","tags":["Python学习之路"],"title":"Python学习之路-多任务:线程","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%BA%BF%E7%A8%8B/"},{"categories":["Python"],"content":"GIL GIL为全局解释器锁。每个线程在执行的过程都需要先获取GIL，保证同一时刻只有一个线程可以执行代码。 Python语言和GIL没有半毛钱关系。仅仅是由于历史原因在Cpython虚拟机(解释器)，难以移除GIL。在IO操作等可能会引起阻塞的system call之前,可以暂时释放GIL,但在执行完毕后,必须重新获取GIL Python 3.x使用计时器（执行时间达到阈值后，当前线程释放GIL）或Python 2.x，tickets计数达到100。Python使用多进程是可以利用多核的CPU资源的。多线程爬取比单线程性能有提升，因为遇到IO阻塞会自动释放GIL锁 ","date":"2020-01-04","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%BA%BF%E7%A8%8B/:3:0","tags":["Python学习之路"],"title":"Python学习之路-多任务:线程","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%BA%BF%E7%A8%8B/"},{"categories":["年终总结"],"content":"前言 一晃眼今年又过去了，这一年发生了不少事，很值得回顾一下，反思一下。 ","date":"2019-12-30","objectID":"/2019%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/:1:0","tags":["生活"],"title":"2019年终总结","uri":"/2019%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"},{"categories":["年终总结"],"content":"爱情 今年最让我兴奋的事就是跟你的感情越来越深了，原来爱情真的这么美妙，虽然我们之前也有吵架，但是总能相互理解，解决隔阂。虽然我们依然异地，但是心越来越近。自从有了你，生活真的变得多彩起来，会时不时想起你，这种异地的感觉也很奇妙，距离反而将我们拉得更近，格外珍惜在一起的时光。前几天忍不住回去看你，那种感觉真的太棒了。异地也有一些不好的地方，在你需要我的时候我不能很快出现在你身边，就想你租房、搬家，我几乎都帮不上忙。希望未来能改善吧。幸福ing~~~ ","date":"2019-12-30","objectID":"/2019%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/:2:0","tags":["生活"],"title":"2019年终总结","uri":"/2019%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"},{"categories":["年终总结"],"content":"经济 自从去年买房之后，身上的压力也大了起来，虽然每个月的房贷有父母帮忙还一部分，但是我知道我需要努力赚钱，尽快把房贷这块早点补上。目前每个月房租加上房贷有我工资的一半多了。今年又给爸妈交了医疗保险和养老保险，大概接近2万吧，所以也没存到啥钱。在搬家的时候发现我真的太能买了，都不是自己的房子就买那么多东西，买了一箱洗衣液，也不知道用多久才能用的完，这次搬家的时候还有3/4，明年一定要控制这些不必要的支出！除了缩减开支，感觉还需要理财，今年看了四本理财方面的书，感觉还是很不错的，很适合入门，分别是穷爸爸和富爸爸，工作前5年决定你一生的财富，小狗钱钱和给业余投资者的10条军规。读完这些最大的感受是，不要小瞧了不经意间花掉的那几块钱，任何钱都可以用来理财，我们可能不能赚很多，但是至少能让我们的财富有正向增长，理财的过程同样是我们对财富积累的过程。对了读书的app推荐用微信读书，现在可以免费领读书卡，免费看书。理财任何时间开始都不算晚，我们可能不会通过理财成为不了大富豪，但是能让我们过上更好的生活！ ","date":"2019-12-30","objectID":"/2019%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/:3:0","tags":["生活"],"title":"2019年终总结","uri":"/2019%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"},{"categories":["年终总结"],"content":"上海 在上海这一年听魔幻的，年初的时候还跟学长学姐一起逛了城隍庙、博物馆和外滩，毕业之后再跟学长学姐们相处感觉还是那么亲切，跟大学时没两样，希望都能在自己的领域发展的更好吧，想跟学姐约羽毛球的，无奈她在浦东我在浦西。。。这一年我的心态也发生了很多变化，之前玩的很好地室友也因为工作经常加班到很晚才能回家，能说上话的机会也变少了，我还记得上一次跟他交流是元宵节我煮了汤圆他吃，然后就是我搬家的时候了。。。现在住在上海的偏西边，这边的生活气息更浓，晚上也会有外面摆摊的，我也逐渐适应了这个较为偏僻的地方，一个人住也挺好。巧合的事，与另一个同事住的很近，还一起出去玩了几次，讨论了一下工作方面的事，东北人果然都很豪爽。。。 ","date":"2019-12-30","objectID":"/2019%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/:4:0","tags":["生活"],"title":"2019年终总结","uri":"/2019%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"},{"categories":["年终总结"],"content":"FPX夺冠 今年再欧洲图书馆有见证了LPL夺冠，G2得气死吧，哈哈，两年决赛，两个3:0，还都是被LPL的战队。网上有些键盘侠说不是全华班，不是全华班咋了，是咱LPL的胜利咋了，国人也帮欧洲人拿了TI的冠军呢，况且今年的FMVP是tian，又一个国产打野拿了FMVP，tian和ning都是瞎子王啊，去年的ning也是好几脚踢到关键人，今年tian更牛逼，这几脚真的是，比国足牛逼多了，什么时候国足能够硬气一回。不过LPL好久没出国产上单了，什么时候有牛逼的国产上单啊，希望明年有牛逼的国产上单能出现在总决赛!LPL加油啊，明年在中国举行了，把奖杯留在上海！ ","date":"2019-12-30","objectID":"/2019%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/:5:0","tags":["生活"],"title":"2019年终总结","uri":"/2019%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"},{"categories":["年终总结"],"content":"蔚来 今年去试驾了蔚来的ES6，国产车现在做的可以啊，行驶品质非常棒，自动驾驶也做的可以，nomi很有意思，可惜就是价格有点贵，偏出我的预期了。而且在我看来汽车这种消耗品，提升不了太多生活品质，或者说10万的车跟50万的车，对我来说区别不大。不过国产车可以做到50万这个级别还是很让人惊喜的，今年蔚来还差点退市了，希望他能越做越好吧，把高端车的市场抓在我们中国人的手里。 ","date":"2019-12-30","objectID":"/2019%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/:6:0","tags":["生活"],"title":"2019年终总结","uri":"/2019%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"},{"categories":["年终总结"],"content":"展望 2019年就这么过去了，去年的小目标实现了部分，攒够5万的小目标还没有实现，这个小目标继续延续下去吧，再给明年定几个小目标吧： 跟女朋友一起出去玩一次 赚更多的钱，增加还房贷的金额，减轻爸妈的负担，负责他们的各类保险 开始投资理财，争取攒够5万块 学会Golang 希望明年年终总结的时候小目标都能实现！ ","date":"2019-12-30","objectID":"/2019%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/:7:0","tags":["生活"],"title":"2019年终总结","uri":"/2019%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"},{"categories":["Python"],"content":"基本操作 在 Python 中要操作文件需要记住 1 个函数和 3 个方法 函数/方法 说明 open 打开文件，并且返回文件操作对象 read 将文件内容读取到内存 write 将指定内容写入文件 close 关闭文件 open 函数负责打开文件，并且返回文件对象 read/write/close 三个方法都需要通过文件对象来调用 ","date":"2019-12-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%96%87%E4%BB%B6/:1:0","tags":["Python学习之路"],"title":"Python学习之路-文件","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%96%87%E4%BB%B6/"},{"categories":["Python"],"content":"打开文件 open 函数默认以只读方式打开文件，并且返回文件对象。语法如下： f = open(\"文件名\", \"访问方式\") open函数的第一个参数是要打开的文件名(文件名区分大小写)，如果文件存在返回文件操作对象，如果文件不存在，会抛出异常。 访问方式 说明 r 以只读方式打开文件。文件的指针将会放在文件的开头，这是默认模式。如果文件不存在，抛出异常 w 以只写方式打开文件。如果文件存在会被覆盖。如果文件不存在，创建新文件 a 以追加方式打开文件。如果该文件已存在，文件指针将会放在文件的结尾。如果文件不存在，创建新文件进行写入 r+ 以读写方式打开文件。文件的指针将会放在文件的开头。如果文件不存在，抛出异常 w+ 以读写方式打开文件。如果文件存在会被覆盖。如果文件不存在，创建新文件 a+ 以读写方式打开文件。如果该文件已存在，文件指针将会放在文件的结尾。如果文件不存在，创建新文件进行写入 提示 文件指针标记从哪个位置开始读取数据。第一次打开文件时，通常文件指针会指向文件的开始位置。 ","date":"2019-12-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%96%87%E4%BB%B6/:1:1","tags":["Python学习之路"],"title":"Python学习之路-文件","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%96%87%E4%BB%B6/"},{"categories":["Python"],"content":"关闭文件 close方法负责关闭文件。如果忘记关闭文件，会造成系统资源消耗，而且会影响到后续对文件的访问。语法如下： file_name.close() 提示 在开发中，通常会先编写打开和关闭的代码，再编写中间针对文件的读/写操作！ ","date":"2019-12-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%96%87%E4%BB%B6/:1:2","tags":["Python学习之路"],"title":"Python学习之路-文件","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%96%87%E4%BB%B6/"},{"categories":["Python"],"content":"读取文件 read 方法可以一次性读入并返回文件的所有内容。当执行了read方法后，文件指针会移动到读取内容的末尾。 提示 如果执行了一次 read 方法，读取了所有内容，那么再次调用 read 方法不会读取到任何的内容 补充 read 方法默认会把文件的所有内容一次性读取到内存，如果文件太大，对内存的占用会非常严重。使用readline 方法可以一次读取一行内容，方法执行后，会把文件指针移动到下一行，准备再次读取。 ","date":"2019-12-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%96%87%E4%BB%B6/:1:3","tags":["Python学习之路"],"title":"Python学习之路-文件","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%96%87%E4%BB%B6/"},{"categories":["Python"],"content":"写入文件 write方法负责写入文件。语法如下： # 打开文件 f = open(\"file_name\", \"w\") f.write(\"hello python！\\n\") 提示 频繁的移动文件指针，会影响文件的读写效率，开发中更多的时候会以只读、只写的方式来操作文件。 ","date":"2019-12-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%96%87%E4%BB%B6/:1:4","tags":["Python学习之路"],"title":"Python学习之路-文件","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%96%87%E4%BB%B6/"},{"categories":["Python"],"content":"管理操作 在终端与文件浏览器中可以执行常规的文件/目录的管理操作，例如：创建、重命名、删除、改变路径、查看目录内容等等，在 Python 中，如果希望通过程序实现上述功能，需要导入 os 模块 ","date":"2019-12-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%96%87%E4%BB%B6/:2:0","tags":["Python学习之路"],"title":"Python学习之路-文件","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%96%87%E4%BB%B6/"},{"categories":["Python"],"content":"文件操作 序号 方法名 说明 示例 01 rename 重命名文件 os.rename(源文件名, 目标文件名) 02 remove 删除文件 os.remove(文件名) ","date":"2019-12-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%96%87%E4%BB%B6/:2:1","tags":["Python学习之路"],"title":"Python学习之路-文件","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%96%87%E4%BB%B6/"},{"categories":["Python"],"content":"目录操作 序号 方法名 说明 示例 01 listdir 目录列表 os.listdir(目录名) 02 mkdir 创建目录 os.mkdir(目录名) 03 rmdir 删除目录 os.rmdir(目录名) 04 getcwd 获取当前目录 os.getcwd() 05 chdir 修改工作目录 os.chdir(目标目录) 06 path.isdir 判断是否是文件 os.path.isdir(文件路径) 提示 文件或者目录操作都支持 相对路径和绝对路径 ","date":"2019-12-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%96%87%E4%BB%B6/:2:2","tags":["Python学习之路"],"title":"Python学习之路-文件","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%96%87%E4%BB%B6/"},{"categories":["Python"],"content":"编码格式 文本文件存储的内容是基于字符编码的文件，常见的编码有 ASCII 编码，UNICODE 编码等。Python 2.x 默认使用 ASCII 编码格式，Python 3.x 默认使用 UTF-8 编码格式。 提示 UTF-8 编码格式：UTF-8 是 UNICODE 编码的一种编码格式。计算机中使用1~6 个字节来表示一个 UTF-8 字符，涵盖了地球上几乎所有地区的文字。大多数汉字会使用3个字节表示。 ","date":"2019-12-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%96%87%E4%BB%B6/:3:0","tags":["Python学习之路"],"title":"Python学习之路-文件","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%96%87%E4%BB%B6/"},{"categories":["Python"],"content":"模块 ","date":"2019-12-21","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85/:1:0","tags":["Python学习之路"],"title":"Python学习之路-模块和包","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85/"},{"categories":["Python"],"content":"简介 模块是 Python 程序架构的一个核心概念。每一个以扩展名 py 结尾的 Python 源代码文件都是一个模块，模块名同样也是一个标识符，需要符合标识符的命名规则。在模块中定义的全局变量、函数、类都是提供给外界直接使用的工具。模块就好比是工具包，要想使用这个工具包中的工具，就需要先导入这个模块。 ","date":"2019-12-21","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85/:1:1","tags":["Python学习之路"],"title":"Python学习之路-模块和包","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85/"},{"categories":["Python"],"content":"导入方式 import导入：是一次性把模块中 所有工具全部导入 import 模块名 在导入模块时，每个导入应该独占一行 通过 模块名. 使用模块提供的工具 提示 开发时 import 代码应该统一写在代码的顶部，更容易及时发现冲突。一旦发现冲突，可以使用 as关键字给其中一个工具起一个别名：import 模块名 as 模块别名 from...import导入：如果希望从某一个模块中，导入部分工具，就可以使用 from ... import 的方式。import 模块名 # 从 模块 导入 某一个工具 from 模块名1 import 工具名 导入之后不需要通过 模块名.可以直接使用模块提供的工具。 注意 如果两个模块，存在同名的函数，那么后导入模块的函数，会覆盖掉先导入的函数 from…import *（不推荐） # 从 模块 导入 所有工具 from 模块名1 import * 注意 这种方式不推荐使用，因为函数重名并没有任何的提示，出现问题不好排查 ","date":"2019-12-21","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85/:1:2","tags":["Python学习之路"],"title":"Python学习之路-模块和包","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85/"},{"categories":["Python"],"content":"模块的搜索顺序 Python 的解释器在导入模块时，会先搜索当前目录指定模块名的文件，如果有就直接导入，如果没有，再搜索系统目录。 补充 可以通过sys.path给出的列表查看目录里依次查找要导入的模块文件，列表中的路径的先后顺序代表了python解释器在搜索模块时的先后顺序。 可以通过sys.path.append('xxx')的方式添加路径，通过sys.path.insert(0, 'xxx')可以确保先搜索这个路径 想重新导入模块可以reload导入,语法如下 from imp import reload reload(模块名) 注意 在开发时，给文件起名，不要和系统的模块文件重名。 提示 Python 中每一个模块都有一个内置属性 __file__ 可以查看模块的完整路径。 ","date":"2019-12-21","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85/:1:3","tags":["Python学习之路"],"title":"Python学习之路-模块和包","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85/"},{"categories":["Python"],"content":"__name__ 属性 __name__ 是 Python 的一个内置属性，记录着一个字符串。如果是被其他文件导入的，__name__就是模块名。如果 是当前执行的程序__name__是__main__。__name__属性可以做到，测试模块的代码只在测试情况下被运行，而在被导入时不会被执行！ 补充 在导入时，模块中所有没有任何缩进的代码都会被执行一遍！在实际开发中通常会在模块下方增加一些测试代码仅在模块内使用，被导入到其他文件中不需要执行。可以在if __name__ == \"__main__\":下方缩进中编写测试代码，从而不会被执行 ","date":"2019-12-21","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85/:1:4","tags":["Python学习之路"],"title":"Python学习之路-模块和包","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85/"},{"categories":["Python"],"content":"包 包是一个包含多个模块的特殊目录，目录下有一个特殊的文件：__init__.py。包名的命名方式和变量名一致。使用 import 包名 可以一次性导入包中所有的模块 ","date":"2019-12-21","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85/:2:0","tags":["Python学习之路"],"title":"Python学习之路-模块和包","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85/"},{"categories":["Python"],"content":"发布模块 如果希望自己开发的模块，分享给其他人，可以按照以下步骤操作： 创建 setup.py from distutils.core import setup setup(name=\"hm_message\", # 包名 version=\"1.0\", # 版本 description=\"itheima's 发送和接收消息模块\", # 描述信息 long_description=\"完整的发送和接收消息模块\", # 完整描述信息 author=\"itheima\", # 作者 author_email=\"itheima@itheima.com\", # 作者邮箱 url=\"www.itheima.com\", # 主页 py_modules=[\"hm_message.send_message\", \"hm_message.receive_message\"]) 补充 有关字典参数的详细信息，可以参阅官方网站 构建模块 $ python3 setup.py build 生成发布压缩包 $ python3 setup.py sdist 注意 要制作哪个版本的模块，就使用哪个版本的解释器执行！ 安装模块 $ tar -zxvf hm_message-1.0.tar.gz $ sudo python3 setup.py install 补充 卸载模块 直接从安装目录下，把安装模块的 目录 删除就可以 $ cd /usr/local/lib/python3.5/dist-packages/ $ sudo rm -r hm_message* ","date":"2019-12-21","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85/:3:0","tags":["Python学习之路"],"title":"Python学习之路-模块和包","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85/"},{"categories":["Python"],"content":"安装第三方模块 第三方模块通常是指由知名的第三方团队开发的并且被程序员广泛使用的Python包 / 模块。例如 request 就是一套非常成熟的HTTP 服务模块。pip 是一个现代的，通用的 Python 包管理工具，提供了对 Python 包的查找、下载、安装、卸载等功能。 安装和卸载命令如下： $ sudo pip3 install requests $ sudo pip3 uninstall requests ","date":"2019-12-21","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85/:4:0","tags":["Python学习之路"],"title":"Python学习之路-模块和包","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85/"},{"categories":["Python"],"content":"简介 程序在运行时，如果 Python 解释器 遇到到一个错误，会停止程序的执行，并且提示一些错误信息，这就是异常。程序停止执行并且提示错误信息这个动作，我们通常称之为：抛出(raise)异常。 程序开发时，很难将所有的特殊情况都处理的面面俱到，通过异常捕获可以针对突发事件做集中的处理，从而保证程序的稳定性和健壮性。 ","date":"2019-12-14","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%BC%82%E5%B8%B8/:1:0","tags":["Python学习之路"],"title":"Python学习之路-异常","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%BC%82%E5%B8%B8/"},{"categories":["Python"],"content":"捕获异常 在程序开发中，如果对某些代码的执行不能确定是否正确，可以增加 try(尝试) 来捕获异常。 捕获异常最简单的语法格式： try: 尝试执行的代码 except: 出现错误的处理 try尝试，下方编写要尝试代码，不确定是否能够正常执行的代码 except如果不是，下方编写尝试失败的代码 ","date":"2019-12-14","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%BC%82%E5%B8%B8/:2:0","tags":["Python学习之路"],"title":"Python学习之路-异常","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%BC%82%E5%B8%B8/"},{"categories":["Python"],"content":"错误类型捕获 在程序执行时，可能会遇到不同类型的异常，并且需要针对不同类型的异常，做出不同的响应，这个时候，就需要捕获错误类型了 语法如下： try: # 尝试执行的代码 pass except 错误类型1: # 针对错误类型1，对应的代码处理 pass except (错误类型2, 错误类型3): # 针对错误类型2 和 3，对应的代码处理 pass except Exception as result: print(\"未知错误 %s\" % result) 当 Python 解释器抛出异常时，最后一行错误信息的第一个单词，就是错误类型。 ","date":"2019-12-14","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%BC%82%E5%B8%B8/:3:0","tags":["Python学习之路"],"title":"Python学习之路-异常","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%BC%82%E5%B8%B8/"},{"categories":["Python"],"content":"捕获未知错误 在开发时，要预判到所有可能出现的错误，还是有一定难度的，如果希望程序无论出现任何错误，都不会因为 Python 解释器抛出异常而被终止，可以再增加一个except。 语法如下： except Exception as result: print(\"未知错误 %s\" % result) ","date":"2019-12-14","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%BC%82%E5%B8%B8/:4:0","tags":["Python学习之路"],"title":"Python学习之路-异常","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%BC%82%E5%B8%B8/"},{"categories":["Python"],"content":"异常捕获完整语法 在实际开发中，为了能够处理复杂的异常情况，完整的异常语法如下： try: # 尝试执行的代码 pass except 错误类型1: # 针对错误类型1，对应的代码处理 pass except 错误类型2: # 针对错误类型2，对应的代码处理 pass except (错误类型3, 错误类型4): # 针对错误类型3 和 4，对应的代码处理 pass except Exception as result: # 打印错误信息 print(result) else: # 没有异常才会执行的代码 pass finally: # 无论是否有异常，都会执行的代码 print(\"无论是否有异常，都会执行的代码\") 补充 else：只有在没有异常时才会执行的代码。finally：无论是否有异常，都会执行的代码 ","date":"2019-12-14","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%BC%82%E5%B8%B8/:5:0","tags":["Python学习之路"],"title":"Python学习之路-异常","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%BC%82%E5%B8%B8/"},{"categories":["Python"],"content":"异常的传递 当函数/方法执行出现异常，会将异常传递给函数/方法的调用一方。如果传递到主程序，仍然没有异常处理，程序才会被终止。 提示 在开发中，可以在主函数中增加异常捕获，而在主函数中调用的其他函数，只要出现异常，都会传递到主函数的异常捕获中，这样就不需要在代码中，增加大量的异常捕获，能够保证代码的整洁。 ","date":"2019-12-14","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%BC%82%E5%B8%B8/:6:0","tags":["Python学习之路"],"title":"Python学习之路-异常","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%BC%82%E5%B8%B8/"},{"categories":["Python"],"content":"抛出 raise 异常 除了代码执行出错 Python 解释器会抛出异常之外，还可以根据应用程序特有的业务需求主动抛出异常。Python 中提供了一个 Exception异常类。在开发时，如果满足特定业务需求时希望抛出异常，可以：创建一个 Exception 的对象，使用 raise 关键字抛出 异常对象。 ","date":"2019-12-14","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%BC%82%E5%B8%B8/:7:0","tags":["Python学习之路"],"title":"Python学习之路-异常","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%BC%82%E5%B8%B8/"},{"categories":["Python"],"content":"简介 类是一个特殊的对象Python中一切皆对象：class AAA: 定义的类属于类对象，obj1 = AAA() 属于实例对象。除了封装实例的属性和方法外，类对象还可以拥有自己的属性和方法成为：类属性和类方法，通过类名.的方式可以访问类的属性或者调用类的方法。 提示 在程序运行时，类同样会被加载到内存，类对象在内存中只有一份，使用一个类可以创建出很多个对象实例 ","date":"2019-12-07","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%B1%BB%E6%96%B9%E6%B3%95/:1:0","tags":["Python学习之路"],"title":"Python学习之路-面向对象:类属性与类方法","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%B1%BB%E6%96%B9%E6%B3%95/"},{"categories":["Python"],"content":"类属性 类属性就是给类对象中定义的属性，通常用来记录与这个类相关的特征。类属性不会用于记录具体对象的特征 ","date":"2019-12-07","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%B1%BB%E6%96%B9%E6%B3%95/:2:0","tags":["Python学习之路"],"title":"Python学习之路-面向对象:类属性与类方法","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%B1%BB%E6%96%B9%E6%B3%95/"},{"categories":["Python"],"content":"属性的获取机制 在 Python 中属性的获取存在一个向上查找机制。因此，要访问类属性有两种方式：1.类名.类属性；2.对象.类属性(不推荐) 提示 向上查找机制：获取对象属性时，首先在对象内部查找对象属性，没有找到就会向上寻找类属性。 如果使用 对象.类属性 = 值 赋值语句，只会给对象添加一个属性，而不会影响到类属性的值 补充 类属性在内存中只保存一份。实例属性在每个对象中都要保存一份。通过类创建实例对象时，如果每个对象需要具有相同名字的属性，那么就使用类属性，用一份既可 ","date":"2019-12-07","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%B1%BB%E6%96%B9%E6%B3%95/:2:1","tags":["Python学习之路"],"title":"Python学习之路-面向对象:类属性与类方法","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%B1%BB%E6%96%B9%E6%B3%95/"},{"categories":["Python"],"content":"类方法 类方法就是针对类对象定义的方法，在类方法内部可以直接访问类属性或者调用其他的类方法。 ","date":"2019-12-07","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%B1%BB%E6%96%B9%E6%B3%95/:3:0","tags":["Python学习之路"],"title":"Python学习之路-面向对象:类属性与类方法","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%B1%BB%E6%96%B9%E6%B3%95/"},{"categories":["Python"],"content":"语法 @classmethod def 类方法名(cls): pass 类方法需要用修饰器 @classmethod来标识，告诉解释器这是一个类方法类方法。类方法的第一个参数应该是cls。由哪一个类调用的方法，方法内的 cls 就是哪一个类的引用。这个参数和实例方法的第一个参数是 self 类似，通过类名. 调用类方法，调用方法时，不需要传递 cls 参数。在方法内部可以通过 cls. 访问类的属性，也可以通过 cls. 调用其他的类方法。 提示 使用其他名称也可以，不过习惯使用 cls ","date":"2019-12-07","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%B1%BB%E6%96%B9%E6%B3%95/:3:1","tags":["Python学习之路"],"title":"Python学习之路-面向对象:类属性与类方法","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%B1%BB%E6%96%B9%E6%B3%95/"},{"categories":["Python"],"content":"拓展 ","date":"2019-12-07","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%B1%BB%E6%96%B9%E6%B3%95/:4:0","tags":["Python学习之路"],"title":"Python学习之路-面向对象:类属性与类方法","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%B1%BB%E6%96%B9%E6%B3%95/"},{"categories":["Python"],"content":"静态方法 当类中某个方法既不需要访问实例属性或者调用实例方法也不需要访问类属性或者调用类方法的时候可以把这个方法封装成一个静态方法。 语法 @staticmethod def 静态方法名(): pass 静态方法需要用修饰器@staticmethod来标识，告诉解释器这是一个静态方法。通过类名.调用静态方法。 补充 实例方法、静态方法和类方法，三种方法在内存中都归属于类，区别在于调用方式不同。 实例方法：由对象调用；至少一个self参数；执行实例方法时，自动将调用该方法的对象赋值给self； 类方法：由类调用； 至少一个cls参数；执行类方法时，自动将调用该方法的类赋值给cls； 静态方法：由类调用；无默认参数； 相同点：对于所有的方法而言，均属于类，所以 在内存中也只保存一份 不同点：方法调用者不同、调用方法时自动传入的参数不同。 ","date":"2019-12-07","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%B1%BB%E6%96%B9%E6%B3%95/:4:1","tags":["Python学习之路"],"title":"Python学习之路-面向对象:类属性与类方法","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%B1%BB%E6%96%B9%E6%B3%95/"},{"categories":["Python"],"content":"单例 单例设计模式 目的：让类创建的对象，在系统中只有唯一的一个实例，每一次执行 类名() 返回的对象，内存地址是相同的。 补充 设计模式是前人工作的总结和提炼，通常，被人们广泛流传的设计模式都是针对某一特定问题的成熟的解决方案。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性 __new__方法 使用类名()创建对象时，Python 的解释器首先会 调用 __new__ 方法为对象分配空间。__new__方法是一个 由object 基类提供的内置的静态方法，主要作用有两个： 在内存中为对象分配空间 返回对象的引用 补充 Python 的解释器获得对象的引用后，将引用作为第一个参数，传递给 __init__ 方法 重写 __new__ 方法一定要return super().__new__(cls)，否则 Python 的解释器得不到分配了空间的对象引用，就不会调用对象的初始化方法。 注意 __new__ 是一个静态方法，在调用时需要主动传递 cls 参数 Python 中的单例 定义一个类属性，初始值是 None，用于记录单例对象的引用 重写 __new__ 方法 如果类属性 is None，调用父类方法分配空间，并在类属性中记录结果 返回类属性中记录的对象引用。 class Singleton(object): # 定义类属性记录单例对象引用 instance = None def __new__(cls, *args, **kwargs): # 1. 判断类属性是否已经被赋值 if cls.instance is None: cls.instance = super().__new__(cls) # 2. 返回类属性的单例引用 return cls.instance 定义一个类属性 init_flag 标记是否执行过初始化动作，初始值为 False 在 __init__ 方法中，判断 init_flag，如果为 False 就执行初始化动作 然后将 init_flag 设置为 True 这样，再次自动调用 __init__ 方法时，初始化动作就不会被再次执行了 class Singleton(object): # 记录第一个被创建对象的引用 instance = None # 记录是否执行过初始化动作 init_flag = False def __new__(cls, *args, **kwargs): # 1. 判断类属性是否是空对象 if cls.instance is None: # 2. 调用父类的方法，为第一个对象分配空间 cls.instance = super().__new__(cls) # 3. 返回类属性保存的对象引用 return cls.instance def __init__(self): if not Singleton.init_flag: print(\"初始化单例\") Singleton.init_flag = True # 创建多个对象 singleton1 = Singleton() print(singleton1) singleton2 = Singleton() print(singleton2) ","date":"2019-12-07","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%B1%BB%E6%96%B9%E6%B3%95/:4:2","tags":["Python学习之路"],"title":"Python学习之路-面向对象:类属性与类方法","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%B1%BB%E6%96%B9%E6%B3%95/"},{"categories":["Python"],"content":"property属性 定义 一种用起来像是使用的实例属性一样的特殊属性。property属性内部进行一系列的逻辑计算，最终将计算结果返回。 注意事项 定义时，在实例方法的基础上添加 @property 装饰器；并且仅有一个self参数 调用时，无需括号 方法：foo_obj.func() property属性：foo_obj.prop 两种方式 装饰器，即：在方法上应用装饰器 类属性，即：在类中定义值为property对象的类属性 类属性访问方式 老式类中的属性只有一种访问方式，其对应被 @property 修饰的方法。新式类中的属性有三种访问方式，并分别对应了三个被@property、@方法名.setter、@方法名.deleter修饰的方法，我们可以根据它们几个属性的访问特点，分别将三个方法定义为对同一个属性：获取、修改、删除。 提示 当使用类属性的方式创建property属性时，经典类和新式类无区别 参数 property方法中有个四个参数 第一个参数是方法名，调用 对象.属性 时自动触发执行方法 第二个参数是方法名，调用 对象.属性 ＝ XXX 时自动触发执行方法 第三个参数是方法名，调用 del 对象.属性 时自动触发执行方法 第四个参数是字符串，调用 对象.属性.__doc__ ，此参数是该属性的描述信息 ","date":"2019-12-07","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%B1%BB%E6%96%B9%E6%B3%95/:4:3","tags":["Python学习之路"],"title":"Python学习之路-面向对象:类属性与类方法","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%B1%BB%E6%96%B9%E6%B3%95/"},{"categories":["Python"],"content":"魔法属性 __init__：初始化方法，通过类创建对象时，自动触发执行 __doc__：表示类的描述信息 __module__：表示当前操作的对象在那个模块 __class__：表示当前操作的对象的类是什么 __del__：当对象在内存中被释放时，自动触发执行 __call__：对象后面加括号，触发执行，即：对象() 或者 类()() __dict__：类或对象中的所有属性(类的实例属性属于对象；类中的类属性和方法等属于类) __str__：如果一个类中定义了__str__方法，那么在打印 对象 时，默认输出该方法的返回值 __getitem__、__setitem__、__delitem__：用于索引操作，如字典 __getslice__、__setslice__、__delslice__：用于切片操作，如列表 ","date":"2019-12-07","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%B1%BB%E6%96%B9%E6%B3%95/:4:4","tags":["Python学习之路"],"title":"Python学习之路-面向对象:类属性与类方法","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%B1%BB%E6%96%B9%E6%B3%95/"},{"categories":["Python"],"content":"元类 元类就是用来创建类的“东西”，就是类的类。使用函数type对类查看类型是type类型，这是因为函数type实际上是一个元类。type就是Python在背后用来创建所有类的元类。 补充 type函数还有一种完全不同的功能，动态的创建类。type可以接受一个类的描述作为参数，然后返回一个类。 ","date":"2019-12-07","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%B1%BB%E6%96%B9%E6%B3%95/:4:5","tags":["Python学习之路"],"title":"Python学习之路-面向对象:类属性与类方法","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%B1%BB%E6%96%B9%E6%B3%95/"},{"categories":["Python"],"content":"三个基本特征 封装：根据职责将属性和方法封装到一个抽象的类中 继承：实现代码的重用，相同的代码不需要重复的编写 多态：不同的对象调用相同的方法，产生不同的执行结果，增加代码的灵活度 ","date":"2019-11-30","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81/:1:0","tags":["Python学习之路"],"title":"Python学习之路-面向对象:三个基本特征","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81/"},{"categories":["Python"],"content":"封装 封装是面向对象编程的一大特点，面向对象编程的第一步就是将属性和方法封装到一个抽象的类中，外界使用类创建对象，然后让对象调用方法，对象方法的细节都被封装在类的内部。 提示 一个对象的属性可以是另外一个类创建的对象 ","date":"2019-11-30","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81/:2:0","tags":["Python学习之路"],"title":"Python学习之路-面向对象:三个基本特征","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81/"},{"categories":["Python"],"content":"继承 ","date":"2019-11-30","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81/:3:0","tags":["Python学习之路"],"title":"Python学习之路-面向对象:三个基本特征","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81/"},{"categories":["Python"],"content":"单继承 概念 子类拥有父类的所有方法和属性 语法 class 类名(父类名): pass 提示 子类继承自父类，可以直接享受父类中已经封装好的方法，不需要再次开发.子类中应该根据职责，封装子类特有的属性和方法 传递性 子类拥有父类以及父类的父类中封装的所有属性和方法，例：C 类从 B 类继承，B 类又从 A 类继承，那么 C 类就具有 B 类和 A 类的所有属性和方法 重写 子类拥有父类的所有方法和属性，子类继承自父类，可以直接享受父类中已经封装好的方法，不需要再次开发，当父类的方法实现不能满足子类需求时，可以对方法进行重写(override)。重写父类方法有两种情况： 覆盖父类的方法：如果在开发中，父类的方法实现和子类的方法实现完全不同，就可以使用覆盖的方式，在子类中重新编写父类的方法实现。具体的实现方式，就相当于在子类中定义了一个和父类同名的方法并且实现，重写之后在运行时，只会调用子类中重写的方法，而不再会调用父类封装的方法 对父类方法进行扩展：子类的方法实现中包含父类的方法实现父类原本封装的方法实现是子类方法的一部分就可以使用扩展的方式。在子类中重写父类的方法在需要的位置使用 super().父类方法 来调用父类方法的执行代码其他的位置针对子类的需求，编写子类特有的代码实现 提示 关于 super：在 Python中 super是一个特殊的类。super() 就是使用 super 类创建出来的对象，最常使用的场景就是在重写父类方法时，调用在父类中封装的方法实现。 提示 在开发时，父类名 和 super() 两种方式不要混用，如果使用当前子类名调用方法，会形成递归调用，出现死循环。 私有属性和私有方法 私有属性、方法是对象的隐私，不对外公开，外界以及子类都不能直接访问。私有属性、方法通常用于做一些内部的事情。 子类对象不能在自己的方法内部，直接访问 父类的私有属性或私有方法。子类对象可以通过父类的公有方法间接访问到私有属性或私有方法 ","date":"2019-11-30","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81/:3:1","tags":["Python学习之路"],"title":"Python学习之路-面向对象:三个基本特征","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81/"},{"categories":["Python"],"content":"多继承 概念 子类可以拥有多个父类，并且具有所有父类的 属性和方法。 语法 class 子类名(父类名1, 父类名2...) pass 注意事项 如果父类之间存在同名的属性或者方法，应该尽量避免使用多继承。 补充 super().__init__相对于类名.__init__，在单继承上用法基本无差 但在多继承上有区别，super方法能保证每个父类的方法只会执行一次，而使用类名的方法会导致方法被执行多次，具体看前面的输出结果 多继承时，使用super方法，对父类的传参数，应该是由于Python中super的算法导致的原因，必须把参数全部传递，否则会报错 单继承时，使用super方法，则不能全部传递，只能传父类方法所需的参数，否则会报错 多继承时，相对于使用类名.__init__方法，要把每个父类全部写一遍, 而使用super方法，只需写一句话便执行了全部父类的方法，这也是为何多继承需要全部传参的一个原因 ","date":"2019-11-30","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81/:3:2","tags":["Python学习之路"],"title":"Python学习之路-面向对象:三个基本特征","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81/"},{"categories":["Python"],"content":"了解 新式类：以 object 为基类的类，推荐使用 旧式类：不以 object 为基类的类，不推荐使用 在 Python 3.x 中定义类时，如果没有指定父类，会默认使用 object 作为该类的基类 —— Python 3.x 中定义的类都是新式类 提示 object 是 Python 为所有对象提供的基类，提供有一些内置的属性和方法，可以使用 dir 函数查看。 今后在定义类时，如果没有父类，建议统一继承自 object ","date":"2019-11-30","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81/:3:3","tags":["Python学习之路"],"title":"Python学习之路-面向对象:三个基本特征","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81/"},{"categories":["Python"],"content":"多态 多态不同的子类对象调用相同的父类方法，产生不同的执行结果。多态可以增加代码的灵活度，以继承和重写父类方法为前提，是调用方法的技巧，不会影响到类的内部设计。 提示 多态更容易编写出出通用的代码，做出通用的编程，以适应需求的不断变化！ ","date":"2019-11-30","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81/:4:0","tags":["Python学习之路"],"title":"Python学习之路-面向对象:三个基本特征","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81/"},{"categories":["Python"],"content":"简介 面向对象编程(英语：Object-oriented programming，缩写：OOP)是种具有对象概念的编程典范，同时也是一种程序开发的抽象方针。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的重用性、灵活性和扩展性，对象里的程序可以访问及经常修改对象相关连的数据。在面向对象程序编程里，计算机程序会被设计成彼此相关的对象。 我们之前学习的编程方式就是面向过程的，面相过程和面相对象，是两种不同的编程方式，对比面向过程的特点，可以更好地了解什么是面向对象。 ","date":"2019-11-23","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:1:0","tags":["Python学习之路"],"title":"Python学习之路-初识面向对象","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["Python"],"content":"特点 ","date":"2019-11-23","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:2:0","tags":["Python学习之路"],"title":"Python学习之路-初识面向对象","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["Python"],"content":"面向过程 注重步骤与过程，不注重职责分工 如果需求复杂，代码会变得很复杂 开发复杂项目，没有固定的套路，开发难度很大！ ","date":"2019-11-23","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:2:1","tags":["Python学习之路"],"title":"Python学习之路-初识面向对象","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["Python"],"content":"面向对象 注重对象和职责，不同的对象承担不同的职责 更加适合应对复杂的需求变化，是专门应对复杂项目开发，提供的固定套路 需要在面向过程基础上，再学习一些面向对象的语法 提示 相比较函数，类是更大的封装，根据职责在一个对象中封装多个方法。在完成某一个需求前，首先确定职责要做的事情(方法)，根据职责确定不同的对象，在对象内部封装不同的方法(多个)。最后完成的代码，就是顺序地让不同的对象调用不同的方法 ","date":"2019-11-23","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:2:2","tags":["Python学习之路"],"title":"Python学习之路-初识面向对象","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["Python"],"content":"类和对象 ","date":"2019-11-23","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:3:0","tags":["Python学习之路"],"title":"Python学习之路-初识面向对象","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["Python"],"content":"简介 类是对一群具有相同特征或者行为的事物的一个统称，是抽象的，不能直接使用。特征被称为属性，行为被称为方法。 对象是由类创建出来的一个具体存在，可以直接使用。由哪一个类创建出来的对象，就拥有在哪一个类中定义的属性和方法。 ","date":"2019-11-23","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:3:1","tags":["Python学习之路"],"title":"Python学习之路-初识面向对象","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["Python"],"content":"关系 类是模板，对象是根据类这个模板创建出来的，应该先有类，再有对象。类只有一个，而对象可以有很多个。不同的对象之间属性可能会各不相同。类中定义了什么属性和方法，对象中就有什么属性和方法，不可能多，也不可能少。 ","date":"2019-11-23","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:3:2","tags":["Python学习之路"],"title":"Python学习之路-初识面向对象","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["Python"],"content":"类的设计 在使用面相对象开发前，应该首先分析需求，确定一下，程序中需要包含哪些类！ 在程序开发中，要设计一个类，通常需要满足一下三个要素： 类名这类事物的名字，满足大驼峰命名法 属性这类事物具有什么样的特征 方法这类事物具有什么样的行为 提示 大驼峰命名法：每一个单词的首字母大写且单词与单词之间没有下划线，如ClassName。 类名 名词提炼法分析整个业务流程，出现的名词，通常就是找到的类 属性和方法 对对象的特征描述，通常可以定义成属性 对象具有的行为(动词)，通常可以定义成方法 提示 需求中没有涉及的属性或者方法在设计类时，不需要考虑 ","date":"2019-11-23","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:3:3","tags":["Python学习之路"],"title":"Python学习之路-初识面向对象","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["Python"],"content":"基础语法 ","date":"2019-11-23","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:4:0","tags":["Python学习之路"],"title":"Python学习之路-初识面向对象","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["Python"],"content":"定义简单的类 定义一个只包含方法的类语法格式如下： class 类名: def 方法1(self, 参数列表): pass def 方法2(self, 参数列表): pass 提示 方法的定义格式和之前学习过的函数几乎一样,区别在于第一个参数必须是self，暂时先记住，稍后介绍 self ","date":"2019-11-23","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:4:1","tags":["Python学习之路"],"title":"Python学习之路-初识面向对象","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["Python"],"content":"创建对象 当一个类定义完成之后，要使用这个类来创建对象，语法格式如下： 对象变量 = 类名() ","date":"2019-11-23","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:4:2","tags":["Python学习之路"],"title":"Python学习之路-初识面向对象","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["Python"],"content":"方法中的 self 参数 由哪一个对象调用的方法，方法内的 self 就是哪一个对象的引用 提示 在面向对象开发中，引用的概念是同样适用的。使用类创建对象之后，对象的变量中仍然记录的是对象在内存中的地址，也就是对象的变量引用了新建的类对象。使用 print 输出对象变量，默认情况下，是能够输出这个变量引用的对象是由哪一个类创建的对象，以及在内存中的地址（十六进制表示） 在类封装的方法内部，self 就表示当前调用方法的对象自己。调用方法时，程序员不需要传递self参数。 在方法内部，可以通过 self. 访问对象的属性，也可以通过 self. 调用其他的对象方法。 在类的外部，通过 变量名. 访问对象的属性和方法，在类封装的方法中，通过 self. 访问对象的属性和方法。 ","date":"2019-11-23","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:4:3","tags":["Python学习之路"],"title":"Python学习之路-初识面向对象","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["Python"],"content":"初始化方法 当使用 类名() 创建对象时，会自动执行以下操作： 为对象在内存中分配空间 —— 创建对象 为对象的属性设置初始值 —— 初始化方法(init) 提示 初始化方法就是 __init__ 方法，__init__ 是对象的内置方法，__init__ 方法是 专门用来定义一个类具有哪些属性的方法 在 __init__ 方法内部使用 self.属性名 = 属性的初始值 就可以定义属性，定义属性之后，再使用类创建的对象，都会拥有该属性。 ","date":"2019-11-23","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:4:4","tags":["Python学习之路"],"title":"Python学习之路-初识面向对象","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["Python"],"content":"内置方法和属性 __del__方法 当使用 类名() 创建对象时，为对象分配完空间后，自动调用 __init__ 方法，当一个对象被从内存中销毁前，会自动调用 __del__ 方法。 提示 __init__ 改造初始化方法，可以让创建对象更加灵活，__del__ 如果希望在对象被销毁前，再做一些事情，可以考虑一下 __del__ 方法 提示 对象的生命周期，一个对象从调用 类名() 创建，生命周期开始，一个对象的 __del__ 方法一旦被调用，生命周期结束，在对象的生命周期内，可以访问对象属性，或者让对象调用方法。 __str__方法 如果在开发中，希望使用 print 输出对象变量时，能够打印自定义的内容，就可以利用__str__这个内置方法了 提示 __str__ 方法必须返回一个字符串 ","date":"2019-11-23","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:4:5","tags":["Python学习之路"],"title":"Python学习之路-初识面向对象","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%88%9D%E8%AF%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["生活"],"content":"前言 来上海已经一年多了，已经逐渐融入上海这座大都市，我的故事还在继续。。。。 ","date":"2019-11-16","objectID":"/%E5%85%A5%E8%81%8C%E4%B8%80%E5%B9%B4%E6%9C%89%E6%84%9F/:1:0","tags":["职场"],"title":"入职一年有感","uri":"/%E5%85%A5%E8%81%8C%E4%B8%80%E5%B9%B4%E6%9C%89%E6%84%9F/"},{"categories":["生活"],"content":"公司 在公司的这一年学习到挺多东西的。这一年公司人员也进进出出也变化挺大的，很庆幸能遇到一个好的leader，不仅在工作中教会了我很多，在生活中也给予我很大的帮助，他的脖子和腰不是太好，希望能早点治疗好疾病。公司整体偏年轻，一群人在一起创业，虽然可能不属于同一个部门，但是大方向都是为了公司更好的未来，感觉创业型的公司凝聚力好强啊。老板给的发挥空间也比较大，可以自己找到自己的位置做出自己的贡献。 ","date":"2019-11-16","objectID":"/%E5%85%A5%E8%81%8C%E4%B8%80%E5%B9%B4%E6%9C%89%E6%84%9F/:2:0","tags":["职场"],"title":"入职一年有感","uri":"/%E5%85%A5%E8%81%8C%E4%B8%80%E5%B9%B4%E6%9C%89%E6%84%9F/"},{"categories":["生活"],"content":"转型 目前公司准备开始了新的项目，会从全Python转向Golang，但这是我们一致开会完制定的方案，虽然有些陌生，但我相信我能很快学会Go语言，并完成新的项目。这也是来上海以来最大的一个挑战了，目前看了一下Go的语法，虽然没有Python这么简洁，但也比较简单，再加上leader作出的指导，应该能很好地适应这个变化。 ","date":"2019-11-16","objectID":"/%E5%85%A5%E8%81%8C%E4%B8%80%E5%B9%B4%E6%9C%89%E6%84%9F/:3:0","tags":["职场"],"title":"入职一年有感","uri":"/%E5%85%A5%E8%81%8C%E4%B8%80%E5%B9%B4%E6%9C%89%E6%84%9F/"},{"categories":["生活"],"content":"未来 我不清楚未来Go会发展成什么样子，虽然现在社区也远不如Python强大，但他的确可以解决我们目前的很多痛点问题，而且未来的大数据时代，我相信它应该也会有一席之地。只会Python也不会提高多少，现在学会了Go也会增加我的竞争力，而且不同语言也会带来我更多的思考，说不定未来转行Go开发了。 ","date":"2019-11-16","objectID":"/%E5%85%A5%E8%81%8C%E4%B8%80%E5%B9%B4%E6%9C%89%E6%84%9F/:4:0","tags":["职场"],"title":"入职一年有感","uri":"/%E5%85%A5%E8%81%8C%E4%B8%80%E5%B9%B4%E6%9C%89%E6%84%9F/"},{"categories":["生活"],"content":"未完待续 未来不管做Python还是Go还是其他语言，我都会努力做到最好的！我的故事还在继续。。。。 ","date":"2019-11-16","objectID":"/%E5%85%A5%E8%81%8C%E4%B8%80%E5%B9%B4%E6%9C%89%E6%84%9F/:5:0","tags":["职场"],"title":"入职一年有感","uri":"/%E5%85%A5%E8%81%8C%E4%B8%80%E5%B9%B4%E6%9C%89%E6%84%9F/"},{"categories":["Python"],"content":"目前已经学习了变量、流程控制、函数、模块，可以利用已学习的知识开发一个学生管理系统 ","date":"2019-11-09","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/:0:0","tags":["Python学习之路"],"title":"Python学习之路-综合练习:学生管理系统","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"categories":["Python"],"content":"项目需求 系统有首页介绍页面与功能菜单 系统功能由查询、显示、修改与删除功能 可以使用数字选择不同的功能 学生信息需要记录：姓名、性别、年龄、班级 ","date":"2019-11-09","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/:1:0","tags":["Python学习之路"],"title":"Python学习之路-综合练习:学生管理系统","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"categories":["Python"],"content":"项目搭建 ","date":"2019-11-09","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/:2:0","tags":["Python学习之路"],"title":"Python学习之路-综合练习:学生管理系统","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"categories":["Python"],"content":"步骤 创建文件 新建student_main.py文件，用于编写主程序功能代码，并作为程序的入口每一次启动名片管理系统都通过这个文件启动 新建student_tools.py文件，用于编写功能函数，将对系统的 新增、查询、修改、删除 等功能封装在不同的函数中 梳理业务逻辑，编写业务流程 # 通过死循环控制整个业务主体运行 # 编写系统欢迎界面，并显示功能菜单 # 提供用户输入选项 # 对输入选项进行输出 # 根据用户输入决定后续的操作 提示 在进行编码前最好进行业务逻辑的梳理，然后根据需求编写一个业务流程。编码前思考再进行编码能大大提高整体的效率。 完成主程序编码 # 通过死循环控制整个业务主体运行 while True: # 编写系统欢迎界面，并显示功能菜单 print(\"*\" * 20) print(\"欢迎使用【学生管理系统】1.0\\n\\n1. 新增学生\\n2. 显示全部学生\\n3. 查询学生\\n0. 退出系统\") print(\"*\" * 20) # 提供用户输入选项 options = input(\"请选择操作功能：\") # 对输入选项进行输出 print(\"您选择的操作是：%s\" % options) # 根据用户输入决定后续的操作 if options in [\"1\", \"2\", \"3\"]: pass # TODO 后续操作业务 elif options == \"0\": print(\"欢迎再次使用【名片管理系统】\") break else: print(\"输入错误，请重新输入\") 提示 在 # 后跟上 TODO，用于标记需要去做的工作 学生管理相关业务流程 新增学生 # 新增学生模块信息提示 # 提示用户输入学生信息 # 判断学生是否存在 # 存在则提示学生已存在 # 不存在将学生信息保存到一个字典 # 并将学生字典添加到学生列表 # 提示添加成功信息 显示所有学生 # 显示全部学生模块信息提示 # 遍历列表显示全部学生信息 查询学生 # 查询学生信息模块信息提示 # 提示用户输入搜索学生的姓名 # 遍历字典进行查询 # 找到后进行后续操作：修改/删除 # 没有找到输出提示信息 修改与删除学生信息 # 修改学生信息模块信息提示 # 提示用户输入修改学生的相关信息 # 提示修改成功信息 # 提示删除成功信息 完成相关业务流程代码 student_list = [] def new_student(): \"\"\"新建名片\"\"\" # 新增学生模块信息提示 print(\"-\" * 50) print(\"功能：新建学生\") # 提示用户输入学生信息 name = input(\"请输入姓名：\") gender = input(\"请输入性别：\") age = input(\"请输入年龄：\") team = input(\"请输入班级：\") # 将学生信息保存到一个字典 student_dict = {\"name\": name, \"gender\": gender, \"age\": age, \"team\": team} # 将学生字典添加到学生列表 student_list.append(student_dict) # 提示添加成功信息 print(\"成功添加学生：%s\" % student_dict[\"name\"]) def show_all_student(): \"\"\"显示全部学生\"\"\" # 显示全部学生模块信息提示 print(\"-\" * 50) print(\"功能：显示全部学生\") # 遍历列表显示全部学生信息 for name in [\"姓名\", \"性别\", \"年龄\", \"班级\"]: print(name, end=\"\\t\\t\") print(\"\") # 打印分隔线 print(\"=\" * 50) # 格式化输出信息 for student_dict in student_list: print(\"%s\\t\\t%s\\t\\t%s\\t\\t%s\" % (student_dict[\"name\"], student_dict[\"gender\"], student_dict[\"age\"], student_dict[\"team\"])) def search_student(): \"\"\"查询学生信息\"\"\" # 查询学生信息模块信息提示 print(\"-\" * 50) print(\"功能：搜索名片\") # 提示用户输入搜索学生的姓名 find_name = input(\"请输入要查询的学生姓名：\") # 遍历字典进行查询 for student_dict in student_list: if student_dict[\"name\"] == find_name: print(\"姓名\\t\\t\\t性别\\t\\t\\t年龄\\t\\t\\t班级\") print(\"-\" * 40) print(\"%s\\t\\t\\t%s\\t\\t\\t%s\\t\\t\\t%s\" % ( student_dict[\"name\"], student_dict[\"gender\"], student_dict[\"age\"], student_dict[\"team\"])) print(\"-\" * 40) # 找到后进行后续操作：修改/删除 # 提示用户输入修改学生的相关信息 options = input(\"请选择要执行的操作[1] 修改 [2] 删除 [0] 返回上级菜单\") if options == \"1\": student_dict[\"name\"] = input(\"请输入姓名：\") student_dict[\"gender\"] = input(\"请输入性别：\") student_dict[\"age\"] = input(\"请输入年龄：\") student_dict[\"team\"] = input(\"请输入班级：\") # 提示修改成功信息 print(\"学生：'%s'的信息修改成功\" % student_dict[\"name\"]) elif options == \"2\": student_list.remove(student_dict) # 提示删除成功信息 print(\"学生：'%s'的信息删除成功\" % student_dict[\"name\"]) break else: # 没有找到输出提示信息 print(\"没有找到 %s\" % find_name) 将相关业务流程代码导入主流程,补充主流程中TUDO部分 from student_tools import new_student,show_all_student,search_student # 通过死循环控制整个业务主体运行 while True: # 编写系统欢迎界面，并显示功能菜单 print(\"*\" * 20) print(\"欢迎使用【学生管理系统】1.0\\n\\n1. 新增学生\\n2. 显示全部学生\\n3. 查询学生\\n0. 退出系统\") print(\"*\" * 20) # 提供用户输入选项 option = input(\"请选择操作功能：\") # 对输入选项进行输出 print(\"您选择的操作是：%s\" % option) # 根据用户输入决定后续的操作 if option in [\"1\", \"2\", \"3\"]: if option == \"1\": new_student() elif option == \"2\": show_all_student() elif option == \"3\": search_student() elif option == \"0\": print(\"欢迎再次使用【名片管理系统】\") break else: print(\"输入错误，请重新输入\") 提示 在代码中大量使用/n和/t等转义字符用于优化字符串输出样式，Python中可以使用的转移字符串如下表格： 转义字符 描述 \\(在行尾时) 续行符 \\\\ 反斜杠符号 ' 单引号 \" 双引号 \\a 响铃 \\b 退格(Backspace) \\e 转义 \\000 空 \\n 换行 \\v 纵向制表符 \\t 横向制表符 \\r 回车 \\f 换页 \\oyy 八进制数，y 代表 0~7 的字符，例如：\\012 代表换行。 \\xyy 十六进制数，以 \\x 开头，yy代表的字符，例如：\\x0a代表换行 \\other 其它的字符以普通格式输出 ","date":"2019-11-09","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/:2:1","tags":["Python学习之路"],"title":"Python学习之路-综合练习:学生管理系统","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"categories":["Python"],"content":"参数和返回值的作用 函数根据有没有参数以及有没有返回值，可以相互组合，一共有4 种组合形式：无参数，无返回值；无参数，有返回值；有参数，无返回值；有参数，有返回值。 提示 定义函数时，是否接收参数，或者是否返回结果，是根据实际的功能需求来决定的！如果函数内部处理的数据不确定，就可以将外界的数据以参数传递到函数内部。如果希望一个函数执行完成后，向外界汇报执行结果，就可以增加函数的返回值 ","date":"2019-11-02","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/:1:0","tags":["Python学习之路"],"title":"Python学习之路-函数进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"不可变和可变的参数 无论传递的参数是可变还是不可变只要针对参数使用赋值语句，会在函数内部修改局部变量的引用**，**不会影响到 外部变量的引用。如果传递的参数是可变类型，在函数内部，使用方法修改了数据的内容，同样会影响到外部的数据 ","date":"2019-11-02","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/:2:0","tags":["Python学习之路"],"title":"Python学习之路-函数进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"缺省参数 定义函数时，可以给某个参数指定一个默认值，具有默认值的参数就叫做缺省参数调用函数时，如果没有传入缺省参数的值，则在函数内部使用定义函数时指定的参数默认值。函数的缺省参数，将常见的值设置为参数的缺省值，从而简化函数的调用 提示 缺省参数需要使用最常见的值作为默认值！如果一个参数的值不能确定，则不应该设置默认值，具体的数值在调用函数时，由外界传递！ ","date":"2019-11-02","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/:3:0","tags":["Python学习之路"],"title":"Python学习之路-函数进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"缺省参数的注意事项 缺省参数的定义位置 必须保证带有默认值的缺省参数在参数列表末尾 调用带有多个缺省参数的函数 在调用函数时，如果有多个缺省参数，需要指定参数名，这样解释器才能够知道参数的对应关系！ ","date":"2019-11-02","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/:3:1","tags":["Python学习之路"],"title":"Python学习之路-函数进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"多值参数 定义支持多值参数的函数，有时可能需要一个函数能够处理的参数个数是不确定的，这个时候就可以使用多值参数。python中有两种多值参数： 参数名前增加 一个 * 可以接收元组 参数名前增加 两个* 可以接收字典 一般在给多值参数命名时，习惯使用以下两个名字: *args —— 存放 元组 参数，前面有一个 * **kwargs —— 存放 字典 参数，前面有两个 * 提示 args是arguments的缩写，有变量的含义，kw 是 keyword 的缩写，kwargs 可以记忆键值对参数 元组和字典的拆包 在调用带有多值参数的函数时，如果希望：将一个元组变量，直接传递给 args将一个 字典变量，直接传递给 kwargs就可以使用拆包，简化参数的传递，拆包的方式是：在元组变量前，增加一个*在字典变量前，增加两个 *。 ","date":"2019-11-02","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/:4:0","tags":["Python学习之路"],"title":"Python学习之路-函数进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"递归 ","date":"2019-11-02","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/:5:0","tags":["Python学习之路"],"title":"Python学习之路-函数进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"简介 函数调用自身的编程技巧称为递归 ","date":"2019-11-02","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/:5:1","tags":["Python学习之路"],"title":"Python学习之路-函数进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"特点 一个函数内部调用自己。函数内部可以调用其他函数，当然在函数内部也可以调用自己 ","date":"2019-11-02","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/:5:2","tags":["Python学习之路"],"title":"Python学习之路-函数进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"代码特点 函数内部的代码是相同的，只是针对参数不同，处理的结果不同 当参数满足一个条件时，函数不再执行 警告 这个非常重要，通常被称为递归的出口，否则会出现死循环！ 提示 初次接触递归会感觉有些吃力！在处理不确定的循环条件时，格外的有用，例如：遍历整个文件目录的结构 ","date":"2019-11-02","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/:5:3","tags":["Python学习之路"],"title":"Python学习之路-函数进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"内置函数 Python 解释器内置了很多函数，可以在任何时候使用，在这里查看具体包含哪些与使用方法。 ","date":"2019-11-02","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/:6:0","tags":["Python学习之路"],"title":"Python学习之路-函数进阶","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"定义 所谓函数就是把具有独立功能的代码块组织为一个小的模块，在需要的时候可以直接调用 ","date":"2019-10-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/:1:0","tags":["Python学习之路"],"title":"Python学习之路-函数基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/"},{"categories":["Python"],"content":"作用 在开发程序时，函数可以提高编写的效率以及代码的重用。 ","date":"2019-10-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/:2:0","tags":["Python学习之路"],"title":"Python学习之路-函数基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/"},{"categories":["Python"],"content":"基本使用 ","date":"2019-10-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/:3:0","tags":["Python学习之路"],"title":"Python学习之路-函数基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/"},{"categories":["Python"],"content":"步骤 使用函数有两个步骤： 定义函数：封装独立功能的代码块 def 函数名(): 函数封装的代码 …… def为英文define的缩写，即定义的意思 函数名称应该能表达函数封装代码的功能，方便后续理解调用 函数名称的命名应该符合标识符的命名规则 调用函数：使用封装好的成功 通过 函数名() 即可完成对函数的调用 ","date":"2019-10-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/:3:1","tags":["Python学习之路"],"title":"Python学习之路-函数基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/"},{"categories":["Python"],"content":"参数 ","date":"2019-10-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/:4:0","tags":["Python学习之路"],"title":"Python学习之路-函数基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/"},{"categories":["Python"],"content":"作用 函数的参数，增加函数的通用性，针对相同的数据处理逻辑，能够适应更多的数据。在函数内部，把参数当做变量使用，进行需要的数据处理。函数调用时，按照函数定义的参数顺序，把希望在函数内部处理的数据，通过参数传递 ","date":"2019-10-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/:4:1","tags":["Python学习之路"],"title":"Python学习之路-函数基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/"},{"categories":["Python"],"content":"形参和实参 形参：定义函数时，小括号中的参数，是用来接收参数用的，在函数内部作为变量使用 实参：调用函数时，小括号中的参数，是用来把数据传递到函数内部用的 ","date":"2019-10-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/:4:2","tags":["Python学习之路"],"title":"Python学习之路-函数基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/"},{"categories":["Python"],"content":"返回值 在程序开发中，有时候，会希望一个函数执行结束后，告诉调用者一个结果，以便调用者针对具体的结果做后续的处理。返回值是函数完成工作后，最后给调用者的一个结果。在函数中使用return关键字可以返回结果，调用函数一方，可以使用变量来接收函数的返回结果。 注意 return 表示返回，后续的代码都不会被执行 ","date":"2019-10-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/:5:0","tags":["Python学习之路"],"title":"Python学习之路-函数基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/"},{"categories":["Python"],"content":"嵌套调用 一个函数里面又调用了另外一个函数，这就是函数嵌套调用。如果函数中，调用了另外一个函数那么执行到调用 外层函数时，会先把被嵌套函数中的任务都执行完才会执行后续的代码 ","date":"2019-10-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/:6:0","tags":["Python学习之路"],"title":"Python学习之路-函数基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/"},{"categories":["Python"],"content":"模块中的函数 模块是 Python 程序架构的一个核心概念。模块就好比是工具包，要想使用这个工具包中的工具，就需要导入 import这个模块。每一个以扩展名 py 结尾的 Python 源代码文件都是一个模块。在模块中定义的全局变量、函数都是模块能够提供给外界直接使用的工具 注意 模块名也是一个标识符 ","date":"2019-10-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/:7:0","tags":["Python学习之路"],"title":"Python学习之路-函数基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/"},{"categories":["Python"],"content":"拓展 ","date":"2019-10-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/:8:0","tags":["Python学习之路"],"title":"Python学习之路-函数基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/"},{"categories":["Python"],"content":"Pyc 文件 简介 C 是 compiled 编译过 的意思。浏览程序目录会发现一个__pycache__的目录，目录下会有一个 xx.cpython-37.pyc 文件，cpython-37 表示 Python 解释器的版本.这个pyc文件是由 Python 解释器将模块的源码转换为字节码 提示 Python 这样保存字节码是作为一种启动速度的优化 字节码 Python 在解释源程序时是分成两个步骤的 首先处理源代码，编译生成一个二进制字节码 再对字节码进行处理，才会生成 CPU 能够识别的机器码 有了模块的字节码文件之后，下一次运行程序时，如果在上次保存字节码之后没有修改过源代码，Python 将会加载 .pyc 文件并跳过编译这个步骤。当Python重编译时，它会自动检查源文件和字节码文件的时间戳。如果你又修改了源代码，下次程序运行时，字节码将自动重新创建 ","date":"2019-10-26","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/:8:1","tags":["Python学习之路"],"title":"Python学习之路-函数基础","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/"},{"categories":["Python"],"content":"程序就是用来处理数据的，而常量和变量就是最简单用来存储数据的 ","date":"2019-10-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/:0:0","tags":["Python学习之路"],"title":"Python学习之路-常量与变量","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/"},{"categories":["Python"],"content":"常量 ","date":"2019-10-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/:1:0","tags":["Python学习之路"],"title":"Python学习之路-常量与变量","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/"},{"categories":["Python"],"content":"定义 声明在文件的顶部 ","date":"2019-10-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/:1:1","tags":["Python学习之路"],"title":"Python学习之路-常量与变量","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/"},{"categories":["Python"],"content":"命名规范 全部大写 单词间用下划线分隔 ","date":"2019-10-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/:1:2","tags":["Python学习之路"],"title":"Python学习之路-常量与变量","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/"},{"categories":["Python"],"content":"变量 ","date":"2019-10-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/:2:0","tags":["Python学习之路"],"title":"Python学习之路-常量与变量","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/"},{"categories":["Python"],"content":"定义 变量在使用前都必须要要进行赋值，只有被赋值后变量才会被创建 ","date":"2019-10-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/:2:1","tags":["Python学习之路"],"title":"Python学习之路-常量与变量","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/"},{"categories":["Python"],"content":"命名规范 一般情况 当变量名需要由二个或多个单词组成时，每个单词都使用小写字母单词与单词之间使用 _下划线连接 驼峰命名法 当变量名是由二个或多个单词组成时，还可以利用驼峰命名法来命名 小驼峰式命名法：第一个单词以小写字母开始，后续单词的首字母大写 大驼峰式命名法：每一个单词的首字母都采用大写字母 注意 变量与常量都属于标识符，需要满足标识符的命名方式。标识符区分大小写。 提示 以上命名规范都不是强制的，命名规范可以更好的满足PEP 8和PEP 20并增加代码的识别和可读性 ","date":"2019-10-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/:2:2","tags":["Python学习之路"],"title":"Python学习之路-常量与变量","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/"},{"categories":["Python"],"content":"类型 在 Python 中定义变量是 不需要指定类型（在其他很多高级语言中都需要） 数据类型可以分为数字型和非数字型 数字型 整型(int) 浮点型float) 布尔型(bool) 真 True 非 0 数 —— 非零即真 假 False 0 复数型(complex) 主要用于科学计算，例如：平面场问题、波动问题、电感电容等问题 非数字型 字符串 列表 元组 字典 ","date":"2019-10-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/:2:3","tags":["Python学习之路"],"title":"Python学习之路-常量与变量","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/"},{"categories":["Python"],"content":"交互 数字型变量之间可以直接计算，bool型True为1，False为0 字符串变量之间使用+拼接字符串 字符串变量可以和整数使用*重复拼接相同的字符串 数字型变量和字符串之间不能进行其他计算 ","date":"2019-10-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/:2:4","tags":["Python学习之路"],"title":"Python学习之路-常量与变量","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/"},{"categories":["Python"],"content":"输入 变量也可以通过键盘输入的信息获取，这时可以使用input函数从键盘等待用户的输入 提示 input函数跟之前使用过的print函数一样都是Python3内置的函数，可以理解为提前准备好的功能，可以直接使用。 语法如下： 字符串变量 = input(\"提示信息：\") 注意 用户输入的任何内容Python 都认为是一个字符串 ","date":"2019-10-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/:2:5","tags":["Python学习之路"],"title":"Python学习之路-常量与变量","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/"},{"categories":["Python"],"content":"类型转换 函数 说明 int(x) 将x转换为整数 float(x) 将x转换为浮点数 str(x) 将x转换为字符串 ","date":"2019-10-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/:2:6","tags":["Python学习之路"],"title":"Python学习之路-常量与变量","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/"},{"categories":["Python"],"content":"格式化输出 想要输出固定字符串的同时一起输出变量的值，可以使用格式化操作符%，%和不同的字符连用可以输出不同类型的数据。 格式化字符 含义 %s 字符串 %d 有符号十进制整数，%06d表示输出的整数显示位数，不足的地方使用 0 补全 %f 浮点数，%.2f 表示小数点后只显示两位 %% 输出 % 提示 包含格式化操作符的字符串称为格式化字符串 ","date":"2019-10-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/:2:7","tags":["Python学习之路"],"title":"Python学习之路-常量与变量","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/"},{"categories":["Python"],"content":"非数字型变量 所有非数字型变量都支持以下特点： 都是一个序列 通过[]取值 通过for in遍历 计算长度、最大/最小值、比较、删除 链接 + 和 重复 * 切片 字符串 定义 字符串就是一串文本字符的数据类型，在 Python 中可以使用一对双引号\"或者一对单引号'定义一个字符串。 提示 当用双引号\"做字符串时内部可以用单引号'定义字符串；当用单引号'做字符串时内部可以用双引号\"定义字符串。 常用操作 判断类型 方法 说明 isspace() 如果 string 中只包含空格，则返回 True isalnum() 如果 string 至少有一个字符并且所有字符都是字母或数字则返回 True isalpha() 如果 string 至少有一个字符并且所有字符都是字母则返回 True isdecimal() 如果 string 只包含十进制数字则返回 True 否则返回 False isdigit() 如果 string 只包含数字则返回 True 否则返回 False isnumeric() 如果 string 中只包含数字字符，则返回 True，否则返回 False istitle() 如果 string 是标题化的(每个单词的首字母大写)则返回 True islower() 如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True isupper() 如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True 查找和替换 方法 说明 startswith(str) 检查字符串是否是以 str 开头，是则返回 True endswith(str) 检查字符串是否是以 str 结束，是则返回 True find(str, start=0, end=len(string)) 检测 str 是否包含在 string 中，如果 start 和 end 指定范围，则检查是否包含在指定范围内，如果是返回开始的索引值，否则返回 -1 rfind(str, start=0, end=len(string)) 类似于 find()，不过是从右边开始查找 index(str, start=0, end=len(string)) 跟 find() 方法类似，不过如果 str 不在 string 会报错 rindex(str, start=0, end=len(string)) 类似于 index()，不过是从右边开始 replace(old_str, new_str, num=string.count(old)) 把 string 中的 old_str 替换成 new_str，如果 num 指定，则替换不超过 num 次 大小写转换 方法 说明 capitalize() 把字符串的第一个字符大写 title() 把字符串的每个单词首字母大写 lower() 转换 string 中所有大写字符为小写 upper() 转换 string 中的小写字母为大写 swapcase() 翻转 string 中的大小写 文本对齐 方法 说明 ljust(width) 返回一个原字符串左对齐，并使用空格填充至长度 width 的新字符串 rjust(width) 返回一个原字符串右对齐，并使用空格填充至长度 width 的新字符串 center(width) 返回一个原字符串居中，并使用空格填充至长度 width 的新字符串 去除空白字符 方法 说明 lstrip() 截掉 string 左边（开始）的空白字符 rstrip() 截掉 string 右边（末尾）的空白字符 strip() 截掉 string 左右两边的空白字符 拆分和连接 方法 说明 partition(str) 把字符串 string 分成一个 3 元素的元组 (str前面, str, str后面) rpartition(str) 类似于 partition() 方法，不过是从右边开始查找 split(str=””, num) 以 str 为分隔符拆分 string，如果 num 有指定值，则仅分隔 num + 1 个子字符串，str 默认包含 ‘\\r’, ‘\\t’, ‘\\n’ 和空格 splitlines() 按照行('\\r’, ‘\\n’, ‘\\r\\n’)分隔，返回一个包含各行作为元素的列表 join(seq) 以 string 作为分隔符，将 seq 中所有的元素（的字符串表示）合并为一个新的字符串 列表 定义 list(列表)是专门用于存储一串信息的对象集合，用[]来定义，数据之间使用,分隔。列表的索引从0开始。 提示 索引就是数据在列表中的位置编号，索引又可以被称为下标。从列表中取值时，如果超出索引范围，程序会报错。 常用操作 增加 列表.insert(索引, 数据)：根据索引位置插入指定数据 列表.append(数据)：在末尾追加数据 列表.extend(list)：将另一个列表合并到当前列表中 修改 通过指定索引进行赋值操作 列表[索引] = 数据 删除 列表.remove[数据]：删除第一个出现的指定数据 列表.pop(索引)：删除指定索引数据并返回该值，不传索引则为删除末尾的数据 列表.clear：清空列表 del 列表[索引]：删除指定索引数据，不写[索引]则为删除整个列表 提示 del关键字可以删除任意变量，在对列表操作时指定索引就删除列表中指定索引的元素不指定索引则直接删除整个列表 统计 len(列表)：计算列表长度 count(数据)：统计数据在列表中出现的次数 排序 列表.sort()：升序排序，传入reverse=True则为降序排列 列表.reverse()：反转列表 元祖 定义 Tuple元祖表示多个元素组成的对象集合。用()来定义，数据之间使用,分隔。元祖的索引从0开始。与列表类似，不同之处在于元素的元素不能修改。 常规操作 统计值出现的次数 元祖.count(值) 返回索引所在的位置 元祖.index(值) 字典 定义 dict(字典)表示存储多个键值对的对象集合。用{}来定义，键与值之间用:分隔，键值对之间使用，分隔。字典的索引为键，键必须是唯一的，且只能使用字符串、数字或元祖。 常规操作 增加 通过对新的键进行赋值 dict['new_key'] = 'value' 修改 通过对存在的键进行修改 dict['key'] = 'value' 删除 dict.clear()：清空字典所有条目 del dict[‘key’]：通过对存在的键进行删除 del dict：删除整个字典 提示 字典是无序的对象集合，字符串、列表、元祖都是有序的对象集合。 字典和列表是可变对象集合，字符串、元祖为不可变对象集合。 内置方法 方法 说明 clear() 删除字典内所有元素 copy() 返回一个字典的浅拷贝 fromkeys(key, value) 创建一个新字典，以序列key中元素做字典的键，value为字典所有键对应的初始值 get(key, default=None) 返回指定键的值，如果值不在字典中返回default值 has_key(key) 如果键在字典dict里返回true，否则返回false items() 以列表返回可遍历的(键, 值) 元组数组 keys() 以列表返回一个字典所有的键 setdefault(key, default=None) 和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default update(dict2) 把字典dict2的键/值对更新到dict里 values() 以列表返回字典中的所有值 pop(key) 删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。 popitem() 返回并删除字典中的最后一对键和值。 公共方法 Python内置函数 函数 描述 备注 len(item) 计算容器中元素个数 del(item) 删除变量 del 有两种方式 max(item) 返回容器中元素最大值 如果是字典，只针对 key 比较 min(item) 返回容器中元素最小值 如果是字典，只针对 key 比较 切片 使用索引值来限定一个范围。列表和元组都是有序的集合，都能够通过索引值获取到对应的数据。字典是一个无序的集合，是使用键值对保存数据。 运算符 运算符 描述 支持的数据类型 + 合并 字符串、列表、元组 * 重复 字符串、列表、元组 in 元素是否存在 字符串、列表、元组、字典 not in 元素是否不存在 字符串、列表、元组、字典 \u003e \u003e= == \u003c \u003c= 元素比较 字符串、列表、元组 注意 in 在对字典操作时，判断的是字典的键。in和not in 被称为成员运算符 for 循环语法 可以通过for进行遍历 语法如下： for 变量 in 集合: 代码块 ","date":"2019-10-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/:2:8","tags":["Python学习之路"],"title":"Python学习之路-常量与变量","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/"},{"categories":["Python"],"content":"深入理解变量 ","date":"2019-10-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/:3:0","tags":["Python学习之路"],"title":"Python学习之路-常量与变量","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/"},{"categories":["Python"],"content":"引用 简介 变量和数据都是保存在内存中的，在Python中函数的参数传递以及返回值都是靠引用传递的 深入理解 在Python中变量和数据是分开存储的。数据保存在内存中的某个位置，变量则保存着数据在内存中的地址。变量中记录数据的地址就是引用，使用id()函数可以查看变量中保存数据所在的内存地址 注意 如果变量已经被定义，当给一个变量赋值的时候，本质上是修改了数据的引用，变量不再对之前的数据引用，变量 改为对新赋值的数据引用 提示 函数的实参/返回值都是是靠引用来传递来的 ","date":"2019-10-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/:3:1","tags":["Python学习之路"],"title":"Python学习之路-常量与变量","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/"},{"categories":["Python"],"content":"可变和不可变类型 不可变类型，内存中的数据不允许被修改：数字类型、字符串 、元组 可变类型，内存中的数据可以被修改：列表、dict 注意 字典的key只能使用不可变类型的数据。 可变类型的数据变化，是通过方法来实现的，如果给一个可变类型的变量，赋值了一个新的数据，引用会修改变量不再对之前的数据引用，改为对新赋值的数据引用 ","date":"2019-10-19","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/:3:2","tags":["Python学习之路"],"title":"Python学习之路-常量与变量","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/"},{"categories":["生活"],"content":"前言 房租差600上班骑车半个小时和坐地铁+公交1个小时大家会怎么选呢 ","date":"2019-10-19","objectID":"/%E7%A7%9F%E6%88%BF%E6%97%A5%E8%AE%B0/:1:0","tags":["租房"],"title":"租房日记","uri":"/%E7%A7%9F%E6%88%BF%E6%97%A5%E8%AE%B0/"},{"categories":["生活"],"content":"公司搬家 由于种种原因公司搬家了，从一个大型商业广场搬家到了一个动物园边上的别墅区。由于临近中秋和国庆，也没来得及仔细想想，还沉浸在搬家的喜悦之中。等收假回来发现，上班变得不方便了，没有直达的地铁，换乘得往回坐一站，还得站外换乘，成本高了不少；坐公交得先骑车1.5km才能到公交车站，下车后还要走1.5km上班时间从原来的20分钟内，变成四五十分钟。现在公司也不属于核心商圈了，感觉没必要租那么贵的房子，虽然房子还有一个多月才到期，但是换房子的想法涌上心头。 ","date":"2019-10-19","objectID":"/%E7%A7%9F%E6%88%BF%E6%97%A5%E8%AE%B0/:2:0","tags":["租房"],"title":"租房日记","uri":"/%E7%A7%9F%E6%88%BF%E6%97%A5%E8%AE%B0/"},{"categories":["生活"],"content":"找房子 由于第一次租房没有经验，找的中介租的房子，导致房租很贵，一年就花了3万多，虽然房子离公司很近，但是由于是老小区隔音非常差，我的睡眠质量又不是很好，这次一定要换一个隔音好的房子。我看了一下地图，由于公司位于长宁区得到边缘，与闵行、青浦相隔。考虑到虹桥机场离的很近，放弃了闵行和长宁附近。根据链家的房租地图和知乎上的租房相关的文章，青浦比长宁的房租会便宜很多，所以准备在青浦往西寻找租房的地点，于是开始在网上寻找那一块的房子。在一个机缘巧合下我发现闲鱼上有个租房信息，在一个比较偏的地方有一个60+的单间，一室一厅一厨一卫加一个4-5平的阳台，看图片第一眼就看中了，当天就约着去看房了，那天到哪里很晚，都没有公交车了，打车过去的。看完我就决定租这里了，就开始谈房租，2200一个月，押一付三，很快就签了合同。 ","date":"2019-10-19","objectID":"/%E7%A7%9F%E6%88%BF%E6%97%A5%E8%AE%B0/:3:0","tags":["租房"],"title":"租房日记","uri":"/%E7%A7%9F%E6%88%BF%E6%97%A5%E8%AE%B0/"},{"categories":["生活"],"content":"搬家 房子是周三签的合同，周四就约了一个货拉拉，然后开始收拾房间，开始了断舍离的部分，我发现我真的是买太多东西了，整整花了两个晚上才将东西打包好。周六一早就开始搬家了，由于老房子没有电梯，就让货拉拉的师傅帮忙搬，给他加了30块辛苦费。搬家整个过程还是很顺利的，从9点半出发到10点40就已经完成了，最后花了120块钱，也还算比较划算了。下午我就开始了收拾房间，整整花了3个多小时才弄完。 ","date":"2019-10-19","objectID":"/%E7%A7%9F%E6%88%BF%E6%97%A5%E8%AE%B0/:4:0","tags":["租房"],"title":"租房日记","uri":"/%E7%A7%9F%E6%88%BF%E6%97%A5%E8%AE%B0/"},{"categories":["生活"],"content":"后记 晚上躺在床上想想这次租房的经历，发现还是有很多要总结的地方。首先说租房，由于当时非常想换房子了，租房也没有看很多，发现了一个合适的，就特别想租，房东说租的很快都不让签到周末，这三天时间都浪费了，而且都没有仔细想想不方便的地方。虽然从公司坐地铁到下地铁也有半个小时，但是转公交的那趟公交最后一班是7点，而且发车间隔20分钟，要是遇到加班或者什么的很有可能赶不上车，那最后这3km就得走回去或者打车。最后是地理位置，中午的时候想点个外卖才发现外卖都没多少，不过有个不小的厨房，以后争取多自己做饭吧。 这次租的房子整体上还是比较满意的，一个人住这个大房子还是蛮舒服的，就是还是有很多细节需要优化，就当做经验吧 ","date":"2019-10-19","objectID":"/%E7%A7%9F%E6%88%BF%E6%97%A5%E8%AE%B0/:5:0","tags":["租房"],"title":"租房日记","uri":"/%E7%A7%9F%E6%88%BF%E6%97%A5%E8%AE%B0/"},{"categories":["Python"],"content":"简介 上一篇讲到Python中的语句提到很多运算符，本篇来总结一下各类运算符的作用与用法。 ","date":"2019-10-12","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%BF%90%E7%AE%97%E7%AC%A6/:1:0","tags":["Python学习之路"],"title":"Python学习之路-运算符","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["Python"],"content":"算数运算符 运算符 描述 实例 + 加 1+1=2 - 减 1-1=0 * 乘 1*1=1 ** 幂次方 2**3=8 / 除 2/1=2 // 取整 5//2=2 % 取余 5%2=1 参考 在 Python 中 * 运算符还可以用于字符串，计算结果就是字符串重复指定次数的结果 ","date":"2019-10-12","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%BF%90%E7%AE%97%E7%AC%A6/:2:0","tags":["Python学习之路"],"title":"Python学习之路-运算符","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["Python"],"content":"比较运算符 运算符 描述 == 比较两个数据的值是否 相等，如果是，则条件成立，返回 True != 比较两个数据的值是否 不相等，如果是，则条件成立，返回 True \u003e 比较左边数的值是否 大于 右边数的值，如果是，则条件成立，返回 True \u003c 比较左边数数的值是否 小于 右边数的值，如果是，则条件成立，返回 True \u003e= 比较左边数的值是否 大于或等于 右边数的值，如果是，则条件成立，返回 True \u003c= 比较左边数数的值是否 小于或等于 右边数的值，如果是，则条件成立，返回 True 参考 Python中所有数据类型都可以用==与!=比较运算符 ","date":"2019-10-12","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%BF%90%E7%AE%97%E7%AC%A6/:3:0","tags":["Python学习之路"],"title":"Python学习之路-运算符","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["Python"],"content":"逻辑运算符 运算符 逻辑表达式 描述 and a and b 只有 a 和 b 的值都为 True，才会返回 True否则只要 a 或者 b 有一个值为 False，就返回 False or a or b 只要 a 或者 b 有一个值为 True，就返回 True只有 a 和 b 的值都为 False，才会返回 False not not a 如果 a 为 True，返回 False如果 a 为 False，返回 True ","date":"2019-10-12","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%BF%90%E7%AE%97%E7%AC%A6/:4:0","tags":["Python学习之路"],"title":"Python学习之路-运算符","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["Python"],"content":"赋值运算符 运算符 描述 实例 = 赋值运算符 c = a + b 将 a + b 的运算结果赋值为 c += 加法赋值运算符 c += a 等效于 c = c + a -= 减法赋值运算符 c -= a 等效于 c = c - a *= 乘法赋值运算符 c *= a 等效于 c = c * a /= 除法赋值运算符 c /= a 等效于 c = c / a //= 取整除赋值运算符 c //= a 等效于 c = c // a %= 取余数赋值运算符 c %= a 等效于 c = c % a **= 幂赋值运算符 c **= a 等效于 c = c** a 注意 赋值运算符中间不能使用空格 ","date":"2019-10-12","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%BF%90%E7%AE%97%E7%AC%A6/:5:0","tags":["Python学习之路"],"title":"Python学习之路-运算符","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["Python"],"content":"成员运算符 运算符 描述 实例 in 如果在指定的序列中找到值返回 True，否则返回 False 3 in (1, 2, 3) 返回 True not in 如果在指定的序列中没有找到值返回 True，否则返回 False 3 not in (1, 2, 3) 返回 False 注意 在对 字典 操作时，判断的是 字典的键 ","date":"2019-10-12","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%BF%90%E7%AE%97%E7%AC%A6/:6:0","tags":["Python学习之路"],"title":"Python学习之路-运算符","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["Python"],"content":"运算符的优先级 以下表格的算数优先级由高到最低顺序排列 运算符 描述 ** 幂 (最高优先级) * / % // 乘、除、取余数、取整除 + - 加法、减法 \u003c= \u003c \u003e \u003e= 比较运算符 == != 等于运算符 = %= /= //= -= += *= **= 赋值运算符 in not in 成员运算符 not or and 逻辑运算符 ","date":"2019-10-12","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%BF%90%E7%AE%97%E7%AC%A6/:7:0","tags":["Python学习之路"],"title":"Python学习之路-运算符","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["Python"],"content":"简介 Python的设计目标之一是让代码具备高度的可阅读性。在设计时尽量使用经常使用的标点符号和英文单字，让代码看起来整洁美观。 ","date":"2019-10-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%AD%E6%B3%95/:1:0","tags":["Python学习之路"],"title":"Python学习之路-语法","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%AD%E6%B3%95/"},{"categories":["Python"],"content":"缩进 在Python中缩进表示语句块的开始和结束，作用等同于Java、Go中的大括号。增加缩进表示语句块的开始，而减少缩进则表示语句块的结束。缩进成为了语法的一部分，违反了“缩进规则”的程序不能通过解释器解释。 提示 根据PEP 8的规定，使用4个空格来表示每级缩进。使用Tab字符和其它数目的空格虽然都可以被解释器识别，但不符合编码规范，偏向使用Tab字符的程序员可以设置文本编辑器将Tab键转换为4个空格。 ","date":"2019-10-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%AD%E6%B3%95/:2:0","tags":["Python学习之路"],"title":"Python学习之路-语法","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%AD%E6%B3%95/"},{"categories":["Python"],"content":"标识符 标识符就是名字。可用于标识符的字符为：大写字母A至Z和小写字母a至z，下划线_以及数字0至9，但不能以数字开头。不能定义关键字标识符。 有关包含下划线的标识符有以下命名约定： 类型 实例 备注 单下划线开头 _abc 私有化属性或方法。通过from M import *将不能导入。 单下划线结尾 acb_ 避免与python关键字的命名冲突。 双下划线开头 __abc 避免与子类中的属性命名冲突，无法在外部直接访问(名字重整所以访问不到) 双下划线开头双下划线结尾 __abc__ 用户名字空间的魔法对象或属性。例如:__name__ , 不要使用这样的方式命名变量或函数。 ","date":"2019-10-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%AD%E6%B3%95/:3:0","tags":["Python学习之路"],"title":"Python学习之路-语法","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%AD%E6%B3%95/"},{"categories":["Python"],"content":"关键字 关键字是保留标识符，不能用作变量名、函数名或任何其他标识符。Python共有35个关键字。 逻辑运算符 and：只有两边的值都为True才会返回True，否则只要两边有一个值为False，就返回False not：如果值为True，返回False。如果值为False，返回True or：只要两边有一个值为True，就返回True。只有两边的值都为False，才会返回False 协程 async：将普通函数和生成器函数包装成异步函数和异步生成器。 await：挂起自身的协程，并等待另一个协程完成直到返回结果(只能出现在通过async修饰的函数中，否则会报SyntaxError错误) 布尔值 False：不成立则为False，等同于0 True：成立则为True，等同于1 循环 break：跳出当前循环 continue：继续循环的下一个迭代 for：创建for循环 while：创建while循环 in：for循环迭代序列或者检查序列中是否存在值 类与函数 class：定义一个类 def：定义一个函数 lambda：创建匿名函数 return：退出函数并返回值 yield：结束函数并返回生成器 条件语句 assert：测试代码中的条件是否返回True，否则程序将引发AssertionError elif：等同于else if else：在条件为False时执行else下的代码块 if：创建条件语句，并且仅当条件为True时，才允许执行代码块。 异常 except：在try ... except块中使用了关键字 except。它定义 try 块引发错误时要运行的代码块。 finally：在try ... except块中使用。它定义的代码块，在try...except...else块结束时运行，无论try块是否引发错误，都将执行 finally 块。 raise：抛出异常。 with： 作用和使用try/finally语句一样，帮助我们简化异常处理。通常用于文件相关处理。 try：用于try...except块中，它定义了代码测试块是否包含任何错误。 模块 from：从模块中仅导入指定的部分 import：导入模块 as：给模块创建别名 变量 global：声明全局变量 is：判断两个变量是否相等 nonlocal：声明非局部变量 其他 del：删除对象 None：表示null值 pass：null语句(什么都不做的语句) 提示 刚开始接触关键字不用详细了解具体含义，先记住这些关键字不要让标识符取成关键字，后面慢慢接触到这些关键字的时候边了解边使用就可以 ","date":"2019-10-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%AD%E6%B3%95/:4:0","tags":["Python学习之路"],"title":"Python学习之路-语法","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%AD%E6%B3%95/"},{"categories":["Python"],"content":"控制流和语句 ","date":"2019-10-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%AD%E6%B3%95/:5:0","tags":["Python学习之路"],"title":"Python学习之路-语法","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%AD%E6%B3%95/"},{"categories":["Python"],"content":"控制流 在程序开发中，存在三种控制流： 顺序结构：从上到下顺序执行代码 分支结构：根据条件判断决定执行代码的分支 循环结构：让特定代码重复执行 根据控制流衍生出了各类语句 ","date":"2019-10-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%AD%E6%B3%95/:5:1","tags":["Python学习之路"],"title":"Python学习之路-语法","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%AD%E6%B3%95/"},{"categories":["Python"],"content":"赋值 等号=为赋值语句，支持同时给多个变量赋值，还可以通过赋值语句改变多个变量的值。 ","date":"2019-10-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%AD%E6%B3%95/:5:2","tags":["Python学习之路"],"title":"Python学习之路-语法","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%AD%E6%B3%95/"},{"categories":["Python"],"content":"判断 简介 又称为分支语句。当条件成立时做某件时间，不成立时做另一件事或者什么都不做。 用法 Python中的判断语句格式为： if 条件1: 满足条件1的代码块 elif 条件2: 满足条件2的代码块 else: 其他情况的代码块 通过if来发起判断语句，当if条件成立时执行if下的代码块，条件不成立时执行else下的代码块。当存在多个条件时可以通过elif来分隔各个条件，执行不同条件下的代码块。 ","date":"2019-10-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%AD%E6%B3%95/:5:3","tags":["Python学习之路"],"title":"Python学习之路-语法","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%AD%E6%B3%95/"},{"categories":["Python"],"content":"循环 简介 while循环是让指定代码按照条件指定执行次数 用法 Python中的判断语句格式为： while 条件(判断计数器是否达到目标次数): 满足条件代码块 ...... 处理条件(计数器+1) 技巧 Python计数从0开始 警告 Python计数从0开始 在使用while时要注意死循环的问题，由于某些原因，忘记在循环内部修改循环的判断条件，导致循环持续执行，程序无法终止！ 结束循环 可以通过break或者continue来结束当前循环。 break：某一条件满足时退出循环 continue：某一条件满足时不执行当前循环，进行下一次循环 ","date":"2019-10-05","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%AD%E6%B3%95/:5:4","tags":["Python学习之路"],"title":"Python学习之路-语法","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%AD%E6%B3%95/"},{"categories":["Python"],"content":"将注释放在Python语法前面足以提现它的重要性。 ","date":"2019-09-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%B3%A8%E9%87%8A/:0:0","tags":["Python学习之路"],"title":"Python学习之路-注释","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%B3%A8%E9%87%8A/"},{"categories":["Python"],"content":"注释的作用 一个好的程序中注释是不可缺失的一环。在程序中对某些代码进行标注说明，可以增强程序的可读性。在团队协同开发中，良好的注释可以提高开发效率。 ","date":"2019-09-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%B3%A8%E9%87%8A/:1:0","tags":["Python学习之路"],"title":"Python学习之路-注释","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%B3%A8%E9%87%8A/"},{"categories":["Python"],"content":"什么时候需要使用注释？ 注释不是越多越好，对于一目了然的代码，不需要添加注释 对于 复杂的操作，应该在操作开始前写上思路的注释 对于 不是一目了然的代码，应在其行尾添加注释(为了提高可读性，注释应该至少离开代码 2 个空格) 绝不要描述代码，假设阅读代码的人比你更懂 Python，他只是不知道你的代码要做什么 提示 在一些正规的开发团队，通常会有 代码审核 的惯例一个团队中彼此阅读对方的代码 ","date":"2019-09-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%B3%A8%E9%87%8A/:2:0","tags":["Python学习之路"],"title":"Python学习之路-注释","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%B3%A8%E9%87%8A/"},{"categories":["Python"],"content":"注释类型 ","date":"2019-09-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%B3%A8%E9%87%8A/:3:0","tags":["Python学习之路"],"title":"Python学习之路-注释","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%B3%A8%E9%87%8A/"},{"categories":["Python"],"content":"单行注释 以 # 开头，# 右边的所有东西都被当做说明文字，而不是真正要执行的程序，只起到辅助说明作用 提示 *为了保证代码的可读性，*# 后面建议先添加一个空格，然后再编写相应的说明文字。需要注意的是，为了保证代码的可读性，注释和代码之间 至少要有 两个空格 ","date":"2019-09-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%B3%A8%E9%87%8A/:3:1","tags":["Python学习之路"],"title":"Python学习之路-注释","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%B3%A8%E9%87%8A/"},{"categories":["Python"],"content":"多行注释 如果要写的注释信息很多，一行无法写完，就可以使用多行注释。在Python程序中使用多行注释，可以用一对连续的三个引号(单引号和双引号都可以)。 ","date":"2019-09-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%B3%A8%E9%87%8A/:3:2","tags":["Python学习之路"],"title":"Python学习之路-注释","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%B3%A8%E9%87%8A/"},{"categories":["Python"],"content":"文档 Python有一种独一无二的的注释方式: 使用文档注释。文档注释是包、模块、 类或函数里的第一个语句。这些注释可以通过对象的__doc__成员被自动提取, 并且被pydoc所用.对文档注释的惯例是使用三重双引号”\"\"( PEP-257 )。一个文档注释应该这样组织: 首先是一行以句号，问号或惊叹号结尾的概述(或者该文档注释单纯只有一行)。接着是一个空行，接着是文档注释剩下的部分，它应该与文档注释的第一行的第一个引号对齐。 ","date":"2019-09-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%B3%A8%E9%87%8A/:3:3","tags":["Python学习之路"],"title":"Python学习之路-注释","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%B3%A8%E9%87%8A/"},{"categories":["Python"],"content":"模块 每个文件应该包含一个许可样板. 根据项目使用的许可(例如, Apache 2.0, BSD, LGPL, GPL), 选择合适的样板. ","date":"2019-09-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%B3%A8%E9%87%8A/:3:4","tags":["Python学习之路"],"title":"Python学习之路-注释","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%B3%A8%E9%87%8A/"},{"categories":["Python"],"content":"函数和方法 下文所指的函数,包括函数、方法以及生成器。一个函数必须要有文档字符串, 除非它满足以下条件: 外部不可见 非常短小 简单明了 注释应该包含函数做什么，以及输入和输出的详细描述。通常不应该描述”怎么做”，除非是一些复杂的算法.。注释应该提供足够的信息，当别人编写代码调用该函数时，他不需要看一行代码，只要看文档字符串就可以了。 对于复杂的代码, 在代码旁边加注释会比使用函数注释更有意义. 关于函数的几个方面应该在特定的小节中进行描述记录，这几个方面如下文所述.。每节应该以一个标题行开始，标题行以冒号结尾， 除标题行外。节的其他内容应被缩进2个空格。 Args：列出每个参数的名字, 并在名字后使用一个冒号和一个空格。分隔对该参数的描述，如果描述太长超过了单行80字符，使用2或者4个空格的悬挂缩进(与文件其他部分保持一致)。描述应该包括所需的类型和含义。 如果一个函数接受foo(可变长度参数列表)或者**bar (任意关键字参数), 应该详细列出foo和**bar. Returns(或者 Yields: 用于生成器)： 描述返回值的类型和语义。如果函数返回None，这一部分可以省略。 Raises：列出与接口有关的所有异常。 ","date":"2019-09-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%B3%A8%E9%87%8A/:3:5","tags":["Python学习之路"],"title":"Python学习之路-注释","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%B3%A8%E9%87%8A/"},{"categories":["Python"],"content":"类 类应该在其定义下有一个用于描述该类的文档字符串. 如果你的类有公共属性(Attributes), 那么文档中应该有一个属性(Attributes)段. 并且应该遵守和函数参数相同的格式. 参考 Python风格规范-注释 ","date":"2019-09-28","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%B3%A8%E9%87%8A/:3:6","tags":["Python学习之路"],"title":"Python学习之路-注释","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%B3%A8%E9%87%8A/"},{"categories":["Python"],"content":"设计哲学 Python的设计哲学是“优雅”、“明确”、“简单”。它的重要准则被称为“Python之禅”。Python之禅又名PEP 20，在Python解释器内运行import this可以获得完整的列表，下面是我的翻译与解读： 提姆·彼得斯（Tim Peters）撰写的《 Python之禅 》 优雅胜于丑陋（以编写优雅的代码为目标） 明确胜于晦涩（明确的代码增强了程序的可读性） 简单胜于复杂（简单的代码能解决复杂的问题） 复杂胜于凌乱（如果项目变得复杂，那代码间也要保持简洁） 扁平胜于嵌套（优雅的代码应该是扁平的，不能有太多嵌套） 间隔胜于紧凑（优雅的代码应当有适当的间隔，不要写一些为了缩减代码丢失了可读性） 可读性很重要（代码的可读的非常重要） 即便假借特例的实用性之名，也不可违背这些规则（这些规则是写Python程序的必备条件） 不要包容所有错误，除非你确定需要这样做（代码中不能存在错误，要善于使用捕获异常） 当存在多种可能，不要尝试去猜测 而是尽量找一种，最好是唯一一种明显的解决方案 虽然这并不容易，因为你不是 Python 之父（虽然你不是Guido，在设计程序时应该多思考，找出最好的解决方案） 做也许好过不做，但不假思索就动手还不如不做（要思考好之后再开始写代码） 如果你无法向人描述你的方案，那肯定不是一个好方案；反之亦然（好的方案是人人都能懂得方案） 命名空间是一种绝妙的理念，我们应当多加利用（要善于利用命令空间） Python开发的哲学是“用一种方法，最好是只有一种方法来做一件事”。在设计Python程序时，如果面临多种选择，一般会拒绝花俏的语法，而选择明确没有或者很少有歧义的语法。 ","date":"2019-09-21","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC/:1:0","tags":["Python学习之路"],"title":"Python学习之路-编码风格","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC/"},{"categories":["Python"],"content":"编码规范 PEP 8是由Guido van Rossum , Barry Warsaw , Nick Coghlan三位共同编写的一个Python代码风格规范。可以在这里查看具体内容，如果英文不好可以在Python风格指南中查看主要的内容 ","date":"2019-09-21","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC/:2:0","tags":["Python学习之路"],"title":"Python学习之路-编码风格","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC/"},{"categories":["Python"],"content":"检查工具 pylint是一个Python代码风格的检查工具, 它依据的标准是Guido van Rossum的PEP 8。 pylint类似于PyChecker, 但提供了更多的功能, 如检查代码行的长度, 检查变量命名是否符合编码规范, 或检查声明的接口是否被真正的实现, 完整的检查功能请参见http://www.logilab.org/card/pylintfeatures。 pylint的最大优势在于其高度的可配置化和可定制化，你可以很容易地写一个小插件添加个人功能。 ","date":"2019-09-21","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC/:2:1","tags":["Python学习之路"],"title":"Python学习之路-编码风格","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC/"},{"categories":["Python"],"content":"用法示例 pylint.bat --reports=n --include-ids=y --disable-msg=W0122,W0702 xlsconverter.py \u003e lint_result.txt 其中： –reports=n 表示不产生输出报告 –include-ids=y 表示输出的错误信息包含错误编号 –disable-msg=W0122,W0702 表示W0122和W0702这两个警告信息被过滤掉了 xlsconverter.py 是被检查的脚本 检查的结果被输出到了lint_result.txt中。 提示 任何语言的程序员，编写出符合规范的代码，是开始程序生涯的第一步。PEP 20和PEP 8陪伴我们整个学习和使用Python的过程。 ","date":"2019-09-21","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC/:2:2","tags":["Python学习之路"],"title":"Python学习之路-编码风格","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC/"},{"categories":["Python"],"content":"Python解释器 ","date":"2019-09-14","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellopython/:1:0","tags":["Python学习之路"],"title":"Python学习之路-HelloPython","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellopython/"},{"categories":["Python"],"content":"简介 前面说到Python是解释型语言，Python解释器的作用就是用于\"翻译\"Python程序。Python规定了一个Python语法规则，根据该规则可编写Python解释器。 ","date":"2019-09-14","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellopython/:1:1","tags":["Python学习之路"],"title":"Python学习之路-HelloPython","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellopython/"},{"categories":["Python"],"content":"常见的Python解释器 CPython：官方提供的解释器，由C语言实现，这是最常用的Python解释器。 PyPy：一种用Python语言实现的解释器，可用于替代CPython。PyPy采用即时编译通常运行速度比CPython快很多。多数Python代码可以很好的运行在PyPy之上，除非代码依赖于CPython扩展， Jython:一种用Java语言实现的解释器，Jython可以直接调用Java的各种函数库。 ","date":"2019-09-14","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellopython/:1:2","tags":["Python学习之路"],"title":"Python学习之路-HelloPython","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellopython/"},{"categories":["Python"],"content":"安装 Python是一门跨平台的脚本语言，不同平台的安装过程稍有区别。 注意 以下安装部分内容仅针对CPython。内容参考Python官方的安装教程，由我摘选出来各平台比较方便快捷的安装方式。如果不符合需求，可以查看官方安装教程搜索需要的内容。 ","date":"2019-09-14","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellopython/:2:0","tags":["Python学习之路"],"title":"Python学习之路-HelloPython","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellopython/"},{"categories":["Python"],"content":"Linux Python预装在大多数Linux发行版上，并作为一个包提供给所有其他用户。 也可以从源代码编译最新版本的Python。 如果Python没有预先安装并且不在发行版提供的库中，也可以轻松地为自己使用的发行版创建包。 参阅以下链接： Debian、OpenSuse、Fedora、Slackware 从源代码编译 首先要做的是获取 source 。您可以下载最新版本的源代码，也可以直接提取最新的 clone 。 构建过程由常用命令组成： ./configure make make install 提示 特定Unix平台的配置选项和注意事项通常记录在Python源代码的根目录下的 README.rst 文件中。 警告 make install 可以覆盖或伪装 python3 二进制文件。因此，建议使用 make altinstall 而不是 make install ，因为后者只安装了 *exec_prefix*/bin/python*version* 。 ","date":"2019-09-14","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellopython/:2:1","tags":["Python学习之路"],"title":"Python学习之路-HelloPython","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellopython/"},{"categories":["Python"],"content":"Windows 从Python官方获取安装包 根据需求进行安装包安装 安装完毕后将Python解释器的路径添加到系统环境变量中 提示 √上Add Python 3.x to PATH后安装程序会自动将PythonPython解释器的路径添加到系统环境变量中) ","date":"2019-09-14","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellopython/:2:2","tags":["Python学习之路"],"title":"Python学习之路-HelloPython","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellopython/"},{"categories":["Python"],"content":"Mac OS X 通过Homebrew安装 提示 使用brew install python3默认安装最新版本，可以通过安装pyenv后安装指定版本的Python。根据需求自行选择 安装pyenv brew install pyenv 将pyenv添加到shell中 echo -e 'if which pyenv \u003e /dev/null; then eval \"$(pyenv init -)\"; fi'\u003e\u003e ~/.bash_profile 使shell生效 exec \"$SHELL\" 查看可安装的Python版本 pyenv install -l 安装需求的Python版本 pyenv install 3.7.1 指定全局的Python环境 pyenv global 3.7.1 查看已安装的Python版本和正在使用的Python版本 pyenv versions ","date":"2019-09-14","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellopython/:2:3","tags":["Python学习之路"],"title":"Python学习之路-HelloPython","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellopython/"},{"categories":["Python"],"content":"检查 安装完毕之后可以通过查看Python版本号的方式来检查是否安装成功 python3 -V Python 3.7.7 或者进入Python交互式命令行中查看，在交互式命令行输入python3能进入交互式命令行并且版本对则安装成功 ","date":"2019-09-14","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellopython/:2:4","tags":["Python学习之路"],"title":"Python学习之路-HelloPython","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellopython/"},{"categories":["Python"],"content":"执行程序的方式 ","date":"2019-09-14","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellopython/:3:0","tags":["Python学习之路"],"title":"Python学习之路-HelloPython","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellopython/"},{"categories":["Python"],"content":"交互式命令行 简介 在控制台输入Python3即可进入Python3解释器集成的一个交互式命令行，可以在交互式命令行中执行程序。 python3 Python 3.7.1 (default, Oct. 20, 2018, 15:43:33) [Clang 11.0.0 (clang-1100.0.33.17)] on darwin Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. \u003e\u003e\u003e 这里我们可以看到Python的版本、当前版本发布的时间和查询相关信息的指令，例如输入help()可以查询到帮助相关的信息。 使用 在交互式命令行中写入print('Hello Python!')按回车 \u003e\u003e\u003e print(\"Hello Python!\") Hello Python! 这里使用了Python一个内置的print()方法，其作用是将传入的对象在控制台打印出来。就这么简单的完成了学习Python的第一个程序，可以看到Python的语法非常简单易懂。 提示 通过quit()方法退出Python的交互式命令行。 ","date":"2019-09-14","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellopython/:3:1","tags":["Python学习之路"],"title":"Python学习之路-HelloPython","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellopython/"},{"categories":["Python"],"content":"通过Python解释器 简介 由于在交互式命令行中编写的Python代码无法保存，当需要保存代码的时候可以用文本编辑器或集成开发环境来编写Python代码。这时候就可以用Python解释器来执行Python程序。 文本编辑器是计算机软件中的一种。主要用于用来编写和查看文本文件。有一些特殊的文本编辑器支持增加自有的格式来丰富文档的表现形式。操作系统或者集成开发环境通常会带有可以查看和编辑纯文本的编辑器，可增加格式的文本编辑器通常是个人用户或者公司在制作需要格式的文件中使用。因为程序和程序的配置文件通常是以纯文本形式储存，所以程序员也需要使用纯文本编辑器来编辑程序和配置文件。 集成开发环境（Integrated Development Environment，简称IDE）是一种辅助程序开发人员开发软件的应用软件，在开发工具内部就可以辅助编写源代码文本、并编译打包成为可用的程序，有些甚至可以设计图形接口。IDE通常包括编程语言编辑器、自动构建工具、通常还包括调试器。 在初学阶段建议用文本编辑器来进行开发，更有利于掌握Python基础相关知识。 使用 首先打开一个文本编辑器(系统自带的即可)，写入print(\"Hello Python!\") 注意 这句话一定要顶格写，Python对缩进的要求非常严格。注意print方法名的小写和中英文字符问题！ 将文本保存为Hello.py在控制台中切换到当前目录，输入python3 Hello.py来运行该程序 python3 Hello.py Hello Python! 看到Hello Python!则第一个程序执行成功。 说明 Python程序以.py结尾。控制台中输入的python3为指定的Python解释器 ","date":"2019-09-14","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellopython/:3:2","tags":["Python学习之路"],"title":"Python学习之路-HelloPython","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-hellopython/"},{"categories":["Python"],"content":"本篇文章由我归纳总结而来，为想要了解学习Python的朋友提供参考。大部分内容参考维基百科 ","date":"2019-09-07","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/:0:0","tags":["Python学习之路"],"title":"Python学习之路-认识Python","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/"},{"categories":["Python"],"content":"简介 Python是一种广泛使用的解释型、高级和通用的编程语言。Python支持多种编程范型，包括函数式、指令式、结构化、面向对象和反射式编程。它拥有动态类型系统和垃圾回收功能，能够自动管理内存使用，并且其本身拥有一个巨大而广泛的标准库。 Python是一种易于学习又功能强大的编程语言。它提供了高效的高级数据结构，还能简单有效地面向对象编程。Python 优雅的语法和动态类型，以及解释型语言的本质，使它成为多数平台上写脚本和快速开发应用的理想语言。 ","date":"2019-09-07","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/:1:0","tags":["Python学习之路"],"title":"Python学习之路-认识Python","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/"},{"categories":["Python"],"content":"Python的起源 ","date":"2019-09-07","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/:2:0","tags":["Python学习之路"],"title":"Python学习之路-认识Python","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/"},{"categories":["Python"],"content":"诞生 由于吉多·范罗苏姆(Guido van Rossum)参与设计的ABC语言没有成功，他在1989年的圣诞节决定开发一个新的解释型语言作为ABC语言的替代者。在他看来ABC语言的失败的原因是其非开放的，他决心在Python中避免这个错误，后来由于他的开放形成了庞大的Python社区。之所以取名为Python，是因为他非常喜欢BBC电视剧中的蒙提·派森的飞行马戏团（Monty Python’s Flying Circus）。 ","date":"2019-09-07","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/:2:1","tags":["Python学习之路"],"title":"Python学习之路-认识Python","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/"},{"categories":["Python"],"content":"发展 1991年2月第一个Python解释器(标记为版本0.9.0)诞生。这时就已经存在了带继承的类、异常处理、函数和核心数据类型list、dict、str等 1994年1月Python达到了版本1.0。这个发行版主要新特征是包括了函数式编程工具lambda、map、filter和reduce。Python 1.4增加了受Modula-3启发的关键字参数和对复数的内建支持，还包含采取名字修饰的一种基本形式[数据隐藏。 2000年10月16日Python 2.0发布。增加了列表推导式，这是从函数式编程语言SETL和Haskell中引入的。它还向垃圾收集系统增加了环检测算法，并且支持Unicode。Python 2.1支持了嵌套作用域，就像其他静态作用域语言一样。Python 2.2的重大革新是将Python的类型(用C写成)和类(用Python写成)统一入一个层级，使得Python的对象模型成为纯粹和一致的面向对象的模型；还增加了迭代器，受CLU和Icon启发的生成器，和描述器协议。Python 2.4加入了集合数据类型，和函数修饰器。Python 2.5加入了with语句。 Python 3.0于2008年12月3日发布，它对语言做了较大修订而不能完全后向兼容。Python 3发行包括了2to3实用工具，它（至少部分的）自动将Python 2代码转换成Python 3代码。Python 3的很多新特性后来也被移植到旧的Python 2.6/2.7版本中。 Python 2.7的产品寿命结束日期最初设定为2015年，出于对大量的现存代码不能前向移植到Python 3的关切而延期至2020年。随着Python 2的产品寿命结束，只有Python 3.8和后续版本仍被完全支持。 在2020年12月，活跃的Python核心开发者选举Barry Warsaw、Brett Cannon、Carol Willing、Pablo Galindo Salgado和Thomas Wouters为2021年度“掌控委员会”的五位成员来领导这个项目。 ","date":"2019-09-07","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/:2:2","tags":["Python学习之路"],"title":"Python学习之路-认识Python","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/"},{"categories":["Python"],"content":"解释型语言与编译型语言 ","date":"2019-09-07","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/:3:0","tags":["Python学习之路"],"title":"Python学习之路-认识Python","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/"},{"categories":["Python"],"content":"区别 高级语言设计的程序必须经过“翻译”成机器语言以后才能被机器执行。“翻译”的方法有两种，一种是解释，一种是编译。两种方式的区别在于“翻译”时间点不同，解释型语言编写的程序不需要编译，程序在运行时才翻译成机器语言，每执 行一次都要翻译一次。编译型语言编写的程序在执行之前需要进行的编译，把程序编译成机器语言的文件，运行时不需要重新“翻译”，直接使用编译的结果就行了。 ","date":"2019-09-07","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/:3:1","tags":["Python学习之路"],"title":"Python学习之路-认识Python","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/"},{"categories":["Python"],"content":"对比 速度：编译型语言比解释型语言执行速度快 跨平台性：解释型语言比编译型语言跨平台性好 ","date":"2019-09-07","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/:3:2","tags":["Python学习之路"],"title":"Python学习之路-认识Python","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/"},{"categories":["Python"],"content":"特点 ","date":"2019-09-07","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/:4:0","tags":["Python学习之路"],"title":"Python学习之路-认识Python","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/"},{"categories":["Python"],"content":"完全面向对象的语言 在 Python 中一切皆对象 完全支持继承、重载、多重继承 支持重载运算符，也支持泛型设计 ","date":"2019-09-07","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/:4:1","tags":["Python学习之路"],"title":"Python学习之路-认识Python","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/"},{"categories":["Python"],"content":"拥有一个强大的标准库 ​ Python 语言的核心只包含 数字、字符串、列表、字典、文件 等常见类型和函数，而由 Python 标准库提供了 系统管理、网络通信、文本处理、数据库接口、图形系统、XML 处理 等额外的功能 ","date":"2019-09-07","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/:4:2","tags":["Python学习之路"],"title":"Python学习之路-认识Python","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/"},{"categories":["Python"],"content":"Python 社区 ​ 社区提供了数量庞大的第三方模块，使用方式与标准库类似。它们的功能覆盖 科学计算、人工智能、机器学习、Web 开发、数据库接口、图形系统 等多个领域 ","date":"2019-09-07","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/:4:3","tags":["Python学习之路"],"title":"Python学习之路-认识Python","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/"},{"categories":["Python"],"content":"为什么选择Python Life is short, you need Python。 ","date":"2019-09-07","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/:5:0","tags":["Python学习之路"],"title":"Python学习之路-认识Python","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/"},{"categories":["Python"],"content":"参考 提示 以下顺序不分先后 Python维基百科 解释型语言 编译型语言 ","date":"2019-09-07","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/:6:0","tags":["Python学习之路"],"title":"Python学习之路-认识Python","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AE%A4%E8%AF%86python/"},{"categories":["Python"],"content":"Python学习之路 Python 是一种易于学习又功能强大的编程语言。目前网上有许多Python相关文档，质量参差不齐，更新时间也都非常久远。也没有看到有相关系统全面的文档，所以我想通过我的努力打造一个全面且及时更新的Python教程，在复习的同时也为其他Python爱好者做出贡献。 由于本人能力有限，所以本文档仅适用于想系统的学习Python的朋友。本文档所有文章皆采用 知识共享署名-非商业性使用 4.0 国际许可协议 进行许可，如果发现文档中存在错误，请联系我修正；如果发现文档中存在侵权情况，请联系我删除相关内容。文档欢迎转载，转载请注明出处，感谢您对Python社区的贡献。 通过本文档你能了解到从Python基础到Python标准库、Web开发、爬虫、数据分析、机器学习等方面的内容。由于Python2.7已于2020年1月1日起停止维护，本文档中的内容全部针对Python3.X版本。 Life is short, you need Python。接下来就让我们开始遨游在Python的世界中吧！ ","date":"2019-09-01","objectID":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%96%87%E6%A1%A3%E8%AF%B4%E6%98%8E/:1:0","tags":["Python学习之路"],"title":"Python学习之路-文档说明","uri":"/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E6%96%87%E6%A1%A3%E8%AF%B4%E6%98%8E/"},{"categories":["Golang"],"content":"前言 最近对Go语言非常感兴趣，准备花一段时间来学习，此系列文章用于学习笔记整理与学习记录。 ","date":"2019-08-03","objectID":"/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/:1:0","tags":["Go"],"title":"Go语言学习之旅-开篇","uri":"/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/"},{"categories":["Golang"],"content":"简介 Go（又称 Golang）是 Google的 Robert Griesemer，Rob Pike 及 Ken Thompson 开发的一种静态强类型、编译型语言。Go 语言语法与 C相近，但功能上有：内存安全，GC（垃圾回收），结构形态及 CSP-style 并发计算。 ","date":"2019-08-03","objectID":"/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/:2:0","tags":["Go"],"title":"Go语言学习之旅-开篇","uri":"/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/"},{"categories":["Golang"],"content":"学习资料 Go官方提供的教程非常丰富： 官网、中文官网、Go指南 非官方推荐 书籍：Go 简易教程、Go 入门指南、Go 语言设计与实现 导航：Go网站导航 论坛：learnku 教程：Go语言学习之路 ","date":"2019-08-03","objectID":"/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/:3:0","tags":["Go"],"title":"Go语言学习之旅-开篇","uri":"/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/"},{"categories":["Golang"],"content":"安装 Go官方提供了丰富的安装方法，可以根据自己的系统与喜好进行安装 如果官方网站打开比较慢的话也可以通过Go语言中文网提供的包进行安装 警告 安装完毕记得添加环境变量！ ","date":"2019-08-03","objectID":"/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/:4:0","tags":["Go"],"title":"Go语言学习之旅-开篇","uri":"/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/"},{"categories":["Golang"],"content":"学习计划 基础：预计两周时间 ","date":"2019-08-03","objectID":"/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/:4:1","tags":["Go"],"title":"Go语言学习之旅-开篇","uri":"/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/"},{"categories":["爬虫"],"content":"Python爬虫实战之bilibili","date":"2019-07-20","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/","tags":["爬虫"],"title":"Python爬虫实战之bilibili","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/"},{"categories":["爬虫"],"content":"声明：以下内容均为我个人的理解，如果发现错误或者疑问可以联系我共同探讨 ","date":"2019-07-20","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/:0:0","tags":["爬虫"],"title":"Python爬虫实战之bilibili","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/"},{"categories":["爬虫"],"content":"爬虫介绍 ","date":"2019-07-20","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/:1:0","tags":["爬虫"],"title":"Python爬虫实战之bilibili","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/"},{"categories":["爬虫"],"content":"网站介绍 本次要爬取的网站为bilibili，它是国内知名的视频弹幕网站,这里有及时的动漫新番,活跃的ACG氛围,有创意的Up主。可以在这里找到许多欢乐。 ","date":"2019-07-20","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/:1:1","tags":["爬虫"],"title":"Python爬虫实战之bilibili","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/"},{"categories":["爬虫"],"content":"编写爬虫的原因和用途 bilibili已经从原来的小破站变成了现在现象级的多元化的社区网站，本次爬取它的目的是以它作为一个典型，告诉大家遇到各类型验证码的一种思路。 其实这类网站有个最简单的办法，就是提前登陆手动获取到cookie，然后根据cookie去请求我们需要爬取的网站。个人目的的爬虫可以用这类方法，比较省编写代码的时间。但是公司中可能会遇到众多账户的爬虫需求，一个一个手动登录去获取cookie就比较麻烦了，这时候使用Selenium自动化去获取效率就高很多了。 ","date":"2019-07-20","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/:1:2","tags":["爬虫"],"title":"Python爬虫实战之bilibili","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/"},{"categories":["爬虫"],"content":"Selenium ","date":"2019-07-20","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/:2:0","tags":["爬虫"],"title":"Python爬虫实战之bilibili","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/"},{"categories":["爬虫"],"content":"简介 正如他们官方的介绍Selenium automates browsers. That's it!，他是一个自动化的浏览器，可以模拟人的操作。 ","date":"2019-07-20","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/:2:1","tags":["爬虫"],"title":"Python爬虫实战之bilibili","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/"},{"categories":["爬虫"],"content":"使用教程 推荐通过Selenium中文网学习，非常全面！ ","date":"2019-07-20","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/:2:2","tags":["爬虫"],"title":"Python爬虫实战之bilibili","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/"},{"categories":["爬虫"],"content":"验证码分析 ","date":"2019-07-20","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/:3:0","tags":["爬虫"],"title":"Python爬虫实战之bilibili","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/"},{"categories":["爬虫"],"content":"滑动验证码 哔哩哔哩从之前的验证码是滑动验证码，主要思路就是找到缺口确定缺口的坐标，然后通过Selenium操作滑动到指定位置就行。类似的还有阿里系的大部分网页，比如飞猪、淘宝、天猫等，不过阿里系的不是每次都需要验证，得根据实际情况操作。 这种就是找到最右边的位置信息，然后滑动即可 这种需要先找到整个图片的位置，然后滑动先找到内容的轮廓在进行滑动，都是同一个思路演变的 ","date":"2019-07-20","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/:3:1","tags":["爬虫"],"title":"Python爬虫实战之bilibili","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/"},{"categories":["爬虫"],"content":"看图填答案系列 包括东方财富网上交易、bigquant等等，这类比较简单。将其下载下来根据验证码的情况进行处理然后交给各大云服务商的ORC服务识别就可以，都有免费试用的额度，根据自己的需求和喜好选择，也可以多试几家进行对比。 百度、腾讯、阿里、有道智云 ","date":"2019-07-20","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/:3:2","tags":["爬虫"],"title":"Python爬虫实战之bilibili","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/"},{"categories":["爬虫"],"content":"根据图片进行操作点击系列 目前多了很多这种验证码，这种的难度在于情况变化比较多，不仅限于汉字和数字，还有可能是图片等等，这时候自己想办法也能解决，但是策略一改变就比较麻烦，可以借助各类打码的平台，对内容进行识别，然后再根据内容去进行操作 易云打码、快识别网址、斐斐打码等等 ","date":"2019-07-20","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/:3:3","tags":["爬虫"],"title":"Python爬虫实战之bilibili","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/"},{"categories":["爬虫"],"content":"bilibili登陆分析 bilibili的最新的验证码属于第三种，在点击登陆按钮就会出现一个验证码的框,我们需要将这个图片下载下来给打码平台去识别，获得坐标信息然后再用Selenium进行点击操作 ​ bilibili验证码 ","date":"2019-07-20","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/:4:0","tags":["爬虫"],"title":"Python爬虫实战之bilibili","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/"},{"categories":["爬虫"],"content":"编写代码 ","date":"2019-07-20","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/:5:0","tags":["爬虫"],"title":"Python爬虫实战之bilibili","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/"},{"categories":["爬虫"],"content":"Selenium模拟登陆 import re import time import base64 import json import requests from selenium import webdriver from selenium.webdriver import ActionChains from selenium.webdriver.chrome.options import Options class Bilibili(object): def __init__(self): chrome_options = Options() # 设置无窗口模式 # chrome_options.add_argument('--headless') self.driver = webdriver.Chrome('./chromedriver', options=chrome_options) def login(self, username, password): # 开登陆页面 self.driver.get(\"https://passport.bilibili.com/login\") # 输入用户名和密码 self.driver.find_element_by_id('login-username').send_keys(username) self.driver.find_element_by_id('login-passwd').send_keys(password) # 点击登陆按钮 self.driver.find_element_by_class_name('btn-login').click() # 等待验证码出现 # self.driver.implicitly_wait(10) time.sleep(5) # 获取图片所在属性 img_style = self.driver.find_element_by_class_name('geetest_tip_img').get_attribute('style') # 通过正则表达式获得图片url url = re.findall('url\\(\"(.*?)\"\\)', img_style)[0] # 通过requests发送请求得到图片 response = requests.get(url).content # 将图片保存在本地 with open('./captcha.png', 'wb') as f: f.write(response) # 通过打码平台进行打码识别 result = self.captcha_recognition() # 识别成功 if result != \"\": # 对识别到的坐标进行分组处理 result_list = result.split('|') for result in result_list: x = result.split(',')[0] y = result.split(',')[1] # 根据坐标执行整个动作链 ActionChains(self.driver).move_to_element_with_offset(img_style, int(x), int(y)).click().perform() # 点击确定按钮 self.driver.find_element_by_class_name('geetest_commit').click() # 获得登陆后的cookie cookie = [item[\"name\"] + \"=\" + item[\"value\"] for item in self.driver.get_cookies()] self.driver.close() return cookie def captcha_recognition(self): \"\"\"验证码识别\"\"\" username = 'username' password = 'password' with open('./captcha.png', 'rb') as f: base64_data = base64.b64encode(f.read()) b64 = base64_data.decode() data = {\"username\": username, \"password\": password, \"typeid\": 27, \"image\": b64} result = json.loads(requests.post(\"http://api.ttshitu.com/predict\", json=data).text) if result['success']: return result[\"data\"][\"result\"] else: print(result[\"message\"]) return \"\" ","date":"2019-07-20","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/:5:1","tags":["爬虫"],"title":"Python爬虫实战之bilibili","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8Bbilibili/"},{"categories":["爬虫"],"content":"Python爬虫实战之萝卜投研","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"声明：以下内容均为我个人的理解，如果发现错误或者疑问可以联系我共同探讨 ","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:0:0","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"爬虫介绍 ","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:1:0","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"网站介绍 本次要爬取的网站为*萝卜投研*，是利用人工智能、大数据、移动应用技术,建立的股票基本面分析智能投研平台，在进行投资交易的时候可以使用期研报与各类数据进行分析。 ","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:1:1","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"编写爬虫的原因和用途 本人闲暇时间会学习投资理财相关内容，萝卜投研可以获取许多财经类的信息与很多研报，本次想通过编写爬虫完成对目标数据完成持久化存储与相关舆情完成程序提醒的目标，由于网站内容十分丰富，一次很难将其全部爬取完毕，本次想通过Scrapy获取首页的投研信息，并完成翻页的目标，后期还会持续更新，尝试将整个网站都爬下来。（仅供个人研究使用） ","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:1:2","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"Scrapy ","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:2:0","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"简介 Scrapy是一个为了爬取网站数据，提取结构性数据编写的爬虫框架，只需要很少的代码就可以完成相关数据的抓取。 Scrapy是一个使用了Twisted的异步网络框架，可以大大提高我们的下载速度。 ","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:2:1","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"使用教程 Scrapy的相关使用教程可以通过官方文档来进行初步入门，了解各模块在框架中的作用，官方文档非常强大，建议先进行系统性的学习之后再开始使用。 学习Scrapy最重要的就是理解Scrapy的工作流程，跟着官方文档的例子去详细分析每一步的操作，与之前编写爬虫的流程相关性与区别。 ","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:2:2","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"抓包工具 ","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:3:0","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"什么是抓包工具 抓包工具是拦截查看网络数据包内容的软件。通过对抓获的数据包进行分析，可以得到有用的信息。 ","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:3:1","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"为什么要用 较为复杂的网站在进行爬取数据分析的时候使用浏览器中的调试工具会比较麻烦，这时候就可以用抓包工具去分析对应的请求，从而更快发现我们需要的数据所在的URL和整个请求的过程 ","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:3:2","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"使用与抓包工具的推荐 抓包工具的使用推荐学习朱安邦的博客中的教程，他讲了三个：Charles、Fiddler、wireshark，这些抓包工具功能各异，但基本原理相同，找一个顺手的学习基本上已经足够了。 ","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:3:3","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"业务逻辑分析 ","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:4:0","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"寻找加载数据的URL 通过对整个首页加载的流程进行抓包与分析，发现首页数据的URL为https://gw.datayes.com/rrp_mammon/web/feed/list，下一页的URL为：https://gw.datayes.com/rrp_mammon/web/feed/list?timeStamp=20210401170127\u0026feedIds=66233,66148， ","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:4:1","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"翻页参数解析 通过观察URL发现timeStamp和feedIds是两个控制翻页的参数，进一步多页进行请求发现20210401170127可以理解为一个时间节点，看到20200228猜测是本次刷新的时间，猜测后6位是当前时间的秒的时间戳，组织一下可以写成''.join(str(datetime.now())[:10].split('-'))+str(time.clock( )).split('.')[1] 再进行多页的数据获取后发现feedIds参数中的前四个是第一个响应中前四个数据的id，最后一个数为响应中最后一个数据的id，并且会随着访问变多而增加，每次新增的都是最后一个数据的id，将下一页的URL拼接起来,进行访问发现请求不到下一页的数据。通过复制原来的timeStamp发现可以访问，问题就出现在前面timeStamp的参数，刚刚再进行feedIds字段拼接的时候发现有三个字段是日期形式的，分别为：\"insertTime\"、updateTime、publishTime，进一步分析发现将其后面三个0去掉就是一个时间戳，对其转换发现就是我们需要的结果 ","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:4:2","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"模拟请求测试 ","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:5:0","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"scrapy shell scrapy shell可以帮助我们模拟请求地址，并进入一个交互式终端，在交互式终端中我们可以查看请求的各类信息，并进行调试。但scrapy shell也有缺陷，不能解析response的格式，看起来比较乱等，这时候可以通过结合Postman来协同调试。 ","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:5:1","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"Postman 简介 Postman是一种网页调试与发送网页http请求的chrome插件。我们可以用来很方便的模拟各种类型的请求来调试 接口。在爬虫中可以用于验证我们的思路。 使用与汉化 Postman官方的使用教程非常详细，可以跟着官方的使用教程中学习，如果想使用中文的版本可以在Postman汉化中下载。 实际使用 通过Postman发送请求，可以得到我们想要的数据，并且可以得到格式化后的数据，看起来条理更加清晰，再配合scrapy shell调试可以很容易就获得我们需要的数据 ","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:5:2","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"编写爬虫 ","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:6:0","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"创建爬虫项目 scrapy startproject datayes ","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:6:1","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"robots协议 在settings.py中可以通过设置ROBOTSTXT_OBEY = True遵守robots.txt 的规则。 ","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:6:2","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"创建爬虫 scrapy genspider mammon gw.datayes.com ","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:6:3","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"修改start_urls 默认的start_urls不是我们要爬取的链接，修改为我们需求的链接 start_urls = ['https://gw.datayes.com/rrp_mammon/web/feed/list'] ","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:6:4","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"完成parse方法 根据之前分析的结果设计方案完成parse，这次难度主要在于如何拼接next_url，由于feedIds参数存在着累加的关系所以将其放在了parse函数外让其可以再访问的时候累加处理。 class MammonSpider(scrapy.Spider): name = 'mammon' allowed_domains = ['gw.datayes.com'] start_urls = ['https://gw.datayes.com/rrp_mammon/web/feed/list'] # 构建一个基础next_url next_url = 'https://gw.datayes.com/rrp_mammon/web/feed/list?timeStamp=' # 构建一个基础feedIds feedIds = '\u0026feedIds=' def parse(self, response): # 将获取到的数据通过json转成字典的形式 result = json.loads(response.text) # 当访问成功时进行数据获取 if result['message'] == 'success': data_list = result['data']['list'] for data in data_list: item = {} detail_id = data['id'] # id # 通过详情页id构造详情页url并访问 detail_url = 'https://gw.datayes.com/rrp_mammon/web/feed?id=' + str(detail_id) yield scrapy.Request(detail_url, callback=self.detail_parse, meta={'item': item}) item['title'] = data['title'] # 标题 item['publish_time'] = int(data['publishTime'] / 1000) # 发布时间 item['author'] = data['roboColumn']['name'] # 作者 item['Avatar'] = data['roboColumn']['logo'] # 头像 related_list = data['related'] item['related_stocks'] = [] # 相关股票列表 for stocks in related_list: item['related_stocks'].append(stocks['targetName']) # 寻找出url的第0，1，2，3位置的id，加入feedIds if response.request.url == 'https://gw.datayes.com/rrp_mammon/web/feed/list' and data_list.index(data) in [0, 1, 2, 3]: self.feedIds = self.feedIds + str(detail_id) + ',' # 构建timeStamp参数 timeStamp = time.strftime(\"%Y%m%d%H%M%S\", time.localtime(item['publish_time'])) # 拼接feedIds参数 self.feedIds = self.feedIds + str(detail_id) + ',' # 组合next_url next_url = self.next_url + timeStamp + self.feedIds # 请求下一页 yield scrapy.Request(next_url, callback=self.parse) def detail_parse(self, response): result = json.loads(response.text) if result['message'] == 'success': item = response.meta['item'] item['content'] = result['data']['longDocContent'] yield item 通过爬虫观察到两日的cookie发生了变化，只有登录之后会保持cookie，并对cookie中的参数进行检测，找到cloud-sso-token为必要参数，并将其添加在settings.py中。 ","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:6:5","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"完成数据存储 先在settings.py中配置pipeline，和数据库相关参数 # Configure item pipelines # See https://docs.scrapy.org/en/latest/topics/item-pipeline.html ITEM_PIPELINES = { 'datayes.pipelines.DatayesPipeline': 300, } # MySQL相关配置 HOST = 'HOST', # 数据库地址 PORT = 3306, # 数据库端口 DB = 'DB', # 数据库名 USER = 'USER', # 数据库用户名 PASSWORD = 'PASSWORD', # 数据库密码 在我们定义的DatayesPipeline类中添加open_spider和close_spider方法，通过spider.settings来导入数据库相关参数 import pymysql class DatayesPipeline: # 爬虫开始时执行，只执行一次 def open_spider(self, spider): # 通过pymysql链接MySQL数据库 self.connect = pymysql.connect( host=spider.settings.HOST, # 数据库地址 port=spider.settings.PORT, # 数据库端口 db=spider.settings.DB, # 数据库名 user=spider.settings.USER, # 数据库用户名 passwd=spider.settings.PASSWORD, # 数据库密码 charset='utf8', # 编码方式 use_unicode=True) # 通过cursor执行增删查改 self.cursor = self.connect.cursor() # 爬虫结束时执行，只执行一次 def close_spider(self, spider): self.connect.close() def process_item(self, item, spider): self.cursor.execute( \"\"\"insert into mammon (title, publish_time,author,avatar,related_stocks,content)value (%s, %s,%s, %s,%s, %s)\"\"\", (item['title'], item['publish_time'], item['author'], item['avatar'], item['related_stocks'], item['content'])) # 提交sql语句 self.connect.commit() return item 最后创建数据库，开启爬虫进行数据爬取。 ","date":"2019-07-06","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/:6:6","tags":["爬虫"],"title":"Python爬虫实战之萝卜投研","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E8%90%9D%E5%8D%9C%E6%8A%95%E7%A0%94/"},{"categories":["爬虫"],"content":"Python爬虫实战之叩富网","date":"2019-06-22","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"声明：以下内容均为我个人的理解，如果发现错误或者疑问可以联系我共同探讨 ","date":"2019-06-22","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:0:0","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"爬虫介绍 爬虫是一种按照一定规则自动抓取网络上的信息数据的程序。我们身处一个大数据的时代，可以通过爬虫获取到我们所需要的数据(遵从robots协议中的规则)。 ","date":"2019-06-22","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:1:0","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"网站介绍 叩富网是江西博辰网络科技公司旗下的一个专业网站。模拟炒股网站初建于2000年，2006年被博辰网络收购，并开始规范系统的运作。目前用户100多万，日均IP数10万左右。是国内唯一一家专业致力于模拟炒股开发和运营的网站。公司旗下有有奖大赛站、免费大赛站以及和其他证券公司合作的网站。 ","date":"2019-06-22","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:1:1","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"编写爬虫的原因和用途 本人闲暇时间会学习投资理财相关内容，并通过叩富网进行模拟炒股，本次想通过编写爬虫来程序化自己的模拟交易 ","date":"2019-06-22","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:1:2","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"robots协议 ","date":"2019-06-22","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:2:0","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"什么是robots协议 robots协议以robots.txt文件形式呈现，是网站中给各类爬虫规定爬取范围的文件，robots.txt存放在网站的根目录下。我们准备爬取某个网站时，首先应该查看我们需要的数据该网站是否允许我们爬取，当我们爬取规则之外的数据时，该网站有权利起诉我们非法获取数据。 ","date":"2019-06-22","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:2:1","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"robots协议的构成 由User-agent、Allow、Disallow构成。User-agent后面的内容是具体的爬虫名，如百度爬虫为Baiduspider，则代表所有爬虫。Allow后面的内容是允许爬取的URL路径，如/.jpg$表示可以爬取该网站下的所有.jpg图片，/表示所有路径均允许爬取。Disallow后面的内容是不允许爬取的URL路径，同Allow相反。 ","date":"2019-06-22","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:2:2","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"常见的规则有哪些 允许爬虫获取所有内容： User-agent: * Disallow: # 或者 User-agent: * Allow: / 禁止爬取所有内容： User-agent: * Disallow: / 禁止访问网站中所有动态页面 User-agent: * Disallow: /*?* 禁止搜索引擎抓取网站上所有图片 User-agent: * Disallow: /*.jpg$ Disallow: /*.jpeg$ Disallow: /*.gif$ Disallow: /*.png$ Disallow: /*.bmp$ ","date":"2019-06-22","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:2:3","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"Feeling 爬虫可以使我们更加高效的获取到互联网中的各类数据，但网络不是法外之地我们也要在合规合法的基础上进行爬取，尊重每一个网站开发者，敬畏法律。 ","date":"2019-06-22","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:2:4","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"requests requests库是学习爬虫入门最适合的一个第三方库，它是将Python内置的urllib进行深度封装的库。是一个非常成熟的HTTP客户端库，当然他也并非完美，我们后期也可以在其基础上进行补充形成适合自己的一个库。 ","date":"2019-06-22","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:3:0","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"快速上手 中文文档：https://docs.python-requests.org/zh_CN/latest/index.html 官方示例：https://docs.python-requests.org/zh_CN/latest/user/quickstart.html ","date":"2019-06-22","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:3:1","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"获取robots协议，查看可爬取范围 使用get请求获取协议内容，并将其输出控制台查看发现规则允许我们爬取整站内容 ","date":"2019-06-22","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:3:2","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"登陆叩富网 在Chrome浏览器中通过开发者选项中的Network选项卡中发现，登陆的时候有一个login.html 我们可以在里面看到请求URL、请求方式和Form Data所需要的内容，根据这个编写一个请求查看一下获取到的数据 由于是字符串格式，所以出现了我们看不懂的字符，通过json转成Python中的字典格式再查看 可以看到显示登陆成功了，接下来通过获取到的cookie就可以获取到我们需要的各种信息了 接下来我们将代码优化一下变成一个方法，让登陆后的cookie可以在以后任意需要的地方使用 import requests import json from lxml import etree def login(username, password): \"\"\" 登陆叩富网 :param username: 用户名 :param password: 密码 :return: 登陆成功返回cookie，失败抛出对应异常 \"\"\" login_url = 'http://www.cofool.com/Passport/login.html' data = { 'username': username, 'password': password } try: response = requests.post(url=login_url, data=data) except Exception as e: raise Exception(\"登陆失败，原因为：{}\".format(e)) content = json.loads(response.content.decode()) if content['status'] == 0: cookie = response.cookies.get_dict() return cookie else: raise Exception(\"登陆失败，原因为：{}\".format(content['info'])) 在出现登录失败的时候抛出异常，并显示错误信息 ","date":"2019-06-22","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:3:3","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"Feeling 爬虫是我们与开发者的博弈，我们需要站在他们的角度去分析他们开发的过程，从而更好的理解并去设计我们的相关爬虫程序。通常爬虫程序都不是一次就完成的，需要通过我们不断根据请求的反馈去修改程序，最终通过多层解析得到结果。 ","date":"2019-06-22","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:3:4","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"获取账户信息 ","date":"2019-06-22","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:4:0","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"练习区信息 通过对相关请求的分析，练习区信息在http://www.cofool.com/Trade/Stock/index/gid/2.html这个URL下 对页面分析我们所需要的数据在class为top_ts的div下 ","date":"2019-06-22","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:4:1","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"XPath XPath是一门在XML文档中查找信息的语言，可以帮助我们在爬虫中对获取数据进行查找得到我们需要的内容。 推荐从大佬崔庆才的个人博客学习XPath及爬虫的相关内容 开始通过XPath获取对应数据，考虑到多个数据在相同的font标签下，可以一次性获取所有标签然后进行处理 def get_account_info(query_category): \"\"\" 根据query_category获取账户相关信息 :param query_category: 查询类别信息,账户信息:ai 持仓状态:ap 当日委托:ac 当日成交:ad 历史成交:hd 股票收益明细:sd 日资产增长明细：da 月资产增长明细：ma 荣耀榜 ho :return: \"\"\" cookie = login('用户名', '密码') if query_category not in ['ai', 'ap', 'ac', 'ad', 'hd', 'sd', 'da', 'ma', 'ho']: raise Exception('查询类别不存在') if query_category == 'ai': url = 'http://www.cofool.com/Trade/Stock/index/gid/2.html' # 抓取账户相关数据 try: response = requests.get(url=url, cookies=cookie).content.decode() except Exception as e: raise Exception(\"获取账户数据失败，原因为：{}\".format(e)) if '总盈利率' not in response: raise Exception(\"获取账户数据失败，未获取到正确信息\") # 使用xpath对抓取到的数据进行清洗得到我们需要的数据 html = etree.HTML(response) account_info = html.xpath('//div [@class=\"top_ts\"]/div//font/text()') if len(account_info) != 4: raise Exception(\"获取账户数据失败，未获取足够的账户数据\") gross_profit_rate = account_info[0] # 总收益率 initial_funding = account_info[1] # 初始资金 number_of_participants = account_info[2] # 参赛人数 average_income = account_info[3] # 平均收益率 overall_ranking = html.xpath('//div [@class=\"top_ts\"]/div//p[2]/b/text()')[0] # 总排名 try: total_assets = float(''.join(re.search('\\d,\\d*,\\d*.\\d*', html.xpath( '//*[@id=\"left2\"]/table/tbody/tr[1]/td[@class=\"btom zjsr\"]/text()')[0])[0].split(','))) available_funds = float(''.join(re.search('\\d,\\d*,\\d*.\\d*', html.xpath( '//*[@id=\"left2\"]/table/tbody/tr[1]/td[@class=\"btom zjl\"]/text()')[0])[0].split(','))) except Exception as e: raise Exception(\"获取账户数据失败，{}\".format(e)) return {'总收益率': gross_profit_rate, '初始资金': initial_funding, '参赛人数': number_of_participants, '平均收益率': average_income, '总排名': overall_ranking, '总资产': total_assets, '可用资金': available_funds} ","date":"2019-06-22","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:4:2","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"持仓、交易、业绩信息 通过对相关请求的分析，当前持仓、当日委托、当日成交、历史成交与业绩报告都用同一个URL进行请求，只是请求中FormData部分数据不同，分析各页面数据发现当前持仓、当日委托、当日成交、历史成交数据类似，将其作为同一个类型进行爬取做简单修改即可。分页相关信息需要根据页码数据进行追加处理 ... url = 'http://www.cofool.com/Trade/Stock/tradeItem.html' data = {'gid': 'gid', 'uid': 'uid', 'web_id': 'web_id} # 根据查询条件设置对应的type值 if query_category == 'ap': data['type'] = 'position' elif query_category == 'ac': data['type'] = 'entrust' elif query_category == 'ad': data['type'] = 'turnover' elif query_category == 'hd': data['type'] = 'history' elif query_category == 'sd': data['type'] = 'earnings' elif query_category == 'da': data['type'] = 'dayasset' elif query_category == 'ma': data['type'] = 'monthasset' elif query_category == 'ho': data['type'] = 'honor' # 第一次获取对应信息，当信息不存在时返回'暂无交易的数据！' try: response = requests.post(url=url, data=data).content.decode() except Exception as e: raise Exception('获取账户数据失败，原因为：{}'.format(e)) if ' 暂无交易的数据！' in response: return '暂无交易的数据！' html = etree.HTML(response) # 当有信息时获取页码数值， number_of_pages = len(html.xpath('//div [@class = \"clearfix fr\"]/a/text()')) + 1 # 获取对应表头名 col_name = html.xpath('//tr/th/text()') # 设置临时存储字典 temp_dict = {} # 根据页码信息进行第二次访问获取信息 for i in range(1, number_of_pages + 1): # 添加页码数据 data['p'] = i try: response = requests.post(url=url, data=data).content.decode() except Exception as e: raise Exception('获取账户数据失败，原因为：{}'.format(e)) # 由于爬取的数据存在大量\\n和空格，先进行一次简单的清洗 response = re.sub('\\n\\s|\\s', '', response) html = etree.HTML(response) # 分别获取各列信息 for j in range(len(col_name)): xpath_index = j + 1 xpath_values = html.xpath('//tr/td[{}]//text()|//tr/td[{}]/font/text()|//tr/td[{}]/text()'.format(xpath_index, xpath_index,xpath_index)) if i == 1: temp_dict[col_name[j]] = xpath_values # 当出现第二页及其以上时，进行数据追加处理 else: temp_dict[col_name[j]].extend(xpath_values) return pd.DataFrame(temp_dict) ","date":"2019-06-22","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:4:3","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"Feeling 爬虫中数据清洗的过程通常也非常熬人，网站开发者的水平高低与反爬的难度，会导致许多数据清洗起来非常复杂，可能会花费大量的时间还得不到你想要的结果，这时候我们需要保持一颗平常心，针对出现的问题一个一个去解决，只要坚持下去一定能解决的！ ","date":"2019-06-22","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:4:4","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"账户操作 ","date":"2019-06-22","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:5:0","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"股票信息 接下来编写账户操作方面的爬虫，要交易首先要拿到进行交易股票的相关信息，通过分析相关请求后发现其URL为http://www.cofool.com/Trade/Stock/stockQuote.html,这个比较简单很快就可以完成对应代码 def get_stock_info(stock_code): \"\"\" 根据股票代码获取相关价格 :param code:股票代码 :return: 相关价格 \"\"\" url = \"http://www.cofool.com/Trade/Stock/stockQuote.html\" data = { \"code\": stock_code, \"uid\": 'uid', } cookie = login('账户名', '密码') try: response = json.loads(requests.post(url=url, data=data, cookies=cookie).content.decode(\"utf-8-sig\")) except Exception as e: raise Exception('获取账户数据失败，原因为：{}'.format(e)) stock_info = response[\"info\"] info_dict = { \"high_limit\": stock_info[\"surgedLimit\"], # 涨停价 \"low_limit\": stock_info[\"declineLimit\"], # 跌停价 \"stock_name\": stock_info['stockName'], # 股票名称 'currentPrice': stock_info[\"currentPrice\"], # 当前价 } return info_dict ","date":"2019-06-22","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:5:1","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"股票交易 通过观察发现买入与卖出操作的URL差距非常小，并且请求参数也高度相似，可以将其放在同一个方法中 def tradeing(stock_code, tradeing_type, amount=0): \"\"\" 股票交易，并返回交易状态 :param stock_code:股票代码 :param tradeing_type:交易类型 :param amount:交易数量,默认为0防止出现没有填写的情况 :return:交易状态 \"\"\" cookie = login('账户名', '密码') # 获取股票相关信息 info_dict = get_stock_info(stock_code) price = info_dict[\"high_limit\"] # 配置相关数据 data = { \"stockName\": info_dict['stock_name'], \"code\": stock_code, \"uid\": 'uid', \"gid\": 2, \"orderPrice\": price, \"orderAmount\": amount, \"declineLimit\": info_dict['low_limit'], \"surgedLimit\": info_dict['high_limit'] } if tradeing_type == 'buy': url = \"http://www.cofool.com/Trade/Stock/buy.html\" # 买入操作，检测买入数量防止超过最大买入数量 available_funds = get_account_info('ai')['可用资金'] if amount \u003c available_funds / float(price): data[\"orderAmount\"] = amount else: raise Exception('购买数量超过最大可购买数量') elif tradeing_type == 'sell': url = \"http://www.cofool.com/Trade/Stock/sell.html\" # 卖出操作，从持仓信息中获取可卖出数量 data[\"orderAmount\"] = get_amount(stock_code) try: content = \\ requests.post(url=url, data=data, cookies=cookie).content.decode(\"utf-8-sig\") status = json.loads(content, encoding=\"unicode_escape\")[\"status\"] except Exception as e: raise Exception('获取账户数据失败，原因为：{}'.format(e)) if status == 1: print(\"买入股票：{}，股数：{}\".format(stock_code, amount)) return 0 else: raise Exception(\"买入失败，失败原因为：{}\".format(json.loads(content, encoding=\"unicode_escape\")[\"info\"])) ","date":"2019-06-22","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:5:2","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["爬虫"],"content":"持仓数量 在卖出交易的时候需要获取账户中持仓的数量 def get_amount(code): \"\"\"根据股票代码获取可交易数量 :param code:股票代码 :return:对应股票可用数量 \"\"\" url = \"http://www.cofool.com/Trade/Stock/sellAmount\" data = { \"code\": code, \"uid\": 'uid', \"web_id\": 'web_id' } cookie = login('账户名', '密码') try: content = json.loads(requests.post(url=url, data=data, cookies=cookie).content.decode('unicode_escape')) except Exception as e: raise Exception(\"获取股数数据失败，{}\".format(e)) status = content['status'] if status == 1: amount = content['info']['frozen_amount'] return amount else: raise Exception(content['info']) 到这里叩富网的爬虫基本完成了，最后将转化为类就可以了，完整代码可以在我的GitHub仓库查看最新的代码 ","date":"2019-06-22","objectID":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/:5:3","tags":["爬虫"],"title":"Python爬虫实战之叩富网","uri":"/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%A9%E5%AF%8C%E7%BD%91/"},{"categories":["一篇文章学会系列"],"content":"一篇文章学会Vim","date":"2019-06-15","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Avim/","tags":["工具","教程"],"title":"一篇文章学会Vim","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Avim/"},{"categories":["一篇文章学会系列"],"content":"声明：以下内容均为我个人的理解，如果发现错误或者疑问可以联系我共同探讨 ","date":"2019-06-15","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Avim/:0:0","tags":["工具","教程"],"title":"一篇文章学会Vim","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Avim/"},{"categories":["一篇文章学会系列"],"content":"简介 Vim是一个高度可定制的终端文本编辑器，它可以很方便的创建和修改任何类型的文本。作为vi的升级版，有许多新的特性(以下列出的特性为比较常用的，详细特性可以查看help vi_diff.)： 无限撤销：可以无限制的撤销 可移植性：Vi仅在Unix上可用，Vim还可以在Windows、Macintosh，Amiga，OS / 2，VMS，QNX和其他系统上运行。 语法高亮：当用Vim进行编程的时候，他可以根据正在编辑的文件类型，使其以内容以不同的颜色或样式突出显示。Vim捆绑了数百种语法突出显示规则集。 图形用户界面：Vim在控制台上运行良好，也可以在许多GUI中本地运行，包括Mac OS和Windows。它还可以操作剪贴板。 vi兼容模式：紧要关头，您可以强制Vim像vi一样。使Vim与vi不兼容的所有改进和错误修复都已关闭，您将获得100％与vi兼容的编辑器。 Vim作为许多程序员最喜欢的文本编辑器之一，它具有像：多级撤销、代码补全、支持数百种编程语言和文本格式、强大的搜索和替换功能等。 ","date":"2019-06-15","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Avim/:1:0","tags":["工具","教程"],"title":"一篇文章学会Vim","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Avim/"},{"categories":["一篇文章学会系列"],"content":"安装与卸载 ","date":"2019-06-15","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Avim/:2:0","tags":["工具","教程"],"title":"一篇文章学会Vim","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Avim/"},{"categories":["一篇文章学会系列"],"content":"安装 Windows 先把安装包下载下来，然后根据提示安装。 Unix 在Github上下载源文件安装 Mac 在github下载，根据文件类型安装。 详细安装教程 ","date":"2019-06-15","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Avim/:2:1","tags":["工具","教程"],"title":"一篇文章学会Vim","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Avim/"},{"categories":["一篇文章学会系列"],"content":"卸载 Unix or Mac 源代码安装 在控制台输入 make uninstall 软件包管理器安装 根据不同软件包管理器的卸载命令卸载 Windows 找到安装目录下的 “uninstall-gui” 程序进行卸载 ","date":"2019-06-15","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Avim/:2:2","tags":["工具","教程"],"title":"一篇文章学会Vim","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Avim/"},{"categories":["一篇文章学会系列"],"content":"教程 ","date":"2019-06-15","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Avim/:3:0","tags":["工具","教程"],"title":"一篇文章学会Vim","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Avim/"},{"categories":["一篇文章学会系列"],"content":"vimtutor Vim自带教程vimtutor是你从零开始学习Vim最好的老师，教程包含了日常所需要的各个命令和功能，还有实操教学。如果你的系统语言是中文，那么打开vimtutor时默认是中文版的教程，中文版教程由梁昌泰 先生进行译制。在命令行中输入vimtutor，就可以打开该教程,学习完该教程大约需要30分钟左右。 有一款游戏Vim Adventure，可以作为学习Vim的一种放松。 Vimtutor章节小结 第一讲 光标在屏幕文本中的移动既可以用箭头键，也可以使用 hjkl 字母键。 ​ h (左移) j (下行) k (上行) l (右移) 欲进入 Vim 编辑器(从命令行提示符)，请输入：vim 文件名 \u003c回车\u003e 欲退出 Vim 编辑器，请输入 :q! \u003c回车\u003e 放弃所有改动。或者输入 :wq \u003c回车\u003e 保存改动。 在正常模式下删除光标所在位置的字符，请按： x 欲插入或添加文本，请输入： ​ i 输入欲插入文本 在光标前插入文本 ​ A 输入欲添加文本 在一行后添加文本 特别提示：按下 键会带您回到正常模式或者撤消一个不想输入或部分完整的命令。 第二讲 欲从当前光标删除至下一个单词，请输入：dw 欲从当前光标删除至当前行末尾，请输入：d$ 欲删除整行，请输入：dd 欲重复一个动作，请在它前面加上一个数字：2w 在正常模式下修改命令的格式是： operator [number] motion 其中： ​ operator - 操作符，代表要做的事情，比如 d 代表删除 ​ [number] - 可以附加的数字，代表动作重复的次数 ​ motion - 动作，代表在所操作的文本上的移动，例如 w 代表单词(word)，$ 代表行末等等。 欲移动光标到行首，请按数字0键：0 欲撤消以前的操作，请输入：u (小写的u)，欲撤消在一行中所做的改动，请输入：U (大写的U)，欲撤消以前的撤消命令，恢复以前的操作结果，请输入：CTRL-R 第三讲 要重新置入已经删除的文本内容，请按小写字母 p 键。该操作可以将已删除的文本内容置于光标之后。如果最后一次删除的是一个整行，那么该行将置于当前光标所在行的下一行。 要替换光标所在位置的字符，请输入小写的 r 和要替换掉原位置字符的新字符即可。 更改类命令允许您改变从当前光标所在位置直到动作指示的位置中间的文本。比如输入 ce 可以替换当前光标到单词的末尾的内容；输入 c$ 可以替换当前光标到行末的内容。 更改类命令的格式是： c [number] motion 第四讲 CTRL-G 用于显示当前光标所在位置和文件状态信息。 G 用于将光标跳转至文件最后一行。先敲入一个行号然后输入大写 G 则是将光标移动至该行号代表的行。gg 用于将光标跳转至文件第一行。 输入 / 然后紧随一个字符串是在当前所编辑的文档中正向查找该字符串。输入 ? 然后紧随一个字符串则是在当前所编辑的文档中反向查找该字符串。完成一次查找之后按 n 键是重复上一次的命令，可在同一方向上查找下一个匹配字符串所在；或者按大写 N 向相反方向查找下一匹配字符串所在。CTRL-O 带您跳转回较旧的位置，CTRL-I 则带您到较新的位置。 如果光标当前位置是括号(、)、[、]、{、}，按 % 会将光标移动到配对的括号上。 在一行内替换头一个字符串 old 为新的字符串 new，请输入 :s/old/new 在一行内替换所有的字符串 old 为新的字符串 new，请输入 :s/old/new/g 在两行内替换所有的字符串 old 为新的字符串 new，请输入 :#,#s/old/new/g 在文件内替换所有的字符串 old 为新的字符串 new，请输入 :%s/old/new/g 进行全文替换时询问用户确认每个替换需添加 c 标志 :%s/old/new/gc 第五讲 :!command 用于执行一个外部命令 command。 请看一些实际例子： (MS-DOS) (Unix) :!dir :!ls # 用于显示当前目录的内容。 :!del FILENAME :!rm FILENAME # 用于删除名为 FILENAME 的文件。 :w FILENAME 可将当前 VIM 中正在编辑的文件保存到名为 FILENAME 的文件中。 v motion :w FILENAME 可将当前编辑文件中可视模式下选中的内容保存到文件FILENAME 中。 :r FILENAME 可提取磁盘文件 FILENAME 并将其插入到当前文件的光标位置后面。 :r !dir 可以读取 dir 命令的输出并将其放置到当前文件的光标位置后面。 第六讲 输入小写的 o 可以在光标下方打开新的一行并进入插入模式。输入大写的 O 可以在光标上方打开新的一行。 输入小写的 a 可以在光标所在位置之后插入文本。输入大写的 A 可以在光标所在行的行末之后插入文本。 e 命令可以使光标移动到单词末尾。 操作符 y 复制文本，p 粘贴先前复制的文本。 输入大写的 R 将进入替换模式，直至按 键回到正常模式。 输入 :set xxx 可以设置 xxx 选项。一些有用的选项如下： ‘ic’ ‘ignorecase’ 查找时忽略字母大小写 ‘is’ ‘incsearch’ 查找短语时显示部分匹配 ‘hls’ ‘hlsearch’ 高亮显示所有的匹配短语 选项名可以用完整版本，也可以用缩略版本。 在选项前加上 no 可以关闭选项： :set noic 第七讲 输入 :help 或者按 键或 键可以打开帮助窗口。 输入 :help cmd 可以找到关于 cmd 命令的帮助。 输入 CTRL-W CTRL-W 可以使您在窗口之间跳转。 输入 :q 以关闭帮助窗口 您可以创建一个 vimrc 启动脚本文件用来保存您偏好的设置。 当输入 : 命令时，按 CTRL-D 可以查看可能的补全结果。 按 可以使用一个补全。 ","date":"2019-06-15","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Avim/:3:1","tags":["工具","教程"],"title":"一篇文章学会Vim","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Avim/"},{"categories":["一篇文章学会系列"],"content":"帮助 在控制台中输入vim就可以查看Vim的相关信息 根据图片所示我们可以知道，当前VIM的版本为8.0.1365，想退出需要输入”:q”，查看在线帮助文档可以输入”:help”，查看版本信息可以输入”:help version8” 在英文模式下输入”:help\"回车后便可以看到 在这里有详细的Vim教程，教你玩转Vim。 ","date":"2019-06-15","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Avim/:3:2","tags":["工具","教程"],"title":"一篇文章学会Vim","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Avim/"},{"categories":["一篇文章学会系列"],"content":"一篇文章学会Linux","date":"2019-06-09","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Alinux/","tags":["操作系统","教程"],"title":"一篇文章学会Linux","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Alinux/"},{"categories":["一篇文章学会系列"],"content":"声明：以下内容均为我个人的理解，如果发现错误或者疑问可以联系我共同探讨 ","date":"2019-06-09","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Alinux/:0:0","tags":["操作系统","教程"],"title":"一篇文章学会Linux","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Alinux/"},{"categories":["一篇文章学会系列"],"content":"简介 ","date":"2019-06-09","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Alinux/:1:0","tags":["操作系统","教程"],"title":"一篇文章学会Linux","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Alinux/"},{"categories":["一篇文章学会系列"],"content":"Linux Linux是一种自由和开放源码的类UNIX操作系统。该操作系统的内核由林纳斯·托瓦兹在1991年10月5日首次发布，在加上用户空间的应用程序之后，成为Linux操作系统。只要遵循GNU 通用公共许可证（GPL），任何个人和机构都可以自由地使用Linux的所有底层源代码，也可以自由地修改和再发布。大多数Linux系统还包括像提供GUI的X Window之类的程序。除了一部分专家之外，大多数人都是直接使用Linux 发行版，而不是自己选择每一样组件或自行设置。详细介绍 ","date":"2019-06-09","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Alinux/:1:1","tags":["操作系统","教程"],"title":"一篇文章学会Linux","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Alinux/"},{"categories":["一篇文章学会系列"],"content":"linux发行版 Linux发行版指的就是通常所说的“Linux操作系统”，它一般是由一些组织、团体、公司或者个人将Linux内核作为发行版的一部分制作并发行的。通常来讲，一个Linux发行版包括Linux内核，以及将整个软件安装到电脑上的一套安装工具，还有各种GNU软件，和其他的一些自由软件，在一些Linux发行版中可能会包含一些专有软件。当前，超过三百个发行版被积极的开发，最普遍被使用的发行版有大约十二个。较为知名的有Debian、Ubuntu、Fedora和openSUSE等。 Linux发行版份额排名，也可以在Linux终端用命令查看：wget -qO - 7z.cx/o|sh，Ubuntu以39.1%的占比遥遥领先，中国武汉深之度科技有限公司开发的deepin是国产Linux发行版中排名最高的，占比12.6%在排行榜中排名第三（截止于2020-01-10 13:54:19） ","date":"2019-06-09","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Alinux/:1:2","tags":["操作系统","教程"],"title":"一篇文章学会Linux","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Alinux/"},{"categories":["一篇文章学会系列"],"content":"安装 如果是初次安装系统建议先通过在虚拟机上安装。 ","date":"2019-06-09","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Alinux/:2:0","tags":["操作系统","教程"],"title":"一篇文章学会Linux","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Alinux/"},{"categories":["一篇文章学会系列"],"content":"下载 下面提供较为知名的Linux发行版下载地址 Ubuntu、manjaro、deepin、CentOS、Arch、Debian、Mint、Fedora Linux发行版提供了Server版和Desktop版，初次使用建议直接安装Server版。 ","date":"2019-06-09","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Alinux/:2:1","tags":["操作系统","教程"],"title":"一篇文章学会Linux","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Alinux/"},{"categories":["一篇文章学会系列"],"content":"安装 以Ubuntu Server 16.10为例 将镜像写入U盘后，开机以U盘为第一启动项启动，可以看到以下界面 选择第一项安装Ubuntu Server 下一步选择语言，这里选择英语，防止乱码与文件名是中文的问题 下一步选择区域，没有中国，所以先选其他 接下来选择亚洲Asia 接着选这中国 下一步选择字符集，这里选择美国的UTF-8字符集，即en_US.UTF-8 下一步检测键盘，选择否 接着让我们设置键盘的类型与布局 下一步是设置主机名称，默认为ubuntu，可以改为你喜欢的名称 设置用户名 下一步设置登陆账号 设置密码，可以在下面选择显示密码，可以确认一次 再次输入，确认密码 是否加密home文件夹，选择否 下一步系统根据区域推断出我们的市区是上海，没有问题，所以选择是 选择分区方式，这里选择Guided - use entire disk and set up LVM 选择安装的硬盘 这里告诉我们会格式化这个盘确认选择 选择自动安装 确认分区 确认安装 选择代理，没有就跳过 选择升级方式，这里选择不自动升级No automatic updates 安装完成后会重启，选择ubuntu启动即可 进入系统后输入用户名密码就可以登录上ubuntu了，到此安装完毕 ","date":"2019-06-09","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Alinux/:2:2","tags":["操作系统","教程"],"title":"一篇文章学会Linux","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Alinux/"},{"categories":["一篇文章学会系列"],"content":"linux 根目录 ","date":"2019-06-09","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Alinux/:3:0","tags":["操作系统","教程"],"title":"一篇文章学会Linux","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Alinux/"},{"categories":["Flask"],"content":"Flask入门教程","date":"2019-05-19","objectID":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/","tags":["Flask"],"title":"Flask入门教程","uri":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"categories":["Flask"],"content":"简介 Flask是由Armin ronacher于2010年用Python语言基于 Werkzeug 工具箱编写的轻量级Web开发框架。 ","date":"2019-05-19","objectID":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:1:0","tags":["Flask"],"title":"Flask入门教程","uri":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"categories":["Flask"],"content":"特点 Flask只提供核心功能，其他几乎所有的功能都需要用到拓展，比如可以通过Flask-SQLAlchemy拓展对数据库进行操作等等。 ","date":"2019-05-19","objectID":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:2:0","tags":["Flask"],"title":"Flask入门教程","uri":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"categories":["Flask"],"content":"核心 由Werkzeug与Jinja2组成，Werkzeug是一个全面的WSGI Web应用程序库，Jinja是一种现代且设计友好的Python模板语言。 ","date":"2019-05-19","objectID":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:3:0","tags":["Flask"],"title":"Flask入门教程","uri":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"categories":["Flask"],"content":"Flask常用扩展 Flask-SQLalchemy：操作数据库 Flask-script：插入脚本 Flask-migrate：管理迁移数据库 Flask-Session：Session存储方式指定 ","date":"2019-05-19","objectID":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:4:0","tags":["Flask"],"title":"Flask入门教程","uri":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"categories":["Flask"],"content":"相关文档 中文文档 英文文档 ","date":"2019-05-19","objectID":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:5:0","tags":["Flask"],"title":"Flask入门教程","uri":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"categories":["Flask"],"content":"Flask初体验 ","date":"2019-05-19","objectID":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:6:0","tags":["Flask"],"title":"Flask入门教程","uri":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"categories":["Flask"],"content":"安装并使用虚拟环境 virtualenv 创建和管理虚拟环境 # 安装 pip install virtualenv # 创建 virtualenv flask_env # 使用 source flask_env/bin/activate Pipenv 创建和管理虚拟环境 # 安装 pip install pipenv # 创建 pipenv install # 使用 pipenv shell ","date":"2019-05-19","objectID":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:6:1","tags":["Flask"],"title":"Flask入门教程","uri":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"categories":["Flask"],"content":"安装指定版本flask框架 sudo pip install flask==1.0.2 ","date":"2019-05-19","objectID":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:6:2","tags":["Flask"],"title":"Flask入门教程","uri":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"categories":["Flask"],"content":"创建一个文件，并带入编写第一个Flask程序 touch helloflask.py vim helloflask.py 在文件中写入以下代码 # 导入Flask类 from flask import Flask # 传递__name__参数，创建一个叫app的Flask实例，该实例将会成为我们的 WSGI 应用。 app = Flask(__name__) # 通过route装饰器来告诉Flask触发函数的URL @app.route('/') # index视图函数，在访问根路径时会调用该函数通过其返回值得到结果 def index(): return 'Hello Flask' if __name__ == '__main__': # 通过run方法启动web服务器 app.run() 退出编辑模式，运行该程序 python helloflask.py 可以看到以下结果 这样就启动了一个非常简单的内建的服务器。这个服务器用于测试应该是足够了，但是 用于生产可能是不够的。现在在浏览器中打开 http://127.0.0.1:5000/ ，应该可以看到 Hello Flask! 字样。 ","date":"2019-05-19","objectID":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:6:3","tags":["Flask"],"title":"Flask入门教程","uri":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"categories":["Flask"],"content":"相关配置参数 ","date":"2019-05-19","objectID":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:7:0","tags":["Flask"],"title":"Flask入门教程","uri":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"categories":["Flask"],"content":"初始化参数 创建Flask项目的第一步就是实例化Flask对象，以下是实例化对象需要的参数详解 import_name：Flask程序所在的包(模块)，传 __name__ 就可以， static_url_path：静态文件访问路径，可以不传，默认为：/ + static_folder static_folder：静态文件存储的文件夹，可以不传，默认为 static static_host：使用远程主机存储静态文件的地址，默认为None。当host_matching为True时，可以通过static_folder配置静态文件存储的文件夹 host_matching：设置url_map.host_matching属性，默认为False subdomain_matching：匹配路由时，请考虑与以下项相关的子域：data:`SERVER_NAME’。默认为False。 template_folder：模板文件存储的文件夹，可以不传，默认为 templates instance_path：默认情况下，应用程序的备用实例路径假定包或模块旁边的文件夹“instance”为实例路径。 instance_relative_config：如果将用于加载配置的相对文件名设置为“True”，则假定该文件名相对于实例路径而不是应用程序根。 root_path：默认情况下，Flask将自动计算应用程序根路径。在某些情况下，这无法实现（例如，如果包是Python 3命名空间包），需要手动定义。 ","date":"2019-05-19","objectID":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:7:1","tags":["Flask"],"title":"Flask入门教程","uri":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"categories":["Flask"],"content":"程序加载配置 在Flask程序运行前，我们可以给Flask设置相关配置，例如ENV(应用程序在什么环境中运行)，DEBUG(是否启用调试模式)TESTING(启用测试模式)等配置，常见的有两种方式来实现. 从配置文件中加载：app.config.from_pyfile() 创建一个配置文件 touch config.ini vim config.ini 写入配置信息 DEBUG = True 选择从配置文件加载 # 创建 Flask 类对象,指向程序所在的包的名称 app = Flask(__name__) # 从配置文件中加载配置 app.config.from_pyfile('config.ini') 从配置对象中加载：app.config.from_object() 创建一个配置类，然后将类名传入即可 # 配置类 class ConfigObject(object): DEBUG = True # 创建 Flask 类对象,指向程序所在的包的名称 app = Flask(__name__) # 从配置对象中加载配置 app.config.from_object(Config) ","date":"2019-05-19","objectID":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:7:2","tags":["Flask"],"title":"Flask入门教程","uri":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"categories":["Flask"],"content":"程序运行配置 这个demo中Flask项目程序启动的入口是app.run()。常见的配置选项有host, port,debug，分别是设置运行主机的ip地址，端口号，是否打开调试模式，当配置文件与这里都有debug时，最终会以这里的debug为准。 app.run(host=\"127.0.0.1\", port=8000) 路由 在Web开发中，路由是一种将URL转发到对应视图的程序。 ","date":"2019-05-19","objectID":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:7:3","tags":["Flask"],"title":"Flask入门教程","uri":"/flask%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"categories":["一篇文章学会系列"],"content":"一篇文章学会Git","date":"2019-05-11","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/","tags":["工具","教程"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"简介 ","date":"2019-05-11","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:0","tags":["工具","教程"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"什么是Git Git是一个免费的开源分布式版本控制系统，也是目前为止世界上最先进的分布式版本控制系统。Git官方有一个视频介绍，可以点此观看 什么是版本控制系统？ 一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。简单点理解就是一个可以帮助我们记录文件修改的系统。Git官方有一个视频介绍，可以点此观看 什么是分布式版本控制系统？ 分布式版本控制系统时相对于集中式版本控制系统的。 集中式版本控制系统将仓库存放在中央服务器中集中管理，当你需要时从中央服务器中拉取最新的版本，修改完后将修改提交给中央服务器。这就会带来例如当中央服务器宕机时整个版本控制系统就会崩溃；推送或者拉取一个较大的文件时就会消耗很多时间等弊端。 分布式版本控制系统中，每个人电脑都是一个仓库，自己的文件可以在本地管理，当需要多人协同时只需要管理好本地仓库与协同仓库的版本即可 ","date":"2019-05-11","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:1","tags":["工具","教程"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"Git有什么作用 进行源代码管理 ","date":"2019-05-11","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:2","tags":["工具","教程"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"为什么要进行源代码管理 方便多人协同开发 方便代码版本控制 ","date":"2019-05-11","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:3","tags":["工具","教程"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"Git的特点 分布式版本控制系统，服务器和客户端都有版本控制能力,都能进行代码的提交、合并等操作。 在使用Git的时候会自动创建一个.git的隐藏文件夹作为本地仓库 ","date":"2019-05-11","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:4","tags":["工具","教程"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"Git操作流程 clone：第一次从Git服务器获取项目 add：将修改添加到本地仓库 commit：将修改提交到本地仓库 push：将本地仓库的修改提交到Git服务器 pull：将Git服务器中的项目获取到本地仓库 ","date":"2019-05-11","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:5","tags":["工具","教程"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"Git仓库 什么是仓库 仓库的英文名是repository，又被称为版本库。它是一个被Git管理的文件目录。 ","date":"2019-05-11","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:6","tags":["工具","教程"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"工作区，暂存区和仓库 工作区：对代码的新增，修改，删除等操作的区域。 暂存区：存储工作区的操作的区域。 仓库区：即本地仓库区域，会记录完成的操作与历史版本。 ","date":"2019-05-11","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:7","tags":["工具","教程"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"Git操作 安装 Mac 在mac上有多种方法可以安装Git，最简单的事通过Xcode命令行工具安装。 通过Xcode安装 1.下载并安装Xcode 2.在终端中运行git即可，如果尚未安装，它将提示您安装。 通过homebrew安装 1.安装homebrew $ /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" 2.安装git $ brew install git 通过安装包安装 1.点击此下载最新版本 2.下载完成后打开安装包，一直下一步安装即可 Linux 在Linux发行版上安装GIt，可以通过附带的软件包管理工具来安装 Debian/Ubuntu $ apt-get install git 其他发行版本见这个链接 Windows 下载安装包 根据操作系统位数选择，链接 安装默认选项安装即可 安装完成后通过可以通过git --version查看安装版本 ","date":"2019-05-11","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:8","tags":["工具","教程"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"配置Git 配置文件介绍 Git有一个git config的工具，可以设置和获取配置，用来控制Git外观及操作。这些变量可以存放在三个不同的位置，根据存放位置不同作用的范围也不同。 1./etc/gitconfig：包含系统上每个用户及其存储库的配置。 2.~/.gitconfig或~/.config/git/config：每个用户专属的配置 3.config.git/config：当前使用存储库的git目录，用于该存储库的配置 如果有相同配置项时，每个级别都会覆盖上一个级别中的值，即：3\u003e2\u003e1 可以使用一下命令查看所有设置以及设置的所属： $ git config --list --show-origin 常见配置 下面介绍一些常见配置 身份配置 安装完Git做的第一件事应该是设置用户名和电子邮箱。 $ git config --global user.name \"John Doe\" $ git config --global user.email johndoe@example.com 使用global后，该信息将会始终作用域Git操作上 Git编辑器配置 Git默认的编辑器是系统默认编辑器 如果要是用其他文本编辑器（例如vim），则可以执行以下操作： $ git config --global core.editor vim 查看配置 如果要查看配置，可以使用git config --list命令列出Git可以找到的所有设置 你可能会看到很多配置项，找不到你想要的，这时候你可以通过git config \u003ckey\u003e来查看特定的配置，例： $ git config user.name silencehuliang ","date":"2019-05-11","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:9","tags":["工具","教程"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"帮助 获取方式 Git获取帮助的方式有三种git help \u003cverb\u003e、git \u003cverb\u003e --help、man git-\u003cverb\u003e 例如，可以通过git help config获取config的相关帮助 如果只需要快速了解Git命令的可用选项也可以用-h来查看相关帮助 例如git add -h ","date":"2019-05-11","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:10","tags":["工具","教程"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"创建项目 1.将本地不收版本控制的目录转换为Git仓库 ①进入本地目录 $ cd ~/Desktop/project ②输入转化命令 $ git init 此时会在当前目录下创建一个.git目录，里面存放着Git仓库中所有的必须文件 $ ls -a . .. .git 2.从其他地方克隆现有的Git仓库 ①进入我们需要存放仓库的路径 $ cd ~/Desktop/ ②将现有的仓库克隆下来 $ git clone https://github.com/Silencehuliang/project ","date":"2019-05-11","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:11","tags":["工具","教程"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"查看状态 可以通过git status 查看仓库中稳健的状态 绿色表示文件在暂存区 红色表示文件在工作区 可以通过git add 将工作区文件添加到暂存区 添加项目中所有文件：git add . 添加指定文件：git add xxx.py 可以通过git commit将暂存区文件提交到仓库区 git commit -m \"修改描述\"，其中-m参数后面跟的是对本次修改的描述 git commit -am \"修改描述\",可以通过-am来实现添加和提交合并操作 ","date":"2019-05-11","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:13","tags":["工具","教程"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"查看历史版本 通过git log或者git relog可以查看历史版本 ","date":"2019-05-11","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:14","tags":["工具","教程"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"回退版本 通过版本号会退版本 git reset --hard 版本号 通过HEAD回退版本 当工作区文件发生了意外需要回退到上一个版本时可以通过 `git reset --hard HEAD` HEAD表示当前最新版本 HEAD^表示当前最新版本的前一个版本 HEAD^^表示当前最新版本的前两个版本，以此类推… HEAD~1表示当前最新版本的前一个版本 HEAD~10表示当前最新版本的前10个版本，以此类推… ","date":"2019-05-11","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:15","tags":["工具","教程"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"撤销修改 只能撤销工作区、暂存区的代码,不能撤销仓库区的代码 撤销仓库区的代码就相当于回退版本操作 撤销工作区代码 新加代码num3 = 30，不add到暂存区，保留在工作区 git checkout 文件名 撤销暂存区代码 新加代码num3 = 30，并add到暂存区 # 第一步：将暂存区代码撤销到工作区 git reset HEAD 文件名 # 第二步：撤销工作区代码 git checkout 文件名 ","date":"2019-05-11","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:16","tags":["工具","教程"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"对比版本 对比版本库与工作区 新加代码num3 = 30，不add到暂存区，保留在工作区 git diff HEAD -- xxx.py 对比版本库 新加代码num3 = 30，并add到暂存区 git diff HEAD HEAD^ -- xxx.py ","date":"2019-05-11","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:17","tags":["工具","教程"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"删除文件 删除文件分为确定删除和误删 在项目中新建test.py文件，并添加和提交到仓库 确定删除处理： # 删除文件 rm 文件名 # git确定删除文件，对比添加文件git add git rm 文件名 # 删除后记录删除操作版本 git commit -m '删除描述' 误删处理：撤销修改即可 # 删除文件 rm 文件名 # git撤销修改 git checkout -- 文件名 ","date":"2019-05-11","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:18","tags":["工具","教程"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"代码冲突 提示：多人协同开发时，避免不了会出现代码冲突的情况 原因：多人同时修改了同一个文件 危害：会影响正常的开发进度 注意：一旦出现代码冲突，必须先解决再做后续开发 解决冲突 原则：谁冲突谁解决，并且一定要协商解决 方案：保留所有代码 或者 保留某一人代码 解决完冲突代码后，依然需要add、commit、push，如果执行pull没有影响，就算真正解决了冲突代码 补充： 容易冲突的操作方式 多个人同时操作了同一个文件 一个人一直写不提交 修改之前不更新最新代码 提交之前不更新最新代码 擅自修改同事代码 减少冲突的操作方式 养成良好的操作习惯,先pull在修改,修改完立即commit和push 一定要确保自己正在修改的文件是最新版本的 各自开发各自的模块 如果要修改公共文件,一定要先确认有没有人正在修改 下班前一定要提交代码,上班第一件事拉取最新代码 一定不要擅自修改同事的代码 ","date":"2019-05-11","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:19","tags":["工具","教程"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"标签 当某一个大版本完成之后,需要打一个标签 作用： 记录大版本 备份大版本代码 在本地打标签 git tag -a 标签名 -m '标签描述' 推送标签到远程仓库 git push origin 标签名 删除本地和远程标签 # 删除本地标签 git tag -d 标签名 # 删除远程仓库标签 git push origin --delete tag 标签名 ","date":"2019-05-11","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:20","tags":["工具","教程"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["一篇文章学会系列"],"content":"分支 作用： 区分生产环境代码以及开发环境代码 研究新的功能或者攻关难题 解决线上bug 特点： 项目开发中公用分支包括master、dev 分支master是默认分支，用于发布，当需要发布时将dev分支合并到master分支 分支dev是用于开发的分支，开发完阶段性的代码后，需要合并到master分支 查看当前分支 git branch 创建并切换到dev分支 git checkout -b dev 设置本地分支跟踪远程指定分支（将分支推送到远程） git push -u origin dev 分支合并到master分支 先切换到master分支 git checkout master 分支合并到master分支 git merge dev ","date":"2019-05-11","objectID":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/:1:21","tags":["工具","教程"],"title":"一篇文章学会Git","uri":"/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Agit/"},{"categories":["Django"],"content":"Django2.x搭建博客","date":"2019-04-20","objectID":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/","tags":["博客","Django"],"title":"Django2.x搭建博客","uri":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Django"],"content":"声明：以下内容均为我个人的理解，如果发现错误或者疑问可以联系我共同探讨 ","date":"2019-04-20","objectID":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:0:0","tags":["博客","Django"],"title":"Django2.x搭建博客","uri":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Django"],"content":"简介 学完Django2.x可以搭建一个个人博客练练手 ","date":"2019-04-20","objectID":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:1:0","tags":["博客","Django"],"title":"Django2.x搭建博客","uri":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Django"],"content":"教程 ","date":"2019-04-20","objectID":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:2:0","tags":["博客","Django"],"title":"Django2.x搭建博客","uri":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Django"],"content":"创建项目 通过pycharm创建博客项目与虚拟环境 ","date":"2019-04-20","objectID":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:2:1","tags":["博客","Django"],"title":"Django2.x搭建博客","uri":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Django"],"content":"修改相关设置 允许任何域名 在开发和测试的时候可以将这里填为*，后期部署上线后修改为指定域名即可 ALLOWED_HOSTS = ['*'] 注册应用 INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', # 注册应用，当使用pycharm创建时会帮我们自动创建 'post.apps.PostConfig', ] 配置模版 TEMPLATES = [ { # 选择我们的模板引擎，刚刚用pycharm创建时已选择django自带的模板引擎 'BACKEND': 'django.template.backends.django.DjangoTemplates', # 注册我们模版文件夹的位置，刚刚用pycharm创建时已将名字定为`templates` 'DIRS': [os.path.join(BASE_DIR, 'templates')] , 'APP_DIRS': True, 'OPTIONS': { 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', ], }, }, ] 注册完后，在项目根目录中（即manage.py所在的目录）创建templates文件夹，使用pycharm创建项目会自动帮我们创建 配置数据库 DATABASES = { 'default': { # 选择使用的数据库类型，这里为mysql 'ENGINE': 'django.db.backends.mysql', # 数据库名称 'NAME': 'djangoblog', # 数据库用户名 'USER': 'root', # 数据库密码 'PASSWORD': '123456', # 数据库ip，留空默认为localhost 'HOST': '', # 数据库端口，留空默认为3306 'PORT': '3306', } } 创建mysql数据库 在注册完数据库后创建mysql数据库 \u003e\u003e\u003e mysql -uroot -p mysql\u003e create database djangoblog charset=utf8; mysql\u003e show databases; +--------------------+ | Database | +--------------------+ | information_schema | | blog | | djangoblog | | mysql | | performance_schema | | sys | +--------------------+ 6 rows in set (0.01 sec) 数据库迁移 接下来进行数据库迁移，并创建django-admin管理员 按照之前的文章：Django2.0正确配置MySQL，配置好MySQL数据库 接下来再进行数据库迁移 (DjangoBlogEnv) hls-MacBook-Pro:DjangoBlog hl$ python manage.py makemigrations No changes detected (DjangoBlogEnv) hls-MacBook-Pro:DjangoBlog hl$ python manage.py migrate Operations to perform: Apply all migrations: admin, auth, contenttypes, sessions Running migrations: Applying contenttypes.0001_initial... OK Applying auth.0001_initial... OK Applying admin.0001_initial... OK Applying admin.0002_logentry_remove_auto_add... OK Applying admin.0003_logentry_add_action_flag_choices... OK Applying contenttypes.0002_remove_content_type_name... OK Applying auth.0002_alter_permission_name_max_length... OK Applying auth.0003_alter_user_email_max_length... OK Applying auth.0004_alter_user_username_opts... OK Applying auth.0005_alter_user_last_login_null... OK Applying auth.0006_require_contenttypes_0002... OK Applying auth.0007_alter_validators_add_error_messages... OK Applying auth.0008_alter_user_username_max_length... OK Applying auth.0009_alter_user_last_name_max_length... OK Applying auth.0010_alter_group_name_max_length... OK Applying auth.0011_update_proxy_permissions... OK Applying sessions.0001_initial... OK 出现Applying sessions.0001_initial… OK 代表mysql数据库已配置完成，接下来创建django-admin管理员 (DjangoBlogEnv) hls-MacBook-Pro:DjangoBlog hl$ python manage.py createsuperuser 用户名 (leave blank to use 'hl'): silencehl 电子邮件地址: silencehuliang@163.com Password: Password (again): 密码跟 用户名 太相似了。 密码长度太短。密码必须包含至少 8 个字符。 这个密码太常见了。 Bypass password validation and create user anyway? [y/N]: y Superuser created successfully. 出现Superuser created successfully.这一阶段数据库配置已完成，这里产生的数据库是Django自带的一些库 其他设置 区域语言设置，防止admin界面乱码 # 设置语言为中文 LANGUAGE_CODE = 'zh-hans' # 设置时区为上海 TIME_ZONE = 'Asia/Shanghai' 静态文件夹与多媒体文件夹设置 # 设置静态文件目录和名称 STATIC_URL = '/static/' # 设置静态文件夹目录的路径 STATICFILES_DIRS = ( os.path.join(BASE_DIR, 'static'), ) # 设置多媒体文件目录和名称 MEDIA_URL = '/media/' # 设置多媒体文件目录的路径 MEDIA_ROOT = os.path.join(BASE_DIR, 'media') 在settings.py里设置完毕后，我们在项目中也创建这两个文件在，在项目根目录中创建static与media这两个文件夹 配置pycharm运行参数 配置完成后点击pycharm中的运行按钮，在浏览器中输入127.0.0.1:8000访问，出现小火箭升空表示Django安装成功， 访问Django-admin界面， 在浏览器中输入127.0.0.1:8000/admin，看到Django管理，需要输入用户名密码，输入用户名密码后可以跳转到Django管理页面表示Django-admin设置成功 ","date":"2019-04-20","objectID":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:2:2","tags":["博客","Django"],"title":"Django2.x搭建博客","uri":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Django"],"content":"数据库表分析 文章表 字段 类型 备注 id PrimaryKey 主键 title CharField 标题 create_time DateTimeField 创建时间 views PositiveIntegerField 阅读数 summary TextField 摘要 content TextField 内容 category_id ForeignKey 外键，分类id tag_id ManyToManyField 外键，标签id 分类表 字段 类型 备注 id PrimaryKey 主键 name CharField 分类名 标签表 字段 类型 备注 id PrimaryKey 主键 name CharField 标签名 用户表 字段 类型 备注 id PrimaryKey 主键 name CharField 用户名 password CharField 密码 评论表 字段 类型 备注 id PrimaryKey 主键 user_id ManyToManyField 外键，用户名id blog_id ManyToManyField 外键，博客id create_time DateTimeField 创建时间 content TextField 评论内容 Parent_id PositiveIntegerField 父评论id ","date":"2019-04-20","objectID":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:2:3","tags":["博客","Django"],"title":"Django2.x搭建博客","uri":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Django"],"content":"编写模型类代码 根据数据库设计表格完成模型类代码 # DjangoBlog/post/models.py from django.db import models class Category(models.Model): \"\"\"分类\"\"\" name = models.CharField('分类', max_length=100) class Meta: verbose_name = '分类' verbose_name_plural = verbose_name def __str__(self): return self.name class Tags(models.Model): \"\"\"标签\"\"\" name = models.CharField('标签', max_length=100) class Meta: verbose_name = '标签' verbose_name_plural = verbose_name def __str__(self): return self.name class Article(models.Model): \"\"\"博客\"\"\" title = models.CharField('标题', max_length=100) create_time = models.DateTimeField('创建时间', auto_now_add=True) views = models.PositiveIntegerField('阅读数', default=0) summary = models.TextField('摘要') content = models.TextField('内容') category_id = models.ForeignKey(Category, on_delete=models.DO_NOTHING, verbose_name='分类') tag_id = models.ManyToManyField(Tags, verbose_name='标签') class Meta: verbose_name = '文章' verbose_name_plural = '文章' def __str__(self): return self.title class User(models.Model): \"\"\"用户\"\"\" name = models.CharField('用户名', max_length=100) password = models.CharField('密码', max_length=100) class Meta: verbose_name = '用户名' verbose_name_plural = verbose_name def __str__(self): return self.name class Comment(models.Model): \"\"\"评论\"\"\" user = models.ManyToManyField(User, verbose_name='用户') article = models.ManyToManyField(Article, verbose_name='博客') create_time = models.DateTimeField('创建时间', auto_now_add=True) content = models.TextField('内容') Parent_id = models.PositiveIntegerField('父评论id') class Meta: verbose_name = '评论' verbose_name_plural = verbose_name def __str__(self): return self.content 数据库迁移 (DjangoBlogEnv) hls-MacBook-Pro:DjangoBlog hl$ python manage.py makemigrations Migrations for 'blog': blog/migrations/0001_initial.py - Create model Article - Create model Category - Create model Tags - Create model User - Create model Comment - Add field category_id to article - Add field tag_id to article (DjangoBlogEnv) hls-MacBook-Pro:DjangoBlog hl$ python manage.py migrate Operations to perform: Apply all migrations: admin, auth, blog, contenttypes, sessions Running migrations: Applying blog.0001_initial... OK ","date":"2019-04-20","objectID":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:2:4","tags":["博客","Django"],"title":"Django2.x搭建博客","uri":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Django"],"content":"用django-admin管理 数据库迁移完成会在post应用下生成一个迁移的文件，接下来在django-admin中注册模型，便于我们用django-admin管理 /post/admin.py from django.contrib import admin from .models import Article, Category, Tags, User, Comment @admin.register(Article) class ArticleAdmin(admin.ModelAdmin): # 在后台显示的字段 list_display = ('id', 'title', 'create_time', 'category_id', 'views') # 分页的个数 list_per_page = 10 # 按时间倒序排序 ordering = ('-create_time',) # 点击修改的字段 list_display_links = ('id', 'title') @admin.register(Category) class CategoryAdmin(admin.ModelAdmin): list_display = ('id', 'name') @admin.register(Tags) class TagsAdmin(admin.ModelAdmin): list_display = ('id', 'name') @admin.register(User) class UserAdmin(admin.ModelAdmin): list_display = ('id', 'name', 'password') @admin.register(Comment) class CommentAdmin(admin.ModelAdmin): list_display = ('id', 'content', 'create_time') 登陆Django管理后台，查看模型是否可以被管理，尝试点击添加与修改，没问题就说明注册成功 ","date":"2019-04-20","objectID":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:2:5","tags":["博客","Django"],"title":"Django2.x搭建博客","uri":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Django"],"content":"集成Markdown 很多人喜欢用markdown格式写博客，我们可以通过集成Django-mdeditor 来实现这个功能 1.安装django-mdeditor pip install django-mdeditor 2.在apps中注册 INSTALLED_APPS = [ ... 'mdeditor', ] 3.在media下创建editor文件夹 cd media mkdir editor 4.集成到路由中 /blog/urls.py from django.conf.urls import url, include from django.conf.urls.static import static from django.conf import settings ... urlpatterns = [ ... url(r'mdeditor/', include('mdeditor.urls')) ] if settings.DEBUG: # static files (images, css, javascript, etc.) urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT) 5.集成到models中 from mdeditor.fields import MDTextField class Article(models.Model): ... content = MDTextField() ... 再次进入admin，选择文章修改就可以看到集成的markdown编辑器了 ","date":"2019-04-20","objectID":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:2:6","tags":["博客","Django"],"title":"Django2.x搭建博客","uri":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Django"],"content":"实现视图 首先找到一套你喜欢的模版，将模版下载下来，html部分放入templates中，其他静态文件放入static中 将重复出现的部分提取出来，这个根据自己的模版抽取，每个都不相同，静态文件加载 如果一次没有提取好，可以慢慢一点点的抽取，对于一个后端程序员来说这个是一个慢工出细活的过程.可以写一个简单的视图，然后开着Django一边抽取一遍调试 接下来实现首页试图 首先在urls.py中配置路由 DjangoBlog/u rls.py ... from blog import views urlpatterns = [ ... path('', views.index, name='index') ] 这里path里第一个参数为访问的url，匹配采用正则表达式，第二个参数为视图函数，第三个为取的名字 接下来在blog应用的views.py中编写视图函数 blog/views.py ... def index(request): return render(request, 'index.html') 这样当我们重新访问127.0.0.1:8000时，我们修改的前端代码就被加载了 接下来我们实现将分类加载,将index视图修改为一下代码 blog/views.py ... from .models import Category # 从models里导入Category类 def index(request): categorys = Category.objects.all() # 把查询出来的分类封装到上下文里 context = { 'categorys': categorys, } print(context) return render(request, 'index.html', context) 在前端代码中渲染，我们找到base.html,将ul标签中的除首页以外的代码改为一下代码 \u003cheader class=\"header-navigation\" id=\"header\"\u003e \u003cnav\u003e \u003cdiv class=\"logo\"\u003e\u003ca href=\"/\"\u003e胡亮个人博客\u003c/a\u003e\u003c/div\u003e \u003ch2 id=\"mnavh\"\u003e\u003cspan class=\"navicon\"\u003e\u003c/span\u003e\u003c/h2\u003e \u003cul id=\"starlist\"\u003e \u003cli\u003e\u003ca href=\"index.html\"\u003e首页\u003c/a\u003e\u003c/li\u003e \u003c/ul\u003e \u003c/nav\u003e \u003c/header\u003e 这样分类栏就加载出来了，如果没有数据可以通过admin添加数据 ","date":"2019-04-20","objectID":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:2:7","tags":["博客","Django"],"title":"Django2.x搭建博客","uri":"/django2.x%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Django"],"content":"Django配置文件详解","date":"2019-04-13","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E6%A8%A1%E6%9D%BF/","tags":["Django","教程"],"title":"Django基础教程之模板","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E6%A8%A1%E6%9D%BF/"},{"categories":["Django"],"content":"声明：以下内容均为我个人的理解，如果发现错误或者疑问可以联系我共同探讨 本教程为Django基础教程系列第六篇，前面篇章在以下链接： Django基础教程之Django介绍 Django基础教程之工程搭建 Django基础教程之配置文件详解 Django基础教程之请求与响应 Django基础教程之类视图与中间件 ","date":"2019-04-13","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E6%A8%A1%E6%9D%BF/:0:0","tags":["Django","教程"],"title":"Django基础教程之模板","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E6%A8%A1%E6%9D%BF/"},{"categories":["Django"],"content":"由于发现目前网上有很多大神的教学文章都比较出色，我就不班门弄斧继续出Django相关教程，以后会继续跟大家分享在使用Django中遇到的问题与解决方案，下面推荐几个比较好的学习Django的博客，大家可以根据自己情况选择学习 菜鸟教程 追梦人物的博客 Django中文网 Django官方文档 ","date":"2019-04-13","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E6%A8%A1%E6%9D%BF/:1:0","tags":["Django","教程"],"title":"Django基础教程之模板","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E6%A8%A1%E6%9D%BF/"},{"categories":["Django"],"content":"Django基础教程之类视图与中间件","date":"2019-03-30","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/","tags":["Django","教程"],"title":"Django基础教程之类视图与中间件","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"categories":["Django"],"content":"声明：以下内容均为我个人的理解，如果发现错误或者疑问可以联系我共同探讨 本教程为Django基础教程系列第五篇，前面篇章在以下链接： Django基础教程之Django介绍 Django基础教程之工程搭建 Django基础教程之配置文件详解 Django基础教程之请求与响应 ","date":"2019-03-30","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/:0:0","tags":["Django","教程"],"title":"Django基础教程之类视图与中间件","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"categories":["Django"],"content":"类视图 以函数的方式定义的视图称为函数视图，函数视图便于理解。但是遇到一个视图对应的路径提供了多种不同HTTP请求方式的支持时，便需要在一个函数中编写不同的业务逻辑，代码可读性与复用性都不佳。 在Django中也可以使用类来定义一个视图，称为类视图。使用类视图可以将视图对应的不同请求方式以类中的不同方法来区别定义。 类视图的好处 代码可读性好 类视图相对于函数视图有更高的复用性， 如果其他地方需要用到某个类视图的某个特定逻辑，直接继承该类视图即可 类视图使用 定义类视图需要继承自Django提供的父类View，可使用from django.views.generic import View或者from django.views.generic.base import View 导入 配置路由时，使用类视图的as_view()方法来添加。 ","date":"2019-03-30","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/:1:0","tags":["Django","教程"],"title":"Django基础教程之类视图与中间件","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"categories":["Django"],"content":"类视图原理 类视图使用装饰器 类视图Mixin扩展类 ","date":"2019-03-30","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/:1:1","tags":["Django","教程"],"title":"Django基础教程之类视图与中间件","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"categories":["Django"],"content":"中间件 Django中的中间件是一个轻量级、底层的插件系统，可以介入Django的请求和响应处理过程，修改Django的输入或输出。中间件的设计为开发者提供了一种无侵入式的开发方式，增强了Django框架的健壮性。 我们可以使用中间件，在Django处理视图的不同阶段对输入或输出进行干预。 ","date":"2019-03-30","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/:2:0","tags":["Django","教程"],"title":"Django基础教程之类视图与中间件","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"categories":["Django"],"content":"中间件的定义方法 定义一个中间件工厂函数，然后返回一个可以别调用的中间件。 中间件工厂函数需要接收一个可以调用的get_response对象。 返回的中间件也是一个可以被调用的对象，并且像视图一样需要接收一个request对象参数，返回一个response对象。 定义好中间件后，需要在settings.py 文件中添加注册中间件 ","date":"2019-03-30","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/:2:1","tags":["Django","教程"],"title":"Django基础教程之类视图与中间件","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"categories":["Django"],"content":"多个中间件的执行顺序 在请求视图被处理前，中间件由上至下依次执行 在请求视图被处理后，中间件由下至上依次执行 ","date":"2019-03-30","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/:2:2","tags":["Django","教程"],"title":"Django基础教程之类视图与中间件","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E7%B1%BB%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"categories":["Django"],"content":"Django基础教程之请求与相应","date":"2019-03-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/","tags":["Django","教程"],"title":"Django基础教程之请求与相应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/"},{"categories":["Django"],"content":"Django基础教程之Django介绍 Django基础教程之工程搭建 Django基础教程之配置文件详解 声明：以下内容均为我个人的理解，如果发现错误或者疑问可以联系我共同探讨 本教程为Django基础教程系列第四篇，前面篇章在以下链接： Django基础教程之Django介绍 Django基础教程之工程搭建 Django基础教程之配置文件详解 ","date":"2019-03-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/:0:0","tags":["Django","教程"],"title":"Django基础教程之请求与相应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/"},{"categories":["Django"],"content":"前言 在Django基础教程之工程搭建中，视图相关部分提到过Django中视图的功能是接受请求，进行业务处理，返回响应。今天就来研究一下Django中的请求与相应部分。 ","date":"2019-03-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/:1:0","tags":["Django","教程"],"title":"Django基础教程之请求与相应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/"},{"categories":["Django"],"content":"请求 利用HTTP协议向服务器传参有几种途径？ 提取URL的特定部分，可以通过服务器端路由中用正则表达式截取； 查询字符串（query string)； 请求体（body）中发送的数据，比如表单数据、json、xml； 在http报文的头（header）中。 ","date":"2019-03-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/:2:0","tags":["Django","教程"],"title":"Django基础教程之请求与相应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/"},{"categories":["Django"],"content":"URL路径参数 在定义路由URL时，可以使用正则表达式提取参数的方法从URL中获取请求参数，Django会将提取的参数直接传递到视图的传入参数中。 未命名参数按定义顺序传递， 如 url(r'^weather/([a-z]+)/(\\d{4})/$', views.weather), def weather(request, city, year): print('city=%s' % city) print('year=%s' % year) return HttpResponse('OK') 命名参数按名字传递，如 url(r'^weather/(?P\u003ccity\u003e[a-z]+)/(?P\u003cyear\u003e\\d{4})/$', views.weather), def weather(request, year, city): print('city=%s' % city) print('year=%s' % year) return HttpResponse('OK') ","date":"2019-03-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/:2:1","tags":["Django","教程"],"title":"Django基础教程之请求与相应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/"},{"categories":["Django"],"content":"QueryDict对象 与python字典不同，QueryDict类型的对象用来处理同一个键带有多个值的情况，HttpRequest对象的属性GET、POST都是QueryDict类型的对象 get方法：根据键获取值，如果一个键同时拥有多个值将获取最后一个值，如果键不存在则返回None值，可以设置默认值进行后续处理 getlist方法：根据键获取值，值以列表返回，可以获取指定键的所有值，如果键不存在则返回空列表，可以设置默认值进行后续处理 ","date":"2019-03-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/:2:2","tags":["Django","教程"],"title":"Django基础教程之请求与相应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/"},{"categories":["Django"],"content":"查询字符串Query String 获取请求路径中的查询字符串参数，可以通过request.GET属性获取，返回QueryDict对象。查询字符串不区分请求方式，即假使客户端进行POST方式的请求，依然可以通过request.GET获取请求中的查询字符串数据。 ","date":"2019-03-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/:2:3","tags":["Django","教程"],"title":"Django基础教程之请求与相应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/"},{"categories":["Django"],"content":"请求体 请求体数据格式不固定，可以是表单类型字符串，可以是JSON字符串，可以是XML字符串，应区别对待。 可以发送请求体数据的请求方式有POST、PUT、PATCH、DELETE。 Django默认开启了CSRF防护，会对上述请求方式进行CSRF防护验证，在测试时可以关闭CSRF防护机制，方法为在settings.py文件中注释掉CSRF中间件 ","date":"2019-03-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/:2:4","tags":["Django","教程"],"title":"Django基础教程之请求与相应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/"},{"categories":["Django"],"content":"表单 Form Data 前端发送的表单类型的请求体数据，可以通过request.POST属性获取，返回QueryDict对象。request.POST只能用来获取POST方式的请求体表单数据。 ","date":"2019-03-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/:2:5","tags":["Django","教程"],"title":"Django基础教程之请求与相应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/"},{"categories":["Django"],"content":"非表单类型 Non-Form Data 非表单类型的请求体数据，Django无法自动解析，可以通过request.body属性获取最原始的请求体数据，自己按照请求体格式（JSON、XML等）进行解析。request.body返回bytes类型。 ","date":"2019-03-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/:2:6","tags":["Django","教程"],"title":"Django基础教程之请求与相应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/"},{"categories":["Django"],"content":"请求头 可以通过request.META属性获取请求头headers中的数据，request.META为字典类型。 常见的请求头如： CONTENT_LENGTH – 请求体的长度。 CONTENT_TYPE – 请求体的类型。 HTTP_ACCEPT – 响应的可接受内容类型。 HTTP_ACCEPT_ENCODING – 可接受的响应码。 HTTP_ACCEPT_LANGUAGE – 响应的可接受语言。 HTTP_HOST – 客户端发送的HTTP主机报头。 HTTP_REFERER – 参考页面。 HTTP_USER_AGENT – 客户机的用户代理字符串。 QUERY_STRING – 查询字符串，作为单个(未解析的)字符串。 REMOTE_ADDR – 客户端的IP地址。 REMOTE_HOST – 客户机的主机名。 REMOTE_USER – Web服务器认证的用户。 REQUEST_METHOD – 请求方式字符串，如\"GET\"或\"POST”。 SERVER_NAME – 服务器的主机名。 SERVER_PORT – 服务器的端口。 ","date":"2019-03-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/:2:7","tags":["Django","教程"],"title":"Django基础教程之请求与相应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/"},{"categories":["Django"],"content":"其他常用HttpRequest对象属性 method：一个字符串，表示请求使用的HTTP方法，常用值包括：‘GET’、‘POST’。 user：请求的用户对象。 path：一个字符串，表示请求的页面的完整路径，不包含域名和参数部分。 encoding：一个字符串，表示提交的数据的编码方式。 如果为None则表示使用浏览器的默认设置，一般为utf-8。 这个属性是可写的，可以通过修改它来修改访问表单数据使用的编码，接下来对属性的任何访问将使用新的encoding值。 FILES：一个类似于字典的对象，包含所有的上传文件。 ","date":"2019-03-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/:2:8","tags":["Django","教程"],"title":"Django基础教程之请求与相应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/"},{"categories":["Django"],"content":"响应 视图在接收请求并处理后，必须返回HttpResponse对象或子对象。HttpRequest对象由Django创建，HttpResponse对象由开发人员创建。 ","date":"2019-03-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/:3:0","tags":["Django","教程"],"title":"Django基础教程之请求与相应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/"},{"categories":["Django"],"content":"HttpResponse 可以使用django.http.HttpResponse来构造响应对象。也可通过HttpResponse对象属性来设置响应体、状态码： content：表示返回的内容。 status_code：返回的HTTP响应状态码。 响应头可以直接将HttpResponse对象当做字典进行响应头键值对的设置 ","date":"2019-03-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/:3:1","tags":["Django","教程"],"title":"Django基础教程之请求与相应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/"},{"categories":["Django"],"content":"HttpResponse子类 Django提供了一系列HttpResponse的子类，可以快速设置状态码 HttpResponseRedirect 301 HttpResponsePermanentRedirect 302 HttpResponseNotModified 304 HttpResponseBadRequest 400 HttpResponseNotFound 404 HttpResponseForbidden 403 HttpResponseNotAllowed 405 HttpResponseGone 410 HttpResponseServerError 500 ","date":"2019-03-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/:3:2","tags":["Django","教程"],"title":"Django基础教程之请求与相应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/"},{"categories":["Django"],"content":"JsonResponse 若要返回json数据，可以使用JsonResponse来构造响应对象，作用： 帮助我们将数据转换为json字符串 设置响应头Content-Type为 application/json ","date":"2019-03-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/:3:3","tags":["Django","教程"],"title":"Django基础教程之请求与相应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/"},{"categories":["Django"],"content":"redirect重定向 ","date":"2019-03-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/:3:4","tags":["Django","教程"],"title":"Django基础教程之请求与相应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/"},{"categories":["Django"],"content":"Cookie Cookie，有时也用其复数形式Cookies，指某些网站为了辨别用户身份、进行session跟踪而储存在用户本地终端上的数据（通常经过加密）。Cookie最早是网景公司的前雇员Lou Montulli在1993年3月的发明。Cookie是由服务器端生成，发送给User-Agent（一般是浏览器），浏览器会将Cookie的key/value保存到某个目录下的文本文件内，下次请求同一网站时就发送该Cookie给服务器（前提是浏览器设置为启用cookie）。Cookie名称和值可以由服务器端开发自己定义，这样服务器可以知道该用户是否是合法用户以及是否需要重新登录等。服务器可以利用Cookies包含信息的任意性来筛选并经常性维护这些信息，以判断在HTTP传输中的状态。Cookies最典型记住用户名。 Cookie是存储在浏览器中的一段纯文本信息，建议不要存储敏感信息如密码，因为电脑上的浏览器可能被其它人使用。 ","date":"2019-03-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/:4:0","tags":["Django","教程"],"title":"Django基础教程之请求与相应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/"},{"categories":["Django"],"content":"Cookie的特点 Cookie以键值对的格式进行信息的存储。 Cookie基于域名安全，不同域名的Cookie是不能互相访问的，如访问itcast.cn时向浏览器中写了Cookie信息，使用同一浏览器访问baidu.com时，无法访问到itcast.cn写的Cookie信息。 当浏览器请求某网站时，会将浏览器存储的跟网站相关的所有Cookie信息提交给网站服务器。 ","date":"2019-03-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/:4:1","tags":["Django","教程"],"title":"Django基础教程之请求与相应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/"},{"categories":["Django"],"content":"设置Cookie 可以通过HttpResponse对象中的set_cookie方法来设置cookie。 ","date":"2019-03-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/:4:2","tags":["Django","教程"],"title":"Django基础教程之请求与相应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/"},{"categories":["Django"],"content":"读取Cookie 可以通过HttpRequest对象的COOKIES属性来读取本次请求携带的cookie值。request.COOKIES为字典类型。 ","date":"2019-03-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/:4:3","tags":["Django","教程"],"title":"Django基础教程之请求与相应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/"},{"categories":["Django"],"content":"Session **Django项目默认启用Session。**如需禁用session，将上图中的session中间件注释掉即可。 ","date":"2019-03-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/:5:0","tags":["Django","教程"],"title":"Django基础教程之请求与相应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/"},{"categories":["Django"],"content":"存储方式 在settings.py文件中，可以设置session数据的存储方式，可以保存在数据库、本地缓存等。 数据库 存储在数据库中，如下设置可以写，也可以不写，这是默认存储方式。 SESSION_ENGINE='django.contrib.sessions.backends.db' 如果存储在数据库中，需要在项INSTALLED_APPS中安装Session应用。 INSTALLED_APPS = [ ... 'django.contrib.sessions', ... ] 存储在数据库中会生成一个diango_session的表，表结构为：键、值、过期时间 本地缓存 存储在本机内存中，如果丢失则不能找回，比数据库的方式读写更快。 SESSION_ENGINE='django.contrib.sessions.backends.cache' 混合存储 优先从本机内存中存取，如果没有则从数据库中存取。 SESSION_ENGINE='django.contrib.sessions.backends.cached_db' Redis 在redis中保存session，需要引入第三方扩展，我们可以使用django-redis来解决。 1） 安装扩展 pip install django-redis 2）配置 在settings.py文件中做如下设置 CACHES = { \"default\": { \"BACKEND\": \"django_redis.cache.RedisCache\", \"LOCATION\": \"redis://127.0.0.1:6379/1\", \"OPTIONS\": { \"CLIENT_CLASS\": \"django_redis.client.DefaultClient\", } } } SESSION_ENGINE = \"django.contrib.sessions.backends.cache\" SESSION_CACHE_ALIAS = \"default\" 注意 如果redis的ip地址不是本地回环127.0.0.1，而是其他地址，访问Django时，可能出现Redis连接错误，如下： 解决方法： 修改redis的配置文件，添加特定ip地址。 Session操作 通过HttpRequest对象的session属性进行会话的读写操作。 1） 以键值对的格式写session。 request.session['键']=值 2）根据键读取值。 request.session.get('键',默认值) 3）清除所有session，在存储中删除值部分。 request.session.clear() 4）清除session数据，在存储中删除session的整条数据。 request.session.flush() 5）删除session中的指定键及值，在存储中只删除某个键及对应的值。 del request.session['键'] 6）设置session的有效期 request.session.set_expiry(value) 如果value是一个整数，session将在value秒没有活动后过期。 如果value为0，那么用户session的Cookie将在用户的浏览器关闭时过期。 如果value为None，那么session有效期将采用系统默认值，默认为两周，可以通过在settings.py中设置SESSION_COOKIE_AGE来设置全局默认值。 ","date":"2019-03-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/:5:1","tags":["Django","教程"],"title":"Django基础教程之请求与相应","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/"},{"categories":["Django"],"content":"Django配置文件详解","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"声明：以下内容均为我个人的理解，如果发现错误或者疑问可以联系我共同探讨 本教程为Django基础教程系列第三篇，前面篇章在以下链接： Django基础教程之Django介绍 Django基础教程之工程搭建 ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:0:0","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"简介 学习Django可以从Django配置文件的各项开始，由简入深的了解其作用，从而一步一步学习。本篇文章主要是介绍各项的作用以及如何配置，可以根据需求按需配置。 ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:1:0","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"内容 ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:0","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"绝对路径映射 ABSOLUTE_URL_OVERRIDES 作用：将应用的模型字符串映射到采用模型对象并返回其url，基于get_absolute_url方法。无论实际模型类名称的大小写如何，此设置中使用的模型名称均应全部小写。 ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:1","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"管理员 ADMINS 作用：用于接收代码错误的人员列表，列表中的元素格式为（全名，电子邮箱） ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:2","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"Django项目根路径 BASE_DIR 作用：以项目根路径为基础衍生其他文件 BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) 从内到外一步一步剖析 __file__：返回当前文件 os.path.abspath(__file__)：返回当前文件的绝对路径 os.path.dirname(os.path.abspath(__file__))：返回当前文件的父目录 os.path.dirname(os.path.dirname(os.path.abspath(__file__)))：返回当前文件父目录的父目录 可能这样还不太清楚，将__file__换成settings.py,可以看出来BASE_DIR是manage.py所在的目录，即整个项目的根目录 ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:3","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"秘钥 SECRET_KEY 作用：校验，主要用于表单、session、csrf SECRET_KEY = \"adsasdasdsafdasfldasfklasdlfnlasdnfklnasdfklnasldfklkdasf\" ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:4","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"调试模式 DEBUG 作用：当开启时，运行出现bug会在前端直接显示，开发，测试过程可以开启 DEBUG = True ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:5","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"允许访问的主机 ALLOWED_HOSTS 作用：在开发的时候可以使用*，当项目上线后需要更换为指定的主机(域名和ip都可以) ALLOWED_HOSTS = [] ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:6","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"应用、模块注册 INSTALLED_APPS 作用：将独立的应用或模块接入Django（注意应用名称或者模块名称必须是唯一的） INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', ] 通常INSTALLED_APPS默认包含以下Django自带的应用 django.contrib.admin：管理员站点，可以通过admin管理项目（数据、用户、权限等），使用admin必须完成以下配置 他依赖django.contrib.auth、django.contrib.contenttypes、django.contrib.sessions、django.contrib.messages四个模块 MIDDLEWARE设置必须包括 django.contrib.auth.middleware.AuthenticationMiddleware并且django.contrib.messages.middleware.MessageMiddleware 在项目url配置中必须加入admin urls.py from django.contrib import admin from django.urls import path urlpatterns = [ path('admin/', admin.site.urls), ] 可以使用django-admin createsuperuser创建管理员用户 django.contrib.auth：认证授权系统。主要负责校验用户信息与用户权限，由以下部分组成 用户：用户管理 权限：以二进制的形式标识指定用户是否可以执行的特殊任务 组：管理多个用户的权限 可配置的密码哈希话系统 为登录用户或限制内容提供表单和视图工具 可插拔的后端系统 需要注意的是它不提供密码强度检查、限制登录尝试、第三方身份验证，对象级权限 django.contrib.contenttypes：内容类型框架,他可以跟踪Django驱动的项目中安装的所有模型，为模型提供高级的通用界面 django.contrib.sessions：会话框架 django.contrib.messages：消息框架 staticfiles：管理静态文件框架 除了这些常见的自带应用外，在我们使用自己注册的应用和第三方模块时，记得第一时间来这里注册，否则会用不了哦 ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:7","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"中间件 MIDDLEWARE 作用：中间件是Django请求/响应处理的钩子框架，用于改变Django的输入或输出 中间件可以放在Python路径上的任何地方，可以自己编写中间件，中间件可以是函数也可以是类。 函数形式的中间件 def simple_middleware(get_response): # 首次配置和初始化 def middleware(request): # 每个请求之前或调用视图函数之前执行的代码 response = get_response(request) # 每个响应、请求或者调用视图函数之后执行的代码 return response return middleware 类形式的中间件 def __init__(self, get_response): self.get_response = get_response # 首次配置和初始化 def __call__(self, request): # 每个请求之前或调用视图函数之前执行的代码 response = self.get_response(request) # 每个响应、请求或者调用视图函数之后执行的代码 return response 上述方法中调用get_response方法并不是实际视图中的，而是处理程序的包装方法，它负责应用视图中间件，调用具有适当的URL参数的视图，并应用模板响应和第三方中间件。 在使用类形式的中间件时，__init__方法必须接受get_response参数，还可以初始化中间件的一些局部状态。 想使用中间件就必须在settings.py文件中的MIDDLEWARE中激活。激活的方式是使用字符串表示指向中间件完整的Python路径 在Django中MIDDLEWARE可以为空，但是强烈建议至少激活CommonMiddleware 由于某些中间件也会依赖其他中间件所以中间件在MIDDLEWARE中的顺序很重要，Django会按自上而下的顺序调用中间件 ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:8","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"路由根路径 ROOT_URLCONF 作用：Django在处理请求时会最先从此处寻找url 需要注意的是，此处的路径是基于BASE_DIR的路径 ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:9","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"模板引擎配置 TEMPLATES 作用：在Django中使用模板引擎的设置列表，列表中每个元素都是一个字典，字典里配置模板引擎 常用的配置参数： BACKEND：项目使用的模板引擎，Django内置了两个 django.template.backends.django.DjangoTemplates django.template.backends.jinja2.Jinja2 DIRS：模板文件夹的位置 APP_DIRS：模板引擎是否在已安装的应用中讯在模板源文件 OPTIONS：传给后端模板的额外参数 ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:10","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"内置服务器的路径 WSGI_APPLICATION 作用：用于调式Django程序的内置服务器， ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:11","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"数据库配置 DATABASES 在mysite/mysite/settings.py中，默认的数据库为SQLite，还支持PostgreSQL、mysql、oracle等其他第三方（这些非官方后端支持的Django版本和ORM功能差异很大。有关这些非官方后端的具体功能的查询以及任何支持查询，应该针对每个第三方项目提供的支持渠道） DATABASES = { 'default': { 'ENGINE': 'django.db.backends.sqlite3', 'NAME': os.path.join(BASE_DIR, 'db.sqlite3'), } } ENGINE，数据库引擎，可选的ENGINE还有 django.db.backends.postgresql、django.db.backends.mysql、django.db.backends.oracle、第三方数据库 NAME，数据库名称，如果使用SQLite,他会在根目录生成一个数据库文件 当不使用SQLite时，还会有一下常用参数，其他参数可以查阅文档DATABASES NAME：数据库名字 USER：数据库的用户名 PASSWORD：数据库的密码 HOST：数据库的主机 PORT：数据库的端口 OPTIONS：连接到数据库时要使用的其他参数。可用参数取决于数据库后端。 TEST：测试数据库 测试数据库也具备一些设置，也是采用键值对的方式对数据库进行设置 CHARSET：创建测试数据库时使用的字符集编码 COLLATION：创建测试数据库时使用的排序规则 DEPENDENCIES：数据库的创建顺序依耐性 MIRROR：测试期间该数据库应镜像的数据库别名。 NAME：运行测试套件时要使用的数据库的名称。 SERIALIZE：一个布尔值，用于控制默认测试运行程序在运行测试之前是否将数据库序列化为内存中的JSON字符串。False如果没有任何带有测试类，可以将其设置为加快创建时间。 TEMPLATE：PostgreSQL的特定设置。从中创建测试数据库的模板（例如'template0'）的名称。 CREATE_DB：默认为True，Oracle特定的设置。如果将其设置为False，则测试表空间将不会在测试开始时自动创建，也不会在测试结束时自动删除。 CREATE_USER：默认为True，Oracle特定的设置。如果将其设置为False，则不会在测试开始时自动创建测试用户，并在测试结束时自动将其删除。 USER：默认为None，Oracle特定的设置。连接到运行测试时将使用的Oracle数据库时使用的用户名。如果未提供，则Django将使用。'test_' + USER PASSWORD：默认为None，Oracle特定的设置。连接到运行测试时将使用的Oracle数据库的密码。如果未提供，Django将生成一个随机密码。 TBLSPACE：默认为None，Oracle特定的设置。运行测试时将使用的表空间的名称。如果未提供，则Django将使用。'test_' + USER TBLSPACE_TMP：默认为None，Oracle特定的设置。运行测试时将使用的临时表空间的名称。如果未提供，则Django将使用。'test_' + USER + '_temp' DATAFILE：默认为None，这是Oracle特定的设置。用于TBLSPACE的数据文件的名称。如果未提供，则Django将使用。TBLSPACE + '.dbf' DATAFILE_TMP：默认为None，Oracle特定的设置。用于TBLSPACE_TMP的数据文件的名称。如果未提供，则Django将使用。TBLSPACE_TMP + '.dbf' DATAFILE_MAXSIZE：默认为500M，Oracle特定的设置。允许DATAFILE增大到的最大大小。 DATAFILE_TMP_MAXSIZE：默认为500M，Oracle特定的设置。DATAFILE_TMP允许增加到的最大大小。 DATAFILE_SIZE：默认为50M，Oracle特定的设置。DATAFILE的初始大小。 DATAFILE_TMP_SIZE：默认为50M，Oracle特定的设置。DATAFILE_TMP的初始大小。 DATAFILE_EXTSIZE：默认为25M，Oracle特定的设置。需要更多空间时，DATAFILE_TMP的扩展量。 其他的配置： ATOMIC_REQUESTS：默认为False，当设置为True时将每个视图包装在该数据库的事务中 AUTOCOMMIT:默认为True，当设置为False时警用Django的事务管理，可以自己编写事务管理机制 CONN_MAX_AGE：数据库连接的生存期，以秒为单位。用于0在每个请求结束时关闭数据库连接-Django的历史行为-并 None用于无限的持久连接。 TIME_ZONE：默认为None，用一个字符串表示存储在此数据库中的时区 ​ ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:12","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"数据库路由器列表 DATABASE_ROUTERS 作用：执行数据库查询时将用来确定要使用哪个数据库的路由器列表。 ​ ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:13","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"阈值检查 DATA_UPLOAD_MAX_NUMBER_FIELDS 作用：调用SuspiciousOperation检查GET或POST接受的最大值，当设为None时禁用检查 ​ ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:14","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"显示日期的默认格式 DATE_FORMAT 作用：在任何地方显示日期字段的默认格式。 ​ ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:15","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"密码强度列表 AUTH_PASSWORD_VALIDATORS 作用：用于检查用户密码强度的验证器列表 ​ ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:16","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"语言 LANGUAGE_CODE 作用：项目语言，默认为‘en-us’ ​ ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:17","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"时区 TIME_ZONE 作用：一个字符串表达的时区默认为’UTC’ ​ ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:18","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"翻译系统 USE_I18N 作用：指定是否启用Django的翻译系统，默认为True ​ ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:19","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"本地化 USE_L10N 作用：指定默认情况下是否启用数据本地化格式，默认为True ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:20","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"时区 USE_TZ 作用：指定日期时间默认情况下是否支持时区 ​ ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:21","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"静态文件夹的路径 STATIC_URL 作用：引用位于静态文件时使用的URL ​ ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:22","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"静态文件的绝对路径 STATIC_ROOT 作用：在部署时收集静态文件的绝对路径 ​ ","date":"2019-03-16","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:2:23","tags":["Django","教程"],"title":"Django基础教程之配置文件详解","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["Django"],"content":"Django介绍","date":"2019-03-09","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/","tags":["Django","教程"],"title":"Django基础教程之工程搭建","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/"},{"categories":["Django"],"content":"声明：以下内容均为我个人的理解，如果发现错误或者疑问可以联系我共同探讨 本教程为Django基础教程系列第二篇，前面篇章在以下链接： Django基础教程之Django介绍 ","date":"2019-03-09","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/:0:0","tags":["Django","教程"],"title":"Django基础教程之工程搭建","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/"},{"categories":["Django"],"content":"简介 每个工程项目的开始阶段往往决定了项目的大致走向，在工程搭建的过程中要为后面的项目开发做好准备。 为了不受Python环境的影响，最好建立虚拟环境，在虚拟环境中搭建项目 ","date":"2019-03-09","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/:1:0","tags":["Django","教程"],"title":"Django基础教程之工程搭建","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/"},{"categories":["Django"],"content":"教程 ","date":"2019-03-09","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/:2:0","tags":["Django","教程"],"title":"Django基础教程之工程搭建","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/"},{"categories":["Django"],"content":"安装环境 安装virtualenv virtualenv是一个用于创建Python虚拟环境的工具包，可以通过pip直接安装 pip3 install virtualenv 创建虚拟环境 virtualenv --python=/usr/bin/python3 django2.2.2_py3 django2.2.2_py3为虚拟环境的名字，这里是以Django的版本+Python版本命名，–python指定了Python的位置。 激活虚拟环境 source django2.2.2_py3/bin/activate 激活完成后会在命令行最前面显示当前的虚拟环境名 安装Django 本教程使用django2.2.2版本 pip install django==2.2.2 ","date":"2019-03-09","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/:2:1","tags":["Django","教程"],"title":"Django基础教程之工程搭建","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/"},{"categories":["Django"],"content":"项目工程 在Django中，项目的工程目录可以通过Django提供的命令来创建。 创建 创建工程的命令为： django-admin startproject 工程名称 例如你想在做面食创建一个demo的工程项目，可以执行如下命令： cd ~/Desktop/ django-admin startproject demo 执行完毕后，会在当前目录即Desktop目录下生成一个名为demo的目录，该目录存放着整个Django工程 工程目录说明 查看创建的工程目录，结构如下 (django2.2.2_py3) ~/Desktop/demo$ tree . |-- demo | |-- __init__.py | |-- settings.py | |-- urls.py | `-- wsgi.py `-- manage.py 1 directory, 5 files demo：与项目同名的目录，存放项目相关文件。 settings.py：项目的配置文件。 urls.py：项目的总URL配置文件。 wsgi.py：项目与WSGI兼容的Web服务器入口。 manage.py 项目管理文件，通过它管理项目，同时也是启动项目的入口。 运行开发服务器 在开发阶段，为了能够快速预览到开发的效果，Djnago提供了一个纯python编写的轻量级web服务器，提供开发阶段使用。 运行服务器命令如下： python manage.py runserver 默认IP是127.0.0.1，默认端口为8000，可以写指定IP与端口，格式为：ip:端口 启动后可以看到以下信息 (django2.2.2_py3) ~/Desktop/demo$ python manage.py runserver Watching for file changes with StatReloader Performing system checks... System check identified no issues (0 silenced). You have 17 unapplied migration(s). Your project may not work properly until you apply the migrations for app(s): admin, auth, contenttypes, sessions. Run 'python manage.py migrate' to apply them. February 17, 2019 - 05:29:56 Django version 2.2.2, using settings 'demo.settings' Starting development server at http://127.0.0.1:8000/ Quit the server with CONTROL-C. 在浏览器中输入网址“127.0.0.1:8000”便可看到效果。 django默认工作在调式Debug模式下，如果增加、修改、删除文件，服务器会自动重启。 按ctrl+c停止服务器。 ","date":"2019-03-09","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/:2:2","tags":["Django","教程"],"title":"Django基础教程之工程搭建","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/"},{"categories":["Django"],"content":"应用 在Web开发中通常一个大型项目是由无数个应用构成的。将开发中的工程项目拆分成不同的功能模块，可以让各功能模块之间保持相对独立，更利于我们开发与管理。 创建 Django为我们提供了创建应用的命令，创建应用的命令为： python manage.py startapp 子应用名称 需要注意的是，创建应用时必须在manage.py所在的目录下 现在创建一个用户相关的应用users，可以执行： python manage.py startapp users 执行后，可以看到工程目录中多出了一个名为users的子目录。 应用目录说明 (django2.2.2_py3) ~/Desktop/demo$ ls db.sqlite3 demo manage.py users (django2.2.2_py3) ~/Desktop/demo$ tree . |-- db.sqlite3 |-- demo | |-- __init__.py | |-- __pycache__ | | |-- __init__.cpython-36.pyc | | |-- settings.cpython-36.pyc | | |-- urls.cpython-36.pyc | | `-- wsgi.cpython-36.pyc | |-- settings.py | |-- urls.py | `-- wsgi.py |-- manage.py `-- users |-- __init__.py |-- admin.py |-- apps.py |-- migrations | `-- __init__.py |-- models.py |-- tests.py `-- views.py 4 directories, 17 files admin.py：后台管理配置信息。 apps.py：配置信息。 migrations 存放数据库迁移历史文件。 models.py：保存数据库模型类。 tests.py：用于开发测试用例，编写单元测试。 注册应用 创建完应用后Django并不能自动将项目与应用联系起来，需要我们在工程配置文件settings.py中注册才能使用。 在工程配置文件settings.py中的INSTALLED_APPS项负责注册安装好的应用，初始工程中的INSTALLED_APPS如下： 这些默认应用的作用可以看这篇文章：Django配置文件详解 注册一个应用的方法是将应用的配置信息文件apps.py中的Config类添加到INSTALLED_APPS列表中。 例如，注册刚创建的users应用，可在INSTALLED_APPS列表中添加**‘users.apps.UsersConfig’**。 创建视图 视图用于编写应用的业务逻辑，Django的视图是在应用中views.py中的 进入users应用，在views.py中编写视图代码。 from django.http import HttpResponse def index(request): \"\"\" 视图index :param request: 包含了请求信息的请求对象 :return: 响应对象 \"\"\" return HttpResponse(\"hello Django\") 说明： Django基础教程之Django介绍中提到过，Django中视图的功能是接受请求，进行业务处理，返回响应。在这里request是接受请求的对象，业务处理是生成hello Django字符串，而HttpResponse是返回响应的对象。 ","date":"2019-03-09","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/:2:3","tags":["Django","教程"],"title":"Django基础教程之工程搭建","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/"},{"categories":["Django"],"content":"路由 什么是路由 在Django中，路由是将请求的URL分发给视图的系统。 路由定义的位置 一般情况下会有两种路由定义的位置，一种是项目工程的urls.py中，一种是每个应用下的urls.py中。项目工程的urls.py是Django解析路由的入口 路由解析顺序 Django在接收到请求时会先从项目工程urls.py中的urlpatterns列表中从上至下的顺序查找对应路由规则，如果发现规则为include包含，则再进入被包含的urls中的urlpatterns列表由上至下进行查询。 路由命名 在定义路由的时候，可以为路由命名，方便查找特定视图的具体路径信息。 在定义include函数定义路由时，可以使用namespace参数定义路由的命名空间，如 url(r'^users/', include('users.urls', namespace='users')), 命名空间表示，凡是users.urls中定义的路由，均属于namespace指明的users名下。 命名空间的作用：避免不同应用中的路由使用了相同的名字发生冲突，使用命名空间区别开。 在定义普通路由时，可以使用name参数指明路由的名字，如 urlpatterns = [ url(r'^index/$', views.index, name='index'), ] 路径结尾斜线的说明 Django中定义路由时，通常以斜线结尾，其好处是用户访问不以斜线结尾的相同路径时，Django会把用户重定向到以斜线/结尾的路径上，而不会返回404不存在。如 urlpatterns = [ url(r'^index/$', views.index, name='index'), ] 用户访问 index 或者 index/ 网址，均能访问到index视图。 虽然路由结尾带斜线能带来上述好处，但是却违背了HTTP中URL表示资源位置路径的设计理念。具体是否结尾带斜线以个人风格为准。 接下来我们要通过路由将工程-\u003e应用-\u003e视图给联系起来 首先在工程的总路由中添加users应用的路由信息 from django.contrib import admin + from django.urls import path, include urlpatterns = [ path('admin/', admin.site.urls), + path('users/', include('users.urls')), ] 说明： ‘users/‘表示所有/users/开头的请求 include表示以/users/匹配到users应用中urls.py的所有路由，即只要请求的URL是/users/开头都会去users应用中的urls.py中匹配剩下的路由。 将总路由引到users应用后，需要修改users应用中urls.py的信息 from django.conf.urls import url,re_path from . import views # urlpatterns是被django自动识别的路由列表变量 urlpatterns = [ # re_path是通过正则表达式来构造路由 # re_path(路由正则表达式，视图) re_path(r'^index/$', views.index), ] 说明： 现在完整的请求url为：/users/index/ 路由修改完成后，重启Django程序，就可以在浏览器中看到返回的信息了 ","date":"2019-03-09","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/:2:4","tags":["Django","教程"],"title":"Django基础教程之工程搭建","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/"},{"categories":["Django"],"content":"Django初体验","date":"2019-03-02","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/","tags":["Django","教程"],"title":"Django基础教程之初体验","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["Django"],"content":"声明：以下内容均为我个人的理解，如果发现错误或者疑问可以联系我共同探讨 ","date":"2019-03-02","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/:0:0","tags":["Django","教程"],"title":"Django基础教程之初体验","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["Django"],"content":"简介 在Django2.0以后，Django已经不支持python2.7，所以我们需要一个python3的系统环境，这里一python3.6为例 ","date":"2019-03-02","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/:1:0","tags":["Django","教程"],"title":"Django基础教程之初体验","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["Django"],"content":"安装Django ","date":"2019-03-02","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/:2:0","tags":["Django","教程"],"title":"Django基础教程之初体验","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["Django"],"content":"三种方式安装 pip安装 一般情况下安装python后会帮你安装好pip，当你没安装时使用这个链接安装,记得更新到最新版本 安装并使用virtualenv 在创建好并激活的虚拟环境中输入一下命令 $ pip install Django 通过第三方软件包 管理系统集成的Django 安装开发版本 安装好git 输入一下命令下载Django $ git clone https://github.com/django/django.git 安装并使用virtualenv 在创建好并激活的虚拟环境中输入一下命令 $ pip install -e django/ 安装好Django后可以通过一下命令查看当前Django版本 $ python -m django --version ","date":"2019-03-02","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/:2:1","tags":["Django","教程"],"title":"Django基础教程之初体验","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["Django"],"content":"Django初体验 ","date":"2019-03-02","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/:3:0","tags":["Django","教程"],"title":"Django基础教程之初体验","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["Django"],"content":"安装并使用virtualenv 详细过程见这个链接 ","date":"2019-03-02","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/:3:1","tags":["Django","教程"],"title":"Django基础教程之初体验","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["Django"],"content":"创建Django项目 在项目存放目录打开命令行运行一下命令： $ django-admin startproject mysite 这句话执行过后会在当前目录生成一个名字为mysite的Django项目，目录结构为下 mysite/ manage.py mysite/ __init__.py settings.py urls.py wsgi.py 这些目录和文件的作用： mysite/目录：存放项目的容器，他的名字不重要可以更换为你喜欢的任何名字 manage.py：Django项目的启动文件，他可以让你通过各种方式管理Django项目。 mysite/mysite/目录：项目目录，里面存放项目相关的文件 mysite/mysite/settings.py：Django项目的配置文件 mysite/mysite/urls.py：Django项目的url声明文件,他将url对应相关的app的视图 mysite/mysite/wsgi.py：Django项目wsgi服务器的入口 当输入以下命令，并进入浏览器输入：http://127.0.0.1:8000/看到Django启动成功 $ python manage.py runserver 这里能启动成功是因为Django自带一个简易的服务器（用纯 Python 写的轻量级的 Web 服务器）。他能帮助我们快速开发。 ","date":"2019-03-02","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/:3:2","tags":["Django","教程"],"title":"Django基础教程之初体验","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["Django"],"content":"创建一个应用 将当前目录切换到manage.py所在的目录，输入下面的命令创建一个应用: $ python manage.py startapp demo 该应用的目录结构大致如下 demo/ __init__.py admin.py apps.py migrations/ __init__.py models.py tests.py views.py 这些目录和文件的作用： admin.py：管理admin后台相关数据库模型 apps.py：该应用的相关配置 migrations/文件夹及其内容：数据库迁移相关的文件夹，里面存放着迁移版本，迁移信息等 models.py：编写模型类的文件 tests.py：用于测试的文件 view.py：编写视图的文件 我们还要在项目配置文件中注册该app，打开settings.py文件，找到INSTALLED_APPS，在列表的最后添加demoapp mysite/settings.py INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', # 注册demo 'demo.apps.DemoConfig' ] ","date":"2019-03-02","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/:3:3","tags":["Django","教程"],"title":"Django基础教程之初体验","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["Django"],"content":"编写第一个视图 视图在应用的views.py中编写 demo/views.py from django.http import HttpResponse def index(request): return HttpResponse(\"Hello, world!\") 为了能看到效果我们还需要配置一下url，在demo目录下创建一个urls.py，并输入一下代码 /demo/urls.py from django.urls import path from . import views urlpatterns = [ path(\"\",views.index,name='index'), ] 更改项目url，通过修改项目urls.py文件修改路由 /mysite/urls.py from django.contrib import admin from django.urls import include, path urlpatterns = [ path('demo/', include('demo.urls')), path('admin/', admin.site.urls), ] 这里include是将demo/的路由转发到demo应用的urls.py里。每当 Django 遇到 include时，它会截断与此项匹配的 URL 的部分，并将剩余的字符串发送到 对应urls.py以供进一步处理。 path有五个参数：route、view、kwargs、name、Pattern，其中route、view是必须传入的参数 route：匹配url的准则（类似于正则表达式）。当Django响应一个请求时，他会从urlpatterns的第一项开始，按顺序依次匹配，知道找到匹配的项 view：目标视图函数。当route找到匹配的项后，会调用当前的视图函数，并传入一个HttpRequest对象作为第一个参数，route中的参数一关键字参数的形式传入 kwargs：关键字参数。任意个关键字参数可以作为一个字典传递给目标视图函数。 name：为url取的名字。他可以使Django在任意地方引用他 Pattern：匹配模式 现在可以启动Django程序来看是否正常工作 ","date":"2019-03-02","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/:3:4","tags":["Django","教程"],"title":"Django基础教程之初体验","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["Django"],"content":"数据库 创建数据库 进入mysql并创建一个test数据库，字符设置为utf8 $ mysql -uroot -p mysql\u003e create database test charset=utf8; Query OK, 1 row affected (0.00 sec) 数据库配置 首先我们需要配置mysite/setting.py中的数据库DATABASES选项，Django默认是sqlite数据库，如果个人项目不大的情况下可以使用这个，也可以使用自己熟悉的数据库，Django不仅支持sqlite，postgresql，mysql，或oracle，还支持很多有第三方插件的数据库，我使用mysql数据库 /mysite/settings.py DATABASES = { 'default': { 'ENGINE': 'django.db.backends.mysql', # 数据库名 'NAME': 'test', # 用户名 'USER': 'root', # 密码 'PASSWORD': 'mysql' # 主机,默认为localhost 'HOST': '' # 端口号，默认为3306 'PORT': '' } } 数据库迁移 因为Django自带应用已经为我们编写了一些数据模型，即时我们不编写任何模型也可以直接使用数据库迁移命令进行迁移 $ python manage.py migrate 会看到初始化了很多用户、权限相关的表 创建一个管理员账号，依次输入用户名、邮箱、密码、确认密码，建议密码设置复杂点 $ python manage.py createsuperuser 用户名 (leave blank to use '02'): admin 电子邮件地址: 1@gmail.com Password: Password (again): 密码跟 用户名 太相似了。 密码长度太短。密码必须包含至少 8 个字符。 这个密码太常见了。 Bypass password validation and create user anyway? [y/N]: y Superuser created successfully. 接下来启动项目，并在浏览器中输入http://127.0.0.1:8000/admin，进入后台管理界面 输入账号密码，点击登录即可 数据库迁移，需要三步 编写models.py文件，改变模型。 运行 python manage.py makemigrations为模型的改变生成迁移文件。 运行 python manage.py migrate 来应用数据库迁移。 创建一个图书模型 在demo应用下创建一个图书模型 /demo/models.py from django.db import models class Books(models.Model): # 书名 book_name = models.CharField(max_length=200) # 作者 author = models.CharField(max_length=50) 建立的模型有两个字段，书名和作者，使用了字符类型，增加了长度限制（注意在使用CharField时必须要添加max_length限制） 创建迁移模型并生成迁移文件 $ python manage.py makemigrations demo Migrations for 'demo': demo\\migrations\\0001_initial.py - Create model Books 会出现创建了Books这个模型，在demo应用的migrations文件夹下会多一个0001_initila.py的迁移文件，可以使用python manage.py sqlmigrate demo 0001可以查看这次数据库迁移的操作与具体的SQL语句 $ python manage.py sqlmigrate demo 0001 BEGIN; -- -- Create model Books -- CREATE TABLE `demo_books` (`id` integer AUTO_INCREMENT NOT NULL PRIMARY KEY, `book_name` varchar(200) NOT NULL, `auhtor` varchar(50) NOT NULL); COMMIT; 需要注意一下几点： 输出的内容与使用的数据库有关。 数据库的表名默认是“应用名_模型名的小写”，也可以自定义表名。 主键会默认自动创建，也可以自定义主键。 Django会为使用的数据库定制相关SQL语句，例如主键：integer AUTO_INCREMENT NOT NULL PRIMARY KEY，varchar：NOT NULL sqlmigrate命令并没有真正执行迁移命令，他只是将迁移命令执行的流程输出到屏幕上，供你查看 执行check命令对项目做检查 $ python manage.py check System check identified no issues (0 silenced). 没有问题后执行迁移命令 $ python manage.py migrate Operations to perform: Apply all migrations: admin, auth, contenttypes, demo, sessions Running migrations: Applying demo.0001_initial... OK 看到以上内容即完成了数据库迁移 通过Python命令行尝试 $ python manage.py shell \u003e\u003e\u003e from demo.models import Books \u003e\u003e\u003e ggzh = Books(book_name=\"硅谷之火\",author=\"迈克尔.斯韦因\") \u003e\u003e\u003e ggzh.save() \u003e\u003e\u003e ggzh.id 1 \u003e\u003e\u003e ggzh.book_name '硅谷之火' \u003e\u003e\u003e ggzh.author '迈克尔.斯韦因' \u003e\u003e\u003e Books.objects.all() \u003cQuerySet [\u003cBooks: Books object (1)\u003e]\u003e 这里我们看到\u003cQuerySet [\u003cBooks: Books object (1)\u003e]\u003e这个并不能让我们知道这个对象的细节，通过修改Books模型来修复这个问题 /demo/models.py class Books(models.Model): # 书名 book_name = models.CharField(max_length=200) # 作者 author = models.CharField(max_length=50) def __str__(self): return self.book_name 修改完成后重新进入交互终端，再次查询就可以显示书名了，这里可以自己定义想显示的字段或内容 $ python manage.py shell \u003e\u003e\u003e from demo.models import Books \u003e\u003e\u003e Books.objects.all() \u003cQuerySet [\u003cBooks: 硅谷之火\u003e]\u003e 再添加一本书，聚合函数 \u003e\u003e\u003e qbsz = Books(book_name=\"史蒂夫*乔布斯传\",author=\"沃尔特·艾萨克森\") \u003e\u003e\u003e qbsz.save() \u003e\u003e\u003e Books.objects.all() \u003cQuerySet [\u003cBooks: 硅谷之火\u003e, \u003cBooks: 史蒂夫*乔布斯传\u003e]\u003e \u003e\u003e\u003e Books.objects.count() 2 \u003e\u003e\u003e Books.objects.filter(book_name=\"硅谷之火\") \u003cQuerySet [\u003cBooks: 硅谷之火\u003e]\u003e 接下来我们将Books模型添加到admin管理，通过register方法，将Books交给admin管理 /demo/admin from django.contrib import admin from .models import Books admin.site.register(Books) 重新运行项目，在地址栏输入：http://127.0.0.1:8000/admin/，输入账号密码登录即可查看到这个模型 点进去可以查看该模型的数据，右上角可以添加，动作可以删除，点图书名可以看到更多细节 ","date":"2019-03-02","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/:3:5","tags":["Django","教程"],"title":"Django基础教程之初体验","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["Django"],"content":"视图与模板 在models.py中添加一个图书模型 /demo/models.py from django.db import models class Books(models.Model): # 书名 name = models.CharField('书名', max_length=200) # 作者 author = models.CharField('作者', max_length=50) publish_house = models.CharField('出版社', max_length=50) publish_date = models.CharField('出版日期', max_length=50) price = models.IntegerField('价格') synopsis = models.TextField('简介') def __str__(self): return self.name 在admin.py中注册Books 迁移数据库 在Django后台中添加图书数据 在应用的views.py中编写一个展示图书的视图 /demo/views.py from django.http import HttpResponse from .models import Books def book_list(request): book_list = Books.objects.all() books = {book.name : book.id for book in book_list} return render(request, 'index.html', context={'books': books}) 通过模板渲染 在templates目录下新建一个index.html文件 /tempaltes/index.html \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv\u003e图书管理系统：\u003c/div\u003e \u003cul\u003e \u003c/ul\u003e \u003c/body\u003e \u003c/html\u003e 在项目的urls.py文件中添加一个关于图书的路由 /mysite/urls.py from django.contrib import admin from django.urls import path from demo import views urlpatterns = [ path('admin/', admin.site.urls), path('book/', include('demo.urls')), ] 在demo目录中新建一个urls.py文件，并添加一个路由 /demo/urls.py from django.urls import path from . import views urlpatterns = [ path('', views.book_list, name='index'), ] 启动项目，访问：http://127.0.0.1:8000/book/ 图书列表页完成了，接下来编写图书详情页 在demo项目中的urls.py文件中添加一个详情页的路由 /demo/urls.py from django.urls import path from . import views urlpatterns = [ path('', views.book_list, name='index'), path('\u003cint:id\u003e/', views.detail, name='detail'), ] 在demo项目中的views.py文件中编写详情页相关视图函数 /demo/views.py def detail(request, id): book = Books.objects.filter(id=id).all()[0] content = { \"name\": book.name, \"author\": book.author, 'publish_house': book.publish_house, 'publish_date': book.publish_date, 'price': book.price, 'synopsis': book.synopsis } return render(request, 'detail.html', context=content) 在templates文件夹里新建一个detail.html文件,并写入一下代码 /templates/detail.html \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ctable\u003e \u003ctr\u003e \u003ctd\u003e书名\u003c/td\u003e \u003ctd\u003e作者\u003c/td\u003e \u003ctd\u003e出版社\u003c/td\u003e \u003ctd\u003e出版日期\u003c/td\u003e \u003ctd\u003e价格\u003c/td\u003e \u003ctd\u003e简介\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e{{ name }}\u003c/td\u003e \u003ctd\u003e{{ author }}\u003c/td\u003e \u003ctd\u003e{{ publish_house }}\u003c/td\u003e \u003ctd\u003e{{ publish_date }}\u003c/td\u003e \u003ctd\u003e{{ price }}\u003c/td\u003e \u003ctd\u003e{{ synopsis }}\u003c/td\u003e \u003c/tr\u003e \u003c/table\u003e \u003c/body\u003e \u003c/html\u003e 启动项目，访问：http://127.0.0.1:8000/book/，点击其中一个图书就可以看到详情页，或者直接选择一个id访问详情页，这时候就会出现一个问题，当访问一个不存在的id时就会出错，我们需要定制一下错误页面，修改detail视图函数。 /demo/views.py from django.http import Http404 ... def detail(request, id): books = Books.objects.filter(id=id).all() if len(books): book = books[0] content = { \"name\": book.name, \"author\": book.author, 'publish_house': book.publish_house, 'publish_date': book.publish_date, 'price': book.price, 'synopsis': book.synopsis } return render(request, 'detail.html', context=content) else: raise Http404(\"图书不存在\") 这里调用的是Django自带的404错误页面，我们需要返回错误说明 ","date":"2019-03-02","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/:3:6","tags":["Django","教程"],"title":"Django基础教程之初体验","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["Django"],"content":"Django介绍","date":"2019-02-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BB%8B%E7%BB%8D/","tags":["Django","教程"],"title":"Django基础教程之介绍","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BB%8B%E7%BB%8D/"},{"categories":["Django"],"content":"声明：以下内容均为我个人的理解，如果发现错误或者疑问可以联系我共同探讨 本教程为Django基础教程系列第一篇 ","date":"2019-02-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BB%8B%E7%BB%8D/:0:0","tags":["Django","教程"],"title":"Django基础教程之介绍","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BB%8B%E7%BB%8D/"},{"categories":["Django"],"content":"前言 为什么网上有很多Django的学习资料，我还想自己写一个Django的教程呢，一是想通过写教程发现自己的不足，二是想通过自己的总结让那些想学习Django的小伙伴们少走一些弯路，当然我写的内容有可能也是错的，欢迎大家纠正，我们可以共同探讨，共同进步。 ","date":"2019-02-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BB%8B%E7%BB%8D/:1:0","tags":["Django","教程"],"title":"Django基础教程之介绍","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BB%8B%E7%BB%8D/"},{"categories":["Django"],"content":"简介 Django是一个高级Python Web框架，可以快速开发和简洁实用的设计。Django负责处理网站开发中遇到的问题，编程人员只需要专注于应用编写，无需重新造轮子。它是免费和开源的。 ","date":"2019-02-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BB%8B%E7%BB%8D/:2:0","tags":["Django","教程"],"title":"Django基础教程之介绍","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BB%8B%E7%BB%8D/"},{"categories":["Django"],"content":"特点 ","date":"2019-02-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BB%8B%E7%BB%8D/:3:0","tags":["Django","教程"],"title":"Django基础教程之介绍","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BB%8B%E7%BB%8D/"},{"categories":["Django"],"content":"完备性 Django原生提供了众多的功能组件，对于开发人员来说Django几乎做到了开箱即用。 ","date":"2019-02-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BB%8B%E7%BB%8D/:3:1","tags":["Django","教程"],"title":"Django基础教程之介绍","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BB%8B%E7%BB%8D/"},{"categories":["Django"],"content":"安全 Django认真对待安全性，并帮助开发人员避免许多常见的安全性错误，例如SQL注入，跨站点脚本编写，跨站点请求伪造和点击劫持。其用户身份验证系统提供了一种安全的方式来管理用户帐户和密码。 ","date":"2019-02-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BB%8B%E7%BB%8D/:3:2","tags":["Django","教程"],"title":"Django基础教程之介绍","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BB%8B%E7%BB%8D/"},{"categories":["Django"],"content":"可扩展性 Django强调代码复用，多个组件可以以\"插件\"的形式服务于整个框架，Django还有许多功能强大的第三方插件，你也可以开发自己的工具包。 ","date":"2019-02-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BB%8B%E7%BB%8D/:3:3","tags":["Django","教程"],"title":"Django基础教程之介绍","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BB%8B%E7%BB%8D/"},{"categories":["Django"],"content":"MVT模式 Django采用MVT程序设计模式 M全拼为Model，主要封装对数据库层的访问，对数据库中的数据进行增、删、改、查操作。 V全拼为View，用于接收请求，进行业务处理，返回应答。 T全拼为Template，用于封装结果，负责封装构造要返回的html。 ","date":"2019-02-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BB%8B%E7%BB%8D/:4:0","tags":["Django","教程"],"title":"Django基础教程之介绍","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BB%8B%E7%BB%8D/"},{"categories":["Django"],"content":"Django学习资料 Django官网 Django项目Github Django Book 教程 Mozilla Django教程 ","date":"2019-02-23","objectID":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BB%8B%E7%BB%8D/:5:0","tags":["Django","教程"],"title":"Django基础教程之介绍","uri":"/django%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BB%8B%E7%BB%8D/"},{"categories":["Django"],"content":"Django2.x配置mysql","date":"2019-02-17","objectID":"/django2.x%E9%85%8D%E7%BD%AEmysql/","tags":["msql","Django"],"title":"Django2.x配置mysql","uri":"/django2.x%E9%85%8D%E7%BD%AEmysql/"},{"categories":["Django"],"content":"声明：以下内容均为我个人的理解，如果发现错误或者疑问可以联系我共同探讨 ","date":"2019-02-17","objectID":"/django2.x%E9%85%8D%E7%BD%AEmysql/:0:0","tags":["msql","Django"],"title":"Django2.x配置mysql","uri":"/django2.x%E9%85%8D%E7%BD%AEmysql/"},{"categories":["Django"],"content":"简介 在Django中使用mysql数据库是很常见的,但是升级到Django2.0以后，已经不支持Python2.x，mysql的配置也需要随之改变 ","date":"2019-02-17","objectID":"/django2.x%E9%85%8D%E7%BD%AEmysql/:1:0","tags":["msql","Django"],"title":"Django2.x配置mysql","uri":"/django2.x%E9%85%8D%E7%BD%AEmysql/"},{"categories":["Django"],"content":"配置 ","date":"2019-02-17","objectID":"/django2.x%E9%85%8D%E7%BD%AEmysql/:2:0","tags":["msql","Django"],"title":"Django2.x配置mysql","uri":"/django2.x%E9%85%8D%E7%BD%AEmysql/"},{"categories":["Django"],"content":"配置settings.py DATABASES = { 'default': { 'ENGINE': 'django.db.backends.mysql', 'NAME': 'dbname', 'USER': 'dbuser', 'PASSWORD': 'dbpassword', 'HOST':'dbhost', 'PORT':'dbport' } } ","date":"2019-02-17","objectID":"/django2.x%E9%85%8D%E7%BD%AEmysql/:2:1","tags":["msql","Django"],"title":"Django2.x配置mysql","uri":"/django2.x%E9%85%8D%E7%BD%AEmysql/"},{"categories":["Django"],"content":"使用pymysql 由于安装mysqlclient不支持python3，所以使用pymysql包，安装pymysql并导入 pip install pymysql 配置pymysql，在settings.py所在的目录下的__init__.py文件中导入 import pymysql pymysql.install_as_MySQLdb() ","date":"2019-02-17","objectID":"/django2.x%E9%85%8D%E7%BD%AEmysql/:2:2","tags":["msql","Django"],"title":"Django2.x配置mysql","uri":"/django2.x%E9%85%8D%E7%BD%AEmysql/"},{"categories":["Django"],"content":"修改源码中的问题 由于在python3中不在使用mysqlclient，所以源码中限制mysqlclient版本这一代码就不适用于现在的环境 文件路径django\\db\\backends\\mysql\\base.py，将版本限制异常给注释掉在文件的第35-36行 # if version \u003c (1, 3, 13): # raise ImproperlyConfigured('mysqlclient 1.3.13 or newer is required; you have %s.' % Database.__version__) 由于python2的str是字节流(类似于bytes类型)需要通过decode转换成unicode类型才能使用，但在python3中str默认unicode类型不需要转换且没有decode解码所以要将这里的代码修改。在最新的Django源码中已经将这里修改了(可以通过Django官网或github查看)，在最新的源码中使用django.utils.encoding中force_str方法解决了该问题，force_str方法实际上是force_text方法，force_text方法通过判断传入参数的类型后将类型转为unicode类型的str之后返回 \\django\\utils\\encoding.py ······ def force_text(s, encoding='utf-8', strings_only=False, errors='strict'): \"\"\" Similar to smart_text, except that lazy instances are resolved to strings, rather than kept as lazy objects. If strings_only is True, don't convert (some) non-string-like objects. \"\"\" # Handle the common case first for performance reasons. if issubclass(type(s), str): return s if strings_only and is_protected_type(s): return s try: if isinstance(s, bytes): s = str(s, encoding, errors) else: s = str(s) except UnicodeDecodeError as e: raise DjangoUnicodeDecodeError(s, *e.args) return s 最后修改\\django\\db\\backends\\mysql\\operations.py文件中的last_executed_query方法（记得导入force_str） from django.utils.encoding import force_str ··· def last_executed_query(self, cursor, sql, params): # With MySQLdb, cursor objects have an (undocumented) \"_executed\" # attribute where the exact query sent to the database is saved. # See MySQLdb/cursors.py in the source distribution. # MySQLdb returns string, PyMySQL bytes. return force_str(getattr(cursor, '_executed', None), errors='replace') ","date":"2019-02-17","objectID":"/django2.x%E9%85%8D%E7%BD%AEmysql/:2:3","tags":["msql","Django"],"title":"Django2.x配置mysql","uri":"/django2.x%E9%85%8D%E7%BD%AEmysql/"},{"categories":["Python"],"content":"Python时间合集","date":"2019-01-26","objectID":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/","tags":["时间"],"title":"Python时间合集","uri":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/"},{"categories":["Python"],"content":"声明：以下内容均为我个人的理解，如果发现错误或者疑问可以联系我共同探讨 ","date":"2019-01-26","objectID":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/:0:0","tags":["时间"],"title":"Python时间合集","uri":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/"},{"categories":["Python"],"content":"python3中时间的表示形式 ","date":"2019-01-26","objectID":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/:1:0","tags":["时间"],"title":"Python时间合集","uri":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/"},{"categories":["Python"],"content":"格式化时间字符串 格式化时间字符串（string_time）,指格式化输出指定输出参数的格式与相对位置的字符串参数，与python中的format作用类似，常见的格式化时间字符串：\"%Y-%m-%d %H:%M:%S %z,%a,%A,%b,%B,%c,%I,%p” 常用的表 名 称 含 义 例 子 %Y 有世纪并用0填充的十进制数年份 0001, 0002, …, 2013, 2014, …, 9998, 9999 %m 用零填充十进制数的月份 01, 02, …, 12 %d 用零填充十进制数的月中的某一天 01, 02, …, 31 %H 24小时格式的用0填充的十进制数小时 00, 01, …, 23 %M 用0填充的十进制数分钟 00, 01, …, 59 %S 用0填充的十进制数秒 00, 01, …, 59 %z 用零填充的十进制小时分钟秒毫秒的时差 (empty), +0000, -0400, +1030, +063415, -030712.345216 %a 根据区域设置的缩写的星期名称 Sun, Mon, …, Sat (en_US) So, Mo, …, Sa (de_DE) %A 根据区域设置的完整星期名称 Sunday, Monday, …, Saturday (en_US) Sonntag, Montag, …, Samstag (de_DE) 吐槽一下官网注释秒的范围是0-59，实测0-61都可以 官方的完整表： 以下是C标准（1989版）所需的所有格式代码的列表，这些代码适用于具有标准C实现的所有平台。请注意，1999版C标准添加了其他格式代码。 名 称 含 义 例 子 %a 根据区域设置的缩写的星期名称 Sun, Mon, …, Sat (en_US)So, Mo, …, Sa (de_DE) %A 根据区域设置的完整星期名称 Sunday, Monday, …, Saturday (en_US)Sonntag, Montag, …, Samstag (de_DE) %w 将工作日变成十进制数，其中0表示星期日，6表示星期六 0, 1, …, 6 %d 用零填充十进制数的月中的某一天 01, 02, …, 31 %b 根据区域设置的缩写月份名 Jan, Feb, …, Dec (en_US);Jan, Feb, …, Dez (de_DE) %B 根据区域改变月份全称 January, February, …, December (en_US)Januar, Februar, …, Dezember (de_DE) %m 用零填充十进制数的月份 01, 02, …, 12 %y 没有世纪并用0填充的十进制数年份 00, 01, …, 99 %Y 有世纪并用0填充的十进制数年份 0001, 0002, …, 2013, 2014, …, 9998, 9999 ","date":"2019-01-26","objectID":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/:1:1","tags":["时间"],"title":"Python时间合集","uri":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/"},{"categories":["Python"],"content":"时间戳 时间戳（Timestamp）,指字符串或编码信息用于辨识记录下来的时间日期，维基百科解释的不容易懂，我的个人理解是从1970年1月1日到现在过去了多少秒。 ","date":"2019-01-26","objectID":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/:1:2","tags":["时间"],"title":"Python时间合集","uri":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/"},{"categories":["Python"],"content":"时间元祖 时间元祖(struct_time),指包含9个特殊元素的元祖，（tm_year，tm_mon，tm_mday，tm_hour，tm_min，tm_sec，tm_wday，tm_yday，tm_isdst），详情见下表格 名 称 含 义 值 tm_year 年 具体年份，例：2017 tm_mon 月 1-12 tm_mday 日 1-31 tm_hour 时 1-23 tm_min 分 0-59 tm_sec 秒 0-61 tm_wday 周 0-6（从周末开始） tm_yday 在一年中的第几天 1-666 tm_isdst 是否为夏令时 -1,0,1（能表示true和flase的值） ","date":"2019-01-26","objectID":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/:1:3","tags":["时间"],"title":"Python时间合集","uri":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/"},{"categories":["Python"],"content":"时间对象 时间对象（time_object）,指通过某些时间类生成的对象，例如datetime对象。 ","date":"2019-01-26","objectID":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/:1:4","tags":["时间"],"title":"Python时间合集","uri":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/"},{"categories":["Python"],"content":"python中两大时间库： ","date":"2019-01-26","objectID":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/:2:0","tags":["时间"],"title":"Python时间合集","uri":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/"},{"categories":["Python"],"content":"time 简介： 常用于具体时间操作 常量 Variables with simple values，值简单的变量 altzone，-32400 daylight，0 timezone，-28800 _STRUCT_TM_ITEMS，11 variables with complex values，值复杂的变量 tzname 但是如果直接调用会得到一个乱码的值，看不懂，查阅资料后发现通过重新编码解码可以看到真实值，这里很感谢这个爱思考的博主，这里编码解码参考他的博客，这条博文在这里：https://www.cnblogs.com/luo630/p/9555684.html，里面讲的很详细 \u003e\u003e\u003e time.tzname[0].encode('latin-1').decode('gbk') '中国标准时间' \u003e\u003e\u003e time.tzname[1].encode('latin-1').decode('gbk') '中国夏令时' 方法： asctime：将时间元组转换为字符串，当没有传入参数时，调用localtime()返回的当前时间，参数类型：元祖，返回类型：字符串。例如： \u003e\u003e\u003e import time \u003e\u003e\u003e time.asctime() 'Tue Jun 11 16:07:40 2017' \u003e\u003e\u003e time.asctime((2017,6,11,16,7,40,59,59,59)) # 这里必须要穿一个包含9个数字的元组，且年月日时分都必须符合时间逻辑，秒必须小于等于61，不知道为什么是61，后面三位逻辑暂时还没弄明白，但是跟前面对应的年月日有关 'Thu Jun 11 16:07:40 2017' clock：计时器函数，在进程结束后返回从开始到第一次调用该函数使用的时间，返回类型：浮点数。例如： \u003e\u003e\u003e time.clock() 5e-07 \u003e\u003e\u003e time.sleep(1) \u003e\u003e\u003e time.clock() 11.9833418 \u003e\u003e\u003e time.sleep(10) \u003e\u003e\u003e time.clock() 35.1999596 ctime：将时间戳转换为以本地时间为单位的字符串。相当于asctime(localtime(seconds))。当没有传入参数时，使用localtime()返回的当前时间。参数类型：时间戳，返回类型：字符串。例如： \u003e\u003e\u003e time.ctime(1555555550) 'Thu Apr 18 10:45:50 2017' \u003e\u003e\u003e time.ctime() 'Tue Jun 11 17:08:44 2017' get_clock_info：获取有关指定时钟的信息作为命名空间对象。支持的时钟名称和读取其值的相应函数是： ‘clock’： time.clock() ‘monotonic’： time.monotonic() ‘perf_counter’： time.perf_counter() ‘process_time’： time.process_time() ‘thread_time’： time.thread_time() ‘time’： time.time() 结果具有以下属性： adjustable：True如果时钟可以自动更改（例如通过NTP守护程序）或由系统管理员手动更改，False否则 implementation：用于获取时钟值的基础C函数的名称。有关可能的值，请参阅时钟ID常量。 单调：True如果时钟不能倒退， False否则分辨率：时钟的分辨率（秒）（float） gmtime：将时间戳转换为时间元祖，当没有传入参数时，返回当前世界标准时间的时间元祖。参数类型：时间戳，返回类型：元祖（但是查看源码只有一个pass）。例如： \u003e\u003e\u003e time.gmtime(1555555550) time.struct_time(tm_year=2017, tm_mon=4, tm_mday=18, tm_hour=2, tm_min=45, tm_sec=50, tm_wday=3, tm_yday=108, tm_isdst=0) \u003e\u003e\u003e time.gmtime() time.struct_time(tm_year=2017, tm_mon=6, tm_mday=11, tm_hour=9, tm_min=18, tm_sec=54, tm_wday=1, tm_yday=162, tm_isdst=0) localtime：与gmtime功能类似，但是返回的时间变成了当地时间。例如： \u003e\u003e\u003e time.localtime(1555555550) time.struct_time(tm_year=2017, tm_mon=4, tm_mday=18, tm_hour=10, tm_min=45, tm_sec=50, tm_wday=3, tm_yday=108, tm_isdst=0) \u003e\u003e\u003e time.localtime() time.struct_time(tm_year=2017, tm_mon=6, tm_mday=11, tm_hour=17, tm_min=28, tm_sec=34, tm_wday=1, tm_yday=162, tm_isdst=0) mktime：将时间元祖转化为时间戳，返回时间戳。参数类型：时间元祖（9个元素），返回类型：时间戳。例如： \u003e\u003e\u003e time.mktime((2017,4,18,10,45,50,3,108,0)) 1555555550.0 monotonic: 一个单调的计时器，不能倒转。不知道从什么时候开始的，返回类型：浮点型。例如： \u003e\u003e\u003e def func(): ... print(time.monotonic()) ... time.sleep(1) ... \u003e\u003e\u003e i = 0 \u003e\u003e\u003e while i\u003c5: ... func() ... i+=1 ... 461875.89 461876.89 461877.89 461878.89 461879.89 perf_counter：性能计数器用于基准测试。不服跑个分！返回类型：浮点型。例如： \u003e\u003e\u003e time.perf_counter() 3674.2299851 \u003e\u003e\u003e time.perf_counter() 3675.2086447 \u003e\u003e\u003e time.perf_counter() 3675.9990329 process_time：用于分析的进程时间:内核和用户空间CPU时间的总和。返回类型：浮点型。例如： \u003e\u003e\u003e time.process_time() 4.40625 sleep:将执行延迟数秒。参数类型：int or float ,返回类型：无，这就不演示了…浪费时间 strftime：根据格式规范将时间元组转换为字符串。有关格式化代码，请参阅库参考手册。当没有传入参数时，使用localtime()返回的当前时间。传入参数：配对字符串,时间元祖（与字符串配对），返回参数：时间字符串,例： # 根据前面的格式化字符串来生成对应时间字符串 \u003e\u003e\u003e time.strftime(\"%Y-%m-%d%H:%M:%S\", (2017, 1, 1, 1, 1, 1, 1, 13, 0)) '2017-01-01 01:01:01' \u003e\u003e\u003e time.strftime(\"%Y-%m-%d%H:%M:%S %I\", (2017, 1, 1, 1, 1, 1, 1, 13, 0)) '2017-01-01 01:01:01 01' \u003e\u003e\u003e time.strftime(\"%Y-%m-%d%H:%M:%S %z,%a,%A,%b,%B,%c,%I,%p\", (2017, 1, 1, 1, 1, 1, 1, 13, 0)) '2017-01-01 01:01:01 +0800,Tue,Tuesday,Jan,January,Tue Jan 1 01:01:01 2017,01,AM' strptime：根据格式规范将字符串解析为时间元组。有关格式化代码，请参阅库参考手册(与strftime ())。传入参数：时间字符串，配对字符串。返回参数：时间元祖 例： python \u003e\u003e\u003e time.strptime(\"2017-01-01 01:01:02\", \"%Y-%m-%d %H:%M:%S\") time.struct_time(tm_year=2017, tm_mon=1, tm_mday=1, tm_hour=1, tm_min=1, tm_sec=2, tm_wday=1, tm_yday=1, tm_isdst=-1) time：以秒为单位返回从纪元开始的当前时间。如果系统时钟提供这些信息，那么可能只存在几分之一秒。就是我们常说的时间戳。返回参数：浮点数 ","date":"2019-01-26","objectID":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/:2:1","tags":["时间"],"title":"Python时间合集","uri":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/"},{"categories":["Python"],"content":"datetime 由五个模块组成 date： 简介 表示日期的类。常用的属性有year, month, day。 常量 date.min = date(1, 1, 1)，date.max = date(9999, 12, 31)，date.resolution = timedelta(days=1)，分别规定了date对象的最小值、最大值，date对象的最小单位，为天 类方法 fromtimestamp：将时间戳转化为date对象，参数类型：float，int，返回类型：date对象 \u003e\u003e\u003e from datetime import date \u003e\u003e\u003e date.fromtimestamp(1560415206) datetime.date(2017, 6, 13) \u003e\u003e\u003e type(date.fromtimestamp(1560415206)) \u003cclass 'datetime.date'\u003e today：获得今天的日期，返回类型：date对象 \u003e\u003e\u003e date.today() datetime.date(2017, 6, 13) \u003e\u003e\u003e type(date.today()) \u003cclass 'datetime.date'\u003e fromordinal：跟fromtimestamp类似 \u003e\u003e\u003e date.fromtimestamp(1560415206) datetime.date(2017, 6, 13) \u003e\u003e\u003e type(date.fromtimestamp(1560415206)) \u003cclass 'datetime.date'\u003e 实例方法 ctime：返回将日期对象转化为标准时间日期的 00:00:00 \u003e\u003e\u003e date(2017,6,13).ctime() 'Thu Jun 13 00:00:00 2017' strftime，返回将date对象转化为指定格式的date对象 \u003e\u003e\u003e d = date(2017,1,1) \u003e\u003e\u003e d.strftime(\"%d/%m/%y\") '01/01/17' \u003e\u003e\u003e type(d) \u003cclass 'datetime.date'\u003e isoformat,返回将date对象转化为’YYYY-MM-DD’格式的date对象, \u003e\u003e\u003e d = date(2017,2,2) \u003e\u003e\u003e d.isoformat() '2017-02-02' \u003e\u003e\u003e type(d) \u003cclass 'datetime.date'\u003e timetuple,返回与time.localtime()兼容的本地时间元组 \u003e\u003e\u003e date(2017,7,7).timetuple() time.struct_time(tm_year=2017, tm_mon=7, tm_mday=7, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=4, tm_yday=188, tm_isdst=-1) toordinal,按年、月、日返回子午线格列高利教序数。返回类型：int \u003e\u003e\u003e d = date(2017,7,7).toordinal() \u003e\u003e\u003e type(d) \u003cclass 'int'\u003e replace,根据传入的年月日修改date对象的年月日,参数类型：int,返回类型:date对象 \u003e\u003e\u003e d = date(2017,7,7) \u003e\u003e\u003e d.replace(month=8,day=8) datetime.date(2017, 8, 8) weekday,根据date对象，判断该日期为星期几,返回类型：int,0-6分别对应星期一到星期天 \u003e\u003e\u003e d = date(2017,6,12) \u003e\u003e\u003e a = d.weekday() 0 \u003e\u003e\u003e type(a) \u003cclass 'int'\u003e isoweekday，根据date对象，判断该日期为星期几,返回类型：int,1-7分别对应星期一到星期天 \u003e\u003e\u003e d = date(2017,6,12) \u003e\u003e\u003e a = d.isoweekday() 1 \u003e\u003e\u003e type(a) \u003cclass 'int'\u003e isocalendar,根据date对象，判断该日期为第几周的星期几，返回类型：包含年，第几周，星期几的元祖 \u003e\u003e\u003e d = date(2017,6,12) \u003e\u003e\u003e d.isocalendar() (2017, 24, 1) \u003e\u003e\u003e d = date(2017,7,12) \u003e\u003e\u003e d.isocalendar() (2017, 28, 3) 魔法属性 year,month,day：返回年、月、日 \u003e\u003e\u003e d = date(2017,6,13) \u003e\u003e\u003e d.year 2017 \u003e\u003e\u003e d.month 6 \u003e\u003e\u003e d.day 13 time 简介 表示时间的类。常用的属性有hour, minute, second, microsecond。 参数 hour=0, minute=0, second=0, microsecond=0, tzinfo=None, fold=0， hour，minute，小时和分钟必须传入，小时为0-23，分钟为0-59 second，microsecond，秒和毫秒，默认为0，可以不传，秒为0-59，毫秒为0-999999 tzinfo，时区默认为None,可以填你想要的时区 fold，在[0,1]。用于消除重复间隔期间的墙壁时间的歧义。(当时钟在夏令时结束时回滚，或由于政治原因降低当前区域的UTC偏移量时，会出现重复间隔。)值0(1)表示具有相同壁面时间表示的两个时刻中较早(较晚)的时刻。 常量 time.min，最早可表示的时间，时间(0,0,0,0)。 time.max，最新可表示时间，时间(23,59,59,999999)。 time.resolution在不相等的时间对象之间可能存在的最小差异是时间增量(微秒=1)，不过请注意，不支持对时间对象进行算术。 魔法属性 hour、minute、second、microsecond、tzinfo、fold分别返回时、分、秒、毫秒、时区与折叠关键字 \u003e\u003e\u003e from datetime import time \u003e\u003e\u003e t = time(9,9) \u003e\u003e\u003e t.hour 9 \u003e\u003e\u003e t.minute 9 \u003e\u003e\u003e t.second 0 \u003e\u003e\u003e t.microsecond 0 \u003e\u003e\u003e t.tzinfo \u003e\u003e\u003e t.fold 0 实例方法 isoformat，返回按ISO格式格式化的时间字符串。完整的格式是’HH:MM:SS.mmmmmm+zz:zz’可选参数：timespec，指定附加的数量所包括的时间条款 \u003e\u003e\u003e t = time(8,8) \u003e\u003e\u003e a = t.isoformat() \u003e\u003e\u003e a '08:08:00' \u003e\u003e\u003e type(a) \u003cclass 'str'\u003e strftime，返回一个表示时间的字符串，由显式格式字符串控制。参数 datetime.time(9, 9) \u003e\u003e\u003e t = time(9,9) \u003e\u003e\u003e t datetime.time(9, 9) \u003e\u003e\u003e t.strftime(\"%H/%H/%S\") '09/09/00' replace,返回根据关键字替换datetime.time对象中的值,参数：hour, minute, second, microsecond, tzinfo,fold \u003e\u003e\u003e time(9,9).replace(8,8) datetime.time(8, 8) utcoffset,根据utc返回以东的时区偏移（可以理解为时差），以分钟为单位，如果没有设置tzinfo则返回none。 \u003e\u003e\u003e class UTC(tzinfo): ... def __init__(self,offset = 0): ... self._offset = offset ... def utcoffset(self,dt): ... return timedelta(hours=self._offset) ... def tzname(self,dt): ... return \"UTC +%s\" % self._offset ... def dst(self, dt): ... return timedelta(hours=self._offset) ... \u003e\u003e\u003e time(9,9).utcoffset() \u003e\u003e\u003e \u003e\u003e\u003e time(9,9,tzinfo=UTC(8)).utcoffset() datetime.timedelta(0, 28800) tzname,返回时区的名字 \u003e\u003e\u003e time(9,9,tzinfo=UTC(8)).tzname() 'UTC +8' dst,返回dst偏移信息，如果没有则返回none \u003e\u003e\u003e time(9,9,tzinfo=UTC(8)).dst() datetime.timedelta(0, 28800) \u003e\u003e\u003e time(9,9).dst() \u003e\u003e\u003e datetime 简介 表示日期+时间 参数 year, month, day, hour=0, minute=0, second=0, microsecond=0, tzinfo=None, fold=0，年，月，日参数是必需的。 tzinfo可以是None，或者是tzinfo子类的实例。其余参数可以是整数，在以下范围内： MINYEAR \u003c= year \u003c= MAXYEAR， 1 \u003c= month \u003c= 12， 1 \u003c= day \u003c= number of days in the given month and year， 0 \u003c= ho","date":"2019-01-26","objectID":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/:2:2","tags":["时间"],"title":"Python时间合集","uri":"/python%E6%97%B6%E9%97%B4%E5%90%88%E9%9B%86/"},{"categories":["Python"],"content":"Python搭建虚拟环境","date":"2019-01-20","objectID":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/","tags":["虚拟环境"],"title":"Python搭建虚拟环境","uri":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"},{"categories":["Python"],"content":"声明：以下内容均为我个人的理解，如果发现错误或者疑问可以联系我共同探讨 ","date":"2019-01-20","objectID":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/:0:0","tags":["虚拟环境"],"title":"Python搭建虚拟环境","uri":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"},{"categories":["Python"],"content":"为什么要搭建虚拟环境 平时开发的过程中会遇到不同的项目，往往不同的项目之间需要的第三方包会有所差异，如果我们都在系统的python环境中会导致遇到很多问题，通过虚拟环境搭建一套独立的python运行环境，可以让项目之间互不干扰。 ","date":"2019-01-20","objectID":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/:1:0","tags":["虚拟环境"],"title":"Python搭建虚拟环境","uri":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"},{"categories":["Python"],"content":"如何搭建 一般我们搭建虚拟环境都会用上virtualenv，它是一个可以创建并管理python虚拟环境的第三方包。 ","date":"2019-01-20","objectID":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/:2:0","tags":["虚拟环境"],"title":"Python搭建虚拟环境","uri":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"},{"categories":["Python"],"content":"安装 不论是windows还是linux还是mac都可以直接通过pip 安装，需要注意的是系统中存在两个python的时候，注意pip的版本，选择对应的版本安装 pip install virtualenv ","date":"2019-01-20","objectID":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/:2:1","tags":["虚拟环境"],"title":"Python搭建虚拟环境","uri":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"},{"categories":["Python"],"content":"创建虚拟环境 我们通常会创建一个文件夹为env(当然你也可以去任何你喜欢的名字)，专门用来存放不同的虚拟环境 进入到env文件夹中通过命令创建一个虚拟环境，名为first_env virtualenv first_env 相关参数说明 -p:选择要使用的Python解释器，默认为安装virtualenv的解释器 –prompt=xx:将xx设置为虚拟环境的提示前缀 ","date":"2019-01-20","objectID":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/:2:2","tags":["虚拟环境"],"title":"Python搭建虚拟环境","uri":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"},{"categories":["Python"],"content":"使用虚拟环境 Windows 进入虚拟环境的Scripts目录 在此处打开命令行工具 输入activate，当命令提示符多了一个虚拟环境名字的前缀时即激活成功 Linux or Mac 通过source激活使用，当命令提示符多了一个虚拟环境名字的前缀时即激活成功 source first_env/bin/activate ","date":"2019-01-20","objectID":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/:2:3","tags":["虚拟环境"],"title":"Python搭建虚拟环境","uri":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"},{"categories":["Python"],"content":"退出虚拟环境 在当前虚拟环境中输入deactivate，当命令提示符虚拟环境名字的前缀消失时即退出 ","date":"2019-01-20","objectID":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/:2:4","tags":["虚拟环境"],"title":"Python搭建虚拟环境","uri":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"},{"categories":["Python"],"content":"删除虚拟环境 在我们不需要这个虚拟环境的时候只需要将该虚拟环境的整个包删除即可 ","date":"2019-01-20","objectID":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/:2:5","tags":["虚拟环境"],"title":"Python搭建虚拟环境","uri":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"},{"categories":["Python"],"content":"Pipenv ","date":"2019-01-20","objectID":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/:3:0","tags":["虚拟环境"],"title":"Python搭建虚拟环境","uri":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"},{"categories":["Python"],"content":"简介 Pipenv是Kenneth Reitz在2017年1月发布的Python依赖管理工具，现在由PyPA维护。可以把它看做是pip和virtualenv的组合。 ","date":"2019-01-20","objectID":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/:3:1","tags":["虚拟环境"],"title":"Python搭建虚拟环境","uri":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"},{"categories":["Python"],"content":"为什么使用Pipenv Pipenv会自动帮你管理虚拟环境和依赖文件，并且提供了一系列命令和选项来帮助你实现各种依赖和环境管理相关的操作。简而言之，它更方便、完善和安全。 ","date":"2019-01-20","objectID":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/:3:2","tags":["虚拟环境"],"title":"Python搭建虚拟环境","uri":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"},{"categories":["Python"],"content":"如何使用Pipenv 安装 pip install pipenv 创建 在项目根目录下执行pipenv install，Pipenv会根据项目文件夹的名称创建一个虚拟环境，并且会在项目根目录下生成 Pipfile 和 Pipfile.lock 用于管理项目依赖（以后使用 Pipenv 安装的依赖会自动写入 Pipfile 文件，无需再手动维护 requirements.txt 文件) 提示 默认情况下Pipenv会将虚拟环境创建在~/.virtualenvs 目录下，在项目根目录下执行 pipenv --venv 可以查看到项目对应的虚拟环境的具体位置 激活使用 两种方式 在项目根目录下执行pipenv shell 在项目根目录下执行pipenv run + 命令 ","date":"2019-01-20","objectID":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/:3:3","tags":["虚拟环境"],"title":"Python搭建虚拟环境","uri":"/python%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"},{"categories":["Python"],"content":"Python2与Python3的区别","date":"2019-01-13","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"声明：以下内容均为我个人的理解，如果发现错误或者疑问可以联系我共同探讨 ","date":"2019-01-13","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:0:0","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"简介 目前用Python开发的项目有两个Python版本，分别是Python2.x与Python3.x，由于Python3相对于python2有着较大的升级，所以Python3将会是现在与未来的主流版本。 ","date":"2019-01-13","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:1:0","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"Python3时间轴 Python3.0发布于2008.12.3 Python3.1发布于2009.6.27 Python3.2发布于2011.2.20 Python 3.3 发布于 2012.9.29 Python 3.4 发布于 2014.3.16 Python 3.5 发布于 2015.9.13 Python 3.6 发布于 2016.12.23 Python3.7发布于2018.6.27 Python3.8发布于2019.10.14 Python 3.9发布于 2020.10.5 为了不带入过多的累赘，在Python3.0设计的时候没有考虑向下兼容，所以早期的项目都无法在Python3.0上正常运行。为了早期的项目可以逐步迁移到Python3.0，Python官方提供了Python2.6过度版本（基于Python2的语法与库，允许使用部分Python3的语法和函数），2010年中推出Python2.7为最后一个Python2.x版本(Python2.7在2020年1月1日以后官方停止维护)。了解Python3版本的变化对我们日常开发与项目维护都十分重要 ","date":"2019-01-13","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:1:1","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"Python3.0后的变化 ","date":"2019-01-13","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:0","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"解释器名称 Python2.x的解释器为python，Python3.x的解释器为python3 其他语言实现的解释器： PyPy Python实现的Python解释器，支持 JIT 即时编译 cpython C语言基于官方版本实现的Python解释器 Jython 运行在Java上的Python解释器 IronPython 运行在.NET与Mono平台的Python解释器 ","date":"2019-01-13","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:1","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"字符串 Python2中字符串是基于ASCII编码的str字符串，当调用字符串变量时会打印其bytes值（16进制表示的字符串内存地址）。 而unicode是一个单独的类型。 Python3中字符串原生支持unicode，byte也变成了一个单独的字节类，并且Python3源码文件默认使用utf-8编码所以中文也可以做变量名。 ","date":"2019-01-13","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:2","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"import Python2中import导包采用相对路径，导致标准库导入变困难。 Python3中import导包采用绝对路径 ","date":"2019-01-13","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:3","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"print Python2中的print是一种特殊的语句，在Python3中print变成了print函数 ","date":"2019-01-13","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:4","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"range函数与xrange函数 xrange函数在Python3中被废弃，range函数的机制进行修改实现了xrange函数返回可迭代对象的效果 ","date":"2019-01-13","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:5","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"老式类与新式类 Python2中存在老式类与新式类，在Python3中统一采用新式类（新式类申明要求继承object），且必须使用新式类应用多重继承 ","date":"2019-01-13","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:6","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"除法与取余 Python2 中若两个整形进行运算，结果为整形，但若其中有一个浮点数类型，则结果为浮点数。python3为真除法，运算结果为float类型。 Python2 中取余返回小于除法运算结果的最大整数，从类型上讲，与”/“运算符返回类型逻辑一致。Python3中与python2作用相同。 ","date":"2019-01-13","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:7","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"raw_input函数与input函数 raw_input函数在Python3中被废弃，统一使用input函数 ","date":"2019-01-13","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:8","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"缩进 Python3采用更严格的缩进方式，tab和space不能共存 ","date":"2019-01-13","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:9","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"long long整型被Python3废弃，统一使用int，int具有long的特性 ","date":"2019-01-13","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:10","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"file file函数被废弃，统一使用open函数 ","date":"2019-01-13","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:11","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"不等运算符 Python3废除\u003c\u003e，只有!= ","date":"2019-01-13","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:12","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"方法返回值 Python3 中这些方法再不再返回 list 对象：dictionary 关联的 keys()、values()、items()，zip()，map()，filter()，但是可以通过 list 强行转换 ","date":"2019-01-13","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:13","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"next()函数 迭代器 iterator 的 next()函数被 Python3 废弃，统一使用 next(iterator) ","date":"2019-01-13","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:14","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"exec exec 语句被 python3 废弃，统一使用 exec 函数 ","date":"2019-01-13","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:15","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"has_key 函数 has_key 函数被 Python 废弃，统一使用 in 关键词 ","date":"2019-01-13","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:16","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"round函数 Python2中，round函数返回float类型值。Python3中，round函数返回int类型值。 ","date":"2019-01-13","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:17","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Python"],"content":"比较操作符 Python2中任意两个对象都可以比较。Python3中只有同一类型数据的对象才可以进行比较。 ","date":"2019-01-13","objectID":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/:2:18","tags":["Python3"],"title":"Python2与Python3的区别","uri":"/python2%E4%B8%8Epython3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["系统优化"],"content":"Windows10在此处打开cmd","date":"2019-01-05","objectID":"/windows10%E5%9C%A8%E6%AD%A4%E5%A4%84%E6%89%93%E5%BC%80cmd/","tags":["cmd"],"title":"Windows10在此处打开cmd","uri":"/windows10%E5%9C%A8%E6%AD%A4%E5%A4%84%E6%89%93%E5%BC%80cmd/"},{"categories":["系统优化"],"content":"声明：以下内容均为我个人的理解，如果发现错误或者疑问可以联系我共同探讨 在Windows10中我们经常需要在某个文件夹下打开cmd窗口，虽然可以在地址栏输入cmd打开，但还是比较麻烦，可以修改注册表添加一个右键菜单来解决这个问题。 ","date":"2019-01-05","objectID":"/windows10%E5%9C%A8%E6%AD%A4%E5%A4%84%E6%89%93%E5%BC%80cmd/:0:0","tags":["cmd"],"title":"Windows10在此处打开cmd","uri":"/windows10%E5%9C%A8%E6%AD%A4%E5%A4%84%E6%89%93%E5%BC%80cmd/"},{"categories":["系统优化"],"content":"步骤 新建一个文本文档 将 一下内容复制粘贴到文本文档中 Windows Registry Editor Version 5.00 [-HKEY_CLASSES_ROOT\\Directory\\shell\\runas] [HKEY_CLASSES_ROOT\\Directory\\shell\\runas] @=\"Open cmd here as admin\" \"HasLUAShield\"=\"\" [HKEY_CLASSES_ROOT\\Directory\\shell\\runas\\command] @=\"cmd.exe /s /k pushd \\\"%V\\\"\" [-HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\runas] [HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\runas] @=\"Open cmd here as admin\" \"HasLUAShield\"=\"\" [HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\runas\\command] @=\"cmd.exe /s /k pushd \\\"%V\\\"\" [-HKEY_CLASSES_ROOT\\Drive\\shell\\runas] [HKEY_CLASSES_ROOT\\Drive\\shell\\runas] @=\"Open cmd here as admin\" \"HasLUAShield\"=\"\" [HKEY_CLASSES_ROOT\\Drive\\shell\\runas\\command] @=\"cmd.exe /s /k pushd \\\"%V\\\"\" 另存为xxx.reg文件 双击运行 ","date":"2019-01-05","objectID":"/windows10%E5%9C%A8%E6%AD%A4%E5%A4%84%E6%89%93%E5%BC%80cmd/:0:1","tags":["cmd"],"title":"Windows10在此处打开cmd","uri":"/windows10%E5%9C%A8%E6%AD%A4%E5%A4%84%E6%89%93%E5%BC%80cmd/"},{"categories":["年终总结"],"content":"前言 不知不觉又到年底了，2018年6月我从母校毕业，进入社会，体会到了社会的残酷。我是幸运的，成功通过校招进入了一家企业，去到了上有天堂下有苏杭的杭州。在经历过一些痛苦后我决定出去闯一闯，年末又成功在上海找到工作。不幸的是家庭中发生了一系列的变故，让我对亲情是否可靠又产生了怀疑，难道血缘关系都不能带来相互的羁绊吗，我现在回答不上来，只希望少点这种糟心的事。 ","date":"2018-12-30","objectID":"/2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/:1:0","tags":["生活"],"title":"2018年终总结","uri":"/2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"},{"categories":["年终总结"],"content":"收获爱情 没想到在我离开母校之后还能追到追了3年都没追到的女神。虽然现在我们是异地恋，但是我想这是上天在看到我Never give up的信念后给予我的礼物吧。说实话这感觉就跟做梦一样，之前经常幻想在一起后的生活是啥样的，现在感觉全都是我无法想到的情况。我们是熟悉的，从大一就开始认识，一起参加社团，参加各种活动，经常互相吐槽。我们是陌生的，在一起后才发现你是这么的柔弱，想法是那么的奇妙。不过跟你在一起越久我就越发的喜欢上你，虽然今年跟你见面的机会很少，但每一次都让我感受到了爱情的美妙。逐渐对你了解的越多发现你跟别的女孩都不一样。我会努力赚钱，给你带来更好的生活的！ ","date":"2018-12-30","objectID":"/2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/:2:0","tags":["生活"],"title":"2018年终总结","uri":"/2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"},{"categories":["年终总结"],"content":"百万负翁 在武汉买房这是我之前从来都没想过的事，不过今年竟然那么巧合的实现了。我哥是做房产中介的，他朋友要结婚了，想把手上的房置换出去我家刚拿到拆迁款不久，身上有点余钱我妈就去看了看房子，发现还挺不错，然后就叫上我一起再去看，位置在3环和4环之前，听说附近马上要搞军运会应该会涨起来。户型和面积都很不错，符合我的要求，就算不拿来住就当投资也是一个不错的选择。就这样，我爸妈替我买了人生的第一套房，我也成了百万负翁，每月房贷5500+，跟爸妈商量着先让他们帮我还，等我找到工作了我再慢慢承担房贷，他们也答应了，现在身上压力很大。。。。 ","date":"2018-12-30","objectID":"/2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/:3:0","tags":["生活"],"title":"2018年终总结","uri":"/2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"},{"categories":["年终总结"],"content":"来上海打拼 从杭州回来后就一直在考虑去哪里打工，问了很多朋友，自己也考虑了很多。想从北上深选一个。北京机会多，工资高，但是空气差，住房条件很差。深圳互联网企业很多，政府的人才引进项目也很有吸引力但是相对的竞争也很大，而且环境氛围不太好。最后选择了上海，不过这是一个完全陌生的城市，当时我也很忐忑，不过在Boss直聘上投的简历很快有了回应，有公司已经向我发出了面试邀请，一冲动买了一张晚上的高铁票就出发了。最后经历了几天面试找到了一家我觉得不错还很适合我的公司，虽然不大，但是氛围很好，我感觉我能学到很多东西。 ","date":"2018-12-30","objectID":"/2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/:4:0","tags":["生活"],"title":"2018年终总结","uri":"/2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"},{"categories":["年终总结"],"content":"IG夺冠 这是中国LOL崭新的篇章，我是LOL的内测玩家，但最开始没有玩下去，因为那时候DOTA更火DOTA2也出来了，到S4看到当时的OMG的一场50血翻盘的比赛，震惊我了，那时候中国的LOL还恐韩，那时候的OMG就专门灭韩国对，看起来真过瘾啊，后来随着OMG的落寞也对LOL关注少了，到2018年8月IG老板王思聪上场比赛，那时候又吸引了我的关注，后面开始看IG的比赛，在LPL里每次都差一步，被巅峰期的小狗给带走了。到S8全球总决赛，随着RNG被G2击败这次网上都说是最没有希望的一年，很多人都小看了IG，结果他摧枯拉朽2个3:0带走了G2和FNC，给LPL带来了第一座世界赛的奖杯，这是具有历史意义的一天！虽然IG里有两个韩援，但是Rookie在韩国接受采访时说的中文！我觉得这就是属于LPL的冠军！ ","date":"2018-12-30","objectID":"/2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/:5:0","tags":["生活"],"title":"2018年终总结","uri":"/2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"},{"categories":["年终总结"],"content":"展望 2018年已经过去，希望2019年我能更进一步在上海扎根，学更多东西，尽快承担起家里的责任。 有几个小目标： 坚持每周写一篇博文 多出去走走看看，了解上海这座大都市，认识更多的朋友 开始偿还房贷，减轻爸妈的负担 开始攒钱，争取攒够5万块 希望明年年终总结的时候小目标都能实现！ ","date":"2018-12-30","objectID":"/2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/:6:0","tags":["生活"],"title":"2018年终总结","uri":"/2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"},{"categories":["生活"],"content":"新的开始 ","date":"2018-12-16","objectID":"/%E4%B8%8A%E6%B5%B7%E6%88%91%E6%9D%A5%E4%BA%86/:1:0","tags":["上海"],"title":"上海我来了","uri":"/%E4%B8%8A%E6%B5%B7%E6%88%91%E6%9D%A5%E4%BA%86/"},{"categories":["生活"],"content":"序 现在还记得来上海那天在高铁上还在Boss直聘上跟几个面试官约面试，那时候真的很兴奋，感觉大展拳脚的时候到了！到上海的时候已经是晚上10点多了，万幸赶上了末班地铁，发现提前定好的青旅离虹桥站还挺近的，半个小时地铁就能到。由于身上钱不多订的是一个8人间的上下铺，我入住的时候好多人都已经准备休息了，我很快洗漱完毕就躺床上了，第一天晚上超级兴奋，根本睡不着(其实还因为有人打呼噜，太吵了，我睡眠质量又不太好！！！) ","date":"2018-12-16","objectID":"/%E4%B8%8A%E6%B5%B7%E6%88%91%E6%9D%A5%E4%BA%86/:1:1","tags":["上海"],"title":"上海我来了","uri":"/%E4%B8%8A%E6%B5%B7%E6%88%91%E6%9D%A5%E4%BA%86/"},{"categories":["生活"],"content":"面试 到上海的第二天就开始准备面试和考察面试的公司。通过地图发现要面试的这几家都很近，很快制定了面试的方案。幸运的是，第三天的面试两家都很成功，成功通过了技术面，不幸的是HR面薪资没有给到我想要的，我决定再多面几家。直到第五天，面了有5，6家了，还是没找到适合自己的，我开始有点慌了,先在美团上把青旅续费了一周时间。然后准备下一家面试给出的面试题，让我按照要求写一个程序出来，如果写的可以就能参加第二面。由于之前没接触过这个包，在网上简单学习了一下入门就开始写代码了，经过一个下午的努力终于完成了代码，发给面试官，然后开始了等消息时间，庆幸的是晚上得到了面试的邀请。面试过程非常nice，问完我问题后，他开始给我介绍他的目标与构想，我感觉非常符合我的预期，很快就收到了HR面的邀请，心里暗自高兴，虽然工资跟前几家差不多，但是这个Leader跟我非常聊得来，在面试的过程中他提出问题涉及到我不熟悉的地方他会指引我的思路，让我想出更好的解决方案，让我感觉就在跟朋友探讨一样，我非常想入职该公司！很快，当天晚上就收到了入职申请，那天是星期四，HR问我明天能不能来上班，我想都没想就说：能！ ","date":"2018-12-16","objectID":"/%E4%B8%8A%E6%B5%B7%E6%88%91%E6%9D%A5%E4%BA%86/:1:2","tags":["上海"],"title":"上海我来了","uri":"/%E4%B8%8A%E6%B5%B7%E6%88%91%E6%9D%A5%E4%BA%86/"},{"categories":["生活"],"content":"租房 由于周五就入职开始上班，周末跟上海的几个朋友聚了一下，导致一直没有时间找房子。还好有一个玩的不错的小伙伴，他找到了一个合适的两居室，我看了一下，当天晚上就一起跟房东签了。从最开始来睡在8人间上下铺的青旅(如果是来上海玩还挺不错的，前台小姐姐人超好的，而且还能认识很多五湖四海的朋友)，到现在找到工作后和志同道合的小伙伴一起合租了一个60+平的两室，生活质量提高了不少，终于不用睡上铺听下铺打呼噜声了，就是房租很肉疼，租的娄山关路这块的房子，一套5800，押一付三。非常感谢爸妈对我提供的资金支持，等赚到钱了我会好好孝顺你们的。 ","date":"2018-12-16","objectID":"/%E4%B8%8A%E6%B5%B7%E6%88%91%E6%9D%A5%E4%BA%86/:1:3","tags":["上海"],"title":"上海我来了","uri":"/%E4%B8%8A%E6%B5%B7%E6%88%91%E6%9D%A5%E4%BA%86/"},{"categories":["生活"],"content":"新的公司 目前对就职的新公司非常满意，老板很开明，让我们有很大的自由发挥空间。Leader人超棒，不仅在工作上给予了我很多帮助，在生活上也教会我很多东西。同事也都超好，大家就跟朋友一样，还经常一起聚会玩狼人杀。 ","date":"2018-12-16","objectID":"/%E4%B8%8A%E6%B5%B7%E6%88%91%E6%9D%A5%E4%BA%86/:1:4","tags":["上海"],"title":"上海我来了","uri":"/%E4%B8%8A%E6%B5%B7%E6%88%91%E6%9D%A5%E4%BA%86/"},{"categories":["生活"],"content":"感想 来上海有一个半月的时间了，对这个城市的初映象还蛮好的。最开始来的时候像个乡下人，一直在惊叹，哇上海都是4车道的大马路耶，上海好多高楼耶，上海的环卫和绿植都做得好好耶。不得不说上海的基础建设非常的棒，希望小武汉也快点跟上脚步。 现在发现刚开始买高铁票来上海可能有点点冲动，但那时候我非常想去一个更大的地方发展。从实习的公司离职其实心里很忐忑，害怕自己找不到新的工作，但来到上海发现这边对学历的包容度还是很高的，只要你有足够的能力，他们愿意给你机会。 ","date":"2018-12-16","objectID":"/%E4%B8%8A%E6%B5%B7%E6%88%91%E6%9D%A5%E4%BA%86/:1:5","tags":["上海"],"title":"上海我来了","uri":"/%E4%B8%8A%E6%B5%B7%E6%88%91%E6%9D%A5%E4%BA%86/"},{"categories":null,"content":"关于 ","date":"2018-03-30","objectID":"/about/:0:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"我 本博客的博主Silence，很高兴能在这里遇见你，以后的日子里就请多多关照啦。 目前是一名Python开发工程师，技术栈丰富，平时喜欢自己捣鼓一些有意思的项目。 ","date":"2018-03-30","objectID":"/about/:1:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"博客 本博客使用 Hugo 搭建的静态博客，主题采用的是 Dillon 开发的 LoveIt主题。 本博客用于我自己的技术记载，相关分享与生活记录总结。 目前博文数量为：64，总字数为：136396 ","date":"2018-03-30","objectID":"/about/:2:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"宗旨 分享是美德，生活因分享而充实，世界因分享而美丽！ ","date":"2018-03-30","objectID":"/about/:3:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"版权 本博客所有文章皆采用 知识共享署名-非商业性使用 4.0 国际许可协议 进行许可。 本博客文章欢迎转载，转载请注明出处。 ","date":"2018-03-30","objectID":"/about/:4:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"声明 本博客所提供的信息，只供参考之用。 本博客毋须以任何方式就任何信息的传递或传送的错误、不准确负任何直接或间接的责任。 本博客图片、文字之类，如有侵犯您的版权，请及时通知我，我一定会在第一时间将其删除。 凡以任何方式直接、间接使用本博客资料者，视为自愿接受本博客声明的约束。 ","date":"2018-03-30","objectID":"/about/:5:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"技能 ","date":"2018-03-30","objectID":"/about/:6:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"熟练 语言：Python、Go 技术栈：Django、Flask、Redis、MySQL、MongoDB、Scrapy、Selenium、Linux ","date":"2018-03-30","objectID":"/about/:6:1","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"了解 语言：Java、JavaScript、 技术栈：Docker、Vue.js、Bootstrap、ECharts、TensorFlow、 ","date":"2018-03-30","objectID":"/about/:6:2","tags":null,"title":"About","uri":"/about/"}]