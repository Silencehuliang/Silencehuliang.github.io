# Python学习之路-面向对象:三个基本特征


## 三个基本特征

1. 封装：根据职责将属性和方法封装到一个抽象的类中
2. 继承：实现代码的重用，相同的代码不需要重复的编写
3. 多态：不同的对象调用相同的方法，产生不同的执行结果，增加代码的灵活度

## 封装

封装是面向对象编程的一大特点，面向对象编程的第一步就是将属性和方法封装到一个抽象的类中，外界使用类创建对象，然后让对象调用方法，对象方法的细节都被封装在类的内部。

{{< admonition tip "提示" true >}}

一个对象的属性可以是另外一个类创建的对象

{{< /admonition >}}

## 继承

### 单继承

#### 概念

子类拥有父类的所有方法和属性

#### 语法

```python
class 类名(父类名):

    pass
```

{{< admonition tip "提示" true >}}

子类继承自父类，可以直接享受父类中已经封装好的方法，不需要再次开发.子类中应该根据职责，封装子类特有的属性和方法

{{< /admonition >}}

#### 传递性

子类拥有父类以及父类的父类中封装的所有属性和方法，例：`C` 类从 `B` 类继承，`B` 类又从 `A` 类继承，那么 `C` 类就具有 `B` 类和 `A` 类的所有属性和方法

#### 重写

子类拥有父类的所有方法和属性，子类继承自父类，可以直接享受父类中已经封装好的方法，不需要再次开发，当父类的方法实现不能满足子类需求时，可以对方法进行重写(override)。重写父类方法有两种情况：

- 覆盖父类的方法：如果在开发中，父类的方法实现和子类的方法实现完全不同，就可以使用覆盖的方式，在子类中重新编写父类的方法实现。具体的实现方式，就相当于在子类中定义了一个和父类同名的方法并且实现，重写之后在运行时，只会调用子类中重写的方法，而不再会调用父类封装的方法

- 对父类方法进行扩展：子类的方法实现中包含父类的方法实现父类原本封装的方法实现是子类方法的一部分就可以使用扩展的方式。在子类中重写父类的方法在需要的位置使用 `super().父类方法` 来调用父类方法的执行代码其他的位置针对子类的需求，编写子类特有的代码实现

{{< admonition tip "提示" true >}}

关于 `super`：在 `Python`中 `super`是一个特殊的类。`super()` 就是使用 `super` 类创建出来的对象，最常使用的场景就是在重写父类方法时，调用在父类中封装的方法实现。

{{< /admonition >}}

{{< admonition tip "提示" true >}}

在开发时，`父类名` 和 `super()` 两种方式不要混用，如果使用当前子类名调用方法，会形成递归调用，出现死循环。

{{< /admonition >}}

#### 私有属性和私有方法

私有属性、方法是对象的隐私，不对外公开，外界以及子类都不能直接访问。私有属性、方法通常用于做一些内部的事情。

子类对象不能在自己的方法内部，直接访问 父类的私有属性或私有方法。子类对象可以通过父类的公有方法间接访问到私有属性或私有方法

### 多继承

#### 概念

子类可以拥有多个父类，并且具有所有父类的 属性和方法。

#### 语法

```python
class 子类名(父类名1, 父类名2...)
    pass
```

{{< admonition warning "注意事项" true >}}

如果父类之间存在同名的属性或者方法，应该尽量避免使用多继承。

{{< /admonition >}}

{{< admonition note "补充" true >}}

1. `super().__init__`相对于`类名.__init__`，在单继承上用法基本无差
2. 但在多继承上有区别，`super`方法能保证每个父类的方法只会执行一次，而使用类名的方法会导致方法被执行多次，具体看前面的输出结果
3. 多继承时，使用`super`方法，对父类的传参数，应该是由于`Python`中`super`的算法导致的原因，必须把参数全部传递，否则会报错
4. 单继承时，使用`super`方法，则不能全部传递，只能传父类方法所需的参数，否则会报错
5. 多继承时，相对于使用`类名.__init__`方法，要把每个父类全部写一遍, 而使用`super`方法，只需写一句话便执行了全部父类的方法，这也是为何多继承需要全部传参的一个原因

{{< /admonition >}}

### 了解

新式类：以 `object` 为基类的类，推荐使用

旧式类：不以 `object` 为基类的类，不推荐使用

在 `Python 3.x` 中定义类时，如果没有指定父类，会默认使用 `object` 作为该类的基类 —— `Python 3.x` 中定义的类都是新式类

{{< admonition tip "提示" true >}}

`object` *是* `Python` 为所有对象提供的基类，提供有一些内置的属性和方法，可以使用 `dir` 函数查看。

今后在定义类时，如果没有父类，建议统一继承自 `object`

{{< /admonition >}}

## 多态

多态不同的子类对象调用相同的父类方法，产生不同的执行结果。多态可以增加代码的灵活度，以继承和重写父类方法为前提，是调用方法的技巧，不会影响到类的内部设计。

{{< admonition tip "提示" true >}}

多态更容易编写出出通用的代码，做出通用的编程，以适应需求的不断变化！

{{< /admonition >}}


